///battle.js

define("scenes/battle/Conf", [], function() {
    return FF.ns.battle.Conf = {
        RECOMPILE: {
            VER: 1000020
        },
        ANIMATION_TYPE: {
            NORMAL: 1,
            BARRAGE: 3,
            DROP_ITEM: 5,
            DAMAGE: 7,
            DEAD: 8,
            DEFORM: 9,
            APPEARANCE: 11,
            TRANSITION: 12,
            JUMP_OUT: 13,
            JUMP_IN: 14,
            DEFORM_ATTACK: 15,
            ENEMY_JUMP: 16,
            INVALIDITY: 17,
            DEFORM_BARRAGE: 18,
            RERAISE_RISE: 19,
            JUMP_IN_AND_BARRAGE: 20,
            MESSAGE: 21,
            WAIT: 22,
            GUTS_RISE: 23,
            DAMAGE_BARRAGE: 24
        },
        WEAPON_EQUIP_TYPE: {
            RIGHT: 1,
            LEFT: 2,
            BOTH: 3,
            FREE: 4
        },
        ABILITY_LAUNCH_TYPE: {
            NORMAL: 1,
            BUDDY_ONLY: 2,
            ONCE: 3,
            ONCE_AND_ATTACK_MOTION_ONCE: 103,
            NONE: 99,
            NONE_AND_ATTACK_MOTION_ONCE: 199
        },
        ABILITY_SHOT_TYPE: {
            NORMAL: 1,
            ATTRACT: 2,
            BACKWARD: 3,
            FORWARD: 4,
            NORMAL_SINGLE_SHOT: 5,
            NORMAL_ONCE: 11,
            ATTRACT_ONCE: 21,
            BACKWARD_ONCE: 31,
            FORWARD_ONCE: 41,
            NONE: 99
        },
        ABILITY_HIT_TYPE: {
            NORMAL: 1,
            MULTI_HIT: 2,
            MULTI_HIT_FAST: 3
        },
        ABILITY_RETURN_TYPE: {
            NORMAL: 1,
            ATTRACT: 2,
            BACKWARD: 3,
            FORWARD: 4,
            NONE: 99
        },
        DROP_ITEM_TYPE: {
            GIL: 11,
            POTION: 21,
            HI_POTION: 22,
            X_POTION: 23,
            ETHER: 31,
            TURBO_ETHER: 32,
            TREASURE: 41,
            ORB: 51,
            EVENT_ITEM: 61
        },
        SCORE_TYPE: {
            ACTION_NUM: 1001,
            DAMAGED_RATE: 1002,
            DROP_NUM: 1003,
            DEFEAT_NUM: 1004,
            ENEMY_ABILITY: 2003,
            ENEMY_ABILITY_TIMING: 2004,
            NOT_ENEMY_ABILITY: 2006,
            NOT_ENEMY_ABILITY_TIMING: 2007,
            DAMAGE_REDUCED: 2009,
            WITHOUT_SPECIAL_EQUIPMENT: 2019,
            DEFEAT_BEFORE_ABILITY: 2021,
            DEFEAT_BEFORE_LOOKING: 2022,
            SUCCESS_ENEMY_ABILITY: 2023,
            SUCCESS_ENEMY_ABILITY_TIMING: 2024,
            SUCCESS_STATUS_AILMENTS: 2025,
            SUCCESS_STATUS_AILMENTS_TIMING: 2026,
            SUCCESS_ENEMY_EXERCISE: 2027,
            SUCCESS_ENEMY_EXERCISE_TIMING: 2028,
            NOT_ENEMY_EXERCISE: 2029,
            NOT_ENEMY_EXERCISE_TIMING: 2030,
            NOT_DEFEAT: 2031,
            SUCCESS_ENEMY_DAMAGED_BY_ENEMY: 2032,
            SUCCESS_ENEMY_ABILITY_BY_ENEMY: 2033,
            SUCCESS_STATUS_AILMENTS_BY_ENEMY: 2034,
            HAS_BUDDY: 2035,
            NOT_DEFEAT_IN_ROUND: 2036,
            SUCCESS_ENEMY_JUMP_TIMING: 2037,
            DEFEAT_ENEMY_NUM: 2038,
            DEFEAT_ENEMY_ORDER: 2039,
            SUCCESS_ENEMY_CUSTOM_PARAM_DECREASE_TIMING: 2040,
            SUCCESS_ENEMY_SA_UNSET_TIMING: 2041,
            NOT_DEFEAT_BUDDY_NUM: 2042,
            ENEMY_TIMING_NUM: 2043,
            ENEMY_ABILITY_NUM: 2044,
            SUCCESS_BUDDY_SA_UNSET_NUM: 2045,
            SUCCESS_BUDDY_RISE_NUM: 2046,
            WITHOUT_CONTINUE: 2047,
            ENEMY_WEAKNESS: 2048
        },
        ACTOR_LOOKING_DEFAULT: 1,
        STATUS_AILMENTS_TYPE: {
            POISON: 200,
            SILENCE: 201,
            PARALYSIS: 202,
            CONFUSION: 203,
            HASTE: 204,
            SLOW: 205,
            STOP: 206,
            PROTECT: 207,
            SHELL: 208,
            REFLECTION: 209,
            BLINDED: 210,
            SLEEP: 211,
            PETRIFACTION: 212,
            DOOM: 213,
            INSTANT_DEATH: 214,
            BERSERKER: 215,
            REGEN: 216,
            LEVITATE: 218,
            WEAKENED: 219,
            ZOMBIE: 220,
            MINIMUM: 221,
            TOAD: 222,
            CURSE: 223,
            GRADUAL_PETRIFACTION: 224,
            BLINK: 225,
            WATER_IMP: 226,
            VANISH: 227,
            PORKY: 228,
            SAP: 229,
            PYRAMID: 231,
            PRISON_CAGE: 232,
            WATER_BALL: 233,
            POSSESSION: 234,
            STOCK_BREAK: 235,
            DOOM_30: 236,
            DOOM_45: 237,
            DOOM_90: 238,
            DOOM_120: 239,
            TRIPLE: 240,
            SWALLOWED: 241,
            STAN: 242,
            REGEN_STRONG: 243,
            ARM_CATCH: 244,
            REFLECTION_FULL_TIME: 245,
            MAGICAL_MINE: 246,
            REGEN_MIDDLE: 247,
            CHANGE_CAST_TIME: 248,
            RERAISE_40: 249,
            RERAISE_60: 250,
            RERAISE_80: 251,
            RERAISE_100: 252,
            RERAISE_DEATH: 253,
            TARGET_BUDDY: 255,
            DOOM_LIGHT_45: 256,
            ZERO_FLIGHT_2: 257,
            ZERO_FLIGHT_3: 258,
            HP_STOCK: 259,
            RADIANT_SHIELD: 260,
            GUTS_1: 261,
            GREASED_LIGHTNING_1: 262,
            GREASED_LIGHTNING_2: 263,
            GREASED_LIGHTNING_3: 264,
            DAMAGE_BARRIER_30: 265,
            SUMMONING: 266,
            CHANGE_CRITICAL_COEFFICIENT: 267,
            THUNDER_GOD_MODE: 268,
            WILD_MODE: 269,
            BLACK_DRAGON_SUMMONING: 270,
            CHANGE_CAST_TIME_200_3_CUSTOM_MAGIC_DAMAGE_ABILITIES: 2001,
            CHANGE_CAST_TIME_200_5_CUSTOM_MAGIC_DAMAGE_ABILITIES: 2002,
            CHANGE_CAST_TIME_MAX_2_ALL: 2003,
            CHANGE_CAST_TIME_200_4_CUSTOM_MAGIC_DAMAGE_ABILITIES: 2004,
            CHANGE_CAST_TIME_MAX_1_PHYSICAL_DAMAGE_ABILITIES: 2005,
            CHANGE_CAST_TIME_MAX_1_CUSTOM_MAGIC_DAMAGE_ABILITIES: 2006,
            CHANGE_CAST_TIME_MAX_1_ALL: 2007,
            CHANGE_CAST_TIME_200_4_ALL: 2008,
            HP_STOCK_2000_25000: 25901,
            CHANGE_CRITICAL_COEFFICIENT_50: 26701,
            MATK_BOOSTER: 501,
            PROVOKE: 502,
            CHARGE: 503,
            INVISIBLE: 505,
            DEFENSE: 506,
            DISABLE: 507,
            COUNTER_AIMING: 508,
            RUNIC: 509,
            AIRFORCE_SPECK: 510,
            FORCE_ESCAPE: 511,
            BASIC_MAGIC_BREAKER: 512,
            RAID: 513,
            LOCK_ON: 514,
            OVER_DRIVE: 515,
            ROAR: 516,
            MAGIC_SEAL: 517,
            MIRAGE_1: 518,
            MIRAGE_2: 519,
            MIRAGE_3: 520,
            NON_DAMAGE: 521,
            CHARM: 522,
            MIGHTY_GUARD_1: 523,
            SUCTION: 524,
            FURY: 525,
            INDOMITABLENESS: 526,
            MAGIC_CHARM: 527,
            CUSTOM_MATK_20_MDEF_50: 528,
            RAGE: 529,
            GRAND_CROSS: 531,
            TRANCE: 532,
            FLIGHT_SEAL: 533,
            EYE_POWER_CHARM: 534,
            ATTACH_ELEMENT_AS_DISADVANTAGE: 535,
            EXTREME_EVRAE_ALTANA: 536,
            EXTREME_EVRAE_ALTANA_ZAKO: 537,
            ANTI_FARAWAY_LIMITED: 538,
            EXTREME_BAHAMUT: 539,
            ABYSS_TONBERRY_SLOW: 540,
            ABYSS_TONBERRY_STAN: 541,
            ABYSS_TONBERRY_STOP: 542,
            ATTACH_ELEMENT_FIRE_FOR_AI: 543,
            ATTACH_ELEMENT_ICE_FOR_AI: 544,
            ATTACH_ELEMENT_LIGHTNING_FOR_AI: 545,
            ATTACH_ELEMENT_WATER_FOR_AI: 546,
            ATTACH_ELEMENT_EARTH_FOR_AI: 547,
            ATTACH_ELEMENT_POISON_FOR_AI: 548,
            ABYSS_WAVE_CANNON_LOCK_ON_1: 549,
            ABYSS_WAVE_CANNON_LOCK_ON_2: 550,
            ABYSS_WAVE_CANNON_LOCK_ON_3: 551,
            ABYSS_NEKURO_DOOM_ATK: 552,
            ABYSS_NEKURO_DOOM_MATK: 553,
            ABYSS_NEKURO_DOOM_DEF: 554,
            ABYSS_NEKURO_DOOM_MDEF: 555,
            USED_ABILITY_COUNTER_WEAPON_MASTER: 556,
            SWALLOWED_GEOSGAENO: 557,
            ADJUST_DAMAGE_FOR_AI: 558,
            ADJUST_DAMAGE_ZERO_ALL: 559,
            USED_ABILITY_COUNTER_FLAME_CANNON: 560,
            USED_ABILITY_COUNTER_TORAIN_COMBO: 561,
            ADJUST_DAMAGE_ZERO_PHYSICAL: 562,
            ADJUST_DAMAGE_ZERO_MAGIC: 563,
            DOOM_DECREASE_COUNT_3: 564,
            USED_ABILITY_COUNTER_THUNDER_FALL: 567,
            CUSTOM_MATK: 601,
            CUSTOM_MND: 602,
            CUSTOM_ATK: 603,
            CUSTOM_DEF: 604,
            CUSTOM_ATK_ACC: 605,
            CUSTOM_EVA: 606,
            CUSTOM_MDEF: 607,
            CUSTOM_DEF_MDEF: 608,
            CUSTOM_ATK_MATK_DEF_MDEF: 609,
            CUSTOM_ATK_MATK: 610,
            CUSTOM_ATK_DEF: 611,
            CUSTOM_ATK_MATK_DEF_MDEF_SPD_ACC_MND: 612,
            CUSTOM_SPD: 613,
            CUSTOM_CRITICAL_ABSOLUTE: 614,
            CUSTOM_ATK_FOR_AI: 615,
            CUSTOM_MATK_FOR_AI: 616,
            CUSTOM_DEF_FOR_AI: 617,
            CUSTOM_MDEF_FOR_AI: 618,
            CUSTOM_DEF_MDEF_NOT_IRON_WALL: 619,
            CUSTOM_DEF_MATK: 620,
            CUSTOM_ATK_MDEF: 621,
            CUSTOM_MATK_MDEF: 622,
            CUSTOM_MATK_MND: 623,
            CUSTOM_ATK_DEF_MND: 624,
            CUSTOM_ATK_SA_COEF_FOR_ENEMY: 625,
            CUSTOM_ATK_FOR_AI_TIMER: 626,
            CUSTOM_MATK_FOR_AI_TIMER: 627,
            CUSTOM_DEF_FOR_AI_TIMER: 628,
            CUSTOM_MDEF_FOR_AI_TIMER: 629,
            CUSTOM_ATK_DEF_MATK_MDEF_MND: 630,
            CUSTOM_MDEF_MND: 631,
            CUSTOM_PARAM_MULTI_ATK_30_DEF_M30: 6001,
            CUSTOM_PARAM_MULTI_MATK_30_DEF_M30: 6002,
            CUSTOM_PARAM_MULTI_ATK_30_DEF_30_MDEF_30: 6003,
            CUSTOM_PARAM_MULTI_ATK_30_MDEF_M30: 6004,
            CUSTOM_PARAM_MULTI_ATK_30_MDEF_25_CRITICAL_50: 6005,
            CUSTOM_PARAM_MULTI_CRITICAL_50: 6006,
            CUSTOM_PARAM_MULTI_ATK_30_DEF_30: 6007,
            CUSTOM_PARAM_MULTI_ATK_30_MND_15_CRITICAL_50: 6008,
            CUSTOM_PARAM_MULTI_MATK_15_DEF_M15: 6009,
            CUSTOM_PARAM_MULTI_MATK_15_MDEF_M15: 6010,
            CUSTOM_PARAM_MULTI_ATK_30_MDEF_30: 6011,
            CUSTOM_PARAM_MULTI_ATK_15_DEF_M15: 6012,
            CUSTOM_PARAM_MULTI_ATK_30_DEF_50: 6013,
            CUSTOM_PARAM_MULTI_MATK_30_MDEF_M30: 6014,
            INVINCIBLE: 701,
            NULL_PHYSICAL: 702,
            NULL_MAGIC: 703,
            FARAWAY: 704,
            NULL_BASIC_MAGIC: 705,
            ATTACH_ELEMENT_LIGHTNING_WEAK: 801,
            ATTACH_ELEMENT_LIGHTNING_MIDDLE: 802,
            ATTACH_ELEMENT_LIGHTNING_STRONG: 803,
            ATTACH_ELEMENT_FIRE_WEAK: 804,
            ATTACH_ELEMENT_FIRE_MIDDLE: 805,
            ATTACH_ELEMENT_FIRE_STRONG: 806,
            ATTACH_ELEMENT_WIND_WEAK: 807,
            ATTACH_ELEMENT_WIND_MIDDLE: 808,
            ATTACH_ELEMENT_WIND_STRONG: 809,
            ATTACH_ELEMENT_EARTH_WEAK: 810,
            ATTACH_ELEMENT_EARTH_MIDDLE: 811,
            ATTACH_ELEMENT_EARTH_STRONG: 812,
            ATTACH_ELEMENT_DARK_WEAK: 813,
            ATTACH_ELEMENT_DARK_MIDDLE: 814,
            ATTACH_ELEMENT_DARK_STRONG: 815,
            ATTACH_ELEMENT_HOLY_WEAK: 816,
            ATTACH_ELEMENT_HOLY_MIDDLE: 817,
            ATTACH_ELEMENT_HOLY_STRONG: 818,
            ATTACH_ELEMENT_WATER_WEAK: 819,
            ATTACH_ELEMENT_WATER_MIDDLE: 820,
            ATTACH_ELEMENT_WATER_STRONG: 821,
            ATTACH_ELEMENT_ICE_WEAK: 822,
            ATTACH_ELEMENT_ICE_MIDDLE: 823,
            ATTACH_ELEMENT_ICE_STRONG: 824,
            ATTACH_ELEMENT_POISON_WEAK: 825,
            ATTACH_ELEMENT_POISON_MIDDLE: 826,
            ATTACH_ELEMENT_POISON_STRONG: 827,
            IGNORE_INCONTROLLABLE: 901,
            DO_NOTHING_FOR_ESNA: 902,
            DO_NOTHING_FOR_DISPEL: 903,
            DEATH: 999
        },
        STATUS_AILMENTS_EXCLUSIVE: {
            TOGETHER: 1,
            BLOCK: 2,
            EXTRUDE: 3
        },
        ACTION_ID_OF: {
            DEFORM: 9001,
            POISON: 9002,
            REGEN: 9003,
            DO_NOTHING: 9004,
            DEFORM_MULTI: 9005,
            DEFENSE: 911,
            HEAL_DEATH: 9006,
            SELF_CUSTOM_PARAM: 9007,
            INCREASE_MP: 9008,
            BUILTIN_INFLICT_SA: 9009,
            RERAISE_RISE: 9010,
            DO_NOTHING_STRICTLY: 9011,
            HEAL_HP_BY_DAMAGE_SUM: 9012,
            BUILTIN_HEAL_HP: 9013,
            BUILTIN_ENEMY_MULTIPLE_ABILITY: 9014,
            BUILTIN_FRACTIONAL_HEAL_HP: 9015,
            HP_STOCK: 9016,
            BUILTIN_HEAL_SA: 9017,
            GUTS_RISE: 9018,
            RADIANT_SHIELD: 9019
        },
        ABILITY_ID_OF: {
            DEFORM: 900101,
            POISON: 900201,
            REGEN: 900301,
            DO_NOTHING: 900401,
            DEFORM_MULTI: 900501,
            DEFENSE: 390001,
            ATTACK: 30151001,
            HEAL_DEATH: 900601,
            SELF_CUSTOM_PARAM: 900701,
            INCREASE_MP: 900801,
            BUILTIN_INFLICT_SA: 900901,
            RERAISE_RISE: 901001,
            DO_NOTHING_STRICTLY: 901101,
            DO_NOTHING_STRICTLY_STEP: 901102,
            HEAL_HP_BY_DAMAGE_SUM: 901201,
            BUILTIN_HEAL_HP: 901301,
            BUILTIN_ENEMY_MULTIPLE_ABILITY: 901401,
            BUILTIN_FRACTIONAL_HEAL_HP: 901501,
            HP_STOCK: 901601,
            BUILTIN_HEAL_SA: 901701,
            GUTS_RISE: 901801,
            RADIANT_SHIELD: 901901,
            DEFAULT_IN_NEGATIVE_INCONTROLLABLE_FOR_ENEMY: 402163
        },
        MATERIA_NOTIFY_TYPE: {
            SETUP_ROUND: 1,
            RESET_FOR_CONTINUE: 2,
            DAMAGE_HOOK: 3,
            ABILITY_PANEL: 4,
            ACTION_EXIT: 5,
            RECIEVE_DAMAGE_HOOK: 6
        },
        ELEMENT_TYPE: {
            NONE: 0,
            FIRE: 100,
            ICE: 101,
            LIGHTNING: 102,
            EARTH: 103,
            WIND: 104,
            WATER: 105,
            HOLY: 106,
            DARK: 107,
            POISON: 108,
            NOTHING: 199
        },
        ADVANTAGE: {
            NONE: 0,
            WEAK: 1,
            HALF: 2,
            VOID: 3,
            ABSORPTION: 4
        },
        TARGET_RANGE: {
            SINGLE: 1,
            ALL: 2,
            SELF: 3
        },
        TARGET_SEGMENT: {
            OPPONENT: 1,
            COLLEAGUE: 2,
            BOTH: 3,
            BOTH_EXCEPT_MYSELF: 4,
            COLLEAGUE_EXCEPT_MYSELF: 5,
            MYSELF_AND_OPPONENT: 6,
            AI_NO_1: 201
        },
        TARGET_DEATH: {
            EXCLUDE: 1,
            INCLUDE: 2,
            EXCLUDE_PURE_DEATH: 3
        },
        TARGET_METHOD: {
            HP_RATIO_DESC: 1,
            HP_RATIO_ASC: 2,
            SA_RANDOM: 3,
            DIS_SA_RANDOM: 4,
            RANDOM: 5,
            NOTHING: 6,
            HP_DESC: 7,
            HP_ASC: 8,
            ESNA: 9,
            DISPEL: 10,
            MP_RANDOM: 11,
            MARAISE: 12,
            LOT_BY_HP_RATE: 13,
            BUDDY_SMART: 101,
            AI_SMART: 201,
            AI_SMART_IGNORE_REFRECTION: 202
        },
        ACTIVE_TARGET_METHOD: {
            BOTH_DISABLE: 1,
            OPPONENT_DISABLE: 2,
            COLLEGUE_DISABLE: 3,
            BOTH_ENABLE: 4
        },
        ROW_TYPE: {
            FRONT: 1,
            BACK: 2
        },
        ATK_TYPE: {
            DIRECT: 1,
            INDIRECT: 2
        },
        MESSAGE_TYPE: {
            ACTOR_APPEARED: 1,
            ACTOR_DEAD: 2,
            ACTOR_ABILITY: 3,
            ACTOR_HP_DECREASED: 4,
            ACTOR_LOOKING_CHANGED: 5,
            MESSAGE: 6,
            PROGRAM: 7
        },
        MESSAGE_DISPLAY_TYPE: {
            ONCE: 1,
            REPEAT: 2
        },
        EXERCISE_TYPE: {
            PHYSICAL: 1,
            WHITE_MAGIC: 3,
            BLACK_MAGIC: 4,
            BLUE_MAGIC: 5,
            SUMMON: 6,
            INBORN: 7,
            NINJA: 8,
            NO_CLASSIFIED: 9
        },
        ABILITY_CATEGORY_ID: {
            BLACK_MAGIC: 1,
            WHITE_MAGIC: 2,
            SUMMONING: 3,
            SPELLBLADE: 4,
            COMBAT: 5,
            SUPPORT: 6,
            CELERITY: 7,
            DRAGOON: 8,
            MONK: 9,
            THIEF: 10,
            KNIGHT: 11,
            SAMURAI: 12,
            NINJA: 13,
            BARD: 14,
            DANCER: 15,
            MACHINIST: 16,
            DARKNESS: 17,
            BURST_MODE: 51
        },
        JUDGE: {
            VICTORY: 1,
            LOSE: 2,
            FORCE_ESCAPE: 3
        },
        PANEL_TYPE: {
            COMMAND: 1,
            SUPPORT: 2,
            DEFENSE: 3
        },
        BACKGROUND_CHANGE_TYPE: {
            NONE: 0,
            WALK: 1,
            STOP: 2
        },
        TRANSITION_TYPE: {
            SCROLL: 1,
            NONE: 2
        },
        CONTINUE_TYPE: {
            SOUL_PIECE: 101,
            COIN: 201,
            FREE: 301
        },
        CONTINUE_ALLOWABLE_TYPE: {
            ALWAYS: 0,
            ALWAYS_CANT: 1
        },
        CONTINUE_TXN_STAT: {
            STARTED: 1,
            CURED: 2,
            DONE: 3,
            CANCELED: 4,
            SELECTED: 5
        },
        CONTINUE_BONUS: {
            ATTACK: 11,
            DEFENSE: 12,
            ABILITY: 13,
            HP: 14
        },
        MATERIA_CONDTION_TYPE: {
            ALL: 1,
            ELEMENT: 2,
            EXERCISE: 3,
            ABILITY_ID: 4,
            FLIGHT: 5,
            ABILITY_CATEGORY_ID: 6,
            REMAINING_HP_RATE: 7
        },
        COUNTER_CONDTION_TYPE: {
            ALL: 1,
            ELEMENT: 2,
            EXERCISE: 3,
            CUSTOM: 4,
            ABILITY_CATEGORY_ID: 5
        },
        COUNTER_CONDTION_CUSTOM_TYPE: {
            BLACK_AND_WHITE_MAGIC_ATTACK: 1,
            SKIP_IN_REFLECTION: 2,
            COUNTER_AIMING: 3,
            LIGHTNING_AND_PHYSICAL_ATTACK: 4
        },
        RECEPTOR: {
            PANEL_ATTACK: 11,
            PANEL_FLEXIBLE_1: 12,
            PANEL_FLEXIBLE_2: 13,
            PANEL_DEFENSE: 14,
            SOUL_STRIKE: 21,
            SOUL_STRIKE_FLEXIBLE_1: 22,
            SOUL_STRIKE_FLEXIBLE_2: 23,
            SOUL_STRIKE_FLEXIBLE_3: 24,
            SOUL_STRIKE_FLEXIBLE_4: 25,
            SKIP: 31,
            SUPPORTER_SOUL_STRIKE: 41,
            POSITIVE_INCONTROLLABLE: 51,
            SPARE_PANEL_TRANCE_CLOUD_1: 10011,
            SPARE_PANEL_TRANCE_CLOUD_2: 10012,
            SPARE_PANEL_TRANCE_YUNA_1: 10021,
            SPARE_PANEL_TRANCE_YUNA_2: 10022,
            SPARE_PANEL_TRANCE_SQUALL_1: 10031,
            SPARE_PANEL_TRANCE_SQUALL_2: 10032,
            SPARE_PANEL_TRANCE_PALADIN_CECIL_1: 10041,
            SPARE_PANEL_TRANCE_PALADIN_CECIL_2: 10042,
            SPARE_PANEL_TRANCE_BUTZ_1: 10051,
            SPARE_PANEL_TRANCE_BUTZ_2: 10052,
            SPARE_PANEL_TRANCE_DESHI_1: 10061,
            SPARE_PANEL_TRANCE_DESHI_2: 10062,
            SPARE_PANEL_TRANCE_TINA_1: 10071,
            SPARE_PANEL_TRANCE_TINA_2: 10072,
            SPARE_PANEL_TRANCE_TIDUS_1: 10081,
            SPARE_PANEL_TRANCE_TIDUS_2: 10082,
            SPARE_PANEL_TRANCE_LIGHTNING_1: 10091,
            SPARE_PANEL_TRANCE_LIGHTNING_2: 10092,
            SPARE_PANEL_TRANCE_SEPHIROTH_1: 10101,
            SPARE_PANEL_TRANCE_SEPHIROTH_2: 10102,
            SPARE_PANEL_TRANCE_RINOA_1: 10111,
            SPARE_PANEL_TRANCE_RINOA_2: 10112,
            SPARE_PANEL_TRANCE_FARIS_1: 10121,
            SPARE_PANEL_TRANCE_FARIS_2: 10122,
            SPARE_PANEL_TRANCE_ZIDANE_1: 10131,
            SPARE_PANEL_TRANCE_ZIDANE_2: 10132,
            SPARE_PANEL_TRANCE_GARNET_1: 10141,
            SPARE_PANEL_TRANCE_GARNET_2: 10142,
            SPARE_PANEL_TRANCE_BEATRIX_1: 10151,
            SPARE_PANEL_TRANCE_BEATRIX_2: 10152,
            SPARE_PANEL_TRANCE_GARLAND_1: 10161,
            SPARE_PANEL_TRANCE_GARLAND_2: 10162,
            SPARE_PANEL_TRANCE_VAAN_1: 10171,
            SPARE_PANEL_TRANCE_VAAN_2: 10172,
            SPARE_PANEL_TRANCE_RAMZA_1: 10181,
            SPARE_PANEL_TRANCE_RAMZA_2: 10182,
            SPARE_PANEL_TRANCE_HOPE_1: 10191,
            SPARE_PANEL_TRANCE_HOPE_2: 10192,
            SPARE_PANEL_TRANCE_TIFA_1: 10201,
            SPARE_PANEL_TRANCE_TIFA_2: 10202,
            SPARE_PANEL_TRANCE_JECHT_1: 10211,
            SPARE_PANEL_TRANCE_JECHT_2: 10212,
            SPARE_PANEL_TRANCE_LOCK_1: 10221,
            SPARE_PANEL_TRANCE_LOCK_2: 10222,
            SPARE_PANEL_TRANCE_BALFLEAR_1: 10231,
            SPARE_PANEL_TRANCE_BALFLEAR_2: 10232,
            SPARE_PANEL_TRANCE_FANG_1: 10241,
            SPARE_PANEL_TRANCE_FANG_2: 10242,
            SPARE_PANEL_TRANCE_GILGAMESH_1: 10251,
            SPARE_PANEL_TRANCE_GILGAMESH_2: 10252,
            SPARE_PANEL_TRANCE_CELES_1: 10261,
            SPARE_PANEL_TRANCE_CELES_2: 10262,
            SPARE_PANEL_TRANCE_RIKKU_1: 10271,
            SPARE_PANEL_TRANCE_RIKKU_2: 10272,
            SPARE_PANEL_TRANCE_SELPHIE_1: 10281,
            SPARE_PANEL_TRANCE_SELPHIE_2: 10282,
            SPARE_PANEL_TRANCE_AERITH_1: 10291,
            SPARE_PANEL_TRANCE_AERITH_2: 10292,
            SPARE_PANEL_TRANCE_EIKO_1: 10301,
            SPARE_PANEL_TRANCE_EIKO_2: 10302,
            SPARE_PANEL_TRANCE_VIVI_1: 10311,
            SPARE_PANEL_TRANCE_VIVI_2: 10312,
            SPARE_PANEL_TRANCE_FRIONIEL_1: 10321,
            SPARE_PANEL_TRANCE_FRIONIEL_2: 10322,
            SPARE_PANEL_TRANCE_LEONHART_1: 10331,
            SPARE_PANEL_TRANCE_LEONHART_2: 10332,
            SPARE_PANEL_TRANCE_MARIA_1: 10341,
            SPARE_PANEL_TRANCE_MARIA_2: 10342,
            SPARE_PANEL_TRANCE_MINWU_1: 10351,
            SPARE_PANEL_TRANCE_MINWU_2: 10352,
            SPARE_PANEL_TRANCE_ASHE_1: 10361,
            SPARE_PANEL_TRANCE_ASHE_2: 10362,
            SPARE_PANEL_TRANCE_PANELO_1: 10371,
            SPARE_PANEL_TRANCE_PANELO_2: 10372,
            SPARE_PANEL_TRANCE_AURON_1: 10381,
            SPARE_PANEL_TRANCE_AURON_2: 10382,
            SPARE_PANEL_TRANCE_WAKKA_1: 10391,
            SPARE_PANEL_TRANCE_WAKKA_2: 10392,
            SPARE_PANEL_TRANCE_VANILLE_1: 10401,
            SPARE_PANEL_TRANCE_VANILLE_2: 10402,
            SPARE_PANEL_TRANCE_NOEL_1: 10411,
            SPARE_PANEL_TRANCE_NOEL_2: 10412,
            SPARE_PANEL_TRANCE_SERAH_1: 10421,
            SPARE_PANEL_TRANCE_SERAH_2: 10422,
            SPARE_PANEL_TRANCE_LUNETH_1: 10431,
            SPARE_PANEL_TRANCE_LUNETH_2: 10432,
            SPARE_PANEL_TRANCE_ONION_KNIGHT_1: 10441,
            SPARE_PANEL_TRANCE_ONION_KNIGHT_2: 10442,
            SPARE_PANEL_TRANCE_INGUS_1: 10451,
            SPARE_PANEL_TRANCE_INGUS_2: 10452,
            SPARE_PANEL_TRANCE_REFIA_1: 10461,
            SPARE_PANEL_TRANCE_REFIA_2: 10462,
            SPARE_PANEL_TRANCE_CAIN_1: 10471,
            SPARE_PANEL_TRANCE_CAIN_2: 10472,
            SPARE_PANEL_TRANCE_RYDIA_1: 10481,
            SPARE_PANEL_TRANCE_RYDIA_2: 10482,
            SPARE_PANEL_TRANCE_GILBART_1: 10491,
            SPARE_PANEL_TRANCE_GILBART_2: 10492,
            SPARE_PANEL_TRANCE_SHANTOTTO_1: 10501,
            SPARE_PANEL_TRANCE_SHANTOTTO_2: 10502,
            SPARE_PANEL_TRANCE_CURILLA_1: 10511,
            SPARE_PANEL_TRANCE_CURILLA_2: 10512,
            SPARE_PANEL_TRANCE_AGRIAS_1: 10521,
            SPARE_PANEL_TRANCE_AGRIAS_2: 10522,
            SPARE_PANEL_TRANCE_EDGE_1: 10531,
            SPARE_PANEL_TRANCE_EDGE_2: 10532,
            SPARE_PANEL_TRANCE_WARRIORS_OF_LIGHT_1: 10541,
            SPARE_PANEL_TRANCE_WARRIORS_OF_LIGHT_2: 10542,
            SPARE_PANEL_TRANCE_ZELL_1: 10551,
            SPARE_PANEL_TRANCE_ZELL_2: 10552,
            SPARE_PANEL_TRANCE_QUISTIS_1: 10561,
            SPARE_PANEL_TRANCE_QUISTIS_2: 10562,
            SPARE_PANEL_TRANCE_RELM_1: 10571,
            SPARE_PANEL_TRANCE_RELM_2: 10572,
            SPARE_PANEL_TRANCE_SHADOW_1: 10581,
            SPARE_PANEL_TRANCE_SHADOW_2: 10582,
            SPARE_PANEL_TRANCE_MASH_1: 10591,
            SPARE_PANEL_TRANCE_MASH_2: 10592,
            SPARE_PANEL_TRANCE_ZACK_1: 10611,
            SPARE_PANEL_TRANCE_ZACK_2: 10612,
            SPARE_PANEL_TRANCE_YUFFIE_1: 10621,
            SPARE_PANEL_TRANCE_YUFFIE_2: 10622,
            SPARE_PANEL_TRANCE_RENO_1: 10631,
            SPARE_PANEL_TRANCE_RENO_2: 10632,
            SPARE_PANEL_TRANCE_GALUF_1: 10641,
            SPARE_PANEL_TRANCE_GALUF_2: 10642,
            SPARE_PANEL_TRANCE_KRILE_1: 10651,
            SPARE_PANEL_TRANCE_KRILE_2: 10652,
            SPARE_PANEL_TRANCE_LENNA_1: 10661,
            SPARE_PANEL_TRANCE_LENNA_2: 10662,
            SPARE_PANEL_TRANCE_SNOW_1: 10671,
            SPARE_PANEL_TRANCE_SNOW_2: 10672,
            SPARE_PANEL_TRANCE_CID_RAINES_1: 10681,
            SPARE_PANEL_TRANCE_CID_RAINES_2: 10682,
            SPARE_PANEL_TRANCE_YSHTOLA_1: 10691,
            SPARE_PANEL_TRANCE_YSHTOLA_2: 10692,
            SPARE_PANEL_TRANCE_MINFILIA_1: 10701,
            SPARE_PANEL_TRANCE_MINFILIA_2: 10702,
            SPARE_PANEL_TRANCE_ALPHINAUD_1: 10711,
            SPARE_PANEL_TRANCE_ALPHINAUD_2: 10712,
            SPARE_PANEL_TRANCE_YDA_1: 10721,
            SPARE_PANEL_TRANCE_YDA_2: 10722,
            SPARE_PANEL_TRANCE_PAPALYMO_1: 10731,
            SPARE_PANEL_TRANCE_PAPALYMO_2: 10732,
            SPARE_PANEL_TRANCE_THANCRED_1: 10741,
            SPARE_PANEL_TRANCE_THANCRED_2: 10742,
            SPARE_PANEL_TRANCE_KUJA_1: 10751,
            SPARE_PANEL_TRANCE_KUJA_2: 10752,
            SPARE_PANEL_TRANCE_FREYA_1: 10761,
            SPARE_PANEL_TRANCE_FREYA_2: 10762,
            SPARE_PANEL_TRANCE_STEINER_1: 10771,
            SPARE_PANEL_TRANCE_STEINER_2: 10772,
            SPARE_PANEL_TRANCE_YUNA_2_1: 10781,
            SPARE_PANEL_TRANCE_YUNA_2_2: 10782,
            SPARE_PANEL_TRANCE_SEYMOUR_1: 10791,
            SPARE_PANEL_TRANCE_SEYMOUR_2: 10792,
            SPARE_PANEL_TRANCE_LULU_1: 10801,
            SPARE_PANEL_TRANCE_LULU_2: 10802,
            SPARE_PANEL_TRANCE_SARAH_1: 10841,
            SPARE_PANEL_TRANCE_SARAH_2: 10842,
            SPARE_PANEL_TRANCE_SUPER_MONK_1: 10851,
            SPARE_PANEL_TRANCE_SUPER_MONK_2: 10852,
            SPARE_PANEL_TRANCE_MATOYA_1: 10861,
            SPARE_PANEL_TRANCE_MATOYA_2: 10862,
            SPARE_PANEL_TRANCE_ORLANDEAU_1: 10811,
            SPARE_PANEL_TRANCE_ORLANDEAU_2: 10812,
            SPARE_PANEL_TRANCE_GAFFGARION_1: 10821,
            SPARE_PANEL_TRANCE_GAFFGARION_2: 10822,
            SPARE_PANEL_TRANCE_DELITA_1: 10831,
            SPARE_PANEL_TRANCE_DELITA_2: 10832,
            SPARE_PANEL_TRANCE_20000: 2e4,
            SPARE_PANEL_TRANCE_20001: 20001,
            SPARE_PANEL_TRANCE_20002: 20002,
            SPARE_PANEL_TRANCE_20003: 20003,
            SPARE_PANEL_TRANCE_20004: 20004,
            SPARE_PANEL_TRANCE_20005: 20005
        },
        PANEL_TARGET_RECEPTABLE: {
            ENABLE: 1,
            DISABLE: 2,
            ANY: 3
        },
        PANEL_TARGET_REMAIN_NUM: {
            EXISTS: 1,
            EMPTY: 2,
            ANY: 3
        },
        PANEL_TARGET_USED_NUM: {
            USED: 1,
            NOT_USED: 2,
            ANY: 3
        },
        PANEL_TARGET_PRIORITY_TYPE: {
            RANDOM: 1,
            LEAST_REMAIN_NUM: 2
        },
        CALC_TYPE: {
            ATTACK: 1,
            MAGIC: 2,
            FRACTION: 3,
            HEAL: 4,
            HEAL_SA: 5,
            HEAL_DEATH: 6,
            POISON: 7,
            REGEN: 8,
            HP_BARTER: 9,
            STATUS_AILMENTS: 10,
            SELF_DESTRUCTION: 11,
            ABILITY_PANEL: 13,
            DAMAGED_HP: 14,
            FIXED_DAMAGE: 15,
            PHYSICAL_STATUS_AILMENTS: 16,
            FRACTION_HEAL: 17,
            HEAL_HP_BY_DAMAGE_SUM: 18,
            DEALING_SS_POINT: 19,
            FIXED_HEAL_HP: 20,
            ABILITY_PANEL_FIXED_DAMAGE: 21,
            RADIANT_SHIELD: 22
        },
        CALC_HOOK: {
            REFRECTOR: 101,
            COUNTER_ENABLE: 102,
            MATERIA: 103,
            RECEIVER_SA: 104,
            BRK_DEF: 105,
            FLIGHT_ATTACK: 106,
            SA_DAMAGE_REVERSE: 107,
            ADJUST_DAMAGE: 108,
            SITUATIONAL_RECALCULATE_DAMAGE: 109,
            HP_STOCK: 110,
            UNDEAD_CURE: 201,
            UNDEAD_RAISE: 202,
            SEALING: 203,
            PYRAMID: 204,
            FARAWAY: 205,
            WATER_BALL: 206,
            NON_DAMAGE: 207,
            SWALLOWED: 208,
            FURY: 209,
            INDOMITABLENESS: 210,
            IGNORE_GENERAL_DAMAGED_RATE_SCORE: 211,
            INVINCIBLE: 212,
            DAMAGE_BARRIER: 213
        },
        SITUATIONAL_RECALCULATE_DAMAGE_HOOK_TYPE: {
            NONE: 0,
            EXECUTER_REMAINING_HP_RATE: 1
        },
        DAMAGE_CALCULATE_PARAM_ADJUST_TYPE: {
            ATK_CONVERT: 101,
            DAMAGE_FACTOR: 102
        },
        DAMAGE_CALCULATE_PARAM_ADJUST: {
            DEF_CONVERT_ATK: 1,
            SPD_CONVERT_ATK: 2,
            VALIANT_ATTACK: 3,
            CURRENT_HP_CONVERT_ATK: 4,
            RECEIVER_SA: 11,
            EXECUTER_SA: 12,
            RECEIVER_SA_BUNDLE: 13,
            EXECUTER_SA_BUNDLE: 14,
            ALL_ALIVE_BUDDIES: 15,
            BUDDIES_IN_FLIGHT: 16,
            RECEIVER_SA_NUM: 17,
            EXECUTER_ATK_TYPE: 18,
            STATUS_DOWN_OF_ATK_DEF_MATK_MDEF_MND: 19,
            ENEMY_NUM: 20,
            EXECUTER_EQUIPMENT_CATEGORY: 21,
            BUDDIES_SEX: 22,
            SS_POINT: 23,
            ATK: 24,
            DAMAGE_RECEIVE_COUNT: 25
        },
        BREED_ID: {
            UNDEAD: 1
        },
        STATUS_AILMENTS_BUNDLE: {
            LOT: 1,
            ESNA: 2,
            DISPEL: 3,
            DEBARIA: 4,
            POISON_AND_PARALYSIS: 5,
            PHOTON_WING: 6,
            POISON_AND_BLINDED: 7,
            SILENCE_AND_STAN: 8,
            SERAPHIC_RAY: 9,
            BLINDED_AND_SILENCE: 10,
            CONFUSION_AND_SLEEP: 11,
            POISON_AND_SILENCE_AND_BLINDED_AND_SLOW: 12,
            PROTECT_AND_SHELL_AND_HASTE: 13,
            SLOW_AND_SLEEP: 14,
            SLOW_AND_BLINDED_AND_POISON: 15,
            POISON_AND_SLOW: 16,
            CONFUSION_AND_SLEEP_AND_BLINDED: 17,
            PARALYSIS_AND_SILENCE: 18,
            PROTECT_AND_SHELL: 19,
            ALL_REGEN: 20,
            PARALYSIS_AND_SLOW: 21,
            SLEEP_AND_SAP: 22,
            CONFUSION_AND_POISON: 23,
            POISON_AND_CUSTOM_DEF_MDEF: 24,
            REGEN_AND_CUSTOM_ATK_MATK: 25,
            POISON_AND_BLINDED_AND_SILENCE_AND_SLEEP: 26,
            DOOMS: 27,
            STAN_AND_STOP: 28,
            POISON_AND_STOP: 29,
            ESNA_AND_SLOW: 30,
            SLOW_AND_CUSTOM_ATK_DEF: 31,
            SLOW_AND_SAP: 32,
            DAMAGE_CALCULATE_PARAM_ADJUST_BY_RECEIVER_SA_NUM: 33,
            BLINDED_AND_SAP: 34,
            SLOW_AND_CUSTOM_ATK: 35,
            POISON_AND_PARALYSIS_AND_SLEEP_AND_SILENCE: 36,
            PARALYSIS_AND_SAP: 37,
            POISON_AND_BLINDED_AND_SILENCE_AND_CONFUSION: 38,
            CONFUSION_AND_SLOW_AND_BLINDED_AND_DOOM_AND_BERSERKER_AND_SAP: 39,
            POISON_AND_BLINDED_AND_SILENCE_AND_PETRIFACTION: 40,
            MIRAGES: 41,
            GUTS_1_AND_CRITICAL_50: 42
        },
        STATUS_BONUS_PARTS: {
            BUDDY: "buddy",
            WEAPON: "weapon",
            ARMOR: "armor",
            ACCESSORY: "accessory"
        },
        BGM_NAME: {
            VICTORY: "bgm_05_008",
            REQUIEM: "bgm_05_009"
        },
        SYSTEM_WINDOW: {
            NETWORK: 101,
            ERROR: 102,
            LOGIN: 103,
            BATTLE_RESULT: 104,
            EXPIRE: 105,
            CONFIRM_CONTINUE: 106,
            MAINTENANCE: 107,
            ESCAPE_ALERT: 108,
            OAUTH_TOKEN_REVOKED: 109,
            PAYMENT_NETWORK: 110,
            HOST_IS_DEAD: 111,
            HOST_IS_RETIRED: 112,
            EXPIRE_MO: 113,
            MO_INVALID_BATTLE_START: 114,
            MO_NOT_IN_ROOM: 115,
            MO_DISCONNECTED_WHEN_WIN_BATTLE: 116
        },
        SYSTEM: {
            SUSPEND_CALLBACKS_NATIVE_SUPPORT_VER: 351,
            ON_APPLICATION_FOREGROUND: "onApplicationForeground",
            ON_APPLICATION_BACKGROUND: "onApplicationBackground",
            ON_CALL_STATE_INCOMMING: "onCallStateIncoming",
            ON_CALL_STATE_DISCONNECTED: "onCallStateDisconnected"
        },
        DEAD_ANIMATE_TYPE: {
            DEAD: 1,
            BOSS: 2,
            APPARENT_DEAD: 3,
            ESCAPE: 4
        },
        STATUS_BONUS_TYPE: {
            SERIES: 1,
            ROLE: 2
        },
        BRK_DEF_TYPE: {
            ATK: 401,
            DEF: 402,
            MATK: 403,
            MDEF: 404,
            MND: 405,
            SPD: 406
        },
        BUDDY_ID: {
            DESHI: 10000200,
            WARRIOR: 10000300,
            KNIGHT: 10000400,
            RED_MAGE: 10000900,
            BLACK_MAGE: 10001100,
            WHITE_MAGE: 10001400,
            SUMMONER: 10001700,
            MAGIC_KNIGHT: 10002100,
            RANGER: 10002600,
            THIEF: 10002700,
            BARD: 10002800,
            NINJA: 10003e3,
            GLADIATOR: 10003300,
            WOL: 10100100,
            GARLAND: 10100200,
            SARAH: 10100300,
            ECHO: 10100500,
            FRIONIEL: 10200100,
            MARIA: 10200200,
            GUY: 10200300,
            LEON: 10200400,
            MINWU: 10200500,
            GORDON: 10200600,
            LEILA: 10200700,
            RICHARD: 10200800,
            JOSEF: 10200900,
            LUNETH: 10300100,
            ARC: 10300200,
            REFIA: 10300300,
            INGUS: 10300400,
            DESCH: 10300500,
            DARK_CECIL: 10400100,
            PALADIN_CECIL: 10400200,
            CAIN: 10400300,
            RYDIA: 10400400,
            ROSA: 10400600,
            GILBERT: 10400700,
            YANG: 10400800,
            PALOM: 10400900,
            POROM: 10401e3,
            TELLAH: 10401100,
            EDGE: 10401200,
            FUSOYA: 10401300,
            GOLBEZ: 10401400,
            BUTS: 10500800,
            LENNA: 10500200,
            GALUF: 10500500,
            GILGAMESH: 10500700,
            FARIS: 10500900,
            DORGANN: 10501e3,
            KRILE: 10501200,
            EXDEATH: 10501100,
            TINA: 10600100,
            LOCK: 10600300,
            CELES: 10600400,
            EDGAR: 10600600,
            MASH: 10600700,
            SHADOW: 10600800,
            CAYENNE: 10600900,
            GAU: 10601e3,
            SETZER: 10601100,
            STRAGUS: 10601200,
            RELM: 10601300,
            KEFKA: 10601600,
            LEO_CHRISTOPHE: 10601700,
            CLOUD: 10700100,
            BARRET: 10700200,
            TIFA: 10700300,
            AERITH: 10700400,
            RED_XIII: 10700500,
            SEPHIROTH: 10701e3,
            VINCENT: 10700800,
            ZACK: 10700900,
            RENO: 10701200,
            ANGEAL: 10701500,
            SQUALL: 10800100,
            RINOA: 10800200,
            QUISTIS: 10800300,
            ZELL: 10800400,
            SELPHIE: 10800500,
            IRVINE: 10800600,
            SEIFER: 10800700,
            LAGUNA: 10800900,
            EDEA: 10801e3,
            ZIDANE: 10900100,
            GARNET: 10900200,
            VIVI: 10900300,
            STEINER: 10900400,
            QUINA: 10900600,
            EIKO: 10900700,
            AMARANT: 10900800,
            BEATRIX: 10900900,
            KUJA: 10901e3,
            FREYA: 10900500,
            TIDUS: 11000100,
            YUNA: 11000200,
            WAKKA: 11000300,
            LULU: 11000400,
            KIMAHRI: 11000500,
            RIKKU: 11000600,
            AURON: 11000700,
            JECHT: 11001e3,
            BRASKA: 11001200,
            PAINE: 11001500,
            SHANTOTTO: 11100100,
            AYAME: 11100200,
            VAAN: 11200100,
            BALFLEAR: 11200200,
            FRAN: 11200300,
            BASCH: 11200400,
            ASHE: 11200500,
            PENELO: 11200600,
            GABRANTH: 11200700,
            LARSA: 11200800,
            LIGHTNING: 11300100,
            SNOW: 11300200,
            VANILLE: 11300300,
            SAZH: 11300400,
            HOPE: 11300500,
            FANG: 11300600,
            SERAH: 11300700,
            CID_RAINES: 11301e3,
            NOEL: 11301100,
            YSHTOLA: 11400100,
            THANCRED: 11400200,
            YDA: 11400300,
            PAPALYMO: 11400500,
            RAMZA: 15000100,
            AGRIAS: 15000200,
            DELITA: 15000300,
            OVELIA: 15000400,
            ORLANDU: 15000600,
            GAFGARION: 15000700
        },
        SPECIAL_AURA_TYPE: {
            NONE: 0,
            NORMAL: 1,
            HAS_PARAM_BOOSTER: 2,
            BREAK_MAX_DAMAGE_THRESHOLD: 3
        },
        SERIES_ID: {
            FF1: 101001,
            FF2: 102001,
            FF3: 103001,
            FF4: 104001,
            FF5: 105001,
            FF6: 106001,
            FF7: 107001,
            FF8: 108001,
            FF9: 109001,
            FF10: 110001,
            FF11: 111001,
            FF12: 112001,
            FF13: 113001,
            FF14: 114001,
            FFT: 150001
        },
        ENEMY_TARGETING: {
            SET_SA: 1,
            UNSET_SA: 2,
            HEAL_HP: 3
        },
        CAST_TIME_TYPE: {
            NORMAL_1: 101,
            QUICK_1: 151,
            SLOW_1: 201,
            TEN_MINS: 255
        },
        PARAM_ID_OF: {
            ATK: 1,
            DEF: 2,
            MATK: 3,
            MDEF: 4,
            MND: 5,
            SPD: 6
        },
        INVALIDITY_TYPE: {
            DO_ABILITY: 1,
            MAGIC: 2,
            FIGHT_ATTACK: 3
        },
        BOOST_TYPE: {
            STATUS: 1,
            RESULT: 2
        },
        ATTENUATION_CURVE: {
            LN: 1,
            LOG: 2
        },
        PARAM_IGNORE_TYPE: {
            NONE: 0,
            DEF_IGNORED: 1,
            DEF_BOOST_IGNORED: 2
        },
        ANIMATION: {
            DEFAULT_SPEED: 1,
            DEFAULT_SA_SPEED: 1,
            DEFAULT_PARTICLE_SPEED: 1,
            IN_DELAY_SPEED: 3,
            IN_DELAY_SA_SPEED: 3,
            IN_DELAY_PARTICLE_SPEED: 3
        },
        MO_CONTINUE: {
            WAIT_CONTINUE_SELECT_TIME: 3e4
        },
        AI_ARG_TYPE: {
            NUMBER: 1,
            NUMBER_LIST: 2,
            STRING: 3,
            STRING_LIST: 4,
            MESSAGE_ID: 5,
            MESSAGE_ID_LIST: 6,
            ABILITY_TAG: 7,
            ABILITY_TAG_LIST: 8
        },
        ENEMY_CONSTRAINT_TYPE: {
            FORCE_BY_TURN: 1001,
            FORCE_BY_INTERVAL_TURN: 1002,
            FORCE_BY_PREV_ABILITY: 1003,
            FORCE_BY_TURN_WITH_NOT_USED: 1004,
            FORCE_BY_HP_RATE_WITH_NOT_USED: 1005,
            WITHOUT_BY_UNLOCK_TURN: 2001,
            WITHOUT_BY_INTERVAL_TURN: 2002,
            WITHOUT_BY_USED_CNT: 2003,
            WITHOUT_BY_HP_RATE_UPPER: 2004,
            WITHOUT_BY_HP_RATE_LOWER: 2005
        },
        ENEMY_CONSTRAINT_FORCE_OPTIONS: {
            STRICT: "STRICT",
            REFLECTION: "REFLECTION",
            SMART: "SMART"
        },
        ENEMY_CONSTRAINT_WITHOUT_OPTIONS: {},
        DEAL_SS_POINT_TYPE: {
            NORMAL: 0,
            ENTRUST: 1
        },
        DAMAGE_THRESHOLD_TYPE: {
            DEFAULT: 0,
            PRIMARY: 1,
            INFINITY: 99
        },
        ENEMY_OPTIONAL_COUNTER_CHECK_TYPE: {
            NONE: 1,
            REFLECTION: 2,
            SMART: 3
        },
        ENEMY_BUILTIN_MULTIPLE_TARGET_TYPE: {
            SAME_CAN_HIT: 1
        },
        ACTOR_STATS_NOTIFY_TYPE: {
            APPLY_DAMAGE_OBJECT: 1,
            DIE: 2,
            RESET_FOR_CONTINUE: 3
        },
        ACTOR_STATS_TYPE: {
            DAMAGE_RECEIVE_COUNT: 1
        },
        DAMAGE_RECEIVE_COUNT_TYPE: {
            STANDARD: 1
        }
    }, FF.ns.battle.Conf
}), define("scenes/battle/AbilityFactory", ["./Conf", "underscore"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.ENEMY_TARGETING;
    FF.ns.battle.AbilityFactory = {
        getActionInfo: function(e) {
            var n = t.find(this.actionMap, function(t) {
                return t.actionId === e
            }, this);
            if (!n) throw new Error("actionInfo not found." + e);
            return n
        },
        create: function(e, n, r) {
            var i = FF.ns.battle.AbilityInfoMgr.getInstance(),
                s = i.getById(e),
                o = s.actionId,
                u = this.getActionInfo(o),
                a = i.isBuiltinAbility(e),
                f = FF.ns.battle.action[u.className];
            if (!f) throw new Error("actionInfo not found." + o);
            var l = i.getSaIdsForSetById(e),
                c = i.getSaIdsForUnsetById(e),
                h = i.getIgnoresReflection(e),
                p = i.isFlightAttackById(e),
                d = i.getElementConfsById(e),
                v = {
                    abilityId: e,
                    actionId: o,
                    categoryId: s.categoryId,
                    exerciseType: s.exerciseType,
                    atkStatusAilmentIds: l,
                    healStatusAilmentIds: c,
                    ignoresReflection: h,
                    isFlightAttack: p,
                    abilityCategoryId: s.categoryId,
                    elementConfs: d,
                    skipStepCnt: a,
                    isPossibleContainMagicDamage: u.isPossibleContainMagicDamage,
                    changeCastTimeCondList: u.changeCastTimeCondList
                },
                m = {};
            !!r && r.isCounter && (m.skipStepCnt = !0), t.extend(v, s.options, r, m);
            var g = new f(n, v),
                y = s.animationInfo;
            if (y && y.id) g.set("animationInfo", y);
            else if (g.get("dependsWeaponEffect")) {
                var b = n.getEquipWeaponEffectInfo();
                b && g.set("animationInfo", b)
            }
            return g.moHelper.setCreateOptions(r), g
        },
        actionMap: [{
            actionId: 1,
            className: "PhysicalAttackMultiAndHpBarterAction",
            elements: {
                args: [3, 8]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 2,
            className: "JumpAction",
            isFlightAttack: !0,
            elements: {
                args: [14, 15]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 3,
            className: "PhysicalAttackAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 4,
            className: "PhysicalAttackAndAbsorbHpAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 5,
            className: "MagicAttackAction",
            ignoresReflectionArg: 4,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 6,
            className: "PhysicalAttackHitAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 7,
            className: "PhysicalAttackMultiAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 8,
            className: "HealSaMultiAction",
            ignoresReflectionArg: 2,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [1]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 10,
            className: "HealSaLotAction",
            isHeal: !0
        }, {
            actionId: 11,
            className: "HealDeathAction",
            isHeal: !0
        }, {
            actionId: 12,
            className: "HealHpAction",
            ignoresReflectionArg: 4,
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 13,
            className: "HealSaAction",
            isHeal: !0,
            unsetSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 14,
            className: "InflictSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 2, 3, 4, 5],
                bundleArgs: [7]
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 15,
            className: "InflictSaHitAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 2, 3, 4, 5],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA],
            ignoresReflectionArg: 6
        }, {
            actionId: 16,
            className: "MagicAttackMultiAction",
            ignoresReflectionArg: 6,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 17,
            className: "FractionalAttackByHpAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 19,
            className: "SelfDestructAction"
        }, {
            actionId: 20,
            className: "LvInflictSaAction"
        }, {
            actionId: 23,
            className: "LotAction",
            changeCastTimeCondList: ["physicalDamageAbilitiesWithoutInborn", "magicDamageAbilitiesWithoutInborn"]
        }, {
            actionId: 25,
            className: "ParamBoosterAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 27,
            className: "PhysicalAttackCriticalOrMissAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 28,
            className: "PhysicalAttackAndCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 29,
            className: "FractionalAttackByMaxHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 30,
            className: "PhysicalAttackAndDefIgnoredAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 31,
            className: "MagicAttackAndDefIgnoredAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 32,
            className: "MagicAttackAndDeformAction",
            ignoresReflectionArg: 4,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 33,
            className: "CustomParamAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 34,
            className: "EnemyJumpAction",
            isFlightAttack: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 35,
            className: "PhysicalAttackElementAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 36,
            className: "MagicAttackAndAbsorbHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 37,
            className: "DamagedHpAttackAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 38,
            className: "DealSsPointAction"
        }, {
            actionId: 39,
            className: "CustomParamAndSelfDestructAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 40,
            className: "ReduceMpAction"
        }, {
            actionId: 41,
            className: "FixedDamageAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 42,
            className: "PhysicalAttackWithoutAimingBySaAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 43,
            className: "MagicAttackAndCustomParamAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 44,
            className: "FixedHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 45,
            className: "FractionalAttackByHpWithoutSaAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 46,
            className: "MagicAttackAndHealDeathAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 47,
            className: "PhysicalAttackWithHealSaAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 48,
            className: "PhysicalAttackWithMultiSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [3]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 49,
            className: "PhysicalAttackAndSelfCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 50,
            className: "InflictSaAndFallbackMagicAttackAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 51,
            className: "InflictSaHitAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [1, 2, 3, 4],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 52,
            className: "ShowAbilityEffectAction"
        }, {
            actionId: 53,
            className: "PhysicalAttackMultiAndDeformAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 54,
            className: "HealHpAndCustomParamAction",
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 55,
            className: "PhysicalAttackAndDeformAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 56,
            className: "FractionalAttackByHpWithoutSaAndInflictSaAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 58,
            className: "PhysicalAttackElementAndCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 59,
            className: "HealAndInflictSaAction",
            ignoresReflectionArg: 5,
            setSa: {
                useStatusAilmentsId: !1,
                args: [2],
                bundleArgs: []
            },
            unsetSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 60,
            className: "IncreaseMpAction"
        }, {
            actionId: 61,
            className: "PhysicalDamagedHpAttackAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 63,
            className: "PhysicalAttackMultiWithMultiParamsAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 64,
            className: "HealHpAndInflictSaAndSelfCustomParamAction"
        }, {
            actionId: 65,
            className: "CustomParamBidirectionallyAction"
        }, {
            actionId: 66,
            className: "PhysicalInflictSaBidirectionallyAction"
        }, {
            actionId: 67,
            className: "MagicAttackAndHealHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 68,
            className: "MagicAttackAndSelfCustomParamAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 69,
            className: "PhysicalAttackAndSelfSaAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 70,
            className: "FixedDamageMultiAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 71,
            className: "FixedHpAndDeformAction"
        }, {
            actionId: 72,
            className: "MagicAttackAndPhysicalAttackElementAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 73,
            className: "PhysicalAttackAndPartyCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 74,
            className: "PhysicalAttackMultiAndCustomParamAndHealSaMultiAction",
            elements: {
                args: [5, 9]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [10]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 76,
            className: "PhysicalAttackMultiAndHealHpAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 77,
            className: "CustomParamMultiAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [8, 9, 10],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 78,
            className: "RageAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 79,
            className: "InflictSaAndCustomProbabilityDeformAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [1, 3, 5, 7, 9],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 80,
            className: "PhysicalAttackAndInflictSaAndSelfSaAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 81,
            className: "ShowAbilityEffectDeformAction"
        }, {
            actionId: 82,
            className: "CustomParamMultiAction"
        }, {
            actionId: 83,
            className: "PhysicalAttackElementMultiAndSelfCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 84,
            className: "AttachElementAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [1],
                bundleArgs: []
            }
        }, {
            actionId: 85,
            className: "PhysicalAttackWithMultiHealSaAction",
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [4, 5, 6, 7, 8],
                bundleArgs: [9]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 86,
            className: "HealHpAndHealSaMultiAction",
            isHeal: !0,
            ignoresReflectionArg: 4,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [6, 7, 8],
                bundleArgs: [5]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 87,
            className: "HealHpAndHealDeathAction",
            isHeal: !0
        }, {
            actionId: 88,
            className: "MagicAttackMultiAndSelfSaAction",
            isPossibleContainMagicDamage: !0,
            ignoresReflectionArg: 10,
            elements: {
                args: [3, 12]
            }
        }, {
            actionId: 89,
            className: "PhysicalAttackElementMultiAndPartyCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 90,
            className: "HealHpAndHealSaAction",
            isHeal: !0,
            ignoresReflectionArg: 4,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [6, 7, 8],
                bundleArgs: [5]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 91,
            className: "PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 92,
            className: "MagicAttackMultiAndPartyCustomParamAction",
            ignoresReflectionArg: 9,
            isPossibleContainMagicDamage: !0,
            elements: {
                args: [3, 11, 12]
            }
        }, {
            actionId: 93,
            className: "SelfDestructAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 94,
            className: "ChangeCastTimeAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            }
        }, {
            actionId: 95,
            className: "MagicAttackAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [5, 6, 7, 8, 9],
                bundleArgs: [4]
            },
            enemyTargeting: [r.SET_SA],
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 96,
            className: "FractionalHealByHpAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 97,
            className: "MagicAttackAndAbsorbHpAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 98,
            className: "HealSaMultiAndDeformAction",
            ignoresReflectionArg: 2,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [1]
            },
            enemyTargeting: [r.UNSET_SA]
        }, {
            actionId: 99,
            className: "PhysicalAttackMultiAndInflictSaAndCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 100,
            className: "PhysicalAttackMultiAndHealSaMultiAction",
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 101,
            className: "PhysicalAttackMultiWithMultiSaAction",
            elements: {
                args: [5, 10]
            },
            setSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 102,
            className: "MagicAttackMultiWithMultiSaAction",
            ignoresReflectionArg: 6,
            setSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [7]
            },
            enemyTargeting: [r.SET_SA],
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 103,
            className: "PhysicalAttackMultiAndSelfSaAction",
            elements: {
                args: [5, 11]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 104,
            className: "MagicAttackAndDefIgnoredAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 105,
            className: "MagicAttackMultiAndInflictSaMultiAndHealSaAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [6, 8],
                bundleArgs: [13]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [10]
            },
            isPossibleContainMagicDamage: !0,
            ignoresReflectionArg: 12,
            elements: {
                args: [2, 15]
            }
        }, {
            actionId: 106,
            className: "MagicAttackAndDefBoostIgnoredAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 107,
            className: "PhysicalAttackMultiAndSelfSaMultiAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 108,
            className: "PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction",
            elements: {
                args: [5, 11, 12]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 109,
            className: "TranceAction"
        }, {
            actionId: 110,
            className: "InflictSaAndIncreaseMpAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [5, 6, 7, 8],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 111,
            className: "PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 112,
            className: "FixedDamageAndHealSaMultiAndInflictSaAndDeformAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [6, 7],
                bundleArgs: []
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [3]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 113,
            className: "FixedDamageAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 114,
            className: "HealHpAndIncreaseMpAction",
            ignoresReflectionArg: 4
        }, {
            actionId: 115,
            className: "PhysicalAttackMultiAndColleagueSaAndCustomParamAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [7, 8],
                bundleArgs: []
            },
            elements: {
                args: [5, 15]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 116,
            className: "PhysicalAttackAndAbsorbHpAndReduceMpAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 117,
            className: "MagicAttackAndInflictSaMultiAndHealSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 118,
            className: "MagicAttackAndInflictSaMultiAndHealSaMultiAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 119,
            className: "PhysicalAttackMultiAndSelfAttachElementAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"],
            elements: {
                args: [4, 13]
            }
        }, {
            actionId: 121,
            className: "PhysicalAttackMultiAndCustomParamAndPartyCustomParamAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 122,
            className: "PhysicalAttackMultiDependedOnSaAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [9, 10],
                bundleArgs: []
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 123,
            className: "FractionalAttackByHpOnAttackerHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 124,
            className: "PhysicalAttackAndAbsorbHpAndDeformAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 125,
            className: "ExecAbilityByStatusAction",
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 126,
            className: "PhysicalAttackMultiAndHealHpByHitDamageAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"],
            elements: {
                args: [5, 8]
            }
        }, {
            actionId: 127,
            className: "FractionalHealByHpAndInflictSaAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 128,
            className: "PhysicalAttackMultiWithHealSaAction",
            isHeal: !0,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [10]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 129,
            className: "FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 130,
            className: "FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 131,
            className: "PhysicalAttackMultiAndCustomParamAndSelfCustomParamWithEffectAction",
            elements: {
                args: [4, 11]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 132,
            className: "MagicAttackAndHealSelfHpAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 133,
            className: "MagicAttackAndHealSelfHpAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 134,
            className: "MagicAttackMultiAndInflictSaAndCustomParamAction",
            elements: {
                args: [2, 10, 11]
            },
            ignoresReflectionArg: 9,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 135,
            className: "HealHpOrHealDeathAction",
            isHeal: !0
        }, {
            actionId: 136,
            className: "MagicAttackMultiAndHealHpAndCustomParamAction",
            ignoresReflectionArg: 7,
            isPossibleContainMagicDamage: !0,
            elements: {
                args: [2, 14]
            }
        }, {
            actionId: 137,
            className: "PhysicalAttackMultiAndAttachElementAsDisadvantageAction",
            elements: {
                args: [5, 15]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 138,
            className: "PhysicalAttackAndCustomParamDeformAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 139,
            className: "CustomParamDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: []
            },
            enemyTargeting: [r.SET_SA]
        }, {
            actionId: 140,
            className: "MagicAttackMultiWithMultiElementAction",
            elements: {
                args: [5, 6, 7, 8]
            },
            ignoresReflectionArg: 9,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 141,
            className: "PhysicalAttackMultiWithMultiElementAction",
            elements: {
                args: [6, 7, 8, 9]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 142,
            className: "PhysicalAttackMultiAndSelfCustomParamAction",
            elements: {
                args: [5, 12]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 143,
            className: "MagicAttackMultiAndSelfAttachElementAction",
            elements: {
                args: [3, 12, 13, 14]
            },
            ignoresReflectionArg: 11,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 144,
            className: "CustomParamMultiAndHpBarterAction"
        }, {
            actionId: 145,
            className: "HealHpAndInflictSaMultiAndHealSaMultiAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP, r.SET_SA, r.UNSET_SA],
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            }
        }, {
            actionId: 146,
            className: "HealHpAndInflictSaMultiAndHealSaMultiAndDeformAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP, r.SET_SA, r.UNSET_SA],
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            }
        }, {
            actionId: 147,
            className: "MagicAttackMultiAndDeformAction",
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 148,
            className: "MagicAttackMultiAndSelfSaAndSelfCustomParamAction",
            ignoresReflectionArg: 10,
            elements: {
                args: [3, 12]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 149,
            className: "MagicAttackMultiAndHpBarterAction",
            ignoresReflectionArg: 6,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 150,
            className: "PhysicalAttackAndDefIgnoredAndDeformAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 151,
            className: "MagicAttackMultiAndAttachElementAsDisadvantageAction",
            ignoresReflectionArg: 6,
            isPossibleContainMagicDamage: !0,
            elements: {
                args: [4, 10]
            }
        }, {
            actionId: 153,
            className: "CustomParamAndInflictSaDirectionSelectiveAction"
        }, {
            actionId: 154,
            className: "MagicAttackMultiAndColleagueSaAction",
            ignoresReflectionArg: 9,
            isPossibleContainMagicDamage: !0,
            setSa: {
                useStatusAilmentsId: !1,
                args: [5, 6, 7],
                bundleArgs: []
            }
        }, {
            actionId: 155,
            className: "PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 156,
            className: "PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 157,
            className: "MagicAttackMultiAndSelfCustomParamAction",
            ignoresReflectionArg: 7,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 158,
            className: "MagicAttackMultiWithMultiElementAndFractionalHealHpAction",
            elements: {
                args: [5, 6, 7, 8]
            },
            ignoresReflectionArg: 9,
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 160,
            className: "PhysicalAttackMultiAndAttachElementAsDisadvantageWithMultiElement",
            elements: {
                args: [9, 10, 11, 12]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 161,
            className: "FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 162,
            className: "FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAndDeformAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [4]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [10],
                bundleArgs: [9]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 163,
            className: "FixedDamageMultiAndCustomParamAndInflictSaMultiAction",
            setSa: {
                useStatusAilmentsId: !0,
                args: [],
                bundleArgs: [8]
            },
            isPossibleContainMagicDamage: !0,
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 164,
            className: "CustomParamAndInflictSaAndSelfAttachElementAction"
        }, {
            actionId: 165,
            className: "HealHpAndInflictHpStockAction",
            isHeal: !0,
            ignoresReflectionArg: 4
        }, {
            actionId: 166,
            className: "PhysicalAttackElementMultiAndColleagueSaAction",
            elements: {
                args: [6, 7, 8, 9]
            },
            setSa: {
                useStatusAilmentsId: !1,
                args: [11, 12],
                bundleArgs: []
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 167,
            className: "ExecAbilityByUsedAbilityCountAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 168,
            className: "PhysicalAttackMultiWithMultiElementAndFractionalHealHpAndHealSaMultiAction",
            elements: {
                args: [6, 7, 8, 9]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [12]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 169,
            className: "HealHpAndSelfCustomParamAction",
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 170,
            className: "ExecAbilityWithNoEffectSelfCustomParamAndSelfSaAction",
            setSa: {
                useStatusAilmentsId: !1,
                args: [5],
                bundleArgs: [6]
            },
            isPossibleContainMagicDamage: !0
        }, {
            actionId: 171,
            className: "PhysicalAttackElementMultiAndIncreaseMpAction",
            elements: {
                args: [6, 7, 8, 9]
            },
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 172,
            className: "PhysicalAttackMultiAndCustomParamAndSelfSaAction",
            changeCastTimeCondList: ["defaultPhysicalDamageAbilities"]
        }, {
            actionId: 173,
            className: "AttachElementAsDisadvantageAndCustomParamAndInflictSaDirectionSelectiveAction"
        }, {
            actionId: 174,
            className: "FractionalHealByHpAndHealSaMultiAndCustomParamAction",
            isHeal: !0,
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [5]
            }
        }, {
            actionId: 175,
            className: "MagicAttackMultiAndHealHpAndInflictSaAction",
            ignoresReflectionArg: 7,
            elements: {
                args: [10, 11]
            },
            changeCastTimeCondList: ["defaultMagicDamageAbilities"]
        }, {
            actionId: 176,
            className: "IncreaseFixedMpAction"
        }, {
            actionId: 177,
            className: "MagicAttackElementMultiAndSelfIncreaseMpAction",
            ignoresReflectionArg: 5,
            elements: {
                args: [6, 7, 8, 9]
            },
            changeCastTimeCondList: ["defaultMagicDamageAbilities"]
        }, {
            actionId: 178,
            className: "ExecAbilityBySelfSaAction",
            changeCastTimeCondList: ["physicalDamageAbilitiesWithoutInborn", "magicDamageAbilitiesWithoutInborn"]
        }, {
            actionId: 179,
            className: "CustomParamAndInflictHpStockAction"
        }, {
            actionId: 180,
            className: "FixedHealHpAction",
            isHeal: !0,
            enemyTargeting: [r.HEAL_HP]
        }, {
            actionId: 181,
            className: "ExecAbilityByTargetWeaknessAction",
            changeCastTimeCondList: ["physicalDamageAbilitiesWithoutInborn", "magicDamageAbilitiesWithoutInborn"]
        }, {
            actionId: 182,
            className: "MagicAttackMultiWithHealSaAction",
            ignoresReflectionArg: 5,
            elements: {
                args: [6]
            },
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [8],
                bundleArgs: []
            },
            changeCastTimeCondList: ["defaultMagicDamageAbilities"]
        }, {
            actionId: 183,
            className: "ExecAbilityByCondThresholdAction",
            changeCastTimeCondList: ["physicalDamageAbilitiesWithoutInborn", "magicDamageAbilitiesWithoutInborn"]
        }, {
            actionId: 185,
            className: "HealSaMultiDirectionSelectiveAction",
            unsetSa: {
                useStatusAilmentsId: !1,
                args: [],
                bundleArgs: [1]
            }
        }, {
            actionId: 186,
            className: "MagicAttackMultiAndHealHpByHitDamageAction",
            ignoresReflectionArg: 3,
            elements: {
                args: [5]
            },
            changeCastTimeCondList: ["defaultMagicDamageAbilities"]
        }, {}, {
            actionId: n.Conf.ACTION_ID_OF.POISON,
            className: "SaPoisonAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.REGEN,
            className: "SaRegenAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.HP_STOCK,
            className: "SaHpStockAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.RADIANT_SHIELD,
            className: "SaRadiantShieldAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFORM,
            className: "DeformAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFORM_MULTI,
            className: "DeformMultiAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DEFENSE,
            className: "DefenseAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DO_NOTHING,
            className: "DoNothingAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.DO_NOTHING_STRICTLY,
            className: "DoNothingStrictlyAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.HEAL_DEATH,
            className: "BuiltinHealDeathAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.SELF_CUSTOM_PARAM,
            className: "BuiltinSelfCustomParamAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.INCREASE_MP,
            className: "BuiltinIncreaseMpAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_INFLICT_SA,
            className: "BuiltinInflictSaAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.RERAISE_RISE,
            className: "ReraiseRiseAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.HEAL_HP_BY_DAMAGE_SUM,
            className: "BuiltinHealHpByDamageSumAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_HEAL_HP,
            className: "BuiltinHealHpAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_ENEMY_MULTIPLE_ABILITY,
            className: "BuiltinEnemyMultipleAbilityAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_FRACTIONAL_HEAL_HP,
            className: "BuiltinFractionalHealHpAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.BUILTIN_HEAL_SA,
            className: "BuiltinHealSaAction"
        }, {
            actionId: n.Conf.ACTION_ID_OF.GUTS_RISE,
            className: "GutsRiseAction"
        }]
    }
}), define("scenes/battle/AbilityInfoMgr", ["lib/ClassBase"], function(e) {
    var t = e.extend({
            initialize: function() {
                this._params = {}
            },
            load: function() {
                _.each(arguments, function(e) {
                    _.each(e, function(e) {
                        if (!e.abilityId) return;
                        this._parseParticleJson(e), this._params[e.abilityId] = this._makeInfo(e)
                    }, this)
                }, this), _.each(FF.ns.battle.Config.getInstance().get("BuiltinAbilities"), function(e) {
                    this._params[e.abilityId] = this._makeInfo(e)
                }, this)
            },
            _parseParticleJson: function(e) {
                if (!e && !e.animationInfo) return;
                e.animationInfo.launchParticleJson && (e.animationInfo.launchParticleJson = JSON.parse(e.animationInfo.launchParticleJson)), e.animationInfo.shotParticleJson && (e.animationInfo.shotParticleJson = JSON.parse(e.animationInfo.shotParticleJson)), e.animationInfo.hitParticleJson && (e.animationInfo.hitParticleJson = JSON.parse(e.animationInfo.hitParticleJson))
            },
            _makeInfo: function(e) {
                var t = e.actionId,
                    n = FF.ns.battle.AbilityFactory.getActionInfo(e.actionId);
                return _.extend({}, e, {
                    actionInfo: n
                })
            },
            getById: function(e) {
                var t = this._params[e];
                if (!t) throw new Error("param not found.id=" + e);
                return t
            },
            isBuiltinAbility: function(e) {
                var t = FF.ns.battle.Config.getInstance().get("BuiltinAbilities");
                return _.any(t, function(t) {
                    return t.abilityId === e
                })
            },
            isHealHpTypeById: function(e) {
                var t = this.getById(e),
                    n = FF.ns.battle.AbilityFactory.getActionInfo(t.actionId);
                return n.isHeal ? !0 : !1
            },
            getEnemyTargeting: function(e) {
                var t = "enemyTargeting",
                    n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t];
                return _.isUndefined(i) ? [] : i
            },
            getIgnoresReflection: function(e) {
                var t = "ignoresReflectionArg",
                    n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t];
                if (_.isUndefined(i)) return !1;
                if (_.isBoolean(i)) return i;
                if (i) {
                    var s = n.options["arg" + i];
                    return !!s
                }
                return !1
            },
            getSaIdsForSetById: function(e) {
                return this._getSaIdsById(e, "setSa")
            },
            getSaIdsForUnsetById: function(e) {
                return this._getSaIdsById(e, "unsetSa")
            },
            _getSaIdsById: function(e, t) {
                var n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t],
                    s = [];
                if (_.isUndefined(i)) return s;
                var o = i.useStatusAilmentsId;
                o && n.options.statusAilmentsId && (s = _.union(s, [n.options.statusAilmentsId]));
                var u = i.args || [];
                _.each(u, function(e) {
                    var t = n.options["arg" + e];
                    t && (s = _.union(s, [t]))
                }, this);
                var a = i.bundleArgs || [];
                return _.each(a, function(e) {
                    var t = n.options["arg" + e];
                    if (t) {
                        var r = FF.ns.battle.StatusAilmentsConfig.getBundle(t);
                        s = _.union(s, r)
                    }
                }, this), s
            },
            isFlightAttackById: function(e) {
                var t = this.getById(e);
                if (t.actionInfo && t.actionInfo.isFlightAttack) return !0;
                var n = FF.ns.battle.Config.getInstance().get("ExceptionalFlightAttackIds");
                return _.contains(n, e) ? !0 : !1
            },
            getElementConfsById: function(e) {
                var t = "elements",
                    n = this.getById(e),
                    r = FF.ns.battle.AbilityFactory.getActionInfo(n.actionId),
                    i = r[t],
                    s = [];
                if (_.isUndefined(i)) return s;
                var o = 1,
                    u = i.args || [];
                return _.each(u, function(e) {
                    var t = n.options[sprintf("arg%d", e)];
                    if (!t) return;
                    s.push({
                        element: t,
                        priority: o
                    }), o++
                }), s
            }
        }),
        n = void 0;
    FF.ns.battle.AbilityInfoMgr = {
        getInstance: function() {
            return n || (n = new t), n
        }
    }
}), define("scenes/battle/AbilityMgr", ["lib/ClassBase", "util"], function(e, t) {
    var n = ["_beforeCounterInterrupters", "_counterInterrupters", "_bossInterrupters", "_radiantShieldInterrupters", "_statusAilmentsInterrupters", "_suspendedAbility"],
        r = e.extend({
            initialize: function() {
                this.reset()
            },
            reset: function() {
                _.each(n, function(e) {
                    this[e] = []
                }, this)
            },
            pushSuspend: function(e) {
                this._suspendedAbility.push(e)
            },
            shiftSuspend: function() {
                return this._suspendedAbility.shift()
            },
            interruptBoss: function(e) {
                this._bossInterrupters.push(e)
            },
            interruptCounter: function(e) {
                this._counterInterrupters.push(e)
            },
            interruptBeforeCounter: function(e) {
                this._beforeCounterInterrupters.push(e)
            },
            interruptStatusAilments: function(e) {
                this._statusAilmentsInterrupters.push(e)
            },
            interruptRadiantShield: function(e) {
                this._radiantShieldInterrupters.push(e)
            },
            shiftInterrupter: function() {
                var e = void 0;
                return e || (e = this._beforeCounterInterrupters.shift()), e || (e = this._counterInterrupters.shift()), e || (e = this._bossInterrupters.shift()), e || (e = this._radiantShieldInterrupters.shift()), e || (e = this._statusAilmentsInterrupters.shift()), e && (this._isDead(e.executer) || this._isDyingCounter(e) || e.isCanceledInterruptAbility()) ? (e.forceQuit(), this.shiftInterrupter()) : e
            },
            _isDead: function(e) {
                return e.isContainer() ? e.isAllDead() : e.isDead()
            },
            _isDyingCounter: function(e) {
                var t = e.executer;
                return t.isContainer() ? !1 : t.judgeDeath() && !!e.get("isCounter")
            },
            shiftAbility: function() {
                for (var e = 0, t = this._suspendedAbility.length; e < t; e++)
                    if (this._suspendedAbility[e].isResumed()) return this._suspendedAbility.splice(e, 1)[0];
                var n = FF.ns.battle.ActorMgr.getAliveActors(),
                    r = _.filter(n, function(e) {
                        return e.isReadyToExecAbility() && e.canDoAbility()
                    });
                if (r.length <= 0) return;
                r.sort(function(e, t) {
                    return e.getReadyToExecAbilityAt() - t.getReadyToExecAbilityAt()
                });
                if (r[0]) return r[0].getAbility();
                return
            },
            cancelInterruptAbilityOfActor: function(e) {
                _.each(n, function(t) {
                    _.each(this[t], function(t) {
                        t.executer.equals(e) && t.cancelInterruptAbility()
                    }, this)
                }, this)
            },
            existsRegisteredInterruptAbility: function(e) {
                e = t.option({
                    upperEqualBoss: !1
                }, e);
                var r = !0,
                    i = _.filter(n, function(t) {
                        return r ? (e.upperEqualBoss && t === "_bossInterrupters" && (r = !1), !0) : !1
                    });
                return _.any(i, function(e) {
                    return 0 < this[e].length
                }, this)
            }
        }),
        i = void 0;
    FF.ns.battle.AbilityMgr = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/ActiveTarget", ["lib/ClassBase"], function(e) {
    FF.ns.battle.ActiveTarget = e.extend({
        initialize: function() {
            this._attributes = {
                selectedUid: void 0
            }
        },
        resetSelected: function() {
            this.get("selectedUid") && FF.logger.debug("uid:" + this.get("selectedUid") + " "), this.set("selectedUid", null)
        },
        setSelected: function(e) {
            var t = this.get("selectedUid");
            if (t)
                if (t === e) this.set("selectedUid", null);
                else {
                    var n = t;
                    this.set("selectedUid", e)
                }
            else this.set("selectedUid", e)
        },
        getSelected: function() {
            return this.get("selectedUid")
        }
    })
}), define("scenes/battle/ActorBase", ["underscore", "util", "lib/ProtectParamsBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = ["hp"];
    return FF.ns.battle.ActorBase = n.extend({
        STATE2FUNC: {
            IDLE: {
                entry: "processForStateIdleEntry"
            },
            IN_CAST: {
                entry: "processForStateInCastEntry"
            },
            IN_ACTION: {
                entry: "processForStateInActionEntry",
                exit: "processForStateInActionExit"
            },
            END: {
                entry: "processForStateEndEntry"
            }
        },
        initialize: function(t, i, s) {
            n.prototype.initialize.call(this), e.extend(this._attributes, s), this._id = i, this._uid = t;
            var o = s.params[0];
            this._attributes.paramId = o.id, this._actorParamHolder = new r.ActorParamHolder(this, o), this.set("hp", s.initHp), this.actorStats = new r.ActorStats, this.statusAilments = new r.StatusAilments(this), this.counters = new r.Counters(this), this.lastApplyDamageObjectActor = void 0, e.each(s.statusAilments, function(e) {
                this.statusAilments.set(e, this)
            }, this), this.setupNewBattle()
        },
        getCurrentParam: function() {
            var e = this._attributes.paramMap,
                t = this._attributes.paramId,
                n = e[t];
            if (!n) throw new Error("param not found.id=" + t);
            return n
        },
        changeBaseParam: function(e) {
            var t = this.getCurrentParam();
            this.set("paramId", e);
            var n = this.getCurrentParam();
            this._actorParamHolder.changeBaseParam(n), this.trigger("ActorBase::changeBaseParam", this, n, t)
        },
        getBaseParam: function() {
            return this._actorParamHolder.getBaseParam()
        },
        getProtectParams: function() {
            var t = n.prototype.getProtectParams.call(this);
            return e.union(t, i)
        },
        get: function(e, t) {
            var r = this.getParamHolderForRead(t);
            if (r.has(e)) return r.get(e);
            var i = this.getCurrentParam();
            return i[e] ? i[e] : n.prototype.get.call(this, e)
        },
        set: function(e, t, r) {
            var i = this.get(e),
                s;
            if (this._actorParamHolder.has(e)) {
                if (this._actorParamHolder.isBoostableParam(e)) throw new Error('can not set key "' + e + '"');
                s = this._actorParamHolder.changeParam(e, t, r)
            } else s = n.prototype.set.call(this, e, t);
            return this.trigger("ActorBase::set", this, e, t, i), s
        },
        setBoost: function(e, t, n) {
            var r;
            return this._actorParamHolder.has(e) && (r = this._actorParamHolder.changeParam(e, t, n)), this.trigger("ActorBase::setBoost", this, e, t, n), r
        },
        setAttachElementBoost: function(e, t, n, r) {
            var i;
            return this._actorParamHolder.has(e) && (i = this._actorParamHolder.changeAttachElementParam(e, t, n)), this.trigger("ActorBase::setAttachElementBoost", this, e, t, n, r), i
        },
        resetParam: function(e) {
            this._actorParamHolder.resetParamById(e)
        },
        getParamHolderForRead: function(e) {
            return this._actorParamHolder
        },
        setupNewBattle: function() {
            this.changeState("IDLE"), this.isSpEnemy() ? this.resetAtb() : this.set("elapsedAtbTime", t.randomInt(this.getAtbTime() - 1)), this.set("elapsedCastTime", 0), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this._lastAbility = null, this.statusAilments.processForSetupNewBattle()
        },
        applyDamageObject: function(t) {
            t.healDeath && t.canHit && this.rise(), t.executer ? this.lastApplyDamageObjectActor = t.executer : this.lastApplyDamageObjectActor = void 0;
            if (t.isSsPoint && t.canHit) {
                var n = t.executer.getSoulStrike(),
                    i = t.receiver.getSoulStrike();
                n.addPoint(t.executorSsPointDiff), i.addPoint(t.receiverSsPointDiff)
            }
            this.counters.evaluate(t);
            if (t.isAbilityPanel) t.abilityPanel.set("remainNum", t.currNum);
            else if (t.damage) {
                var s = this.get("hp");
                this.set("prevHp", s);
                var o = this.applyDamage(t.damage);
                t.actualDamage = s - o, t.executer && t.absorbHp && t.absorbHp.damage && t.executer.applyDamage(t.absorbHp.damage), t.receiver && t.receiver.isBuddy() && t.receiver.getSoulStrike().addPointAsReceiver(t), this.statusAilments.processForDamaged(t), this.trigger("ActorBase::addDamage", this, t)
            }
            if (t.statusAilments) {
                var u = [];
                e.each(t.statusAilments, function(e) {
                    var n = {
                        ability: t.ability
                    };
                    this.statusAilments.set(e, t.executer, t.statusAilmentsOptions, n) && u.push(e)
                }, this), t.statusAilments = u, this.trigger("ActorBase::addStatusAilments", this, t)
            }
            t.unsetStatusAilments && (e.each(t.unsetStatusAilments, function(e) {
                this.statusAilments.unset(e)
            }, this), this.trigger("ActorBase::unsetStatusAilments", this, t)), this.actorStats.notify(r.Conf.ACTOR_STATS_NOTIFY_TYPE.APPLY_DAMAGE_OBJECT, {
                damageObject: t
            }), this.trigger("ActorBase::applyDamageObject", this, t)
        },
        applyDamage: function(e) {
            var t = this.get("maxHp"),
                n = this.get("hp") - e;
            return n <= 0 && (n = 0), n > t && (n = t), this.set("hp", n), n
        },
        canHealDeath: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.DEATH) || this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH)
        },
        judgeDeath: function() {
            return this.get("hp") <= 0 || this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH) || this.statusAilments.judgeDeathByDoom()
        },
        rise: function() {
            this.isInReraiseDeath() ? (this.statusAilments.unset(r.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH), this.trigger("ActorBase::reraise::rise", this)) : (this.statusAilments.unset(r.Conf.STATUS_AILMENTS_TYPE.DEATH), this.trigger("ActorBase::rise", this))
        },
        kill: function() {
            this.statusAilments.set(r.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, this)
        },
        die: function() {
            this.changeState("IDLE");
            var e = r.ActorMgr.getAbilityPanelSelector();
            e && e.equals(this) && r.ActorMgr.clearActiveTarget();
            var n = r.ActorMgr.getActiveTarget();
            n && n.equals(this) && r.ActorMgr.clearActiveTarget(), this.set("hp", 0), this.set("elapsedAtbTime", t.randomInt(this.getAtbTime() - 1)), this.set("elapsedCastTime", 0), this.statusAilments.set(r.Conf.STATUS_AILMENTS_TYPE.DEATH, this), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this._lastAbility = null, this.actorStats.notify(r.Conf.ACTOR_STATS_NOTIFY_TYPE.DIE), this.isInReraiseDeath() ? this.trigger("ActorBase::reraise::die", this) : this.trigger("ActorBase::die", this)
        },
        getReadyToSelectAbilityAt: function() {
            return this._readyToSelectAbilityAt
        },
        getReadyToExecAbilityAt: function() {
            return this._readyToExecAbilityAt
        },
        changeState: function(e) {
            var n = this.get("state");
            if (e === n) return;
            this.set("state", e), this._stateChangedAt = t.getTime();
            if (n) {
                var r = this.STATE2FUNC[n].exit;
                r && this[r]()
            }
            var i = this.STATE2FUNC[this.get("state")].entry;
            i && this[i](), this.trigger("ActorBase::changeState", this, e, n)
        },
        update: function() {
            var e = this.STATE2FUNC[this.get("state")].update;
            this[e] && this[e]()
        },
        isHittable: function(e, t) {
            return this.statusAilments.isHittable(e, t)
        },
        canDoAbility: function() {
            return this.statusAilments.canDoAbility()
        },
        canSelectAbility: function() {
            return this.statusAilments.canSelectAbility() && !r.BattleInfo.getInstance().get("isInAutoBattle")
        },
        canUseAllMagic: function() {
            return this.statusAilments.canUseAllMagic()
        },
        canUseFlightAttack: function() {
            return this.statusAilments.canUseFlightAttack()
        },
        getAtbTimeFactor: function() {
            var t = this.statusAilments.getAtbTimeFactor();
            return e.isNumber(t) ? t : 100
        },
        getCastTimeFactor: function() {
            var t = {},
                n = this.getAbility();
            n && (t.abilityCategoryId = n.get("abilityCategoryId"), t.exerciseType = n.get("exerciseType"), t.isPossibleContainMagicDamage = n.get("isPossibleContainMagicDamage"), t.changeCastTimeCondList = n.get("changeCastTimeCondList"));
            var r = this.statusAilments.getCastTimeFactor(t);
            return e.isNumber(r) ? r : 100
        },
        isReadyToSelectAbility: function() {
            return this.isStateIdle() && this.isAtbFull()
        },
        isReadyToExecAbility: function() {
            return this.isStateInCast() && this.isCastFull()
        },
        getAbility: function() {
            return this._currentAbility
        },
        setAbility: function(e) {
            if (!this.isReadyToSelectAbility()) throw new Error("can not set ability");
            this._currentAbility = e, this.changeState("IN_CAST")
        },
        getLastAbility: function() {
            return this._lastAbility
        },
        reset: function() {
            this.set("elapsedAtbTime", 0), this.set("elapsedCastTime", 0), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0, this._currentAbility = null, this.changeState("IDLE")
        },
        resetAtb: function() {
            this.set("elapsedAtbTime", 0)
        },
        resetAbility: function() {
            this._currentAbility = null
        },
        processForStateIdleEntry: function() {
            this.resetAbility(), this.resetAtb(), this._readyToSelectAbilityAt = 0, this._readyToExecAbilityAt = 0
        },
        processForStateInCastEntry: function() {
            this.set("elapsedCastTime", 0), this.statusAilments.processForStateInCastEntry()
        },
        processForStateInActionEntry: function() {
            this.trigger("ActorBase::entryInAction", this), this.statusAilments.processForStateInActionEntry(), this._lastAbility = this._currentAbility
        },
        processForStateInActionExit: function() {
            this.trigger("ActorBase::exitInAction", this), this.statusAilments.processForStateInActionExit()
        },
        notifyAbilityBegun: function(e) {
            this.trigger("ActorBase::notifyAbilityBegun", this, e)
        },
        notifyAbilityDone: function() {
            this.changeState("IDLE")
        },
        setEnd: function() {
            this.changeState("END")
        },
        processForStateEndEntry: function() {
            this.resetAbility()
        },
        notifyAtbFull: function() {
            this._readyToSelectAbilityAt = t.getTime()
        },
        notifyCastFull: function() {
            this._readyToExecAbilityAt = t.getTime()
        },
        getAtbTime: function() {
            var e = this.get("spd"),
                t = r.Config.getInstance().get("ATB", "a"),
                n = r.Config.getInstance().get("ATB", "b");
            return Math.floor(t - e / n)
        },
        getCastTime: function() {
            return this._currentAbility.getCastTime()
        },
        isAtbFull: function() {
            return this.get("elapsedAtbTime") >= this.getAtbTime()
        },
        isCastFull: function() {
            return this.get("elapsedCastTime") >= this.getCastTime()
        },
        isStateIdle: function() {
            return this.get("state") === "IDLE"
        },
        isStateInCast: function() {
            return this.get("state") === "IN_CAST"
        },
        isStateInAction: function() {
            return this.get("state") === "IN_ACTION"
        },
        isStateEnd: function() {
            return this.get("state") === "END"
        },
        getId: function() {
            return this._id
        },
        getUid: function() {
            return this._uid
        },
        isBuddy: function() {
            return !1
        },
        isEnemy: function() {
            return !1
        },
        isSpEnemy: function() {
            return !e.isUndefined(this.container) && this.container.isSpEnemy()
        },
        isColleague: function(e) {
            return this.isBuddy() && e.isBuddy() || this.isEnemy() && e.isEnemy()
        },
        isOpponent: function(e) {
            return !this.isColleague(e)
        },
        isAlive: function(e) {
            return !this.isDead(e)
        },
        isDead: function(e) {
            return this.statusAilments.isDead(e)
        },
        canSubstitute: function(t) {
            var n = this.statusAilments.retrieveSubstituteTypes();
            return e.contains(n, t)
        },
        isInDefense: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.DEFENSE)
        },
        isInReflection: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.REFLECTION) || this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.REFLECTION_FULL_TIME)
        },
        isInConfusion: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.CONFUSION)
        },
        isInSleeping: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.SLEEP)
        },
        isInBerserker: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.BERSERKER)
        },
        isInRage: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.RAGE)
        },
        hasReraise: function() {
            return this.statusAilments.hasReraise()
        },
        hasGuts: function() {
            return this.statusAilments.hasGuts()
        },
        isInReraiseDeath: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH)
        },
        isInProtect: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.PROTECT)
        },
        isInShell: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.SHELL)
        },
        isPositiveIncontrollable: function() {
            return this.isInRage() && !this.shouldIgnoreIncontrollable() ? !0 : !1
        },
        isIncontrollable: function() {
            if (this.isPositiveIncontrollable()) return !0;
            if (this.isInConfusion() || this.isInBerserker())
                if (!this.shouldIgnoreIncontrollable()) return !0;
            return !1
        },
        shouldIgnoreIncontrollable: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.IGNORE_INCONTROLLABLE) ? !0 : !1
        },
        isContainer: function() {
            return !1
        },
        isPossibleToTarget: function() {
            return this.statusAilments.isPossibleToTarget()
        },
        getEquipWeaponEffectInfo: function() {
            var t = r.BattleInfo.getInstance().getActorParam(this.getUid());
            return e.has(t, "weaponEffect") ? t.weaponEffect.animationInfo : void 0
        },
        getCount: function() {
            return this.statusAilments.getCount()
        },
        isBlinded: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.BLINDED)
        },
        isReflected: function() {
            return this.isInReflection()
        },
        isUndeadBreed: function() {
            return this.get("breedId") === r.Conf.BREED_ID.UNDEAD || this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.ZOMBIE)
        },
        isContinuousBattle: function() {
            return this.isAlive() && this.statusAilments.isContinuousBattle()
        },
        isForceEscaped: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.FORCE_ESCAPE)
        },
        isInvisible: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.INVISIBLE)
        },
        isInvincible: function() {
            return this.statusAilments.has(r.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE)
        },
        getAbilityInfoByPositiveIncontrollable: function() {
            var e = {
                abilityId: 0,
                abilityOptions: {}
            };
            if (!this.isInRage()) throw new Error("not found vaild status ailments");
            return e.abilityId = this.statusAilments.getNextAbilityIdForRage(), e
        },
        getAttributes: function(t) {
            var n = {};
            return e.each(t, function(e) {
                n[e] = this.get(e)
            }, this), n
        },
        equals: function(e) {
            return this.getUid() === e.getUid()
        },
        toPlainObject: function() {
            var t = n.prototype.toPlainObject.call(this);
            return e.extend({
                statusAilments: this.statusAilments.toPlainObject(),
                actorParamHolder: this._actorParamHolder.toPlainObject(),
                counters: this.counters.toPlainObject(),
                actorStats: this.actorStats.toPlainObject()
            }, t)
        },
        applyPlainObject: function(e) {
            n.prototype.applyPlainObject.call(this, e), this.statusAilments.applyPlainObject(e.statusAilments), this._actorParamHolder.applyPlainObject(e.actorParamHolder), this.counters.applyPlainObject(e.counters), this.actorStats.applyPlainObject(e.actorStats)
        },
        getRemainingHpRate: function() {
            return Math.floor(this.get("hp") / this.get("maxHp") * 100)
        },
        getDamagedHpRate: function() {
            var e = this.getRemainingHpRate();
            return Math.floor(100 - e)
        },
        cancelInterruptAbility: function() {
            r.AbilityMgr.getInstance().cancelInterruptAbilityOfActor(this)
        },
        getAttachElementAddOnFactor: function(e, t) {
            return 100
        },
        setStatusAilments: function(t, n) {
            t = e.isArray(t) ? t : [t], n = n || {};
            var i = r.util.DamageCalculator.makeDamageObject(this, this, void 0, {
                statusAilments: t,
                statusAilmentsOptions: n.statusAilmentsOptions
            });
            this.applyDamageObject(i)
        },
        unsetStatusAilments: function(t) {
            t = e.isArray(t) ? t : [t];
            var n = r.util.DamageCalculator.makeDamageObject(this, this, void 0, {
                unsetStatusAilments: t
            });
            this.applyDamageObject(n)
        },
        getDamageReverseSaIds: function() {
            return this.statusAilments.retrieveDamageReverseSaIds()
        },
        hasAdjustDamageConf: function(e) {
            var t = this._detectAdjustDamageConfig(e);
            return !!t
        },
        _detectAdjustDamageConfig: function(n) {
            n = t.option({
                calcType: void 0,
                exerciseType: void 0,
                damage: void 0
            }, n);
            var i = n.calcType,
                s = n.exerciseType,
                o = this.statusAilments.retrieveAdjustDamageConfigs();
            return e.find(o, function(t) {
                if (!e.isUndefined(t.exerciseTypes) && !e.contains(t.exerciseTypes, s)) return !1;
                if (!e.isUndefined(t.calcTypes) && !e.contains(t.calcTypes, i)) return !1;
                if (!e.isUndefined(t.hitReasons)) {
                    var o = e.any(t.hitReasons, function(e) {
                        return r.StatusAilments.judgeHittabilityByReason(s, i, e)
                    });
                    if (!o) return !1
                }
                return t.damagedOnly && !(e.isNumber(n.damage) && n.damage > 0) ? !1 : !0
            })
        },
        detectAdjustDamageConfig: function(e) {
            return this._detectAdjustDamageConfig(e)
        },
        isFaraway: function() {
            return this.statusAilments.isFaraway()
        },
        isAntiFaraway: function() {
            return this.statusAilments.isAntiFaraway()
        },
        matchesOptionalCounterCondition: function(e) {
            return !0
        },
        canUpdateElapsedAtbTime: function() {
            return !0
        }
    }), FF.ns.battle.ActorBase
}), define("scenes/battle/ActorBuddy", ["./ActorBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorBuddy = e.extend({
        initialize: function(r, i, s) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, t.option({
                posId: void 0,
                no: s.no
            }, s));
            var o = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.receptors = {}, _.each([{
                "class": "AbilityPanel",
                info: o.abilityPanels
            }, {
                "class": "AbilityPanel",
                info: n.Config.getInstance().get("BuiltinPanels")
            }, {
                "class": "SoulStrike",
                info: _.extend({}, o.soulStrikes[0], {
                    point: o.soulStrikeGauge
                })
            }, {
                "class": "SoulStrikePanel",
                info: o.soulStrikes
            }, {
                "class": "Skip"
            }, {
                "class": "PositiveIncontrollable"
            }], function(e) {
                var t = e.class,
                    r = _.isArray(e.info) ? e.info : [e.info];
                _.each(r, function(e) {
                    (new n.recept[t](this)).load(e)
                }, this)
            }, this), this.sparePanelReceptors = {}, this._setupStatusBonusFlgOf(o), this._setupStatusBonusTypeOf(o), this.set("seriesId", o.seriesIdMap ? o.seriesIdMap.buddy : void 0), this.materiaHolder = this._createMateriaHolder(s), this._isPossessedBySupporter = !1
        },
        _createMateriaHolder: function(e) {
            return n.MateriaFactory.createMateriaHolder(this, e.unifiedMaterias)
        },
        update: function() {
            e.prototype.update.apply(this, arguments), this.materiaHolder.update(), this.isIncontrollable() && this.isReadyToSelectAbility() && (this.isPositiveIncontrollable() ? n.BuddyPartyMgr.getInstance().reserveAbilityForPositiveIncontrollable(this) : n.BuddyPartyMgr.getInstance().reserveAbility(this, n.Conf.RECEPTOR.PANEL_ATTACK)), n.BattleInfo.getInstance().get("isInAutoBattle") && this.isReadyToSelectAbility() && n.BuddyPartyMgr.getInstance().reserveAbilityForAutoBattle(this)
        },
        processForStateInActionEntry: function() {
            e.prototype.processForStateInActionEntry.apply(this, arguments);
            var t = this.getAbility();
            if (t.get("isAbilityPanel")) {
                var r = t.get("receptorId");
                this.getReceptorById(r).decreaseResources()
            } else t.get("isSoulStrike") && this.getSoulStrike().decreaseResources();
            t.get("isSupporterSoulStrike") && (this._isPossessedBySupporter = !0, n.ActorMgr.getSupporter().getSupporterSoulStrike().decreaseResources())
        },
        processForStateInActionExit: function() {
            e.prototype.processForStateInActionExit.apply(this, arguments);
            var t = this.getLastAbility();
            t.get("isAbilityPanel") && this.getSoulStrike().addPointAsExecuter(t), t.get("isSupporterSoulStrike") && (this._isPossessedBySupporter = !1), t.get("isPositiveIncontrollable") && t.get("shouldAddSsPoint") && this.getSoulStrike().addPointAsExecuter(t), this.materiaHolder.notify(n.Conf.MATERIA_NOTIFY_TYPE.ACTION_EXIT, {
                ability: t
            })
        },
        getBaseParam: function(e) {
            return this.getParamHolderForRead(e).getBaseParam()
        },
        getParamHolderForRead: function(r) {
            return r = t.option({
                usesSelfBaseParam: !1
            }, r), this._isPossessedBySupporter && !r.usesSelfBaseParam ? n.ActorMgr.getSupporter().getParamHolderForRead() : e.prototype.getParamHolderForRead.apply(this, arguments)
        },
        getAbilityPanels: function() {
            var e = [].concat(_.values(this.receptors), _.values(this.sparePanelReceptors));
            return _.filter(e, function(e) {
                return e instanceof n.recept.AbilityPanel ? e.isLocated() ? !0 : !1 : !1
            }, this)
        },
        getAbilityPanelReceptorByPanelNo: function(e) {
            return _.find(this.getAbilityPanels(), function(t) {
                return +t.get("panelNo") === +e
            }, this)
        },
        findSparePanelInfo: function(e) {
            var t = this.getUid();
            this.isPossessedBySupporter() && (t = n.ActorMgr.getSupporter().getUid());
            var r = n.BattleInfo.getInstance().getActorParam(t);
            return _.find(r.sparePanels, function(t) {
                return t.receptorId && +t.receptorId === +e
            })
        },
        _validateSparePanelReceptorId: function(e) {
            if (!_.contains(n.Config.getInstance().get("SparePanelReceptors"), +e)) throw new Error("invalid spare ability panel receptorId. " + e)
        },
        retrieveAndLoadSparePanel: function(e) {
            this._validateSparePanelReceptorId(e);
            var t = this.getReceptorById(e);
            if (t) return t;
            var r = this.findSparePanelInfo(e);
            if (!r) throw new Error("Not found such receptorId." + e);
            return t = new n.recept.AbilityPanel(this), t.load(_.extend({}, r, {
                isSpare: !0
            })), t
        },
        swapSparePanel: function(e, n, r) {
            r = t.option({
                highlight: !1
            }, r), this._validateSparePanelReceptorId(e);
            var i = this.retrieveAndLoadSparePanel(e);
            if (i.isLocated()) throw new Error("already located. receptorId:" + e);
            i.set("highlight", r.highlight);
            var s = this.getAbilityPanelReceptorByPanelNo(n),
                o = void 0;
            return s ? (o = s.get("receptorId"), s.dislocate(), i.locate(n)) : i.locate(n), o
        },
        rewindSparePanel: function(e, t) {
            this._validateSparePanelReceptorId(e);
            var n = this.getReceptorById(e);
            if (!n || !n.isLocated()) throw new Error("cannot rewind spare. receptorId:" + e);
            if (t) {
                var r = this.getReceptorById(t),
                    i = n.get("panelNo");
                r.locate(i)
            }
            n.dislocate()
        },
        getSoulStrikePanels: function() {
            var e = _.values(n.Config.getInstance().get("SoulStrikePanels"));
            return _.pick(this.receptors, e)
        },
        getSoulStrike: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.SOUL_STRIKE)
        },
        getAtkSsPointFactor: function() {
            var e = this.get("atkSsPointFactor"),
                t = this.get("atkSsPointFactorByMateria") || 0;
            return e + t
        },
        getDefSsPointFactor: function() {
            var e = this.get("defSsPointFactor"),
                t = this.get("defSsPointFactorByMateria") || 0;
            return e + t
        },
        getSkip: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.SKIP)
        },
        getPositiveIncontrollable: function() {
            return this.getReceptorById(n.Conf.RECEPTOR.POSITIVE_INCONTROLLABLE)
        },
        isBuddy: function() {
            return !0
        },
        isFatal: function() {
            var e = this.get("maxHp"),
                t = this.get("hp");
            return this.isAlive() && t / e <= .125
        },
        resetForContinue: function() {
            var e = n.BattleInfo.getInstance().getActorParam(this.getUid()),
                t = e.maxHp,
                r = this.statusAilments.cloneIds();
            _.each(r, function(e) {
                this.statusAilments.unset(e)
            }, this), this.statusAilments = new n.StatusAilments(this), this._actorParamHolder.resetAllParam(), this.set("hp", t), this.set("maxHp", t), this.set("damage", 0), this.setupNewBattle(), _.each(this.getAbilityPanels(), function(e) {
                e.resetForContinue()
            }, this), this.materiaHolder.notify(n.Conf.MATERIA_NOTIFY_TYPE.RESET_FOR_CONTINUE), this.actorStats.notify(n.Conf.ACTOR_STATS_NOTIFY_TYPE.RESET_FOR_CONTINUE)
        },
        _setupStatusBonusFlgOf: function(e) {
            this._statusBonusFlgOf = {};
            var t = e.statusBonusFlgOf || {};
            _.each(n.Conf.STATUS_BONUS_PARTS, function(e) {
                this._statusBonusFlgOf[e] = !!t[e]
            }, this)
        },
        _setupStatusBonusTypeOf: function(e) {
            this._statusBonusTypeOf = e.statusBonusTypeOf
        },
        getStatusBonusFlgOf: function() {
            return this._statusBonusFlgOf
        },
        getStatusBonusTypeOf: function() {
            return this._statusBonusTypeOf
        },
        getSeriesId: function() {
            return this.get("seriesId")
        },
        isPossessedBySupporter: function() {
            return this._isPossessedBySupporter
        },
        isSameSeries: function(e) {
            return this.getSeriesId() === e
        },
        isInDefense: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInDefense.apply(this, arguments)
        },
        isInReflection: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInReflection.apply(this, arguments)
        },
        isInConfusion: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInConfusion.apply(this, arguments)
        },
        isInSleeping: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInSleeping.apply(this, arguments)
        },
        isInBerserker: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInBerserker.apply(this, arguments)
        },
        isInRage: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInRage.apply(this, arguments)
        },
        hasReraise: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.hasReraise.apply(this, arguments)
        },
        hasGuts: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.hasGuts.apply(this, arguments)
        },
        isInReraiseDeath: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isInReraiseDeath.apply(this, arguments)
        },
        isBlinded: function() {
            return this.isPossessedBySupporter() ? !1 : e.prototype.isBlinded.apply(this, arguments)
        },
        canSubstitute: function(t) {
            return this.isPossessedBySupporter() ? !1 : e.prototype.canSubstitute.apply(this, arguments)
        },
        canUseAllMagic: function() {
            return this.isPossessedBySupporter() ? !0 : e.prototype.canUseAllMagic.apply(this, arguments)
        },
        getReceptorById: function(e) {
            var t = this.receptors[e];
            return t || (t = this.sparePanelReceptors[e]), t
        },
        toPlainObject: function() {
            var t = e.prototype.toPlainObject.apply(this, arguments);
            return t.receptors = {}, _.each(this.receptors, function(e, n) {
                t.receptors[n] = e.toPlainObject()
            }), t.sparePanelReceptors = {}, _.each(this.sparePanelReceptors, function(e, n) {
                t.sparePanelReceptors[n] = e.toPlainObject()
            }), t.materiaHolder = this.materiaHolder.toPlainObject(), t
        },
        applyPlainObject: function(t) {
            e.prototype.applyPlainObject.apply(this, arguments);
            if (!t) return;
            _.each(this.receptors, function(e, n) {
                e.applyPlainObject(t.receptors[n])
            }), _.each(t.sparePanelReceptors, function(e, t) {
                var r = new n.recept.AbilityPanel(this);
                r.applyPlainObject(e), this.sparePanelReceptors[t] = r
            }, this), this.materiaHolder.applyPlainObject(t.materiaHolder)
        },
        getAttachElementAddOnFactor: function(t, n) {
            var r = 100;
            if (!t) return r;
            var i = n || this.getAbility();
            if (!i) return r;
            if (i.get("isSupporterSoulStrike")) return r;
            var s = this.statusAilments.getRefsOfAttachElementInfoMap();
            return s && s.attachElementId === t ? i.get("isSoulStrike") ? s.soulStrikeDamageFactor : s.normalAbilityDamageFactor : e.prototype.getAttachElementAddOnFactor.apply(this, arguments)
        },
        getSwapAbilityByAttachedElement: function() {
            var e = this.statusAilments.getRefsOfAttachElementInfoMap();
            return e ? e.swapAbilityId : void 0
        }
    })
}), define("scenes/battle/ActorSupporter", ["./ActorBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorSupporter = e.extend({
        initialize: function(r, i, s) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, t.option({}, s));
            var o = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.receptors = {}, (new n.recept.SupporterSoulStrike(this)).load(_.extend({
                restCount: o.supporterSsGauge
            }, o.soulStrikes[0])), this._setupStatusBonusFlgOf(o), this._setupStatusBonusTypeOf(o)
        },
        isBuddy: function() {
            return !0
        },
        resetForContinue: function() {
            var e = n.BattleInfo.getInstance().getActorParam(this.getUid());
            this.getSupporterSoulStrike().set("restCount", e.maxSupporterSsGauge)
        },
        _setupStatusBonusFlgOf: function(e) {
            this._statusBonusFlgOf = {};
            var t = e.statusBonusFlgOf || {};
            _.each(n.Conf.STATUS_BONUS_PARTS, function(e) {
                this._statusBonusFlgOf[e] = !!t[e]
            }, this)
        },
        _setupStatusBonusTypeOf: function(e) {
            this._statusBonusTypeOf = e.statusBonusTypeOf
        },
        getStatusBonusFlgOf: function() {
            return this._statusBonusFlgOf
        },
        getStatusBonusTypeOf: function() {
            return this._statusBonusTypeOf
        },
        getSupporterSoulStrike: function() {
            return this.receptors[n.Conf.RECEPTOR.SUPPORTER_SOUL_STRIKE]
        },
        toPlainObject: function() {
            var t = e.prototype.toPlainObject.apply(this, arguments);
            return t.receptors = {}, _.each(this.receptors, function(e, n) {
                t.receptors[n] = e.toPlainObject()
            }), t
        },
        applyPlainObject: function(t) {
            e.prototype.applyPlainObject.apply(this, arguments);
            if (!t) return;
            _.each(this.receptors, function(e, n) {
                e.applyPlainObject(t.receptors[n])
            })
        }
    })
}), define("scenes/battle/ActorEnemy", ["util", "./ActorBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorEnemy = t.extend({
        initialize: function(e, r, i) {
            t.prototype.initialize.apply(this, arguments), this._abilityBox = {}, this._abilityBoxFirst = {}, this._atbFullTurnNum = 0, this._abilityUnlockTurnNumInfo = {}, this._abilityTag = {}, this._optionalCounterCheckType = n.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.NONE, _.each(i.params, function(e) {
                var t = [],
                    r = [],
                    i = [],
                    s = [],
                    o = {};
                _.each(e.abilities, function(e) {
                    t.push(e.abilityId), r.push(e.weight), !n.AbilityInfoMgr.getInstance().isHealHpTypeById(e.abilityId) && e.weight > 0 && (i.push(e.abilityId), s.push(e.weight)), o[e.abilityId] = e.unlockTurnNum, e.tag && _.map(e.tag.split(","), function(t) {
                        this._abilityTag[t] = e.abilityId
                    }, this)
                }, this), this._abilityBox[e.id] = new n.LotteryBox(t, r), i.length && (this._abilityBoxFirst[e.id] = new n.LotteryBox(i, s)), this._abilityUnlockTurnNumInfo[e.id] = o, _.each(e.counters, function(t) {
                    this.counters.addWithParamId(e.id, t.abilityId, t.conditionType, t.conditionValue, t.rate)
                }, this)
            }, this), this._registerAbilityCount = 0, this.stateMap = n.ai.StateMapBuilder.createById(i.aiId, this), this.set("atbTime", i.atbTime), this.materiaHolder = n.MateriaFactory.createMateriaHolder(this, []), this.constraint = new n.ai.Constraint(this, i.constraints)
        },
        set: function(e, n) {
            return t.prototype.set.apply(this, arguments)
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            if (this.isIncontrollable() && this.isReadyToSelectAbility()) {
                if (this.isPositiveIncontrollable()) throw new Error("ActorEnemy cannot use PositiveIncontrollable");
                var e = this.detectAbilityInNegativeIncontrollable();
                n.Commander.getInstance().register(e, this)
            } else this.stateMap.update()
        },
        notifyAtbFull: function() {
            this._atbFullTurnNum++, t.prototype.notifyAtbFull.apply(this, arguments)
        },
        getAtbFullTurnNum: function() {
            return this._atbFullTurnNum
        },
        hasAbilityTag: function(e) {
            var t = this._abilityTag[e];
            return _.isUndefined(t) ? !1 : !0
        },
        getAbilityIdByTag: function(e) {
            if (_.isArray(e)) return _.map(e, function(e) {
                return this.getAbilityIdByTag(e)
            }, this);
            var t = this._abilityTag[e];
            if (_.isUndefined(t)) throw new Error("invalid tag [" + e + "]");
            return t
        },
        getCurrentBox: function() {
            return this._abilityBox[this.get("paramId")]
        },
        getCurrentBoxFirst: function() {
            return this._abilityBoxFirst[this.get("paramId")]
        },
        lotAndRegisterAbility: function() {
            var e = this.lotAbility();
            return this.registerAbility(e)
        },
        lotAndRegisterAbilityWithout: function(e) {
            var t = this.lotAbilityWithout(e);
            return this.registerAbility(t)
        },
        withoutAndLotAndRegisterAbility: function(e) {
            var t = this.getWithoutAbilityList(e);
            return this.lotAndRegisterAbilityWithout(t)
        },
        smartLotAndRegisterAbility: function(e) {
            e = _.extend({
                forceIgnoresReflection: !1
            }, e);
            var t = this.getWithoutAbilityList(e);
            return this.lotAndRegisterAbilityWithout(t)
        },
        _decideUsingBox: function() {
            var e = this.getCurrentBox(),
                t = this.getCurrentBoxFirst();
            return this._registerAbilityCount <= 0 && t && (e = t), e
        },
        lotAbility: function() {
            return this.lotAbilityWithout([])
        },
        withoutAndLotAbility: function(e) {
            var t = this.getWithoutAbilityList(e);
            return this.lotAbilityWithout(t)
        },
        lotAbilityWithout: function(e) {
            var t = this.constraint.getForceAbilityId();
            if (!t) {
                var n = this._decideUsingBox(),
                    r = this._getLockedAbilityIdList(),
                    i = this.constraint.getWithoutAbilityIdList(),
                    s = _.union(r, i, e),
                    o = n.lotWithout(s);
                if (!o) throw new Error("invalid box");
                return o
            }
            return t
        },
        smartLotAbility: function(e) {
            e = _.extend({
                forceIgnoresReflection: !1
            }, e);
            var t = this.getWithoutAbilityList(e);
            return this.lotAbilityWithout(t)
        },
        _getLockedAbilityIdList: function() {
            var e = this._decideUsingBox(),
                t = e._params.lottery,
                n = this.get("paramId"),
                r = this._abilityUnlockTurnNumInfo[n],
                i = this.getAtbFullTurnNum(),
                s = _.filter(t, function(e) {
                    var t = r[e],
                        n = t <= i;
                    return !n
                }, this);
            return s
        },
        registerAbility: function(e, t) {
            return this._registerAbility(e, t)
        },
        registerAbilityByTag: function(e, t) {
            var n = this.getAbilityIdByTag(e);
            return this.registerAbility(n, t)
        },
        registerInterruptAbility: function(e, t, n) {
            return n || (n = {
                interruptBoss: !0
            }), this._registerAbility(e, t, n)
        },
        registerInterruptAbilityByTag: function(e, t, n) {
            var r = this.getAbilityIdByTag(e);
            return this.registerInterruptAbility(r, t, n)
        },
        _registerAbility: function(e, t, r) {
            if (this._getCandidatableAbilityIds().indexOf(e) < 0) throw new Error("invalid abilityId [" + e + "]");
            var i = n.Commander.getInstance().register(e, this, t, r);
            return this._registerAbilityCount++, i
        },
        _getCandidatableAbilityIds: function() {
            var e = FF.ns.battle.Config.getInstance().get("BuiltinAbilities"),
                t = _.map(e, function(e) {
                    return e.abilityId
                }),
                n = [].concat(this.getCurrentBox().getCandidates(), t);
            return n
        },
        resetAbilityBox: function(e) {
            var t = this.getCurrentBox();
            t.resetBox(e)
        },
        isEnemy: function() {
            return !0
        },
        die: function() {
            t.prototype.die.call(this)
        },
        getSize: function() {
            return this.get("size")
        },
        notifyJudgedDeath: function() {
            return this.stateMap.notifyJudgedDeath(this)
        },
        setDeadAnimateType: function(e) {
            this._deadAnimateType = e
        },
        getDeadAnimateType: function() {
            return this._deadAnimateType
        },
        setOptionalCounterCheckType: function(e) {
            this._optionalCounterCheckType = e
        },
        getOptionalCounterCheckType: function() {
            return this._optionalCounterCheckType
        },
        setInvisible: function() {
            this.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.INVISIBLE, this)
        },
        getWithoutAbilityList: function(e) {
            var t = this._decideUsingBox(),
                r = t._params.lottery,
                i = n.util.EnemyTargeting.getWithoutAbilityList(this, r, e);
            return i
        },
        getExcludedAbilityListBySmartLot: function(e) {
            e = _.extend({
                forceIgnoresReflection: !1
            }, e);
            var t = this._decideUsingBox(),
                r = t._params.lottery,
                i = n.util.EnemyTargeting.getWithoutAbilityList(this, r, e);
            return i
        },
        detectAbilityInNegativeIncontrollable: function() {
            var e = n.Config.getInstance().get("EnemyAblityTag", "NegativeIncontrollable");
            return this.hasAbilityTag(e) ? this.getAbilityIdByTag(e) : n.Conf.ABILITY_ID_OF.DEFAULT_IN_NEGATIVE_INCONTROLLABLE_FOR_ENEMY
        },
        getCastTime: function() {
            var e = n.Config.getInstance().get("EnemyCastTime"),
                r = e[this.get("castTimeType")];
            return _.isNumber(r) ? r : t.prototype.getCastTime.call(this)
        },
        resetCastAbility: function() {
            if (!this.isStateInCast()) return;
            this.reset(), this.set("elapsedAtbTime", this.getAtbTime() - 1)
        },
        resetAndShuffleAtb: function() {
            this.isStateInCast() && this.reset();
            var t = e.randomInt(this.getAtbTime() - 1);
            this.set("elapsedAtbTime", t)
        },
        setEnable: function(e) {
            var t = n.Conf.STATUS_AILMENTS_TYPE.DISABLE,
                r = this.statusAilments.has(t);
            e ? r && this.unsetStatusAilments(t) : r || this.setStatusAilments(t)
        },
        retrieveExtraDefStatusAilmentConfig: function() {
            return this.statusAilments.retrieveExtraDefStatusAilmentConfig()
        },
        getParamIdBySuffixNo: function(e) {
            return this.container.getParamIdBySuffixNo(e)
        },
        getMessageIdBySuffixNo: function(e) {
            return this.container.getMessageIdBySuffixNo(e)
        },
        setElapsedAtbTimeByRate: function(e) {
            this.set("elapsedAtbTime", Math.floor(this.getAtbTime() * (e / 100)))
        },
        matchesOptionalCounterCondition: function(e) {
            var t = !0,
                r = e.abilityId;
            switch (this.getOptionalCounterCheckType()) {
                case n.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.NONE:
                    break;
                case n.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.REFLECTION:
                    t = n.util.EnemyTargeting.isThereEnableAbilityTargetWithCondReflection(this, r, {
                        forceIgnoresReflection: !1
                    });
                    break;
                case n.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.SMART:
                    t = n.util.EnemyTargeting.isThereEnableAbilityTarget(this, r, {
                        forceIgnoresReflection: !1
                    })
            }
            return t
        },
        dieForcibly: function(t) {
            t = e.option({
                isInvisibleDeath: !1
            }, t);
            if (this.isDead()) throw new Error("Already Die This Enemy [" + this.get("no") + "]");
            var r = n.ActorMgr.getActiveTarget();
            r && r.equals(this) && n.ActorMgr.clearActiveTarget();
            var i = this.statusAilments.cloneIds();
            this.unsetStatusAilments(i), this.reset(), this.cancelInterruptAbility();
            var s = 0,
                o = n.Conf.STATUS_AILMENTS_TYPE.DISABLE;
            t.isInvisibleDeath && (s = this.get("maxHp"), o = n.Conf.STATUS_AILMENTS_TYPE.INVISIBLE), this.set("hp", s), this.statusAilments.set(o, this), this.trigger("ActorEnemy::dieForcibly", this), FF.logger.debug("Actor Enemy AI Die", "enemyName", this.get("dispName"), "no", this.get("no"))
        }
    })
}), define("scenes/battle/ActorMgr", ["lib/Events", "util"], function(e, t) {
    var n = {},
        r = {},
        i = {},
        s = [],
        o = void 0,
        u = void 0,
        a = 0,
        f = FF.ns.battle;
    FF.ns.battle.ActorMgr = _.extend({
        registerBuddy: function(e) {
            _.isArray(e) || (e = [e]);
            if (!e.length) throw new Error("empty buddies");
            _.each(e, function(e) {
                var t = e.uid,
                    r = new f.ActorBuddy(t, e.id, e);
                n[t] = r, this._startListening(r), this.trigger("ActorMgr::registerBuddy", r)
            }, this)
        },
        registerSupporter: function(e) {
            _.isArray(e) || (e = [e]), _.each(e, function(e) {
                var t = e.uid;
                r[t] = new f.ActorSupporter(t, e.id, e)
            }, this)
        },
        registerEnemy: function(e) {
            _.isArray(e) || (e = [e]);
            if (!e.length) throw new Error("empty enemies");
            var t = 0,
                n = 0,
                r = 0,
                o = 0,
                u;
            for (t = 0, n = e.length; t < n; t++) {
                var a = e[t];
                u = {};
                for (r = 0, o = a.children.length; r < o; r++) {
                    var l = a.children[r],
                        c = new f.ActorEnemy(l.uid, a.id, l);
                    u[c.get("no")] = c, i[l.uid] = c, this._startListening(c), this.trigger("ActorMgr::registerEnemy", c)
                }
                var h = new f.EnemyContainer(a, u);
                s.push(h)
            }
        },
        getAllEnemyContainers: function() {
            return s
        },
        getEnemyContainerByUid: function(e) {
            return _.find(this.getAllEnemyContainers(), function(t) {
                return t.containerUid === e
            })
        },
        getAliveEnemyContainers: function() {
            return _.filter(this.getAllEnemyContainers(), function(e) {
                return !e.isAllDead()
            })
        },
        getAll: function() {
            return [].concat(_.values(n)).concat(_.values(i))
        },
        getAliveActors: function() {
            return _.filter(this.getAll(), function(e) {
                return e.isAlive()
            })
        },
        getAllBuddies: function() {
            return _.values(n)
        },
        getAliveBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isAlive()
            })
        },
        getDeadBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isDead()
            })
        },
        getReraiseDeathBuddies: function() {
            return _.filter(this.getAllBuddies(), function(e) {
                return e.isInReraiseDeath()
            })
        },
        getGutsRiseBuddies: function() {
            return _.filter(this.getAliveBuddies(), function(e) {
                return e.get("hp") <= 0 && e.hasGuts()
            })
        },
        getAbilityPanelSelector: function() {
            var e = f.BattleInfo.getInstance();
            return e.isJustEnded() ? null : u && u.isReadyToSelectAbility() ? u : (u = this._findNextSelector(u), u)
        },
        notifySkipAbility: function(e) {
            u = this._findNextSelector(e)
        },
        _findNextSelector: function(e) {
            var t = f.BattleInfo.getInstance(),
                n = t.getSkipOrderCandidates();
            switch (t.getSkipOrder()) {
                case n.NO:
                    return this._findNextSelectorOrderByNo(e);
                case n.ATB:
                    return this._findNextSelectorOrderByAtb(e);
                default:
                    return this._findNextSelectorOrderByAtb(e)
            }
        },
        _findNextSelectorOrderByAtb: function(e) {
            var t = this.getReadyToSelectAbilityBuddies();
            if (t.length === 0) return null;
            t.sort(function(e, t) {
                return e.getReadyToSelectAbilityAt() - t.getReadyToSelectAbilityAt() || e.get("no") - t.get("no")
            });
            var n = t[a];
            return n && e && n.equals(e) && a++, t.length <= a && (a = 0), t[a]
        },
        _findNextSelectorOrderByNo: function(e) {
            var t = this.getReadyToSelectAbilityBuddies();
            if (t.length === 0) return null;
            t.sort(function(e, t) {
                return e.get("no") - t.get("no")
            });
            var n = _.find(t, function(t) {
                return e && e.get("no") < t.get("no")
            });
            return n || (n = t[0]), n
        },
        getReadyToSelectAbilityBuddies: function() {
            var e = this.getAliveBuddies();
            return f.BattleInfo.getInstance().isMo() ? _.filter(e, function(e) {
                return e.isOperable() && e.isReadyToSelectAbility() && e.canSelectAbility()
            }) : _.filter(e, function(e) {
                return e.isReadyToSelectAbility() && e.canSelectAbility()
            })
        },
        getAllEnemies: function() {
            return _.values(i)
        },
        getAliveEnemies: function() {
            return _.filter(this.getAllEnemies(), function(e) {
                return e.isAlive()
            })
        },
        getSupporter: function() {
            return _.first(_.values(r))
        },
        getByUid: function(e) {
            var t = n[e] || i[e] || r[e];
            if (!t) throw new Error("actor not found.uid=" + e);
            return t
        },
        getBuddyByPosId: function(e) {
            var t = _.filter(this.getAllBuddies(), function(t) {
                return t.get("posId") === e
            });
            return t.shift()
        },
        getEnemyByPosId: function(e) {
            var t = _.filter(this.getAllEnemies(), function(t) {
                return t.get("posId") === e
            });
            return t.shift()
        },
        clearEnemy: function() {
            i = {}, s = [], this.trigger("ActorMgr::clearEnemy")
        },
        getActiveTarget: function() {
            if (o) {
                var e = this.getByUid(o);
                if (e.isBuddy() || !e.isDead()) return e
            }
            return null
        },
        getActiveTargetForMo: function(e, t) {
            return e ? t ? this.getActiveTargetByUid(t) : null : this.getActiveTarget()
        },
        getActiveTargetByUid: function(e) {
            var t = this.getByUid(e);
            return t.isBuddy() || !t.isDead() ? t : null
        },
        getActiveTargetUid: function() {
            return o
        },
        toggleActiveTarget: function(e) {
            var t = this.getByUid(e),
                n = void 0;
            t.isEnemy() ? n = t.isPossibleToTarget() && t.isAlive() : n = t.isPossibleToTarget(), o ? o !== e ? n && (o = e) : o = void 0 : n && (o = e)
        },
        clearActiveTarget: function() {
            o = void 0
        },
        getSubstituteTarget: function(e, n) {
            var r = _.filter(this.getAliveActors(), function(t) {
                return e.isColleague(t) ? !1 : t.canSubstitute(n)
            }, this);
            return r.length > 0 ? t.lot(r, function() {
                return 100
            }, {}) : void 0
        },
        resetBuddiesForContinue: function() {
            _.each(n, function(e) {
                e.resetForContinue()
            });
            var e = this.getSupporter();
            e && e.resetForContinue(), f.BattleInfo.getInstance().isMo() ? f.BattleInfo.getInstance().isMoHost() && this.trigger("ActorMgr::resetBuddiesForContinue") : this.trigger("ActorMgr::resetBuddiesForContinue")
        },
        getBuddiesInFlight: function() {
            var e = _.filter(this.getAliveBuddies(), function(e) {
                if (e.isStateInCast()) return !1;
                var t = e.getAbility();
                return t && t.get("isFlightAttack") && !t.isDone()
            });
            return e
        },
        setActorSyncData: function(e) {
            var t = this;
            _.each(e, function(e) {
                var n = t.getByUid(e.uid);
                n.setActorSyncData(e)
            })
        },
        getSetupActorsData: function() {
            return _.map(this.getAllBuddies(), function(e) {
                return {
                    uid: e.getUid(),
                    elapsedAtbTime: e.get("elapsedAtbTime")
                }
            })
        },
        setSetupActorsData: function(e) {
            var t = this;
            _.each(e, function(e) {
                var n = t.getByUid(e.uid);
                n.set("elapsedAtbTime", e.elapsedAtbTime)
            })
        },
        getBuddiesByPartyIndex: function(e) {
            return _.filter(this.getAllBuddies(), function(t) {
                return t.get("partyIndex") === e
            })
        },
        notifyExitInAction: function() {
            this.trigger("ActorMgr::exitInAction", this)
        },
        _startListening: function(e) {
            this.listenTo(e, "all", this._listen), e.container && this.listenTo(e.container, "all", this._listen)
        },
        _listen: function() {
            this.trigger.apply(this, arguments)
        }
    }, e)
}), define("scenes/battle/ActorParamHolder", ["underscore", "util", "lib/ClassBase", "lib/ProtectParamsBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = {
            atk: {
                isBoostable: !0,
                protect: !0
            },
            def: {
                isBoostable: !0,
                protect: !0
            },
            matk: {
                isBoostable: !0,
                protect: !0
            },
            mdef: {
                isBoostable: !0,
                protect: !0
            },
            spd: {
                isBoostable: !0,
                protect: !0
            },
            mnd: {
                isBoostable: !0,
                protect: !0
            },
            acc: {
                isBoostable: !0,
                protect: !0
            },
            eva: {
                isBoostable: !0,
                protect: !0
            },
            critical: {
                isBoostable: !0,
                absoluteOnly: !0,
                protect: !0
            },
            atkSsPointFactor: {
                init: 0,
                isBoostable: !0
            },
            defSsPointFactor: {
                init: 0,
                isBoostable: !0
            },
            looking: {
                init: i.Conf.ACTOR_LOOKING_DEFAULT
            },
            atkElement: {
                init: ""
            },
            atkStatusAilments: {
                init: {}
            },
            matkElementMap: {
                init: {}
            },
            defAttributeMap: {},
            atbCoef: {
                init: 1
            },
            atkType: {
                init: i.Conf.ATK_TYPE.DIRECT
            },
            atkSaCoef: {
                init: 100,
                isBoostable: !0,
                protect: !0
            }
        },
        o = [];
    e.each(s, function(e, t) {
        e.protect && o.push(t)
    });
    var u = r.extend({
        initialize: function(e) {
            r.prototype.initialize.call(this), e && this.resetParams(e)
        },
        getProtectParams: function() {
            var t = r.prototype.getProtectParams.call(this);
            return e.union(t, o)
        },
        resetParams: function(e) {
            this._attributes = {}, this.applyPlainObject({
                attributes: e
            })
        }
    });
    FF.ns.battle.ActorParamHolder = r.extend({
        initialize: function(e, t) {
            n.prototype.initialize.call(this), this._baseParam = new u(t), this._actorUid = e.getUid(), this.resetAllParam(), this._holderId = 1, this._holders = {}
        },
        resetAllParam: function() {
            e.each(s, function(n, r) {
                var i = this._baseParam.get(r);
                e.isUndefined(i) && (i = n.init);
                if (e.isUndefined(i)) throw new Error("invalid param.key=" + r);
                e.isObject(i) && (i = t.cloneDeep(i)), this.set(r, i)
            }, this), this._holders = {}
        },
        updateVal: function(t) {
            var n = this._baseParam.get(t),
                r = n;
            if (e.isUndefined(r)) {
                var o = s[t];
                o && !e.isUndefined(o.init) && (r = o.init)
            }
            var u = e.filter(this._holders, function(n) {
                return n.propName !== t ? !1 : e.isUndefined(n.boostValue) ? !1 : !0
            });
            if (u.length > 0) {
                var a = e.last(u);
                if (a.isAbsolute) r = a.boostValue;
                else {
                    var f = i.util.ParamCalculator.calulateBoostRate(t, u);
                    r = Math.floor(r * f)
                }
            }
            if (r === this.get(t)) return;
            this.set(t, r)
        },
        updateObjVal: function(n) {
            var r = this,
                i = this._baseParam.get(n),
                s = t.cloneDeep(i),
                o = e.filter(this._holders, function(t) {
                    return t.propName !== n ? !1 : e.isUndefined(t.boostValue) ? !1 : e.isObject(t.boostValue) ? !0 : !1
                });
            o.length > 0 && e.each(o, function(t) {
                e.each(t.boostValue, function(e, n) {
                    if (!e) throw new Error("ActorParamholder::updateObjVal, val is 0 or undefined");
                    if (t.boostType === "attachElement") {
                        var i = s[n] || 0;
                        s[n] = r._getAttachElementBoostNextVal(i, e)
                    } else s[n] = e
                })
            }), this.set(n, s)
        },
        _getAttachElementBoostNextVal: function(t, n) {
            var r = i.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE_ORDER_LIST"),
                s;
            e.find(r, function(e, n) {
                if (+e.id === t) return s = n, !0
            });
            if (s === void 0) throw new Error("ActorParamHolder::_getAttachElementBoostNextVal currentIndex undefined.");
            var o = r.length - 1,
                u = e.max([s - n, 0]);
            u = e.min([u, o]);
            var a = r[u];
            if (!a) throw new Error("invalid nextIndex " + u);
            return +a.id
        },
        changeParam: function(e, n, r) {
            r = t.option({
                isAbsolute: !1,
                boostType: i.Conf.BOOST_TYPE.STATUS
            }, r);
            if (r.isAbsolute && !s[e].absoluteOnly) throw new Error("not allowed to use without absoluteOnly flag " + e);
            if (!r.isAbsolute && s[e].absoluteOnly) throw new Error("not allowed to use absolute with rate " + e);
            var o = this._holderId++;
            return this._holders[o] = {
                propName: e,
                boostValue: n,
                isAbsolute: r.isAbsolute,
                boostType: r.boostType
            }, this.updateVal(e), o
        },
        changeAttachElementParam: function(e, t, n) {
            var r = this._holderId++;
            return this._holders[r] = {
                propName: e,
                boostValue: t,
                boostType: n
            }, this.updateObjVal(e), r
        },
        isBoostableParam: function(e) {
            var t = s[e];
            return t && t.isBoostable === !0
        },
        changeBaseParam: function(e) {
            this._baseParam.resetParams(e), this.recalc()
        },
        getBaseParam: function() {
            return this._baseParam
        },
        recalc: function() {
            e.each(s, function(t, n) {
                var r = this._baseParam.get(n);
                e.isObject(r) ? this.updateObjVal(n) : this.updateVal(n)
            }, this)
        },
        resetParamById: function(t) {
            var n = this._holders[t];
            if (!n) throw new Error("not found such a holderId. " + t);
            var r = n.propName,
                i = n.boostValue;
            delete this._holders[t], e.isObject(i) ? this.updateObjVal(r) : this.updateVal(r)
        },
        getProtectParams: function() {
            var t = r.prototype.getProtectParams.call(this);
            return e.union(t, o)
        },
        toPlainObject: function() {
            var t = r.prototype.toPlainObject.call(this);
            return e.extend({
                holderId: this._holderId,
                holders: this._holders,
                baseParam: this._baseParam.toPlainObject()
            }, t)
        },
        applyPlainObject: function(e) {
            if (!e) return;
            r.prototype.applyPlainObject.call(this, e), this._holderId = e.holderId || 1, this._holders = e.holders, this._baseParam.applyPlainObject(e.baseParam), this.recalc()
        }
    })
}), define("scenes/battle/ActorTimeMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = e.extend({
            initialize: function() {
                e.prototype.initialize.apply(this, arguments)
            },
            onPostHit: function(e) {
                var n = t.ActorMgr.getByUid(e.uid);
                n.resetAtb()
            },
            enable: function() {
                this._disabled = !1
            },
            disable: function() {
                this._disabled = !0
            },
            update: function() {
                var e = t.BattleInfo.getInstance();
                if (e.isJustEnded()) return;
                if (e.isBattleState("IN_ACTION") || e.isBattleState("RERAISE_RISE")) return;
                _.each(t.ActorMgr.getAliveActors(), function(e) {
                    this._updateAtb(e), this._updateCast(e), this._updateSa(e)
                }, this)
            },
            calcElapsedCastTimeForMo: function(e, n) {
                var r = t.BattleInfo.getInstance().getBattleConfig().speed || 100,
                    i = Math.floor(e * +r / 100);
                return i = Math.floor(i * n.getAtbTimeFactor() / 100), i
            },
            _updateAtb: function(e) {
                if (this._disabled) return;
                if (!e.isStateIdle() || e.isAtbFull()) return;
                if (!e.canDoAbility()) return;
                var t = e.get("elapsedAtbTime"),
                    n = FF.scene.elapsedBattleTime;
                n = Math.floor(n * e.getAtbTimeFactor() / 100), e.set("elapsedAtbTime", _.min([t + n, e.getAtbTime()])), e.isAtbFull() && e.notifyAtbFull()
            },
            _updateCast: function(e) {
                if (this._disabled) return;
                if (!e.isStateInCast() || e.isCastFull()) return;
                if (!e.canDoAbility()) return;
                if (!e.canUpdateElapsedAtbTime()) return;
                var t = e.get("elapsedCastTime"),
                    n = FF.scene.elapsedBattleTime;
                n = Math.floor(n * e.getCastTimeFactor() / 100), e.set("elapsedCastTime", _.min([t + n, e.getCastTime()])), e.isCastFull() && e.notifyCastFull()
            },
            _updateSa: function(e) {
                var n = FF.scene.elapsedBattleTime;
                e.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE) || e.statusAilments.update(n)
            }
        }),
        r = void 0;
    FF.ns.battle.ActorTimeMgr = {
        getInstance: function() {
            return r || (r = new n), r
        }
    }
}), define("scenes/battle/Api", ["util", "lib/api"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.Api = {
        _openLoading: function() {
            n.BattleViewController.getInstance().loadingView.open()
        },
        _closeLoading: function() {
            n.BattleViewController.getInstance().loadingView.close()
        },
        requestApiDeferred: function(t, n) {
            var r = this;
            return n = e.option({
                loading: !0,
                notifyNetworkError: !0,
                notifyMaintenance: !0
            }, n), this._callSafelyDeferred(t, n)
        },
        requestDeferred: function(e, n, r, i) {
            var s = function() {
                return t.requestDeferred(e, n, r)
            };
            return this.requestApiDeferred(s, i)
        },
        _callSafelyDeferred: function(t, r, i) {
            var s = this;
            r.loading && this._openLoading();
            var o = i || $.Deferred();
            return t().done(function() {
                r.loading && s._closeLoading(), o.resolve.apply(o, arguments)
            }).fail(function(i, u, a) {
                r.loading && s._closeLoading();
                if (i && i.status === 403 || a && a.error === "REQUIRE_LOGIN") {
                    n.BattleViewController.getInstance().showSystemWindow(n.Conf.SYSTEM_WINDOW.LOGIN);
                    return
                }
                if (a && a.error === "MAINTENANCE") {
                    var f = _.extend({
                        isMaintenance: !0
                    }, e.camelizeDeep(a.misc_data));
                    r.notifyMaintenance ? n.BattleViewController.getInstance().notifyMaintenance(function() {
                        s._callSafelyDeferred(t, r, o)
                    }, f) : o.reject(i, u, a, f);
                    return
                }
                r.notifyNetworkError ? n.BattleViewController.getInstance().notifyCheckingNetwork(function() {
                    s._callSafelyDeferred(t, r, o)
                }) : o.reject.apply(o, arguments)
            }), o.promise()
        },
        battleWinDeferred: function(e, t) {
            var r = n.BattleInfo.getInstance().getAppInitDataEndpointMap().win,
                i = {};
            return this.requestDeferred(r, {
                results: e
            }, _.extend({
                type: "POST"
            }, t), i)
        },
        winTutorialBattleDeferred: function(e, t) {
            var r = n.BattleInfo.getInstance().getAppInitDataEndpointMap().lose,
                i = {};
            return this.requestDeferred(r, {
                results: e
            }, _.extend({
                type: "POST"
            }, t), i)
        },
        battleLoseDeferred: function(e, t) {
            var r = n.BattleInfo.getInstance().getAppInitDataEndpointMap().lose,
                i = {};
            return this.requestDeferred(r, {
                results: e
            }, _.extend({
                type: "POST"
            }, t), i)
        },
        battleEscapeDeferred: function(e, t) {
            var r = n.BattleInfo.getInstance().getAppInitDataEndpointMap().escape,
                i = {};
            return this.requestDeferred(r, {
                results: e
            }, {
                type: "POST"
            }, i)
        },
        getBattleInitDeferred: function(e) {
            var t = n.BattleInfo.getInstance().getAppInitDataEndpointMap().get_init_data,
                r = {
                    loading: !1,
                    notifyNetworkError: !1,
                    notifyMaintenance: !1
                };
            return this.requestDeferred(t, {
                crystal: e
            }, {}, r)
        },
        getContinueInfoDeferred: function(e) {
            var t = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/get_info", {}, e, t)
        },
        startContinueDeferred: function(e, t, n, r, i) {
            var s = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/start", {
                type_id: e,
                session_key: t,
                token: n,
                crystal: r
            }, _.extend({
                type: "POST"
            }, i), s)
        },
        closeContinueDeferred: function(e, t, n, r, i, s) {
            var o = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/close", {
                continue_id: e,
                type_id: t,
                session_key: n,
                token: r,
                crystal: i
            }, _.extend({
                type: "POST"
            }, s), o)
        },
        inquireContinueStatusDeferred: function(e, t, n, r, i, s) {
            var o = {
                notifyNetworkError: !1,
                notifyMaintenance: !0
            };
            return this.requestDeferred("/dff/continue/inquire_status", {
                continue_id: e,
                type_id: t,
                session_key: n,
                token: r,
                crystal: i
            }, _.extend({
                type: "POST"
            }, s), o)
        },
        getBalanceDeferred: function() {
            var e = {
                    notifyNetworkError: !1,
                    notifyMaintenance: !0
                },
                n = function() {
                    var e = $.Deferred();
                    return t.getBalanceDeferred().done(function(t) {
                        e.resolve(t)
                    }).fail(function(t) {
                        e.reject(null, null, t)
                    }), e.promise()
                };
            return this.requestApiDeferred(n, e)
        },
        purchaseItemDeferred: function(e) {
            var n = {
                    notifyNetworkError: !1,
                    notifyMaintenance: !0
                },
                r = function() {
                    var n = $.Deferred();
                    return t.purchaseItemDeferred(e).done(function(e) {
                        n.resolve(e)
                    }).fail(function(e) {
                        n.reject(null, null, e)
                    }), n.promise()
                };
            return this.requestApiDeferred(r, n)
        },
        notificationGetDataDeferred: function(e) {
            var t = {
                notifyNetworkError: !1,
                notifyMaintenance: !1
            };
            return this.requestDeferred("/dff/notification/get_data", {}, e, t)
        },
        createExternalUserAuthHashDeffered: function(e, t) {
            var n = {};
            return this.requestDeferred("/dff/external_user_auth/create_hash_battle", {
                guest_id: e,
                callback_url: t
            }, {
                type: "POST"
            }, n)
        },
        sendBattleErrorDeferred: function(e, n) {
            var r = kickmotor.nativefn.getAppVersion(),
                i = {
                    ver: r,
                    userId: FF.env.userId,
                    href: location.href,
                    message: "ERROR: " + n + ", failed to start battle, " + (e ? e.message : "no message")
                },
                s = JSON.stringify(i);
            return t.warnDeferred(s)
        },
        warnDeferred: function(e) {
            return t.warnDeferred(e)
        }
    }
}), define("scenes/battle/BattleEventMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.BattleEventMgr = e.extend({
        initialize: function() {
            this.eventFsm = this._createFsm(), this.battleProcessMgr = new t.BattleProcessMgr, this.eventFsm.setParent(this)
        },
        update: function() {
            this.eventFsm.update()
        },
        battleUpdate: function() {
            this.battleProcessMgr.update()
        },
        _createFsm: function() {
            return new t.EventFsm
        }
    })
}), define("scenes/battle/BattleFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.BattleFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.call(this), this.changeState("IDLE")
        },
        changeState: function(n) {
            e.prototype.changeState.apply(this, arguments), t.BattleInfo.getInstance().set("state", n)
        },
        processForStateIdleUpdate: function() {
            if (this._judgeChangeStateAndProcess()) return;
            _.each(t.ActorMgr.getAliveActors(), function(e) {
                e.update()
            }), _.each(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                e.update()
            });
            if (this._judgeChangeStateAndProcess()) return;
            t.ActorTimeMgr.getInstance().update();
            var e = t.BattleInfo.getInstance(),
                n = t.AbilityMgr.getInstance().shiftInterrupter();
            if (n) {
                this._interruptedAbility = n, e.setCurrentAbility(n), this.changeState("IN_ACTION");
                return
            }
            var r = t.AbilityMgr.getInstance().shiftAbility();
            if (r) {
                this._activeAbility = r, e.setCurrentAbility(r), r.isResumed() || r.executer.changeState("IN_ACTION"), this.changeState("IN_ACTION");
                return
            }
        },
        processForStateInActionEntry: function() {
            var e = this._interruptedAbility || this._activeAbility;
            e.isResumed() || e.begin()
        },
        processForStateInActionUpdate: function() {
            var e = void 0,
                n = void 0;
            t.ActorTimeMgr.getInstance().update(), this._interruptedAbility ? (n = this._interruptedAbility, n.update(), e = n.isDone()) : this._activeAbility && (n = this._activeAbility, n.update(), e = n.isDone(), e && n.executer.notifyAbilityDone());
            var r = n.isSuspended();
            r && t.AbilityMgr.getInstance().pushSuspend(n);
            if (e || r) this.changeState("IDLE"), this._interruptedAbility = null, this._activeAbility = null, t.BattleInfo.getInstance().setCurrentAbility(null)
        },
        processForStateInActionExit: function() {
            t.ActorMgr.notifyExitInAction()
        },
        processForStateInterruptActionEntry: function() {
            var e = this._interruptedAbility;
            e.begin()
        },
        processForStateInterruptActionUpdate: function() {
            t.ActorTimeMgr.getInstance().update();
            var e = this._interruptedAbility;
            e.update();
            var n = e.isDone();
            n && (this.changeState("IDLE"), this._interruptedAbility = null, t.BattleInfo.getInstance().setCurrentAbility(null))
        },
        changeStateToInterruptAction: function(e) {
            this._interruptedAbility = e, t.BattleInfo.getInstance().setCurrentAbility(e), this.changeState("INTERRUPT_ACTION")
        },
        makeAbilityForReraiseRise: function() {
            var e = t.ActorMgr.getReraiseDeathBuddies(),
                n = {
                    interruptAbility: !0
                };
            return t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.RERAISE_RISE, e[0], {
                registerOptions: n
            })
        },
        makeAbilityForGutsRise: function() {
            var e = t.ActorMgr.getGutsRiseBuddies(),
                n = {
                    interruptAbility: !0
                };
            return t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.GUTS_RISE, e[0], {
                registerOptions: n
            })
        },
        processForStateDeathEntry: function() {
            var e = [];
            _.each(t.ActorMgr.getAliveBuddies(), function(t) {
                t.judgeDeath() && (t.die(), e.push(t))
            }), e.length === 0 && _.each(t.ActorMgr.getAliveEnemies(), function(t) {
                t.judgeDeath() && (t.die(), e.push(t))
            }), this._judge = this._judgeVictory(), this._judge && t.BattleInfo.getInstance().set("isJustEnded", !0), this._death = new t.DeathFsm({
                deadActors: e,
                judge: this._judge
            })
        },
        processForStateDeathUpdate: function() {
            t.ActorTimeMgr.getInstance().update(), this._death.update();
            if (!this._death.isState("END")) return;
            var e = t.BattleInfo.getInstance();
            this._judge ? (e.set("judge", this._judge), e.isVictory() && e.isFinalRound() && e.set("isClear", !0), this.changeState("CLEANING")) : 0 < t.ActorMgr.getReraiseDeathBuddies().length ? this.changeStateToInterruptAction(this.makeAbilityForReraiseRise()) : this.changeState("IDLE")
        },
        processForStateDeathExit: function() {
            this._death = void 0, this._judge = void 0
        },
        processForStateCleaningEntry: function() {
            var e = t.AbilityMgr.getInstance().shiftSuspend();
            if (!e) {
                this.changeState("END");
                return
            }
            this._activeAbility = e, e.forceQuit()
        },
        processForStateCleaningUpdate: function() {
            var e = this._activeAbility;
            e.update(), e.isDone() && (e.executer.changeState("IDLE"), this._activeAbility = void 0, this.changeState("CLEANING"))
        },
        processForStateEndEntry: function() {
            var e = _.filter(t.ActorMgr.getAliveActors(), function(e) {
                if (e.isStateInAction()) throw new Error("invalid state. uid:" + e.getUid());
                return !e.isStateEnd()
            });
            _.each(e, function(e) {
                e.setEnd()
            })
        },
        _judgeChangeStateAndProcess: function() {
            if (0 < t.ActorMgr.getGutsRiseBuddies().length) return this.changeStateToInterruptAction(this.makeAbilityForGutsRise()), !0;
            if (this._judgeVictory()) return this.changeState("DEATH"), !0;
            if (_.any(t.ActorMgr.getAliveBuddies(), function(e) {
                    return e.judgeDeath()
                })) return this.changeState("DEATH"), !0;
            var e = _.map(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                return this._judgeDeathEnemyContainer(e)
            }, this);
            return _.any(e) ? (this.changeState("DEATH"), !0) : !1
        },
        _judgeDeathEnemyContainer: function(e) {
            var t = [],
                n = [];
            return _.each(e.getAliveChildren(), function(e) {
                e.judgeDeath() && (t.push(e), n.push(e.notifyJudgedDeath()))
            }, this), t.length > 0 && n.push(e.notifyJudgedDeath(t)), n.length > 0 ? _.all(n) : !1
        },
        _judgeVictory: function() {
            if (0 < t.ActorMgr.getReraiseDeathBuddies().length) return;
            var e = _.filter(t.ActorMgr.getAllBuddies(), function(e) {
                return e.isContinuousBattle()
            });
            if (e.length <= 0) {
                var n = _.any(t.ActorMgr.getAllBuddies(), function(e) {
                    return e.isForceEscaped()
                });
                return n ? t.Conf.JUDGE.FORCE_ESCAPE : t.Conf.JUDGE.LOSE
            }
            var r = _.filter(t.ActorMgr.getAllEnemyContainers(), function(e) {
                return e.isContinuousBattle()
            });
            if (r.length <= 0) return t.Conf.JUDGE.VICTORY;
            return
        }
    })
}), define("scenes/battle/BattleInfo", ["lib/ClassBase", "lib/BattleConfig", "util"], function(e, t, n) {
    var r, i = FF.ns.battle,
        s = e.extend({
            load: function(e) {
                this._battleInitData = e, this.reset();
                var t = e.battle.buddy,
                    n = e.battle.supporter,
                    r = e.battle.rounds;
                this.set("roundNum", r.length), this.continueTxns = [], this._uid2actor = {};
                var i = 0,
                    s = 0;
                for (i = 0, s = t.length; i < s; i++) this._uid2actor[t[i].uid] = t[i];
                for (i = 0, s = n.length; i < s; i++) this._uid2actor[n[i].uid] = n[i];
                var o = [],
                    u = [];
                for (i = 0, s = r.length; i < s; i++) Array.prototype.push.apply(o, r[i].enemy);
                for (i = 0, s = o.length; i < s; i++) Array.prototype.push.apply(u, o[i].children);
                for (i = 0, s = u.length; i < s; i++) this._uid2actor[u[i].uid] = u[i];
                this._translate(t, n, u), this._enemies = u, this._enemyContainers = o, this._initUnifiedMaterias(t), FF.logger.debug("buddies", t), FF.logger.debug("enemies", u)
            },
            _translate: function(e, t, n) {
                var r = [];
                Array.prototype.push.apply(r, e), Array.prototype.push.apply(r, t), Array.prototype.push.apply(r, n);
                var s = _.invert(i.Conf.STATUS_AILMENTS_TYPE),
                    o = _.invert(i.Conf.ELEMENT_TYPE);
                _.each(r, function(e) {
                    e.paramMap = {}, e.row = e.row || i.Conf.ROW_TYPE.FRONT, _.each(e.params, function(t) {
                        var n = void 0,
                            r = {};
                        _.each(t.atkAttributes, function(e) {
                            var t = e.attributeId;
                            o[t] && (n = t), s[t] && (r[t] = e.factor)
                        });
                        var i = {};
                        _.each(t.matkAttributes, function(e) {
                            var t = e.attributeId;
                            o[t] && (i[t] = e.factor)
                        });
                        var u = {};
                        _.each(t.defAttributes, function(e) {
                            u[e.attributeId] = e.factor
                        }), t.atkStatusAilments = r, t.matkElementMap = i, t.defAttributeMap = u, t.row = e.row, e.paramMap[t.id] = t
                    })
                })
            },
            _initUnifiedMaterias: function(e) {
                _.each(e, function(e) {
                    e.unifiedMaterias = i.MateriaUnifier.unifySkillsIntoMateria(e.sphereSkills, e.materias)
                })
            },
            toPlainObject: function() {
                var e = [];
                return _.each(this.continueTxns, function(t) {
                    e.push(t.toPlainObject())
                }, this), {
                    round: this.get("round"),
                    actionTime: this.get("actionTime"),
                    continueTxns: e,
                    roundRevertObject: this.get("roundRevertObject")
                }
            },
            applyPlainObject: function(e) {
                if (!e) return;
                this.set("round", e.round), this.set("actionTime", e.actionTime), this.set("roundRevertObject", e.roundRevertObject);
                var t = [];
                _.each(e.continueTxns, function(e) {
                    var n = new i.ContinueTxn;
                    n.applyPlainObject(e), t.push(n)
                }, this), this.continueTxns = t
            },
            reset: function() {
                _.extend(this._attributes, n.option({
                    judge: void 0,
                    resultInfo: void 0,
                    state: void 0,
                    isJustEnded: !1
                }))
            },
            getBattleInitData: function() {
                return this._battleInitData
            },
            getBattleParam: function(e) {
                return e = e || this.get("round"), this._battleInitData.battle.rounds[e - 1]
            },
            getActorParam: function(e) {
                return this._uid2actor[e]
            },
            getBuddyParams: function() {
                return this._battleInitData.battle.buddy
            },
            getSupporterParams: function() {
                return this._battleInitData.battle.supporter
            },
            getEnemyParams: function() {
                return this._enemies
            },
            getEnemyContainerParams: function() {
                return this._enemyContainers
            },
            getNextBattleParam: function() {
                var e = this.get("round") + 1;
                return this._battleInitData.battle.rounds[e - 1]
            },
            getDropItemList: function(e) {
                e = e || this.get("round");
                var t = this.getBattleParam(e);
                return t.dropItemList
            },
            getDropMaterias: function(e) {
                e = e || this.get("round");
                var t = this.getBattleParam(e);
                return t.dropMaterias
            },
            getBackgroundAnimationTime: function() {
                return this._battleInitData.battle.background.animationTime
            },
            isEnded: function() {
                return !!this.get("judge")
            },
            isJustEnded: function() {
                return this.get("isJustEnded")
            },
            isVictory: function() {
                return this.get("judge") === i.Conf.JUDGE.VICTORY
            },
            isLose: function() {
                return this.get("judge") === i.Conf.JUDGE.LOSE
            },
            isForceEscape: function() {
                return this.get("judge") === i.Conf.JUDGE.FORCE_ESCAPE
            },
            isBattleState: function(e) {
                return this.get("state") === e
            },
            isFinalRound: function(e) {
                return e = e || this.get("round"), e >= this.get("roundNum")
            },
            getAppInitData: function() {
                return FF.env.isNative() ? (r || (r = JSON.parse($("[data-app-init-data]").html())), r) : {}
            },
            getAppInitDataSessionKey: function() {
                return this.getAppInitData().session_key
            },
            getAppInitDataEndpointMap: function() {
                return this.getAppInitData().endpoint_map
            },
            getAppInitDataEventId: function() {
                var e = this.getAppInitData().event;
                return e ? e.event_id : void 0
            },
            addNewContinueTxn: function(e) {
                if (this._readLockForContinueTxn) throw new Error("transaction list has been locked for adding.");
                this._readLockForContinueTxn = !0;
                var t = _.any(this.continueTxns, function(t) {
                    return e.get("continueId") === t.get("continueId")
                }, this);
                if (t) throw new Error("continueId duplicated. id:" + e.get("continueId"));
                var n = this._getLastContinueTxn(),
                    r;
                if (n) {
                    if (n.chkNextTxnCreatedInDisallowTime(e)) throw r = {
                        lastTxn: n.toPlainObject(),
                        newTxn: e.toPlainObject()
                    }, new Error("txn generated within 1000ms. txns:" + JSON.stringify(r));
                    if (!n.isEnded()) throw r = {
                        lastTxn: n.toPlainObject(),
                        newTxn: e.toPlainObject()
                    }, new Error("last transaction has not been ended. txns:" + JSON.stringify(r))
                }
                this.continueTxns.push(e), this._readLockForContinueTxn = !1
            },
            getLastContinueTxn: function() {
                if (this._readLockForContinueTxn) throw new Error("transaction list has been locked for reading.");
                this._readLockForContinueTxn = !0;
                var e = this._getLastContinueTxn();
                return this._readLockForContinueTxn = !1, e
            },
            _getLastContinueTxn: function() {
                return _.first(this.continueTxns.sort(function(e, t) {
                    return e.get("continueId") < t.get("continueId") ? 1 : -1
                }))
            },
            getAllContinueTxns: function() {
                return this.continueTxns
            },
            setCurrentAbility: function(e) {
                return this.set("currentAbility", e)
            },
            getCurrentAbility: function() {
                return this.get("currentAbility")
            },
            getExpiredAt: function() {
                return this.getBattleInitData().battle.expiredAt
            },
            getMateriaBoostExpBuddies: function() {
                var e = [],
                    t = this.getBattleInitData().battle.buddyBoostMap || {};
                return _.each(t.exp, function(t, n) {
                    if (t) {
                        var r = i.ActorMgr.getByUid(n);
                        e.push(r)
                    }
                }), e
            },
            getMateriaBoostGilBuddies: function() {
                var e = [],
                    t = this.getBattleInitData().battle.buddyBoostMap || {};
                return _.each(t.gil, function(t, n) {
                    var r = i.ActorMgr.getByUid(n);
                    e.push(r)
                }), e
            },
            addActionTime: function(e) {
                var t = this.get("actionTime") || 0;
                this.set("actionTime", t + e)
            },
            isResultAlreadyEnded: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error && e.data.error === "BATTLE_ALREADY_ENDED" ? !0 : !1
            },
            isResultExpired: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error && e.data.error === "BATTLE_EXPIRE" ? !0 : !1
            },
            isResultError: function() {
                var e = this.get("resultInfo");
                return e && e.data && e.data.error ? !0 : !1
            },
            detectUrlFromResultInfo: function() {
                var e = this.get("resultInfo");
                if (!e) throw new Error("not found resultInfo");
                var t = this.isResultAlreadyEnded() ? "/dff/" : this.isResultExpired() ? "/dff/" : _.isString(e.data.url) ? e.data.url : "/dff/";
                return t
            },
            canOperateBattle: function() {
                return this.get("isPlaying") && this.get("isInBattle") && !this.isJustEnded()
            },
            setBattleConfig: function(e) {
                this.set("battleConfig", e)
            },
            getBattleConfig: function() {
                return this.get("battleConfig")
            },
            getBattleSpeedIndex: function() {
                return t.getBattleSpeedIndex(this.getBattleConfig().speed)
            },
            setBattleSpeedIndex: function(e) {
                var n = this.getBattleConfig(),
                    r = t.getBattleSpeedCandidates(),
                    i = r[e];
                if (!i) throw new Error("invalid battle speed" + i);
                n.speed = i, this.setBattleConfig(n)
            },
            getSkipOrder: function() {
                return this.getBattleConfig().skipOrder
            },
            getSkipOrderCandidates: function() {
                return t.getSkipOrderCandidates()
            },
            isAutoEnabledAtBattleStart: function() {
                return this.getBattleConfig().isAutoEnabledAtBattleStart
            },
            isMo: function() {
                return !1
            }
        }),
        o = void 0;
    FF.ns.battle.BattleInfo = {
        getInstance: function() {
            return o || (o = new s), o
        }
    }
}), define("scenes/battle/BattleInitData", ["lib/ValidatorLite", "lib/ClassBase", "util"], function(e, t, n) {
    var r = {
            root: {
                assets: {
                    type: "object",
                    norecursive: !0
                },
                battle: {
                    type: "object"
                },
                success: {
                    type: "boolean",
                    optional: !0
                },
                initChkResult: {
                    type: "boolean",
                    optional: !0
                },
                initChkResultText: {
                    type: "string",
                    optional: !0
                },
                resServerSnapshot: {
                    type: "string",
                    optional: !0
                },
                resClientSnapshot: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle": {
                battleId: {
                    type: "uint"
                },
                enemyAbilities: {
                    type: "array"
                },
                background: {
                    type: "object",
                    norecursive: !0
                },
                rounds: {
                    type: "array"
                },
                buddy: {
                    type: "array"
                },
                dungeon: {
                    type: "object"
                },
                supporter: {
                    type: "array"
                },
                score: {
                    type: "object"
                },
                messages: {
                    type: "array"
                },
                expiredAt: {
                    type: "uint"
                },
                version: {
                    type: "uint"
                },
                win_bgm: {
                    type: "string",
                    optional: !0
                },
                assets: {
                    type: "object",
                    norecursive: !0
                },
                buddyBoostMap: {
                    type: "object",
                    optional: !0
                },
                continueAllowableType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.enemyAbilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.enemyAbilities.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                land: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                landSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.enemyAbilities.options": {
                name: {
                    type: "string"
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                arg11: {
                    type: "number",
                    optional: !0
                },
                arg12: {
                    type: "number",
                    optional: !0
                },
                arg13: {
                    type: "number",
                    optional: !0
                },
                arg14: {
                    type: "number",
                    optional: !0
                },
                arg15: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                maxDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                minDamageThresholdType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.rounds": {
                round: {
                    type: "uint"
                },
                dropItemList: {
                    type: "array"
                },
                enemy: {
                    type: "array"
                },
                bgm: {
                    type: "string"
                },
                backgroundChangeType: {
                    type: "uint"
                },
                buddyTransitType: {
                    type: "uint"
                },
                dropMaterias: {
                    type: "array"
                }
            },
            "root.battle.rounds.dropMaterias": {
                itemId: {
                    type: "uint"
                },
                name: {
                    type: "string"
                },
                description: {
                    type: "string"
                },
                buddyPos: {
                    type: "string"
                }
            },
            "root.battle.rounds.enemy": {
                deformAnimationInfo: {
                    type: "array",
                    optional: !0
                },
                aiArguments: {
                    type: "array",
                    optional: !0
                },
                aiId: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                children: {
                    type: "array"
                },
                isSpEnemy: {
                    type: "boolean"
                }
            },
            "root.battle.rounds.enemy.aiArguments": {
                tag: {
                    type: "string"
                },
                argType: {
                    type: "uint"
                },
                argValue: {
                    type: "string"
                }
            },
            "root.battle.rounds.enemy.children": {
                aiId: {
                    type: "uint"
                },
                childPosId: {
                    type: "uint",
                    optional: !0
                },
                dropItemList: {
                    type: "array",
                    optional: !0
                },
                initHp: {
                    type: "uint"
                },
                maxHp: {
                    type: "uint"
                },
                no: {
                    type: "uint",
                    optional: !0
                },
                params: {
                    type: "array"
                },
                constraints: {
                    type: "array",
                    optional: !0
                },
                uid: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.children.params": {
                abilities: {
                    type: "array"
                },
                counters: {
                    type: "array"
                },
                acc: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                atk: {
                    type: "uint"
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                size: {
                    type: "string"
                },
                spd: {
                    type: "uint"
                },
                looking: {
                    type: "uint"
                },
                breedId: {
                    type: "uint"
                },
                lv: {
                    type: "uint"
                },
                castTimeType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.deformAnimationInfo": {
                id: {
                    type: "uint"
                },
                deformTag: {
                    type: "string"
                },
                state: {
                    type: "array",
                    optional: !0,
                    norecursive: !0
                },
                isRandom: {
                    type: "boolean"
                }
            },
            "root.battle.rounds.enemy.children.params.animationInfo": {
                path: {
                    type: "string"
                },
                offsetX: {
                    type: "number"
                },
                offsetY: {
                    type: "number"
                },
                scale: {
                    type: "float"
                },
                usesFixPos: {
                    type: "boolean"
                },
                hpGaugeSize: {
                    type: "number",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.abilities": {
                abilityId: {
                    type: "uint"
                },
                weight: {
                    type: "uint"
                },
                unlockTurnNum: {
                    type: "uint"
                },
                tag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.rounds.enemy.children.params.counters": {
                abilityId: {
                    type: "uint"
                },
                conditionType: {
                    type: "uint"
                },
                conditionValue: {
                    type: "uint"
                },
                rate: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.children.constraints": {
                priority: {
                    type: "uint"
                },
                enemyStatusId: {
                    type: "uint"
                },
                abilityTag: {
                    type: "string"
                },
                constraintType: {
                    type: "uint"
                },
                constraintValue: {
                    type: "string"
                },
                options: {
                    type: "string"
                }
            },
            "root.battle.rounds.dropItemList": {
                type: {
                    type: "uint"
                },
                rarity: {
                    type: "uint"
                }
            },
            "root.battle.rounds.enemy.children.dropItemList": {
                type: {
                    type: "uint"
                },
                rarity: {
                    type: "uint"
                },
                amount: {
                    type: "uint",
                    optional: !0
                },
                num: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy": {
                id: {
                    type: "uint"
                },
                dressRecordId: {
                    type: "uint"
                },
                abilities: {
                    type: "array"
                },
                abilityPanels: {
                    type: "array"
                },
                animationInfo: {
                    type: "object"
                },
                initHp: {
                    type: "uint"
                },
                materias: {
                    type: "array"
                },
                sphereSkills: {
                    type: "array",
                    optional: !0
                },
                maxHp: {
                    type: "uint"
                },
                no: {
                    type: "uint"
                },
                params: {
                    type: "array"
                },
                posId: {
                    type: "string"
                },
                row: {
                    type: "uint"
                },
                soulStrikes: {
                    type: "array"
                },
                soulStrikeGauge: {
                    type: "uint"
                },
                statusAilments: {
                    type: "array",
                    norecursive: !0
                },
                uid: {
                    type: "uint"
                },
                weapon: {
                    type: "object"
                },
                weaponEffect: {
                    type: "object"
                },
                armor: {
                    type: "object",
                    optional: !0,
                    norecursive: !0
                },
                statusBonusFlgOf: {
                    type: "object"
                },
                statusBonusTypeOf: {
                    type: "uint"
                },
                seriesIdMap: {
                    type: "object",
                    optional: !0
                },
                sparePanels: {
                    type: "array",
                    optional: !0
                },
                sex: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.materias": {
                slot: {
                    type: "number"
                },
                effectType: {
                    type: "number"
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                }
            },
            "root.battle.buddy.sphereSkills": {
                effectType: {
                    type: "number"
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                }
            },
            "root.battle.buddy.params": {
                acc: {
                    type: "uint"
                },
                atk: {
                    type: "uint"
                },
                atkType: {
                    type: "uint",
                    optional: !0
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                atkAttributes: {
                    type: "array"
                },
                matkAttributes: {
                    type: "array"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                handedness: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                level: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                spd: {
                    type: "uint"
                },
                atkSsPointFactor: {
                    type: "number"
                },
                defSsPointFactor: {
                    type: "number"
                }
            },
            "root.battle.buddy.params.atkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.buddy.params.matkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.buddy.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "float"
                }
            },
            "root.battle.buddy.animationInfo": {
                left1OffsetX: {
                    type: "number"
                },
                left1OffsetY: {
                    type: "number"
                },
                left2OffsetX: {
                    type: "number"
                },
                left2OffsetY: {
                    type: "number"
                },
                right1OffsetX: {
                    type: "number"
                },
                right1OffsetY: {
                    type: "number"
                },
                right2OffsetX: {
                    type: "number"
                },
                right2OffsetY: {
                    type: "number"
                }
            },
            "root.battle.buddy.weapon": {
                categoryId: {
                    type: "number"
                },
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.buddy.weapon.animationInfo": {
                id: {
                    type: "uint"
                },
                attackTag: {
                    type: "string"
                },
                equipType: {
                    type: "uint"
                },
                canMove: {
                    type: "uint"
                }
            },
            "root.battle.buddy.armor": {
                categoryId: {
                    type: "number"
                }
            },
            "root.battle.buddy.weaponEffect": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.buddy.weaponEffect.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.buddy.abilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                categoryId: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.buddy.abilities.animationInfo": {
                id: {
                    type: "uint",
                    optional: !0
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string",
                    optional: !0
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string",
                    optional: !0
                },
                hit: {
                    type: "string",
                    optional: !0
                },
                land: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint",
                    optional: !0
                },
                shotType: {
                    type: "uint",
                    optional: !0
                },
                hitType: {
                    type: "uint",
                    optional: !0
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint",
                    optional: !0
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint",
                    optional: !0
                },
                reverseHit: {
                    type: "uint",
                    optional: !0
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                landSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.abilities.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                panelName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "uint",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                arg11: {
                    type: "number",
                    optional: !0
                },
                arg12: {
                    type: "number",
                    optional: !0
                },
                arg13: {
                    type: "number",
                    optional: !0
                },
                arg14: {
                    type: "number",
                    optional: !0
                },
                arg15: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                maxDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                minDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                ssPoint: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.abilityPanels": {
                panelNo: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                num: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.buddy.sparePanels": {
                receptorId: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.buddy.soulStrikes": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                slot: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.buddy.soulStrikes.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                land: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                landSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.soulStrikes.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                dispName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                arg11: {
                    type: "number",
                    optional: !0
                },
                arg12: {
                    type: "number",
                    optional: !0
                },
                arg13: {
                    type: "number",
                    optional: !0
                },
                arg14: {
                    type: "number",
                    optional: !0
                },
                arg15: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                hasParamBooster: {
                    type: "uint",
                    optional: !0
                },
                consumeSoulStrikePoint: {
                    type: "uint"
                },
                maxDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                minDamageThresholdType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.buddy.statusBonusFlgOf": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.dungeon": {
                dungeonId: {
                    type: "uint",
                    optional: !0
                },
                isForce: {
                    type: "boolean"
                }
            },
            "root.battle.supporter": {
                id: {
                    type: "uint"
                },
                abilities: {
                    type: "array"
                },
                animationInfo: {
                    type: "object"
                },
                maxHp: {
                    type: "uint"
                },
                params: {
                    type: "array"
                },
                soulStrikes: {
                    type: "array"
                },
                uid: {
                    type: "uint"
                },
                weapon: {
                    type: "object"
                },
                weaponEffect: {
                    type: "object"
                },
                statusBonusFlgOf: {
                    type: "object"
                },
                statusBonusTypeOf: {
                    type: "uint"
                },
                supporterSsGauge: {
                    type: "uint"
                },
                maxSupporterSsGauge: {
                    type: "uint"
                },
                sparePanels: {
                    type: "array",
                    optional: !0
                },
                sex: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.params": {
                acc: {
                    type: "uint"
                },
                atk: {
                    type: "uint"
                },
                atkType: {
                    type: "uint",
                    optional: !0
                },
                critical: {
                    type: "uint"
                },
                def: {
                    type: "uint"
                },
                atkAttributes: {
                    type: "array"
                },
                matkAttributes: {
                    type: "array"
                },
                defAttributes: {
                    type: "array"
                },
                dispName: {
                    type: "string"
                },
                handedness: {
                    type: "string"
                },
                eva: {
                    type: "uint"
                },
                id: {
                    type: "uint"
                },
                level: {
                    type: "uint"
                },
                matk: {
                    type: "uint"
                },
                mdef: {
                    type: "uint"
                },
                mnd: {
                    type: "uint"
                },
                spd: {
                    type: "uint"
                },
                atkSsPointFactor: {
                    type: "number"
                },
                defSsPointFactor: {
                    type: "number"
                }
            },
            "root.battle.supporter.params.atkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.supporter.params.matkAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "uint"
                }
            },
            "root.battle.supporter.params.defAttributes": {
                attributeId: {
                    type: "uint"
                },
                factor: {
                    type: "float"
                }
            },
            "root.battle.supporter.sparePanels": {
                receptorId: {
                    type: "uint"
                },
                abilityId: {
                    type: "uint"
                },
                maxNum: {
                    type: "uint"
                },
                abilitySsPoint: {
                    type: "uint"
                },
                name: {
                    type: "string"
                }
            },
            "root.battle.supporter.animationInfo": {
                left1OffsetX: {
                    type: "number"
                },
                left1OffsetY: {
                    type: "number"
                },
                left2OffsetX: {
                    type: "number"
                },
                left2OffsetY: {
                    type: "number"
                },
                right1OffsetX: {
                    type: "number"
                },
                right1OffsetY: {
                    type: "number"
                },
                right2OffsetX: {
                    type: "number"
                },
                right2OffsetY: {
                    type: "number"
                }
            },
            "root.battle.supporter.weapon": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.supporter.weapon.animationInfo": {
                id: {
                    type: "uint"
                },
                attackTag: {
                    type: "string"
                },
                equipType: {
                    type: "uint"
                },
                canMove: {
                    type: "uint"
                }
            },
            "root.battle.supporter.weaponEffect": {
                animationInfo: {
                    type: "object"
                }
            },
            "root.battle.supporter.weaponEffect.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.supporter.abilities": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object",
                    optional: !0
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.supporter.abilities.animationInfo": {
                id: {
                    type: "uint",
                    optional: !0
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string",
                    optional: !0
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string",
                    optional: !0
                },
                hit: {
                    type: "string",
                    optional: !0
                },
                land: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint",
                    optional: !0
                },
                shotType: {
                    type: "uint",
                    optional: !0
                },
                hitType: {
                    type: "uint",
                    optional: !0
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint",
                    optional: !0
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint",
                    optional: !0
                },
                reverseHit: {
                    type: "uint",
                    optional: !0
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                landSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.abilities.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                panelName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "uint",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                arg11: {
                    type: "number",
                    optional: !0
                },
                arg12: {
                    type: "number",
                    optional: !0
                },
                arg13: {
                    type: "number",
                    optional: !0
                },
                arg14: {
                    type: "number",
                    optional: !0
                },
                arg15: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                maxDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                minDamageThresholdType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.soulStrikes": {
                abilityId: {
                    type: "uint"
                },
                actionId: {
                    type: "uint"
                },
                exerciseType: {
                    type: "uint"
                },
                animationInfo: {
                    type: "object"
                },
                options: {
                    type: "object"
                }
            },
            "root.battle.supporter.soulStrikes.animationInfo": {
                id: {
                    type: "uint"
                },
                atkMotion: {
                    type: "string",
                    optional: !0
                },
                launch: {
                    type: "string"
                },
                launchBack: {
                    type: "string",
                    optional: !0
                },
                hasLaunchEnd: {
                    type: "boolean",
                    optional: !0
                },
                shot: {
                    type: "string"
                },
                hit: {
                    type: "string"
                },
                land: {
                    type: "string",
                    optional: !0
                },
                missHit: {
                    type: "string",
                    optional: !0
                },
                returnShot: {
                    type: "string",
                    optional: !0
                },
                returnHit: {
                    type: "string",
                    optional: !0
                },
                returnMissHit: {
                    type: "string",
                    optional: !0
                },
                launchType: {
                    type: "uint"
                },
                shotType: {
                    type: "uint"
                },
                hitType: {
                    type: "uint"
                },
                hasHitTiming: {
                    type: "uint",
                    optional: !0
                },
                returnType: {
                    type: "uint"
                },
                hitArg: {
                    type: "uint",
                    optional: !0
                },
                reverseShot: {
                    type: "uint"
                },
                reverseHit: {
                    type: "uint"
                },
                charaOut: {
                    type: "string",
                    optional: !0
                },
                charaIn: {
                    type: "string",
                    optional: !0
                },
                otherOut: {
                    type: "string",
                    optional: !0
                },
                otherIn: {
                    type: "string",
                    optional: !0
                },
                damageTag: {
                    type: "string",
                    optional: !0
                },
                recoverTag: {
                    type: "string",
                    optional: !0
                },
                launchNextTag: {
                    type: "string",
                    optional: !0
                },
                shotNextTag: {
                    type: "string",
                    optional: !0
                },
                hitNextTag: {
                    type: "string",
                    optional: !0
                },
                launchSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                shotSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                hitSpriteNum: {
                    type: "uint",
                    optional: !0
                },
                landSpriteNum: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.soulStrikes.options": {
                name: {
                    type: "string"
                },
                aliasName: {
                    type: "string",
                    optional: !0
                },
                dispName: {
                    type: "string",
                    optional: !0
                },
                abilityAnimationId: {
                    type: "string",
                    optional: !0
                },
                arg1: {
                    type: "number",
                    optional: !0
                },
                arg2: {
                    type: "number",
                    optional: !0
                },
                arg3: {
                    type: "number",
                    optional: !0
                },
                arg4: {
                    type: "number",
                    optional: !0
                },
                arg5: {
                    type: "number",
                    optional: !0
                },
                arg6: {
                    type: "number",
                    optional: !0
                },
                arg7: {
                    type: "number",
                    optional: !0
                },
                arg8: {
                    type: "number",
                    optional: !0
                },
                arg9: {
                    type: "number",
                    optional: !0
                },
                arg10: {
                    type: "number",
                    optional: !0
                },
                arg11: {
                    type: "number",
                    optional: !0
                },
                arg12: {
                    type: "number",
                    optional: !0
                },
                arg13: {
                    type: "number",
                    optional: !0
                },
                arg14: {
                    type: "number",
                    optional: !0
                },
                arg15: {
                    type: "number",
                    optional: !0
                },
                targetRange: {
                    type: "uint",
                    optional: !0
                },
                targetSegment: {
                    type: "uint",
                    optional: !0
                },
                targetDeath: {
                    type: "uint",
                    optional: !0
                },
                targetMethod: {
                    type: "uint",
                    optional: !0
                },
                activeTargetMethod: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsId: {
                    type: "uint",
                    optional: !0
                },
                statusAilmentsFactor: {
                    type: "uint",
                    optional: !0
                },
                castTime: {
                    type: "uint",
                    optional: !0
                },
                counterEnable: {
                    type: "uint",
                    optional: !0
                },
                consumeSoulStrikePoint: {
                    type: "uint"
                },
                maxDamageThresholdType: {
                    type: "uint",
                    optional: !0
                },
                minDamageThresholdType: {
                    type: "uint",
                    optional: !0
                }
            },
            "root.battle.supporter.statusBonusFlgOf": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.buddy.seriesIdMap": {
                buddy: {
                    type: "uint"
                },
                weapon: {
                    type: "uint"
                },
                armor: {
                    type: "uint"
                },
                accessory: {
                    type: "uint"
                }
            },
            "root.battle.score": {
                general: {
                    type: "array"
                },
                specific: {
                    type: "array"
                }
            },
            "root.battle.score.general": {
                no: {
                    type: "uint"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "string",
                    optional: !0
                },
                arg2: {
                    type: "string",
                    optional: !0
                },
                arg3: {
                    type: "string",
                    optional: !0
                },
                arg4: {
                    type: "string",
                    optional: !0
                },
                arg5: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.score.specific": {
                no: {
                    type: "uint"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "string",
                    optional: !0
                },
                arg2: {
                    type: "string",
                    optional: !0
                },
                arg3: {
                    type: "string",
                    optional: !0
                },
                arg4: {
                    type: "string",
                    optional: !0
                },
                arg5: {
                    type: "string",
                    optional: !0
                }
            },
            "root.battle.messages": {
                id: {
                    type: "uint"
                },
                message: {
                    type: "string"
                },
                type: {
                    type: "uint"
                },
                arg1: {
                    type: "uint",
                    optional: !0
                },
                arg2: {
                    type: "uint",
                    optional: !0
                },
                displayType: {
                    type: "uint"
                }
            },
            "root.battle.buddyBoostMap": {
                exp: {
                    type: "object",
                    norecursive: !0,
                    optional: !0
                },
                gil: {
                    type: "object",
                    norecursive: !0,
                    optional: !0
                }
            }
        },
        i = {
            talks: {
                type: "object",
                norecursive: !0
            }
        };
    FF.ns.battle.BattleInitData = t.extend({
        initialize: function(e) {
            t.prototype.initialize.call(this), this._attributes = {
                original: e
            }, FF.env.isTutorial() && (r.root.tutorial = {
                type: "object"
            }, r["root.tutorial"] = i)
        },
        validate: function() {
            var e = this.get("original"),
                t = n.camelizeDeep(e);
            return t.assets = n.cloneDeep(e.assets), t.battle.assets = n.cloneDeep(e.battle.assets), this._validate("root", "root", t), t
        },
        _validate: function(t, n, i, s) {
            if (s && s.norecursive) return;
            if (!r[t]) throw new Error("invalid schema." + t);
            var o, u, a, f, l;
            if (s && s.type === "array") {
                f = i.splice(0, i.length);
                for (u = 0, a = f.length; u < a; u++) o = e(r[t], f[u], {
                    message: t + "." + u
                }), i.push(o.valid());
                l = i
            } else s && s.optional && !i ? i = {} : (o = e(r[t], i, {
                message: t
            }), _.extend(i, o.valid())), l = [i];
            _.each(r[t], function(e, n) {
                var r = t + "." + n;
                for (u = 0, a = l.length; u < a; u++)(e.type === "array" || e.type === "object") && this._validate(r, n, l[u][n], e)
            }, this)
        }
    })
}), define("lib/EventBase", ["underscore", "backbone"], function(e, t) {
    var n = function() {
        this.initialize.apply(this, arguments)
    };
    return e.extend(n.prototype, {
        initialize: function() {
            this._attributes = {}
        },
        dispose: function() {},
        get: function(e) {
            return this._attributes[e]
        },
        set: function(e, t) {
            this._attributes[e] = t
        },
        has: function(t) {
            return e.has(this._attributes, t)
        }
    }), e.extend(n.prototype, t.Events), n.extend = t.View.extend, n
}), define("scenes/battle/BattleLog", ["underscore", "sprintf", "lib/EventBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = r.Conf,
        s = 1e4,
        o = n.extend({
            initialize: function(e) {
                this._results = {
                    action_num: 0,
                    supporter_ss_use_num: 0,
                    buddy_damage: 0,
                    enemy_damage: 0,
                    continue_infos: [],
                    fps: [],
                    buddy_ab_use_num: {},
                    buddy_ss_use_num: {},
                    enemy_ab_use_num: {}
                }, this._elapsedTimeFps = 0, this.listenTo(r.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(r.ActorMgr, "ActorBase::entryInAction", this._onEntryInAction), this.listenTo(r.ActorMgr, "ActorBase::notifyAbilityBegun", this._onNotifiyAbilityBegun), this.listenTo(r.ActorMgr, "ActorMgr::resetBuddiesForContinue", this._onContinue)
            },
            _onDamage: function(e, t) {
                var n = t.executer,
                    r = t.receiver,
                    i = t.actualDamage || 0;
                if (!n || !r) return;
                n.isBuddy() && r.isEnemy() && i > 0 ? this._results.buddy_damage += i : n.isEnemy() && r.isBuddy() && i > 0 && (this._results.enemy_damage += i)
            },
            _onEntryInAction: function(e) {
                e.isBuddy() && (this._results.action_num++, this._recordSupporterSsUseNum(e))
            },
            _onNotifiyAbilityBegun: function(e, t) {
                if (!e) return;
                if (!t) return;
                this._recordBuddyAbilityUseNum(e, t), this._recordSoulStrikeUseNum(e, t), this._recordEnemyAbilityUseNum(e, t)
            },
            _recordSupporterSsUseNum: function(e) {
                var t = e.getAbility();
                if (!t) return;
                if (!t.get("isSupporterSoulStrike")) return;
                this._results.supporter_ss_use_num++
            },
            _recordBuddyAbilityUseNum: function(e, n) {
                if (!e) return;
                if (!e.isBuddy()) return;
                if (!n) return;
                if (!n.get("isAbilityPanel")) return;
                var r = e.get("no");
                this._results.buddy_ab_use_num[r] || (this._results.buddy_ab_use_num[r] = {});
                var i = e.getReceptorById(n.get("receptorId"));
                if (!i) return;
                var s = t("panel%d", +i.get("panelNo"));
                this._results.buddy_ab_use_num[r][s] || (this._results.buddy_ab_use_num[r][s] = 0), this._results.buddy_ab_use_num[r][s]++
            },
            _recordSoulStrikeUseNum: function(t, n) {
                if (!t) return;
                if (!t.isBuddy()) return;
                if (!n) return;
                if (!n.get("isSoulStrike")) return;
                var r = t.get("no");
                this._results.buddy_ss_use_num[r] || (this._results.buddy_ss_use_num[r] = {});
                var i = e.find(t.getSoulStrikePanels(), function(e) {
                    return e.get("abilityId") === n.get("abilityId")
                });
                if (!i) return;
                var s = +i.get("slot");
                this._results.buddy_ss_use_num[r][s] || (this._results.buddy_ss_use_num[r][s] = 0), this._results.buddy_ss_use_num[r][s]++
            },
            _recordEnemyAbilityUseNum: function(t, n) {
                if (!t) return;
                if (t.isBuddy()) return;
                if (!t.container.isSpEnemy()) return;
                if (!n) return;
                if (e.some(r.Config.getInstance().get("BuiltinAbilities"), function(e) {
                        return e.abilityId === +n.get("abilityId")
                    })) return;
                var i = t.get("paramId"),
                    s = n.get("abilityId");
                this._results.enemy_ab_use_num[i] || (this._results.enemy_ab_use_num[i] = {}), this._results.enemy_ab_use_num[i][s] || (this._results.enemy_ab_use_num[i][s] = 0), this._results.enemy_ab_use_num[i][s]++
            },
            _onContinue: function() {
                var e = r.BattleInfo.getInstance().getLastContinueTxn();
                this._results.continue_infos.push(e.makeResultData()), this._results.buddy_ab_use_num = {}, this._results.buddy_ss_use_num = {}, this._results.enemy_ab_use_num = {}
            },
            _recordFps: function() {
                var e = this;
                if (!FF.env.isNative()) return;
                if (this._results.fps.length >= 20) return;
                kickmotor.nativefn.getFrameRate(function(t) {
                    e._results.fps.push(t.fps || 0)
                })
            },
            _makeFpsData: function() {
                var t = this._results.fps;
                if (t.length === 0) return 0;
                var n = 0;
                return e.each(t, function(e) {
                    n += e
                }), Math.floor(n / t.length)
            },
            makeResultData: function() {
                var t = r.BattleInfo.getInstance().get("actionTime"),
                    n = r.EnemyPartyMgr.getInstance().makeResultData();
                return e.extend({}, this._results, {
                    action_time: Math.floor(t / 1e3) || 0,
                    all_enemy_info: n.all,
                    enemy_info: n.current,
                    fps: this._makeFpsData()
                })
            },
            update: function() {
                this._elapsedTimeFps += FF.scene.elapsedTime, this._elapsedTimeFps >= s && (this._recordFps(), this._elapsedTimeFps = 0)
            },
            toPlainObject: function() {
                return this._results
            },
            applyPlainObject: function(t) {
                if (!t) return;
                e.extend(this._results, t)
            }
        }),
        u = void 0,
        a = void 0;
    FF.ns.battle.BattleLog = {
        load: function() {
            a = new o
        },
        toPlainObject: function() {
            return a.toPlainObject()
        },
        applyPlainObject: function(e) {
            return a.applyPlainObject(e)
        },
        makeResultData: function() {
            return a.makeResultData()
        },
        update: function() {
            if (a) return a.update()
        }
    }
}), define("scenes/battle/BattleProcessMgr", ["jquery", "util", "lib/Battle", "lib/BattleConfig", "lib/BattleStorage", "lib/Storage", "lib/NameConventionFsm"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    FF.ns.battle.BattleProcessMgr = o.extend({
        initialize: function() {
            o.prototype.initialize.call(this);
            var e = this,
                t = u.BattleInfo.getInstance(),
                n = t.getBattleInitData();
            u.Score.load(n.battle.score), u.BattleLog.load(), t.set("round", 1), this.battleFsm = new u.BattleFsm, this.preBattleFsm = new u.PreBattleFsm, this.battleResultFsm = new u.BattleResultFsm, this.continueFsm = new u.ContinueFsm, this.continueFsm.setParent(this), this._isSetTouchEventOnceDone = !1, u.BuddyPartyMgr.getInstance().setParent(this), u.EnemyPartyMgr.getInstance().setParent(this), this.changeState("LOAD_BATTLE")
        },
        processForStateLoadBattleEntry: function() {
            var e = this,
                t = u.BattleInfo.getInstance(),
                n = u.BuddyPartyMgr.getInstance();
            this.setAuto(t.isAutoEnabledAtBattleStart()), u.EnemyPartyMgr.getInstance().load(t.getBattleInitData().battle), u.ActorMgr.registerBuddy(t.getBuddyParams()), u.ActorMgr.registerSupporter(t.getSupporterParams()), this.loadResumeData(), this.loadPersistentBattleDataDeferred().then(function() {
                e.changeState("SETUP")
            })
        },
        processForStateSetupEntry: function() {
            var e = this;
            this.setupNewBattle(), this._isDoneSave = !1, this.saveResumeDataDeferred().then(function() {
                return FF.scene.saveBattleConfigDeferred()
            }).then(function() {
                return e.savePersistentBattleDataDeferred()
            }).then(function() {
                e._isDoneSave = !0
            })
        },
        processForStateSetupUpdate: function() {
            this._isDoneSave && this.changeState("PRE_BATTLE")
        },
        processForStatePreBattleEntry: function() {
            this.preBattleFsm.changeState("APPEARANCE")
        },
        processForStatePreBattleUpdate: function() {
            this.preBattleFsm.isState("END") ? this.changeState("IN_BATTLE") : this.preBattleFsm.update()
        },
        setupNewBattle: function() {
            var e = u.BattleInfo.getInstance();
            e.reset(), this._setRoundRevertObjectIfNeed(), this._applyRoundRevertObject(), u.AbilityMgr.getInstance().reset();
            var t = e.get("round");
            FF.logger.debug("\n--------- start round " + t + " ---------"), u.ActorMgr.clearEnemy(), u.ActorMgr.clearActiveTarget();
            var n = e.getBattleParam();
            u.ActorMgr.registerEnemy(n.enemy), _.each(u.ActorMgr.getAll(), function(e) {
                e.setupNewBattle(), e.materiaHolder.notify(u.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND, {
                    round: t
                })
            }), this.fixEnemyPosId(u.ActorMgr.getAliveEnemyContainers()), u.BattleViewController.getInstance().setupNewBattle(), this._setTouchEventBySetupNewBattle(), FF.SoundMgr.playMusic(n.bgm)
        },
        processForStateInBattleEntry: function() {
            u.BattleInfo.getInstance().set("isInBattle", !0)
        },
        processForStateInBattleUpdate: function() {
            if (this._checkIsExpired()) {
                this.changeState("EXPIRE");
                return
            }
            u.BattleInfo.getInstance().addActionTime(FF.scene.elapsedTime), u.BuddyPartyMgr.getInstance().update(), u.EnemyPartyMgr.getInstance().update(), this.battleFsm.update(), u.Debug.update(), this.battleFsm.isState("END") && (this._canContinue() ? this.changeState("IN_CONTINUE") : this.changeState("IN_RESULT"))
        },
        processForStateInBattleExit: function() {
            u.BattleInfo.getInstance().set("isInBattle", !1)
        },
        processForStateInResultEntry: function() {
            this.battleResultFsm.begin()
        },
        processForStateInResultUpdate: function() {
            var e = u.BattleInfo.getInstance();
            this.battleResultFsm.update(), this.battleResultFsm.isState("END") && (u.EnemyPartyMgr.getInstance().activeTarget.resetSelected(), e.get("isClear") ? this.changeState("END") : e.isVictory() ? this.enterNextBattle() : this.changeState("END"))
        },
        processForStateInContinueEntry: function() {
            this.continueFsm.begin()
        },
        processForStateInContinueUpdate: function() {
            this.continueFsm.update(), this.continueFsm.isState("RETIRE") ? this.changeState("IN_RESULT") : this.continueFsm.isState("CONTINUE") ? this.enterSameBattleForContinue() : this.continueFsm.isState("EXPIRE") && this.changeState("EXPIRE")
        },
        processForStateEndEntry: function() {
            this.removeData(), FF.scene.saveBattleConfigDeferred(), u.BattleInfo.getInstance().set("isAllEnded", !0)
        },
        processForStateExpireEntry: function() {
            this.expireFsm = new u.ExpireFsm
        },
        processForStateExpireUpdate: function() {
            this.expireFsm.update()
        },
        enterNextBattle: function() {
            var e = u.BattleInfo.getInstance();
            e.set("round", 1 + e.get("round")), this.battleFsm.changeState("IDLE"), this.battleResultFsm.changeState("IDLE"), this.changeState("SETUP")
        },
        enterSameBattleForContinue: function() {
            this.battleFsm.changeState("IDLE"), this.battleResultFsm.changeState("IDLE"), this.continueFsm.changeState("IDLE"), u.AbilityMgr.getInstance().reset(), u.Message.reset();
            var e = u.BattleInfo.getInstance().get("roundRevertObject");
            e.isNeedToResetForContinue = !0, this.changeState("SETUP")
        },
        loadPersistentBattleDataDeferred: function() {
            var t = e.Deferred();
            return s.getItem("persistentBattle", function(e) {
                var n = e.result ? JSON.parse(e.value) : {};
                u.BuddyPartyMgr.getInstance().set("lastReceptorInfo", n.lastReceptorInfo || {}), t.resolve()
            }), t.promise()
        },
        savePersistentBattleDataDeferred: function() {
            var t = {
                    lastReceptorInfo: u.BuddyPartyMgr.getInstance().get("lastReceptorInfo")
                },
                n = e.Deferred(),
                r = JSON.stringify(t);
            return s.setItem("persistentBattle", r, function(e) {
                n.resolve()
            }), n.promise()
        },
        saveResumeDataDeferred: function() {
            var e = this.toPlainObject();
            return i.getInstance().setResumeData(e), i.getInstance().saveDeferred()
        },
        loadResumeData: function() {
            var e = i.getInstance().getResumeData();
            this.applyPlainObject(e)
        },
        removeData: function() {
            i.removeDataDeferred()
        },
        _setRoundRevertObjectIfNeed: function() {
            var e = u.BattleInfo.getInstance(),
                n = e.get("round"),
                r = e.get("roundRevertObject");
            if (r && r.round === n) return;
            var i = t.cloneDeep({
                buddyPartyMgr: u.BuddyPartyMgr.getInstance().toPlainObject(),
                score: u.Score.toPlainObject(),
                round: n
            });
            u.BattleInfo.getInstance().set("roundRevertObject", i)
        },
        _applyRoundRevertObject: function() {
            var e = u.BattleInfo.getInstance(),
                n = e.get("round"),
                r = u.BattleInfo.getInstance().get("roundRevertObject");
            if (!r) throw new Error("roundRevertObject not found");
            var i = r.round;
            if (n !== i) throw new Error("invalid round (current:%d, revert:%d)", n, i);
            var s = t.cloneDeep(e.get("roundRevertObject"));
            u.BuddyPartyMgr.getInstance().applyPlainObject(s.buddyPartyMgr), u.Score.applyPlainObject(s.score), !s.isNeedToResetForContinue || (u.Score.resetForContinue(), s.isNeedToResetForContinue = !1)
        },
        fixEnemyPosId: function(e) {
            var t = _.filter(e, function(e) {
                    return e.isSpEnemy()
                }),
                n = _.filter(e, function(e) {
                    return !e.isSpEnemy()
                });
            if (t.length > 1) throw new Error("invalid sp enemy num." + t.length);
            _.each(t, function(e) {
                e.set("posId", "5_03"), _.each(e.getChildren(), function(e) {
                    e.set("posId", "5_03")
                })
            });
            var r = {
                    1: ["1_01"],
                    2: ["2_01", "2_02"],
                    3: ["5_01", "5_05", "1_01"],
                    4: ["5_01", "5_02", "4_03", "4_04"],
                    5: ["5_01", "5_02", "5_03", "5_04", "5_05"]
                },
                i = _.sortBy(n, function(e) {
                    var t = e.getChildren();
                    return t[0].getSize()
                });
            _.each(i, function(e, t) {
                var n = e.getChildren(),
                    s = r[i.length][t];
                e.set("posId", s), _.each(e.getChildren(), function(e) {
                    e.set("posId", s), e.set("childPosId", 1)
                })
            })
        },
        setAuto: function(e) {
            var t = u.BattleViewController.getInstance();
            u.BattleInfo.getInstance().set("isInAutoBattle", e), t.showAutoButton(e), e && u.ActorMgr.clearActiveTarget()
        },
        _setTouchEventOnce: function() {
            var e = this;
            if (!FF.env.isNative()) return;
            var t = u.BattleViewController.getInstance();
            t.setAutoButtonTouch(function() {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                FF.SoundMgr.playChooseEffect(), e.setAuto(!u.BattleInfo.getInstance().get("isInAutoBattle"))
            }), t.setSkipButtonTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var n = u.ActorMgr.getAbilityPanelSelector();
                if (!n || !e) return;
                if (!n.equals(u.ActorMgr.getByUid(e))) return;
                var r = u.Conf.RECEPTOR.SKIP;
                u.BuddyPartyMgr.getInstance().reserveAbility(n, r) && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.setSoulStrikeTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var n = u.ActorMgr.getAbilityPanelSelector();
                if (!n || !e) return;
                if (!n.equals(u.ActorMgr.getByUid(e))) return;
                var r = u.Conf.RECEPTOR.SOUL_STRIKE;
                u.BuddyPartyMgr.getInstance().reserveAbility(n, r) && (FF.SoundMgr.playChooseEffect(), t.hideAbilityPanel())
            }), t.setSoulStrikePanelTouch(function(e, n) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var r = u.ActorMgr.getAbilityPanelSelector();
                if (!r || !e) return;
                if (!r.equals(u.ActorMgr.getByUid(e))) return;
                var i = u.Config.getInstance().get("SoulStrikePanels", n);
                u.BuddyPartyMgr.getInstance().reserveAbility(r, i) ? (FF.SoundMgr.playChooseEffect(), t.hideAbilityPanel()) : t.cancelSoulStrikePanelTouch()
            }), t.setPanelTouch(function(e, n) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                var r = u.ActorMgr.getAbilityPanelSelector();
                if (!r || !e) return;
                if (!r.equals(u.ActorMgr.getByUid(e))) return;
                var i = r.getAbilityPanelReceptorByPanelNo(n);
                u.BuddyPartyMgr.getInstance().reserveAbility(r, i.get("receptorId")) && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.setBuddyTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                if (u.BattleInfo.getInstance().get("isInAutoBattle")) return;
                var t = u.ActorMgr.getAbilityPanelSelector();
                if (!t) return;
                u.ActorMgr.toggleActiveTarget(e), u.BattleViewController.getInstance().updateActiveTarget()
            }), t.setSupporterButtonTouch(function() {
                var e = u.BuddyPartyMgr.getInstance();
                if (!e.canReceptSupporterSoulStrike()) return;
                e.reserveSupporterSoulStrike() && (FF.SoundMgr.playChooseEffect(), u.ActorMgr.clearActiveTarget(), t.clearCursor(), t.hideAbilityPanel())
            }), t.menuWindowView.setBattleSpeedTouch(function(e) {
                u.BattleInfo.getInstance().setBattleSpeedIndex(e)
            });
            var n = !1;
            t.setDebugTouch(function() {
                u.Debug.toggleInfo()
            }), t.setDebugTouchMoved(function() {
                u.Debug.increaseSsGauge()
            }), t.setDebugTouch1(function() {
                u.Debug.openDebugForm()
            }), t.setDebugTouch2(function() {
                u.Debug.killEnemies()
            })
        },
        _setTouchEventBySetupNewBattle: function() {
            var e = u.BattleViewController.getInstance();
            e.setEnemyTouch(function(e) {
                if (!u.BattleInfo.getInstance().get("isPlaying")) return;
                if (u.BattleInfo.getInstance().get("isInAutoBattle")) return;
                var t = u.ActorMgr.getAbilityPanelSelector();
                if (!t) return;
                u.ActorMgr.toggleActiveTarget(e), u.BattleViewController.getInstance().updateActiveTarget()
            }), this._isSetTouchEventOnceDone || (this._setTouchEventOnce(), this._isSetTouchEventOnceDone = !0)
        },
        _checkIsExpired: function() {
            if (!FF.env.isNative()) return !1;
            var e = u.BattleInfo.getInstance().getExpiredAt(),
                n = t.getTimeAsSec();
            return n += FF.scene._debugExpired || 0, n >= e
        },
        toPlainObject: function() {
            var e = u.BattleInfo.getInstance(),
                t = {};
            _.each(u.ActorMgr.getAllBuddies(), function(e) {
                t[e.getUid()] = e.toPlainObject()
            });
            var n = u.ActorMgr.getSupporter();
            return {
                battleInfo: e.toPlainObject(),
                buddies: t,
                supporter: n ? n.toPlainObject() : void 0,
                buddyPartyMgr: u.BuddyPartyMgr.getInstance().toPlainObject(),
                score: u.Score.toPlainObject(),
                log: u.BattleLog.toPlainObject()
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            u.BattleInfo.getInstance().applyPlainObject(e.battleInfo), u.BuddyPartyMgr.getInstance().applyPlainObject(e.buddyPartyMgr), u.Score.applyPlainObject(e.score), u.BattleLog.applyPlainObject(e.log), _.each(e.buddies, function(e, t) {
                var n = u.ActorMgr.getByUid(t);
                n.applyPlainObject(e)
            });
            if (!!e.supporter) {
                var t = u.ActorMgr.getSupporter();
                t.applyPlainObject(e.supporter)
            }
        },
        _canContinue: function() {
            if (!u.BattleInfo.getInstance().isLose()) return !1;
            var e = u.BattleInfo.getInstance().getBattleInitData().battle.continueAllowableType;
            return e === u.Conf.CONTINUE_ALLOWABLE_TYPE.ALWAYS_CANT ? !1 : !0
        }
    })
}), define("scenes/battle/BattleResultFsm", ["lib/BattleStorage", "lib/Cipher", "lib/NameConventionFsm"], function(e, t, n) {
    var r = FF.ns.battle,
        i = 2e3;
    FF.ns.battle.BattleResultFsm = n.extend({
        initialize: function() {
            n.prototype.initialize.call(this), this.changeState("IDLE"), _.bindAll(this, "_onTransitionEnd")
        },
        begin: function() {
            var e = r.BattleInfo.getInstance();
            if (e.get("isClear")) this.changeState("CLEAR");
            else if (e.isVictory()) this.changeState("TRANSITION");
            else if (e.isLose()) this.changeState("LOSE");
            else {
                if (!e.isForceEscape()) throw new Error("invalid judge");
                this.changeState("ESCAPE")
            }
        },
        processForStateTransitionEntry: function() {
            this._isTransitionDone = !1;
            var e = r.BattleInfo.getInstance().getNextBattleParam(),
                t = r.BattleViewController.getInstance().createAnimation({
                    animationType: r.Conf.ANIMATION_TYPE.TRANSITION,
                    buddyTransitType: e.buddyTransitType,
                    backgroundChangeType: e.backgroundChangeType,
                    buddies: r.ActorMgr.getAllBuddies()
                });
            t.addCallbackOnce("end", this._onTransitionEnd), t.play()
        },
        _onTransitionEnd: function() {
            this._isTransitionDone = !0
        },
        processForStateTransitionUpdate: function() {
            this._isTransitionDone && this.changeState("END")
        },
        processForStateClearEntry: function() {
            var e = this;
            if (!FF.env.isNative()) {
                this.changeState("END");
                return
            }
            r.BattleViewController.getInstance().startVictory(), r.RemoteLogger.logRemoteNotificationIfNeedDeferred();
            var t = this._makeWinResult();
            $.when(this.constructor._callBattleResultApiDeferred(r.Api.battleWinDeferred.bind(r.Api), t), r.util.DelayCallback.registerDeferred(i)).then(function(t) {
                FF.logger.debug("BATTLE RESULT", t[0]), e.changeState("END"), r.BattleInfo.getInstance().set("resultInfo", {
                    isVictory: !0,
                    data: t[0]
                })
            })
        },
        processForStateLoseEntry: function() {
            var e = this;
            r.BattleViewController.getInstance().startLose();
            if (!FF.env.isNative()) {
                this.changeState("END");
                return
            }
            r.RemoteLogger.logRemoteNotificationIfNeedDeferred();
            var t = this._makeLoseResult();
            $.when(this.constructor._callBattleResultApiDeferred(r.Api.battleLoseDeferred.bind(r.Api), t), r.util.DelayCallback.registerDeferred(i)).done(function(t) {
                e.changeState("END"), r.BattleInfo.getInstance().set("resultInfo", {
                    isVictory: !1,
                    data: t[0]
                })
            })
        },
        processForStateEscapeEntry: function() {
            var e = this,
                t = $.when(this.constructor.sendEscapeResultDeferred(), r.util.DelayCallback.registerDeferred(i)).done(function(t) {
                    e.changeState("END"), r.BattleInfo.getInstance().set("resultInfo", {
                        data: t[0]
                    })
                })
        },
        ///HERE
        _makeWinResult: function() {
            var e = {};
            return _.extend(e, r.BuddyPartyMgr.getInstance().makeResultData()), e.score = r.Score.makeResultData(), e.log = r.BattleLog.makeResultData(), e.initChkResult = r.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.initChkResultText = r.BattleInfo.getInstance().getBattleInitData().initChkResultText, e.session_key = r.BattleInfo.getInstance().getAppInitDataSessionKey(), this._setParameterSnapshot(e), FF.logger.info("RESULT", JSON.stringify(e)), e
        },
        _makeLoseResult: function() {
            var e = {},
                t = r.ActorMgr.getAliveEnemyContainers();
            return e.enemy_ids = _.map(t, function(e) {
                return e.getId()
            }), e.log = r.BattleLog.makeResultData(), e.initChkResult = r.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.initChkResultText = r.BattleInfo.getInstance().getBattleInitData().initChkResultText, e.session_key = r.BattleInfo.getInstance().getAppInitDataSessionKey(), e
        },
        _setParameterSnapshot: function(e) {
            if (!FFEnv.chkParameter) return;
            e.cup = {
                srqc: r.ParameterEncoder.snapshotRequest(e)
            };
            if (e.initChkResult) return;
            e.cup.srsc = r.BattleInfo.getInstance().getBattleInitData().resClientSnapshot, e.cup.srss = r.BattleInfo.getInstance().getBattleInitData().battle.resServerSnapshot
        }
    }, {
        _callBattleResultApiDeferred: function(e, n) {
            var r = JSON.stringify(n);
            return t.encryptTextDeferred(r).then(function(t) {
                return e(t, {
                    retryCount: 1
                })
            })
        },
        sendEscapeResultDeferred: function() {
            r.RemoteLogger.logRemoteNotificationIfNeedDeferred();
            var e = this._makeEscapeResult();
            return this._callBattleResultApiDeferred(r.Api.battleEscapeDeferred.bind(r.Api), e)
        },
        _makeEscapeResult: function() {
            var e = {};
            return _.extend(e, r.BuddyPartyMgr.getInstance().makeResultData()), e.log = r.BattleLog.makeResultData(), e.initChkResult = r.BattleInfo.getInstance().getBattleInitData().initChkResult ? 1 : 0, e.initChkResultText = r.BattleInfo.getInstance().getBattleInitData().initChkResultText, e.session_key = r.BattleInfo.getInstance().getAppInitDataSessionKey(), FF.logger.info("RESULT", JSON.stringify(e)), e
        }
    })
}), define("scenes/battle/BattleViewController", ["jquery", "sprintf", "lib/ab/BattleAssetsManager", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/Events", "lib/EventBase", "lib/BattleStorage", "components/Loading", "components/Overlay"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = FF.ns.battle,
        c = {
            initialize: function() {
                o.prototype.initialize.call(this), this._isBuddyInitialized = !1, FF.logger.debug("BattleView: initialize"), this.overlay = new f({
                    el: e(".overlay")
                }), this.loading = new a({
                    el: e(".loading")
                }), this.overlay.registerChildren(this.loading), this.assetsManager = new n, this.battleLayer = null, this.rootNodes = [], this.ignoreSuspendLayers = [], this.messageView = void 0, this.soulStrikeView = void 0, this.backgroundView = void 0, this.commandView = void 0, this.buddyViews = {}, this.buddyCommonAssetId = "player_common", this.forceLayerName = "layer_bg-force_01", this.enemyContainers = {}, this.tutorialBattleView = void 0, this.isAnimating = !1, this._targetUid = void 0, this._fingerPosId = void 0, this._cursorPosInfo = {}, this._specialMessage = void 0, this._cbTouchAbscreen = void 0, this._setupAbscreenTouchEvent(), this._isTouchedPause = !1, this._canStartPause = !0, this._canStartPauseBySoulStrikeView = !0, this._canStartPauseBySoulStrikeSelector = !0, FF.env.isUsingWWBackKeyHandler() && this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", this._onBackKey)
            },
            _setupAbscreenTouchEvent: function() {
                var e = this,
                    t = "BattleViewController::ABScreen::ActionTouchEnded",
                    n = kickmotor.nativefn.registerCallback(function() {
                        e.trigger(t)
                    });
                kickmotor.animation.processAnimation([{
                    exec: "addCallback",
                    layer: "ABScreen",
                    callback: n,
                    event: "action_touch_ended",
                    autoDelete: !0
                }]), this.listenTo(this, t, this._onTouchAbscreen)
            },
            _onTouchAbscreen: function() {
                _.isFunction(this._cbTouchAbscreen) && this._cbTouchAbscreen()
            },
            loadDeferred: function(e) {
                var t = this,
                    n = e.battle.assets || {};
                return this.assetsManager.populateAssetsDeferred(e.assets, {
                    restriction: n,
                    isPreloadEffect: !0
                }).then(function() {
                    t.loadLayer(), t.setRootNodesVisible(!1), t.drawView(e)
                })
            },
            loadViewDeferred: function() {
                FF.logger.debug("BattleView: loadView");
                var t = this,
                    n = {
                        isDummy: !0,
                        battle: {
                            background: {
                                assetId: "bg-10001"
                            }
                        }
                    },
                    r = e.Deferred();
                return this.loadAssetsDeferred().then(function() {
                    t.loadLayer(), t.drawView(n), r.resolve()
                }), r.promise()
            },
            loadAssetsDeferred: function() {
                FF.logger.debug("BattleView: loadAssetsDeferred");
                var t = this,
                    n = e.Deferred(),
                    r = "../debug/get_battle_init_data";
                r += "?dungeon_id=1&battle_id=1";
                var i = e.ajax({
                    url: r,
                    dataType: "json"
                });
                return i.then(function(e) {
                    return FF.logger.debug(e), t.assetsManager.populateAssetsDeferred(e.assets)
                }).then(n.resolve), n.promise()
            },
            loadLayer: function() {
                FF.logger.debug("BattleView: loadLayer");
                var e = "battle_field",
                    t = this.assetsManager.getAssetInfo(e);
                this.battleLayer = new i({
                    layerName: t.layerName
                }), _.each(this.assetsManager.getCreatedLayerNames(), function(e) {
                    var t = new r({
                        name: "AnimationBuilderRoot",
                        layer: e
                    });
                    this.rootNodes.push(t)
                }, this), this.battleLayer.activate()
            },
            activateNativeTouch: function() {
                kickmotor.nativefn.call("setIsEnableTouchEvent", {
                    isEnable: !0,
                    isEnableScreen: !0
                })
            },
            deactivateABScreen: function() {
                kickmotor.nativefn.call("setIsEnableTouchEvent", {
                    isEnableScreen: !1
                })
            },
            drawView: function(e) {
                FF.logger.debug("BattleView: drawView");
                var t = this;
                FF.env.isDevelop() && kickmotor.nativefn.call("showTouchArea", {
                    isShow: !1
                }), this.materiaDropView = new l.view.MateriaDropView({
                    battleViewController: this
                }), this.menuWindowView = new l.view.MenuWindowView({
                    battleViewController: this
                }), this.loadingView = new l.view.LoadingView({
                    battleViewController: this
                });
                var n = this.battleLayer.createNode("pause_btn_nul"),
                    r = n.createChildNode("pause_btn_visible_touch");
                r.addCallback("action_touch_began", function() {
                    if (l.DataConstructor.isAllEnded()) return;
                    t.startPause()
                }).process(), this.messageView = new l.view.MessageView({
                    battleViewController: this
                }), this.messageView.hide(), this.backgroundView = new l.view.BackgroundView({
                    battleViewController: this,
                    backgroundInfo: e.battle.background
                }), this.commandView = new l.view.CommandView({
                    battleViewController: this
                }), this.commandView.setSoulStrikeSelectorVisibleChangeHandler(_.bind(this._updateSupporterViewControllerVisible, this)), this.shakeBackgroundNode = this.battleLayer.createNode("shake_part_nul"), this.shakeAllNode = this.battleLayer.createNode("shake_all_nul"), this.flashNode = this.battleLayer.createNode("flash_nul"), this.specialMessageNode = this.battleLayer.createNode("special_name_nul"), this.blackOutNode = this.battleLayer.createNode("black_out_win"), this.shouldPlayForceEffect(e) && this.playForceEffect(), this.targetArrowView = new l.view.TargetArrowView({
                    battleViewController: this
                }), this.supporterViewController = new l.SupporterViewController({
                    battleViewController: this
                }), this._supporterViewCanBeVisible = !1, this._supporterViewShown = void 0, this._drawHeader(), this.loading.hide(), this.activateNativeTouch(), FF.logger.debug("BattleView: drawView")
            },
            shouldPlayForceEffect: function(e) {
                return e.battle.dungeon.isForce ? !0 : !1
            },
            _drawHeader: function() {
                this.setTreasureNum(0), this.setOrbNum(0), this.setGilNum(0), this.setEventItemImg(), this.setEventItemNum(0)
            },
            setupNewBattle: function() {
                FF.logger.debug("BattleView: setupNewBattle"), this.removeEnemyContainers(), this._isBuddyInitialized || (this.updateBuddy(), this._isBuddyInitialized = !0), this.updateEnemy(), this.setGilNum(l.DataConstructor.getGil()), this.setOrbNum(l.DataConstructor.getOrb()), this.setTreasureNum(l.DataConstructor.getTreasure()), this.setEventItemNum(l.DataConstructor.getEventItem()), this.updateBackgroundIdle(), this.setRootNodesVisible(!0)
            },
            setBuddyTouch: function(e) {
                _.each(this.buddyViews, function(t) {
                    t.setTouchBegan(e)
                })
            },
            setEnemyTouch: function(e) {
                _.each(this.enemyContainers, function(t) {
                    t.setTouchBegan(e)
                })
            },
            setSoulStrikeTouch: function(e) {
                this.commandView.setSpecialTouch(e)
            },
            setSoulStrikePanelTouch: function(e) {
                this.commandView.setSpecialPanelTouch(e)
            },
            setAutoButtonTouch: function(e) {
                this.commandView.setAutoTouch(e)
            },
            setSkipButtonTouch: function(e) {
                this.commandView.setSkipTouch(e)
            },
            setPanelTouch: function(e) {
                this.commandView.setTouch(e)
            },
            setSupporterButtonTouch: function(e) {
                this.supporterViewController.setButtonTouch(e)
            },
            setDebugTouch: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul");
                    t.addCallback("action_touch_ended", e).process();
                    var n = this.battleLayer.createNode("debug_nul");
                    n.setText("debug_txt", "").setVisible(!0).process()
                }
            },
            setDebugTouchMoved: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul");
                    t.addCallback("action_touch_moved", e).process()
                }
            },
            setDebugTouch1: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul_1");
                    t.addCallback("action_touch_ended", e).process()
                }
            },
            setDebugTouch2: function(e) {
                if (FF.env.isDevelop()) {
                    var t = this.battleLayer.createNode("dev_btn_nul_2");
                    t.addCallback("action_touch_ended", e).process()
                }
            },
            setDebugText: function(e) {
                if (FF.env.isDevelop()) {
                    if (this._debugText === e) return;
                    var t = this.battleLayer.createNode("debug_nul");
                    t.setText("debug_txt", e).process(), this._debugText = e
                }
            },
            updateAbilityPanel: function() {
                var e = l.DataConstructor.getCurrentAbility(),
                    t = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    n = t ? t.selector : void 0,
                    r = e && e.isInLongAction;
                !n || this.commandView.isChangedSelector(n) || r ? (this.clearTargetActor(), this.clearCursor(), this.hideAbilityPanel(r)) : (this.commandView.commandInDeferred(n, {
                    panelInfoArray: t.abilityPanelInfo,
                    specialInfo: t.soulStrikeInfo,
                    canSkip: t.canSkipSelect
                }), this._supporterViewCanBeVisible = !0, this._updateSupporterViewControllerVisible()), this.commandView.setAutoButtonEnabled(l.DataConstructor.isAutoEnabled())
            },
            hideAbilityPanel: function(e) {
                this.commandView.commandOutDeferred({
                    keepCurrentMenu: e
                }), this.setCanStartPauseBySoulStrikeView(!0), this._supporterViewCanBeVisible = !1, this._updateSupporterViewControllerVisible()
            },
            cancelSoulStrikePanelTouch: function() {
                this.commandView.cancelSoulStrikePanelTouch()
            },
            _updateSupporterViewControllerVisible: function() {
                if (FF.env.isTutorial()) return;
                var e = this._supporterViewCanBeVisible && !this.commandView.isSoulStrikeSelectorMenuShown();
                this._supporterViewShown === e, this._supporterViewShown = e;
                if (this._supporterViewShown) {
                    var t = l.DataConstructor.getSupporterSoulStrikeInfo();
                    this.supporterViewController.supporterButtonInDeferred(t)
                } else this.supporterViewController.supporterButtonOutDeferred()
            },
            updateBuddy: function() {
                _.each(l.DataConstructor.loadBuddyDrawInfo(), function(e) {
                    this.showBuddy(e)
                }, this)
            },
            showBuddy: function(e) {
                var t = e.posId;
                this.buddyViews[t] || (this.buddyViews[t] = new l.view.BuddyView({
                    battleViewController: this,
                    buddyInfo: e
                })), this.buddyViews[t].setBuddyInfo(e)
            },
            updateEnemy: function() {
                _.each(l.DataConstructor.loadEnemyDrawInfo(), function(e) {
                    this.showEnemy(e)
                }, this)
            },
            showEnemy: function(e) {
                var t = e.posId;
                this.enemyContainers[t] || (this.enemyContainers[t] = new l.view.EnemyContainer({
                    battleViewController: this,
                    posId: t,
                    usesFixPos: !!e.usesFixPos
                })), this.isAnimating || this.enemyContainers[t].updateEnemyInfo(e)
            },
            updateEnemyContainerPosArray: function(e) {
                if (!this.enemyContainers[e]) throw new Error("undefined enemy container. posId:" + e);
                if (!this.isAnimating) {
                    var t = l.DataConstructor.getEnemyPosArrayByEnemyPosId(e);
                    this.enemyContainers[e].updatePosArray(t)
                }
            },
            getAllActorViews: function() {
                var e = [];
                return e = e.concat(_.values(this.buddyViews)), _.each(this.enemyContainers, function(t) {
                    e = e.concat(_.values(t.enemyViews))
                }), e
            },
            getActorView: function(e) {
                if (e.isEnemy) {
                    var t = this.enemyContainers[e.posId];
                    if (t) {
                        var n = t.enemyViews[e.childPosId];
                        if (n) return n
                    }
                    throw "target enemy view is not found : " + e.posId + " : " + e.childPosId
                }
                return this.buddyViews[e.posId]
            },
            getActorViewByActorInfo: function(e) {
                return this.getActorView(e.posInfo)
            },
            update: function() {
                this.updateBuddy(), this.updateEnemy(), this.updateActiveTarget(), this.updateAbilityPanel();
                if (this._isTouchedPause && this.canStartPause() && l.DataConstructor.judgePauseOrEscapeAvailable()) {
                    if (FF.env.isTutorial()) {
                        if (this.canNotPause) return;
                        this.tutorialBattleView.setVisible(!1), this.menuWindowView.prepareForTutorial()
                    }
                    this.menuWindowView.startPause(), this._isTouchedPause = !1
                }
            },
            setCanStartPause: function(e) {
                if (!_.isBoolean(e)) throw new Error("invalid argument");
                this._canStartPause = e
            },
            setCanStartPauseBySoulStrikeView: function(e) {
                this._canStartPauseBySoulStrikeView = e
            },
            setCanStartPauseBySoulStrikeSelector: function(e) {
                this._canStartPauseBySoulStrikeSelector = e
            },
            canStartPause: function() {
                return !this._canStartPause || !this._canStartPauseBySoulStrikeView || !this._canStartPauseBySoulStrikeSelector ? !1 : this.menuWindowView.isOpeningWindow() ? !1 : this.menuWindowView.isJustAnimatingWindow() ? !1 : !0
            },
            updateActiveTarget: function() {
                var e = l.DataConstructor.getCurrentAbility(),
                    t = l.DataConstructor.getActiveTarget(),
                    n = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    r = n ? n.selector : void 0;
                !r || !t || e && e.isInLongAction ? this.clearTargetActor() : this.toggleTargetActor(t, r)
            },
            closeTargetArrowOnDeformStartingDeferred: function() {
                return this.targetArrowView.closeDeferred()
            },
            openTargetArrowOnDeformFinishing: function() {
                var e = l.DataConstructor.getActiveTarget(),
                    t = l.DataConstructor.getSelectorAbilityPanelInfo(),
                    n = t ? t.selector : void 0;
                if (!n || !e) return;
                var r = this.getActorViewByActorInfo(e),
                    i = this.getActorViewByActorInfo(n);
                this.targetArrowView.open(r, i)
            },
            setTreasureNum: function(e) {
                var t = this.battleLayer.createNode("treasure_nul");
                t.setText("treasure_num_txt", "" + e).process()
            },
            setOrbNum: function(e) {
                var t = this.battleLayer.createNode("orb_nul");
                t.setText("orb_num_txt", "" + e).process()
            },
            setToolsNum: function(e) {
                var t = this.battleLayer.createNode("tools_nul");
                t.setText("tools_num_txt", "" + e).process()
            },
            setGilNum: function(e) {
                var t = this.battleLayer.createNode("gil_nul");
                t.setText("gil_num_txt", "" + e).process()
            },
            setEventItemNum: function(e) {},
            setEventItemImg: function() {},
            showMessage: function(e) {
                this.messageView.show(e)
            },
            hideMessage: function() {
                this.messageView.hide()
            },
            updateSoulStrikeGauge: function() {
                var e = l.DataConstructor.getSoulStrikePoint();
                this.commandView.setSpecialGauge(e)
            },
            toggleCursor: function(e) {
                var t = l.DataConstructor.getActorInfoByUid(e);
                if (t.posInfo.posId === this._cursorPosInfo.posId) return;
                this.getActorView(t.posInfo).setCursorEnabled(!0), this._cursorPosInfo.posId && this.getActorView(this._cursorPosInfo).setCursorEnabled(!1), this._cursorPosInfo = t.posInfo
            },
            clearCursor: function() {
                _.each(this.buddyViews, function(e) {
                    e.setCursorEnabled(!1)
                }, this), this._cursorPosInfo = {}
            },
            toggleTargetActor: function(e, t) {
                var n = this,
                    r = e.uid;
                if (r === this._targetUid) return;
                var i = this.getActorViewByActorInfo(e),
                    s = this.getActorViewByActorInfo(t);
                if (this._targetUid) {
                    var o = l.DataConstructor.getActorInfoByUid(this._targetUid),
                        u = this.getActorViewByActorInfo(o);
                    u.setTargetEnabled(!1)
                }
                i.setTargetEnabled(!0), this.targetArrowView.open(i, s), this._targetUid = r
            },
            clearTargetActor: function() {
                var e = this.getAllActorViews();
                _.each(e, function(e) {
                    e.setTargetEnabled(!1)
                }), this.targetArrowView.close(), this._targetUid = void 0
            },
            getScreenPositionDeferred: function(t) {
                var n = e.Deferred();
                return t.getNodePos(function(e) {
                    if (e.err) n.reject(e);
                    else {
                        var t = _.first(e.pos);
                        n.resolve(t)
                    }
                }, {
                    isScreen: !0
                }), n.promise()
            },
            playBuddiesVictoryMotion: function(e) {
                _.each(l.DataConstructor.loadBuddyDrawInfo(), function(e) {
                    if (e.isDead) return;
                    this.getActorView(e.posInfo).handsUpMotion()
                }, this)
            },
            createAnimation: function(e) {
                return l.view.animation.AnimationFactory.create(e, this)
            },
            suspendAnime: function() {
                var e = [];
                _.each(this.rootNodes, function(t) {
                    if (_.contains(this.ignoreSuspendLayers, t.layer)) return;
                    t.suspendPlay({
                        descendant: !0
                    }).pauseParticle({
                        descendant: !0
                    }).suspendSpriteAnime({
                        descendant: !0
                    }), e.push(t)
                }, this), this.flush(e)
            },
            resumeAnime: function() {
                var e = [];
                _.each(this.rootNodes, function(t) {
                    if (_.contains(this.ignoreSuspendLayers, t.layer)) return;
                    t.resumePlay({
                        descendant: !0
                    }).continueParticle({
                        descendant: !0
                    }).resumeSpriteAnime({
                        descendant: !0
                    }), e.push(t)
                }, this), this.flush(e)
            },
            addIngoreSupendLayers: function(e) {
                var t = _.isArray(e) ? e : [e];
                _.each(t, function(e) {
                    this.ignoreSuspendLayers.push(e)
                }, this)
            },
            showBalanceErrorWindowDeferred: function(e, t) {
                if (FF.env.isWWRegion()) return this.menuWindowView.showBalanceErrorWindowDeferred(e, t);
                throw new Error("showBalanceErrorWindowDeferred is unimplemented in JP")
            },
            confirmWithUserDeferred: function(e, t) {
                if (FF.env.isWWRegion()) return this.menuWindowView.confirmWithUserDeferred(e, t);
                throw new Error("confirmWithUserDeferred is unimplemented in JP")
            },
            showContinueDoneWindow: function(e, t) {
                this.menuWindowView.showContinueDoneWindow(e, t)
            },
            closeMenuWindowDeferred: function() {
                return this.menuWindowView.closeWindowDeferred()
            },
            showFreeWindow: function(e) {
                this.menuWindowView.showFreeWindow(e)
            },
            showSystemWindow: function(e, n, r, i) {
                var s = this,
                    o = void 0,
                    u = l.TextMaster.getInstance(),
                    a = {
                        yes: u.get("yes"),
                        no: u.get("no"),
                        ok: u.get("ok")
                    };
                switch (e) {
                    case l.Conf.SYSTEM_WINDOW.NETWORK:
                        o = {
                            title: u.get("B15030"),
                            description: u.get("B15040"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.ERROR:
                        o = {
                            title: u.get("B15050"),
                            description: u.get("B15060"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.LOGIN:
                        o = {
                            title: u.get("B15070"),
                            description: u.get("B15080"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.BATTLE_RESULT:
                        o = {
                            title: u.get("B15090"),
                            description: u.get("B15100"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.EXPIRE:
                        o = {
                            title: u.get("B15110"),
                            description: u.get("B15120"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.CONFIRM_CONTINUE:
                        o = {
                            title: u.get("B15150"),
                            description: u.get("B15160"),
                            buttons: [{
                                title: a.yes,
                                callback: n
                            }, {
                                title: a.no,
                                callback: r
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.MAINTENANCE:
                        var f = new Date((i.closedAt + FF.env.offsetFromUTC) * 1e3),
                            c = FF.env.isWWRegion() ? t("%02d:%02d %d/%d PST", f.getUTCHours(), f.getUTCMinutes(), f.getUTCMonth() + 1, f.getUTCDate()) : t("%d/%d%02d:%02d", f.getUTCMonth() + 1, f.getUTCDate(), f.getUTCHours(), f.getUTCMinutes()),
                            h = t(u.get("B15181"), c);
                        o = {
                            title: u.get("B15170"),
                            description: h,
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.ALERT_ESCAPE:
                        o = {
                            title: u.get("B15190"),
                            description: u.get("B15200"),
                            buttons: [{
                                title: a.ok,
                                callback: n
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.OAUTH_TOKEN_REVOKED:
                        o = {
                            title: u.get("B15210"),
                            description: u.get("B15220"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirect("/dff/login")
                                }
                            }]
                        };
                        break;
                    case l.Conf.SYSTEM_WINDOW.PAYMENT_NETWORK:
                        o = {
                            title: u.get("B15030"),
                            description: u.get("B15045"),
                            buttons: [{
                                title: a.ok,
                                callback: function() {
                                    FF.scene.redirectTop()
                                }
                            }]
                        };
                        break;
                    default:
                        throw new Error("unknown type: " + e)
                }
                this.menuWindowView.showFreeWindow(o)
            },
            showAutoButton: function(e) {
                this.commandView.showAutoButton(e)
            },
            removeEnemyContainers: function() {
                _.each(this.enemyContainers, function(e, t) {
                    e.dispose(), delete this.enemyContainers[t]
                }, this)
            },
            startShakeBackground: function() {
                this.shakeBackgroundNode.play("shake_part", {
                    isPlayChild: !1
                }).process()
            },
            stopShakeBackground: function() {
                this.shakeBackgroundNode.play("reset", {
                    isPlayChild: !1
                }).process()
            },
            startShakeField: function() {
                this.shakeAllNode.play("shake_all", {
                    isPlayChild: !1
                }).process()
            },
            stopShakeField: function() {
                this.shakeAllNode.play("reset", {
                    isPlayChild: !1
                }).process()
            },
            playFlash: function() {
                this.flashNode.setVisible(!0).play("flash").process()
            },
            playForceEffect: function() {
                var e = this.battleLayer.createNode("force_pos_nul"),
                    t = (new r({
                        name: "bg_effect_nul",
                        layer: this.forceLayerName,
                        visualParentTo: e.name,
                        visualParentToOptions: {
                            visualParentLayer: this.battleLayer.layerName
                        }
                    })).play("play").process()
            },
            showSpecialMessage: function(e) {
                if (e === this._specialMessage) return;
                this.specialMessageNode.setText("special_name_txt", e), this.specialMessageNode.setVisible(!0).play("special_name_in").process(), this._specialMessage = e
            },
            hideSpecialMessage: function() {
                if (!this._specialMessage) return;
                this.specialMessageNode.play("special_name_out").process(), this._specialMessage = void 0
            },
            resetSpecialMessage: function() {
                if (!this._specialMessage) return;
                var e = this.battleLayer.createNode("bg_color_win");
                e.play("reset").process(), this.specialMessageNode.play("special_name_out").process(), this._specialMessage = void 0
            },
            resetBgColor: function() {
                var e = this.battleLayer.createNode("bg_color_win");
                e.play("reset").process()
            },
            playFadeOutDeferred: function() {
                var e = this;
                return this.blackOutNode.setVisible(!0).play("black_in_all").processDeferred("action_stop").then(function() {
                    e.menuWindowView.setInvisible()
                })
            },
            updateBackgroundIdle: function() {
                if (this.isAnimating) return;
                this.backgroundView.playBackgroundIdle(l.DataConstructor.isChangedBackground())
            },
            playWipeDeferred: function() {
                var e = new r({
                    name: "wipe_nul",
                    layer: "layer_wipe_test"
                });
                return e.setStream({
                    exec: "setZOrder",
                    node: "AnimationBuilderRoot",
                    z: 1
                }), e.play("fade_in_black").processDeferred("action_stop").then(function() {
                    return e.play("fade_in_bg").processDeferred("action_stop")
                }).then(function() {
                    return e.play("play").processDeferred("action_stop")
                })
            },
            setUpdateTimeSpeed: function(e) {
                this.battleLayer.setUpdateTimeSpeed(e).process()
            },
            flush: function(e) {
                var t = [];
                _.each(e, function(e) {
                    t = t.concat(e.stream), e.stream = []
                }), t.length && kickmotor.animation.processAnimation(t)
            },
            startVictory: function() {
                this.isAnimating = !0, this.playBuddiesVictoryMotion(), this.playWinBgm()
            },
            playWinBgm: function() {
                FF.SoundMgr.playMusic(l.DataConstructor.getWinBgm())
            },
            startLose: function() {
                var e = l.TextMaster.getInstance().get("B10030");
                this.showMessage({
                    message: e
                }), this.playRequiem()
            },
            playRequiem: function() {
                FF.SoundMgr.playMusic(l.Conf.BGM_NAME.REQUIEM)
            },
            startPause: function() {
                FF.logger.debug("");
                if (this.menuWindowView.isOpeningWindow()) return;
                this._isTouchedPause = !0
            },
            startOpeningWindow: function() {
                this.menuWindowView.setOpeningWindow(!0)
            },
            startContinueWizard: function(e, t, n, r) {
                this.menuWindowView.showGameOverWindow(e, t, n, r)
            },
            startFreeContinueWizard: function(e, t, n) {
                this.menuWindowView.showGameOverWindowFreeContinue(e, t, n)
            },
            startMithrilOnlyContinueWizard: function(e, t, n) {
                this.menuWindowView.showGameOverWindowMithrilContinueOnly(e, t, n)
            },
            stopContinueWizardDeferred: function() {
                return this.closeMenuWindowDeferred()
            },
            notifyCheckingNetwork: function(e) {
                this.showSystemWindow(l.Conf.SYSTEM_WINDOW.NETWORK, e)
            },
            notifyMaintenance: function(e, t) {
                this.showSystemWindow(l.Conf.SYSTEM_WINDOW.MAINTENANCE, e, null, t)
            },
            setTouchVisible: function(e) {
                _.each(this.buddyViews, function(t) {
                    t.setTouchVisible(e)
                }, this), _.each(this.enemyContainers, function(t) {
                    _.each(t.enemyViews, function(t) {
                        t.setTouchVisible(e)
                    }, this)
                }, this), this.commandView.setTouchVisible(e)
            },
            setRootNodesVisible: function(e) {
                _.each(this.rootNodes, function(t) {
                    t.setVisible(e).process()
                }, this)
            },
            setAbscreenTouch: function(e) {
                this._cbTouchAbscreen = e
            },
            setupTutorialView: function(e) {
                this.tutorialBattleView = new l.view.TutorialBattleView({
                    battleViewController: this
                }), this.tutorialBattleView.setup(e), this.listenTo(this, "BattleViewController::specialCommand::touch", this._onTouchSpecialCommnadTutorial), this.listenTo(this, "BattleViewController::commandSet::touch", this._onTouchCommandSetTutorial)
            },
            _onTouchSpecialCommnadTutorial: function() {
                _.isFunction(this._cbTouchSpecialCommnadTutorial) && this._cbTouchSpecialCommnadTutorial()
            },
            setCbTouchSpecialCommnadTutorial: function(e) {
                this._cbTouchSpecialCommnadTutorial = e
            },
            _onTouchCommandSetTutorial: function(e) {
                _.isFunction(this._cbTouchCommandSetTutorial) && this._cbTouchCommandSetTutorial(e)
            },
            setCbTouchCommandSetTutorial: function(e) {
                this._cbTouchCommandSetTutorial = e
            },
            _onBackKey: function() {
                if (FF.env.isUsingWWBackKeyHandler())
                    if (_.isFunction(this._cbTouchAbscreen)) FF.ns.battle.BattleViewController && FF.ns.battle.BattleViewController.getInstance().trigger("BattleViewController::ABScreen::ActionTouchEnded");
                    else {
                        if (l.DataConstructor.isAllEnded() || l.DataConstructor.isJustEnded()) return;
                        var e = FF.ns.battle.BattleViewController.getInstance();
                        e.menuWindowView && e.menuWindowView.isOpeningWindow() ? e.menuWindowView.endPause() : e.startPause()
                    }
            },
            dispose: function() {
                this.commandView.dispose();
                var e = [];
                e.push(this.battleLayer.layerName), e.push(this.backgroundView.layerName), e.push(this.assetsManager.getAssetInfo(this.buddyCommonAssetId).layerName), e.push(this.forceLayerName), e.push(this.menuWindowView.layerName), e = e.concat(this.backgroundView.bgEffLayerNames), this.assetsManager.destroyLayersWithoutTargetLayers(e), this.assetsManager.dispose()
            }
        },
        h = o.extend(c),
        p = void 0;
    return FF.ns.battle.BattleViewController = {
        getInstance: function() {
            return p || (FF.env.isNative() || (_.each(c, function(e, t) {
                c[t] = function() {}
            }), c.createAnimation = function(e) {
                return _.extend({
                    addCallbackOnce: function(e, t) {
                        return this.once(e, t), this
                    },
                    play: function() {
                        return this.trigger("end"), this
                    }
                }, s)
            }, c.showSystemWindow = function(e, t, n, r) {
                t()
            }, h = o.extend(c)), p = new h), p
        }
    }, h
}), define("scenes/battle/SupporterViewController", ["underscore", "jquery", "backbone", "sprintf", "lib/ClassBase", "lib/ab/ABNode"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    return FF.ns.battle.SupporterViewController = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.assetsManager = this.battleViewController.assetsManager, this.battleLayer = this.battleViewController.battleLayer, this.supporterButtonEnabled = !1, this._setupNodes()
        },
        _setupNodes: function() {
            this._setupBgNode(), this._setSupporterEffNodes(), this._setupButton()
        },
        _setupBgNode: function() {
            if (!this.socialBgNode) {
                var e = "bg_social",
                    t = this.assetsManager.getAssetInfo(e);
                this.socialBgNode = new s({
                    name: "bg_social_nul",
                    layer: t.layerName,
                    visualParentTo: "bg_social_pos_nul",
                    visualParentToOptions: {
                        visualParentLayer: this.battleLayer.layerName
                    }
                })
            }
            this.socialBgNode.process()
        },
        _setSupporterEffNodes: function() {
            if (!this.supporterFrontEffNode) {
                var e = "player_friend_front_eff",
                    t = this.assetsManager.getAssetInfo(e);
                this.supporterFrontEffNode = new s({
                    name: "player_friend_front_eff_nul",
                    layer: t.layerName
                })
            }
        },
        _setupButton: function() {
            var e = this;
            this.supporterButtonEnableNode || (this.supporterButtonEnableNode = this.battleLayer.createNode("friend_special_color_nul"), this.supporterButtonNode = this.supporterButtonEnableNode.createChildNode("friend_special_nul"), this.supporterButtonNode.setVisible(!1).play("command_change_out").process())
        },
        setButtonTouch: function(e) {
            var t = this;
            this.supporterButtonTouchNode || (this.supporterButtonTouchNode = this.supporterButtonNode.createChildNode("friend_visible_touch"), this.supporterButtonTouchNode.addCallback("action_touch_began", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_start").process()
            }), this.supporterButtonTouchNode.addCallback("action_touch_ended", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonEnabled = !1, t.supporterButtonNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    e()
                })
            }), this.supporterButtonTouchNode.addCallback("action_touch_enterd", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_start").process()
            }), this.supporterButtonTouchNode.addCallback("action_touch_exited", function() {
                if (!o.DataConstructor.canOperateBattle()) return;
                if (!t.supporterButtonEnabled) return;
                t.supporterButtonNode.play("command_tap_cancel").process()
            }), this.supporterButtonTouchNode.process())
        },
        supporterButtonInDeferred: function(e) {
            if (!e) return;
            if (this._isShownSupporterButton && this._isEnabled === e.enabled) return;
            return this._setSupporterButtonInfo(e), this._isShownSupporterButton = !0, this._isEnabled = e.enabled, this.supporterButtonNode.play("command_change_in").setVisible(!0).processDeferred("action_stop")
        },
        supporterButtonOutDeferred: function() {
            if (!this._isShownSupporterButton) return;
            return this._isShownSupporterButton = !1, this.supporterButtonNode.play("command_change_out").setVisible(!1).processDeferred("action_stop")
        },
        setSupporterButtonEnabled: function(e) {
            e ? (this.supporterButtonEnabled = !0, this.supporterButtonEnableNode.play("enabled", {
                isPlayChild: !1
            }).process()) : (this.supporterButtonEnabled = !1, this.supporterButtonEnableNode.play("disabled", {
                isPlayChild: !1
            }).process())
        },
        _setSupporterButtonInfo: function(e) {
            var t = e.enabled,
                n = e.restCount;
            if (this.buttonAssetId !== e.assetId) {
                var r = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
                this.supporterButtonNode.loadBundle(r.bundle).setImage("friend_critical_btn_img", r.assetPath), this.buttonAssetId = e.assetId
            }
            this.buttonNum !== n && (this.supporterButtonNode.setText("friend_num_txt", n), this.buttonNum = n);
            if (this.charaAssetId !== e.charaAssetId) {
                var i = this.battleViewController.assetsManager.getAssetInfo(e.charaAssetId);
                this.supporterButtonNode.loadBundle(i.bundle).setSpriteAnimeByNode("friend_sprite", i.assetPath).setSpriteActionByNode("friend_sprite", "idle_cut"), this.charaAssetId = e.charaAssetId
            }
            n <= 0 || !t ? this.setSupporterButtonEnabled(!1) : this.setSupporterButtonEnabled(!0), this.supporterButtonNode.process()
        },
        showSupporterEffectDeferred: function(e) {
            var t = this,
                n = e.posId;
            return this.socialBgNode.addCallbackOnce("action_next", function() {
                var r = t.battleViewController.buddyViews[n];
                r.setVisibleForReplacingSupporter(!1), r.replaceBuddyInfo(e.supporterInfo), r.flush()
            }), this._changeSupporterPosId(n), this.supporterFrontEffNode.play("change_eff_bg").process(), this.socialBgNode.setVisible(!0).play("change_eff_bg").processDeferred("action_stop")
        },
        hideSupporterEffectDeferred: function(e) {
            var t = this,
                n = e.posId;
            return this.socialBgNode.addCallbackOnce("action_next", function() {
                var e = t.battleViewController.buddyViews[n];
                e.setVisibleForReplacingSupporter(!0), e.replaceBuddyInfo(e.buddyInfo), e.flush()
            }), this.supporterFrontEffNode.play("restore_eff_bg").process(), this.socialBgNode.play("restore_eff_bg").processDeferred("action_next")
        },
        _changeSupporterPosId: function(e) {
            this.supporterFrontEffNode.setVisualParent(this.battleLayer.layerName, r("player_friend_front_eff_%s", e)).process()
        }
    }), FF.ns.battle.SupporterViewController
}), define("scenes/battle/BuddyPartyMgr", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = e.extend({
            initialize: function(t) {
                e.prototype.initialize.apply(this, arguments), this.activeTarget = new n.ActiveTarget, this.set("gil", 0), this.set("treasure", 0), this.set("orb", 0), this.set("eventItem", 0), this.set("lastReceptorInfo", {})
            },
            giveGil: function(e) {
                if (!e || e < 0) e = 0;
                this.set("gil", this.get("gil") + e)
            },
            giveTreasure: function(e) {
                if (!e || e < 0) e = 0;
                this.set("treasure", this.get("treasure") + e)
            },
            giveOrb: function(e) {
                if (!e || e < 0) e = 0;
                this.set("orb", this.get("orb") + e)
            },
            giveEventItem: function(e) {
                if (!e || e < 0) e = 0;
                this.set("eventItem", this.get("eventItem") + e)
            },
            setParent: function(e) {
                this.parent = e
            },
            update: function() {
                this.execReservedAbilitys()
            },
            reserveAbility: function(e, t) {
                var n = e.getUid(),
                    r = e.getReceptorById(t);
                return !r || !r.canRecept(e) ? !1 : this.hasReservedAbility(n) ? !1 : (this._reservedAbilitys[n] = r.makeCommandFunc(e), this.setLastReceptorId(e, t), !0)
            },
            reserveSupporterSoulStrike: function() {
                var e = n.ActorMgr.getAbilityPanelSelector(),
                    t = e.getUid(),
                    r = n.ActorMgr.getSupporter().getSupporterSoulStrike();
                return !r || !r.canRecept(e) ? !1 : this.hasReservedAbility(t) ? !1 : (this._reservedAbilitys[t] = r.makeCommandFunc(e), !0)
            },
            canReceptSupporterSoulStrike: function() {
                var e = n.ActorMgr.getAbilityPanelSelector(),
                    t = n.ActorMgr.getSupporter();
                return !e || !t ? !1 : t.getSupporterSoulStrike().canRecept(e)
            },
            isDuringSupporterSoulStrike: function() {
                return _.any(n.ActorMgr.getAliveBuddies(), function(e) {
                    return e.isStateInCast() || e.isStateInAction() ? !!e.getAbility().get("isSupporterSoulStrike") : !1
                }, this)
            },
            reserveAbilityForPositiveIncontrollable: function(e) {
                this.reserveAbility(e, n.Conf.RECEPTOR.POSITIVE_INCONTROLLABLE)
            },
            reserveAbilityForAutoBattle: function(e) {
                var t = 1,
                    n = e.getAbilityPanelReceptorByPanelNo(t);
                this.reserveAbility(e, n.get("receptorId"))
            },
            setLastReceptorId: function(e, t) {
                this.get("lastReceptorInfo")[e.get("no")] = {
                    id: e.getId(),
                    receptorId: t
                }
            },
            getLastReceptorId: function(e) {
                var t = this.get("lastReceptorInfo")[e.get("no")];
                if (t && t.id === e.getId()) return t.receptorId;
                return
            },
            hasReservedAbility: function(e) {
                return this._reservedAbilitys[e] ? !0 : !1
            },
            execReservedAbilitys: function() {
                _.each(this._reservedAbilitys, function(e, t) {
                    _.isFunction(e) && n.ActorMgr.getByUid(t).isReadyToSelectAbility() && e()
                }), this._reservedAbilitys = {}
            },
            makeResultData: function() {
                var e = {};
                _.each(n.ActorMgr.getAllBuddies(), function(t) {
                    var r = n.BattleInfo.getInstance().getActorParam(t.getUid()),
                        i = {
                            hp: _.min([t.get("hp"), r.maxHp]),
                            sa: t.statusAilments.getContinuanceIds()
                        };
                    _.each(n.Config.getInstance().get("DefaultAbilityPanels"), function(e, n) {
                        var r = t.getReceptorById(e);
                        if (!r || !r.isCommandPanel()) return;
                        i["panel" + n] = r.isInfinity() ? null : _.min([r.get("remainNum"), r.get("defaultMaxNum")])
                    }, this), i.ss_gauge = t.getSoulStrike().get("point"), e[t.get("no")] = i
                }, this);
                var t = {
                        supporter_ss_gauge: 0
                    },
                    r = n.ActorMgr.getSupporter();
                if (r) {
                    var i = r.getSupporterSoulStrike().get("restCount");
                    t.supporter_ss_gauge = i
                }
                return {
                    buddy: e,
                    supporter: t
                }
            },
            toPlainObject: function() {
                return {
                    attributes: this._attributes
                }
            },
            applyPlainObject: function(e) {
                if (!e) return;
                _.extend(this._attributes, e.attributes)
            },
            getMaxPartyNum: function() {
                return n.Config.getInstance().get("MaxPartyNum")
            }
        }),
        i = void 0;
    FF.ns.battle.BuddyPartyMgr = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/Commander", ["util", "lib/ClassBase"], function(e, t) {
    var n = FF.ns.battle,
        r = t.extend({
            createAbility: function(e, t, r) {
                var i = n.AbilityFactory.create(e, t, r);
                return r && r.activeTarget && i.set("activeTarget", r.activeTarget), i
            },
            register: function(t, r, i, s) {
                s = e.option({
                    interruptBoss: !1,
                    interruptBeforeCounter: !1,
                    interruptCounter: !1,
                    interruptRadiantShield: !1,
                    interruptStatusAilments: !1,
                    interruptAbility: !1,
                    delayBattleTime: 0
                }, s), FF.logger.debug("CMD_REG:" + t, i, s);
                var o = this.createAbility(t, r, _.extend({}, i, {
                    registerOptions: s
                }));
                if (s.interruptBoss) return n.AbilityMgr.getInstance().interruptBoss(o), o;
                if (s.interruptBeforeCounter) return n.AbilityMgr.getInstance().interruptBeforeCounter(o), o;
                if (s.interruptCounter) return n.AbilityMgr.getInstance().interruptCounter(o), o;
                if (s.interruptRadiantShield) return n.AbilityMgr.getInstance().interruptRadiantShield(o), o;
                if (s.interruptStatusAilments) return n.AbilityMgr.getInstance().interruptStatusAilments(o), o;
                if (!r.isReadyToSelectAbility()) throw new Error(["executer is not ready ability", r.getId(), r.getUid(), r.get("state")]);
                return r.setAbility(o, s.delayBattleTime), o
            }
        }),
        i = void 0;
    FF.ns.battle.Commander = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/Config", ["util", "lib/ClassBase", "./Conf"], function(e, t, n) {
    var r = {};
    r.HpGaugeVisibleEventIds = [506, 26, 27, 902, 28], r.DamageCalculator = {}, r.DamageCalculator.DAMAGE = {
        minDamage: 5,
        basePower: 1.3,
        magicBasePower: 1.15,
        ratioDefence: 1.2,
        ratioMagicDefence: 1.2,
        maxBasic: 2e3,
        maxBasicForPhysicalAndReceiverEnemy: 4e3,
        maxBasicForMagicAndReceiverEnemy: 3e3,
        maxBasicForNinja: 30,
        defBufAtkConvertPower: .18,
        maxDefBufRatio: 1.8,
        ratioPower: .5,
        ratioPowerDefence: .7,
        ratioCoefficient: 1,
        summonRatioPower: .05,
        summonRatioCoefficient: 1,
        maxRatio: 1e3,
        defenseCoefficient: {
            "default": 10,
            defense: 5
        },
        criticalCoefficient: 15,
        randCoeffiecient: 3
    }, r.DamageCalculator.DAMAGE.damageThresholdTypeMap = {}, r.DamageCalculator.DAMAGE.damageThresholdTypeMap[n.DAMAGE_THRESHOLD_TYPE.DEFAULT] = 9999, r.DamageCalculator.DAMAGE.damageThresholdTypeMap[n.DAMAGE_THRESHOLD_TYPE.PRIMARY] = 99999, r.DamageCalculator.ROW = {}, r.DamageCalculator.ROW.DEFAULT = 10, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT] = {}, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT][n.ROW_TYPE.FRONT] = 10, r.DamageCalculator.ROW[n.ROW_TYPE.FRONT][n.ROW_TYPE.BACK] = 5, r.DamageCalculator.ROW[n.ROW_TYPE.BACK] = {}, r.DamageCalculator.ROW[n.ROW_TYPE.BACK][n.ROW_TYPE.FRONT] = 5, r.DamageCalculator.ROW[n.ROW_TYPE.BACK][n.ROW_TYPE.BACK] = 3, r.DamageCalculator.HEAL = {
        a: 5,
        b: 100,
        c: 3
    }, r.DamageCalculator.ACC = {
        a: 8,
        b: 6,
        c: 35,
        d: 90,
        e: 100,
        f: 20,
        blinded: 25
    }, r.DamageCalculator.DROP_ITEM = {}, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.POTION] = 10, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.HI_POTION] = 25, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.X_POTION] = 50, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.ETHER] = 20, r.DamageCalculator.DROP_ITEM[n.DROP_ITEM_TYPE.TURBO_ETHER] = 33, r.DamageCalculator.STATUS_AILMENTS = {
        a: 3,
        b: 3
    }, r.DamageCalculator.FORCE_HITTABLE_STATUS_AILMENTS_FACTOR = 999, r.DamageCalculator.ELEMENT_ADVANTAGE = {
        0: [n.ADVANTAGE.NONE, 10],
        1: [n.ADVANTAGE.WEAK, 20],
        2: [n.ADVANTAGE.HALF, 9],
        3: [n.ADVANTAGE.HALF, 8],
        4: [n.ADVANTAGE.HALF, 7],
        5: [n.ADVANTAGE.HALF, 6],
        6: [n.ADVANTAGE.HALF, 5],
        7: [n.ADVANTAGE.HALF, 4],
        8: [n.ADVANTAGE.HALF, 3],
        9: [n.ADVANTAGE.HALF, 2],
        10: [n.ADVANTAGE.HALF, 1],
        11: [n.ADVANTAGE.VOID, 0],
        12: [n.ADVANTAGE.ABSORPTION, -1],
        13: [n.ADVANTAGE.ABSORPTION, -2],
        14: [n.ADVANTAGE.ABSORPTION, -3],
        15: [n.ADVANTAGE.ABSORPTION, -4],
        16: [n.ADVANTAGE.ABSORPTION, -5],
        17: [n.ADVANTAGE.ABSORPTION, -6],
        18: [n.ADVANTAGE.ABSORPTION, -7],
        19: [n.ADVANTAGE.ABSORPTION, -8],
        20: [n.ADVANTAGE.ABSORPTION, -9],
        21: [n.ADVANTAGE.ABSORPTION, -10],
        22: [n.ADVANTAGE.WEAK, 19],
        23: [n.ADVANTAGE.WEAK, 18],
        24: [n.ADVANTAGE.WEAK, 17],
        25: [n.ADVANTAGE.WEAK, 16],
        26: [n.ADVANTAGE.WEAK, 15],
        27: [n.ADVANTAGE.WEAK, 14],
        28: [n.ADVANTAGE.WEAK, 13],
        29: [n.ADVANTAGE.WEAK, 12],
        30: [n.ADVANTAGE.WEAK, 11]
    }, r.DamageCalculator.ELEMENT_ADVANTAGE_ORDER_LIST = _.sortBy(_.map(r.DamageCalculator.ELEMENT_ADVANTAGE, function(e, t) {
        return {
            id: t,
            advantage: e[0],
            factor: e[1]
        }
    }), function(e) {
        return e.factor
    }), r.DamageCalculator.ELEMENT_ADVANTAGE_DEFAULT = [n.ADVANTAGE.NONE, 10], r.DamageCalculator.SITUATIONAL_RECALCULATE_DAMAGE = {}, r.DamageCalculator.SITUATIONAL_RECALCULATE_DAMAGE.SCALE_LIMIT = {
        EXECUTER_REMAINING_HP_RATE: 1.4
    }, r.DamageCalculateParamAdjusts = {}, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.DEF_CONVERT_ATK] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.SPD_CONVERT_ATK] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.VALIANT_ATTACK] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.CURRENT_HP_CONVERT_ATK] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_SA] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA_BUNDLE] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_SA_BUNDLE] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.ALL_ALIVE_BUDDIES] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.BUDDIES_IN_FLIGHT] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA_NUM] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_ATK_TYPE] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.STATUS_DOWN_OF_ATK_DEF_MATK_MDEF_MND] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.ENEMY_NUM] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.SS_POINT] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_EQUIPMENT_CATEGORY] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.BUDDIES_SEX] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.ATK] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.DamageCalculateParamAdjusts[n.DAMAGE_CALCULATE_PARAM_ADJUST.DAMAGE_RECEIVE_COUNT] = n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR, r.ATB = {
        a: 4500,
        b: .15
    }, r.SoulStrike = {
        maxSsPoint: 1500,
        damagedSsPoint: 50,
        c: 150
    }, r.BuiltinAbilities = [{
        abilityId: n.ABILITY_ID_OF.DEFORM,
        actionId: n.ACTION_ID_OF.DEFORM,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DEFORM_MULTI,
        actionId: n.ACTION_ID_OF.DEFORM_MULTI,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.POISON,
        actionId: n.ACTION_ID_OF.POISON,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.REGEN,
        actionId: n.ACTION_ID_OF.REGEN,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.HP_STOCK,
        actionId: n.ACTION_ID_OF.HP_STOCK,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.RADIANT_SHIELD,
        actionId: n.ACTION_ID_OF.RADIANT_SHIELD,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DEFENSE,
        actionId: n.ACTION_ID_OF.DEFENSE,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DO_NOTHING,
        actionId: n.ACTION_ID_OF.DO_NOTHING,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DO_NOTHING_STRICTLY,
        actionId: n.ACTION_ID_OF.DO_NOTHING_STRICTLY,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.DO_NOTHING_STRICTLY_STEP,
        actionId: n.ACTION_ID_OF.DO_NOTHING_STRICTLY,
        options: {
            castTime: 0,
            skipStepCnt: !1
        }
    }, {
        abilityId: n.ABILITY_ID_OF.HEAL_DEATH,
        actionId: n.ACTION_ID_OF.HEAL_DEATH,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_INFLICT_SA,
        actionId: n.ACTION_ID_OF.BUILTIN_INFLICT_SA,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.INCREASE_MP,
        actionId: n.ACTION_ID_OF.INCREASE_MP,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.RERAISE_RISE,
        actionId: n.ACTION_ID_OF.RERAISE_RISE,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.HEAL_HP_BY_DAMAGE_SUM,
        actionId: n.ACTION_ID_OF.HEAL_HP_BY_DAMAGE_SUM,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_HEAL_HP,
        actionId: n.ACTION_ID_OF.BUILTIN_HEAL_HP,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_ENEMY_MULTIPLE_ABILITY,
        actionId: n.ACTION_ID_OF.BUILTIN_ENEMY_MULTIPLE_ABILITY,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_FRACTIONAL_HEAL_HP,
        actionId: n.ACTION_ID_OF.BUILTIN_FRACTIONAL_HEAL_HP,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.BUILTIN_HEAL_SA,
        actionId: n.ACTION_ID_OF.BUILTIN_HEAL_SA,
        options: {
            castTime: 0
        }
    }, {
        abilityId: n.ABILITY_ID_OF.GUTS_RISE,
        actionId: n.ACTION_ID_OF.GUTS_RISE,
        options: {
            castTime: 0
        }
    }], r.DefaultAbilityPanels = {
        1: n.RECEPTOR.PANEL_ATTACK,
        2: n.RECEPTOR.PANEL_FLEXIBLE_1,
        3: n.RECEPTOR.PANEL_FLEXIBLE_2,
        4: n.RECEPTOR.PANEL_DEFENSE
    }, r.SoulStrikePanels = {
        1: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_1,
        2: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_2,
        3: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_3,
        4: n.RECEPTOR.SOUL_STRIKE_FLEXIBLE_4
    }, r.PanelNoToPosId = {
        1: "01",
        2: "03",
        3: "04",
        4: "02"
    }, r.PosIdToPanelNo = _.invert(r.PanelNoToPosId), r.FlexibleAbilities = [n.RECEPTOR.PANEL_FLEXIBLE_1, n.RECEPTOR.PANEL_FLEXIBLE_2], r.SparePanelReceptors = [n.RECEPTOR.SPARE_PANEL_TRANCE_CLOUD_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CLOUD_2, n.RECEPTOR.SPARE_PANEL_TRANCE_YUNA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_YUNA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SQUALL_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SQUALL_2, n.RECEPTOR.SPARE_PANEL_TRANCE_PALADIN_CECIL_1, n.RECEPTOR.SPARE_PANEL_TRANCE_PALADIN_CECIL_2, n.RECEPTOR.SPARE_PANEL_TRANCE_BUTZ_1, n.RECEPTOR.SPARE_PANEL_TRANCE_BUTZ_2, n.RECEPTOR.SPARE_PANEL_TRANCE_DESHI_1, n.RECEPTOR.SPARE_PANEL_TRANCE_DESHI_2, n.RECEPTOR.SPARE_PANEL_TRANCE_TINA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_TINA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_TIDUS_1, n.RECEPTOR.SPARE_PANEL_TRANCE_TIDUS_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LIGHTNING_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LIGHTNING_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SEPHIROTH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SEPHIROTH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RINOA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RINOA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_FARIS_1, n.RECEPTOR.SPARE_PANEL_TRANCE_FARIS_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ZIDANE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ZIDANE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GARNET_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GARNET_2, n.RECEPTOR.SPARE_PANEL_TRANCE_BEATRIX_1, n.RECEPTOR.SPARE_PANEL_TRANCE_BEATRIX_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GARLAND_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GARLAND_2, n.RECEPTOR.SPARE_PANEL_TRANCE_VAAN_1, n.RECEPTOR.SPARE_PANEL_TRANCE_VAAN_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RAMZA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RAMZA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_TIFA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_TIFA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_JECHT_1, n.RECEPTOR.SPARE_PANEL_TRANCE_JECHT_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LOCK_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LOCK_2, n.RECEPTOR.SPARE_PANEL_TRANCE_BALFLEAR_1, n.RECEPTOR.SPARE_PANEL_TRANCE_BALFLEAR_2, n.RECEPTOR.SPARE_PANEL_TRANCE_FANG_1, n.RECEPTOR.SPARE_PANEL_TRANCE_FANG_2, n.RECEPTOR.SPARE_PANEL_TRANCE_HOPE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_HOPE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GILGAMESH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GILGAMESH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_CELES_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CELES_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RIKKU_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RIKKU_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SELPHIE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SELPHIE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_AERITH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_AERITH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_EIKO_1, n.RECEPTOR.SPARE_PANEL_TRANCE_EIKO_2, n.RECEPTOR.SPARE_PANEL_TRANCE_VIVI_1, n.RECEPTOR.SPARE_PANEL_TRANCE_VIVI_2, n.RECEPTOR.SPARE_PANEL_TRANCE_FRIONIEL_1, n.RECEPTOR.SPARE_PANEL_TRANCE_FRIONIEL_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LEONHART_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LEONHART_2, n.RECEPTOR.SPARE_PANEL_TRANCE_MARIA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_MARIA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_MINWU_1, n.RECEPTOR.SPARE_PANEL_TRANCE_MINWU_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ASHE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ASHE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_PANELO_1, n.RECEPTOR.SPARE_PANEL_TRANCE_PANELO_2, n.RECEPTOR.SPARE_PANEL_TRANCE_AURON_1, n.RECEPTOR.SPARE_PANEL_TRANCE_AURON_2, n.RECEPTOR.SPARE_PANEL_TRANCE_WAKKA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_WAKKA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_VANILLE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_VANILLE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_NOEL_1, n.RECEPTOR.SPARE_PANEL_TRANCE_NOEL_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SERAH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SERAH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LUNETH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LUNETH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ONION_KNIGHT_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ONION_KNIGHT_2, n.RECEPTOR.SPARE_PANEL_TRANCE_INGUS_1, n.RECEPTOR.SPARE_PANEL_TRANCE_INGUS_2, n.RECEPTOR.SPARE_PANEL_TRANCE_REFIA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_REFIA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_CAIN_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CAIN_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RYDIA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RYDIA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GILBART_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GILBART_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SHANTOTTO_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SHANTOTTO_2, n.RECEPTOR.SPARE_PANEL_TRANCE_CURILLA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CURILLA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_AGRIAS_1, n.RECEPTOR.SPARE_PANEL_TRANCE_AGRIAS_2, n.RECEPTOR.SPARE_PANEL_TRANCE_EDGE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_EDGE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_WARRIORS_OF_LIGHT_1, n.RECEPTOR.SPARE_PANEL_TRANCE_WARRIORS_OF_LIGHT_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ZELL_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ZELL_2, n.RECEPTOR.SPARE_PANEL_TRANCE_QUISTIS_1, n.RECEPTOR.SPARE_PANEL_TRANCE_QUISTIS_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RELM_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RELM_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SHADOW_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SHADOW_2, n.RECEPTOR.SPARE_PANEL_TRANCE_MASH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_MASH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ZACK_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ZACK_2, n.RECEPTOR.SPARE_PANEL_TRANCE_YUFFIE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_YUFFIE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_RENO_1, n.RECEPTOR.SPARE_PANEL_TRANCE_RENO_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GALUF_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GALUF_2, n.RECEPTOR.SPARE_PANEL_TRANCE_KRILE_1, n.RECEPTOR.SPARE_PANEL_TRANCE_KRILE_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LENNA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LENNA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SNOW_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SNOW_2, n.RECEPTOR.SPARE_PANEL_TRANCE_CID_RAINES_1, n.RECEPTOR.SPARE_PANEL_TRANCE_CID_RAINES_2, n.RECEPTOR.SPARE_PANEL_TRANCE_YSHTOLA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_YSHTOLA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_MINFILIA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_MINFILIA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ALPHINAUD_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ALPHINAUD_2, n.RECEPTOR.SPARE_PANEL_TRANCE_YDA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_YDA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_PAPALYMO_1, n.RECEPTOR.SPARE_PANEL_TRANCE_PAPALYMO_2, n.RECEPTOR.SPARE_PANEL_TRANCE_THANCRED_1, n.RECEPTOR.SPARE_PANEL_TRANCE_THANCRED_2, n.RECEPTOR.SPARE_PANEL_TRANCE_KUJA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_KUJA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_FREYA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_FREYA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_STEINER_1, n.RECEPTOR.SPARE_PANEL_TRANCE_STEINER_2, n.RECEPTOR.SPARE_PANEL_TRANCE_YUNA_2_1, n.RECEPTOR.SPARE_PANEL_TRANCE_YUNA_2_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SEYMOUR_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SEYMOUR_2, n.RECEPTOR.SPARE_PANEL_TRANCE_LULU_1, n.RECEPTOR.SPARE_PANEL_TRANCE_LULU_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SARAH_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SARAH_2, n.RECEPTOR.SPARE_PANEL_TRANCE_SUPER_MONK_1, n.RECEPTOR.SPARE_PANEL_TRANCE_SUPER_MONK_2, n.RECEPTOR.SPARE_PANEL_TRANCE_MATOYA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_MATOYA_2, n.RECEPTOR.SPARE_PANEL_TRANCE_ORLANDEAU_1, n.RECEPTOR.SPARE_PANEL_TRANCE_ORLANDEAU_2, n.RECEPTOR.SPARE_PANEL_TRANCE_GAFFGARION_1, n.RECEPTOR.SPARE_PANEL_TRANCE_GAFFGARION_2, n.RECEPTOR.SPARE_PANEL_TRANCE_DELITA_1, n.RECEPTOR.SPARE_PANEL_TRANCE_DELITA_2], r.SparePanelReceptors = r.SparePanelReceptors.concat(_.filter(n.RECEPTOR, function(e, t) {
        return t.match(/^SPARE_PANEL_TRANCE_2\d{4}$/)
    })), r.BuiltinPanels = [{
        receptorId: n.RECEPTOR.PANEL_DEFENSE,
        panelType: n.PANEL_TYPE.DEFENSE,
        abilityId: n.ABILITY_ID_OF.DEFENSE
    }], r.BuddyTagPriority = {
        dead: 1,
        stone: 2,
        chant_wait: 3,
        ready: 3,
        fatal: 4,
        idle: 5
    }, r.StatusAilments = {}, r.StatusAilments.GRAPHIC_TAG = {}, r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.DEATH] = "dead", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.RERAISE_DEATH] = "dead", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.CHARGE] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.COUNTER_AIMING] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.DEFENSE] = "ready", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.PARALYSIS] = "fatal", r.StatusAilments.GRAPHIC_TAG[n.STATUS_AILMENTS_TYPE.STOCK_BREAK] = "fatal", r.StatusAilments.Z_ORDER = {
        NONRESIDENT_AURA_MIN: 1e3,
        NONRESIDENT_AURA_MAX: 1999
    }, r.ExerciseTypeToCastTag = {}, r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.PHYSICAL] = "ready", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.BLACK_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.WHITE_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.BLUE_MAGIC] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.SUMMON] = "chant_wait", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.INBORN] = "ready", r.ExerciseTypeToCastTag[n.EXERCISE_TYPE.NINJA] = "ready";
    var i = [{
        bonusId: n.CONTINUE_BONUS.ATTACK,
        giveFuncName: "giveBonusAttack",
        boostFactor: 10,
        cardImageId: "continue_bonus_1",
        descTextId: "B10110",
        colorTag: "color_1"
    }, {
        bonusId: n.CONTINUE_BONUS.DEFENSE,
        giveFuncName: "giveBonusDefense",
        boostFactor: 10,
        cardImageId: "continue_bonus_2",
        descTextId: "B10120",
        colorTag: "color_2"
    }, {
        bonusId: n.CONTINUE_BONUS.ABILITY,
        giveFuncName: "giveBonusAbility",
        boostFactor: 2,
        cardImageId: "continue_bonus_3",
        descTextId: "B10130",
        colorTag: "color_3"
    }, {
        bonusId: n.CONTINUE_BONUS.HP,
        giveFuncName: "giveBonusHp",
        boostFactor: 10,
        cardImageId: "continue_bonus_4",
        descTextId: "B10140",
        colorTag: "color_4"
    }];
    r.ContinueBonusIds = _.pluck(i, "bonusId"), r.ContinueBonus = _.indexBy(i, "bonusId"), r.MagicExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.BLUE_MAGIC, n.EXERCISE_TYPE.SUMMON], r.BasicMagicExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC], r.ExerciseTypesWithoutPhysical = _.difference(_.values(n.EXERCISE_TYPE), [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.NINJA, n.EXERCISE_TYPE.NO_CLASSIFIED]), r.ReflectionExerciseTypes = [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC], r.CounterAimingEffectedExerciseTypes = [n.EXERCISE_TYPE.PHYSICAL], r.MightyGuardEffectedCalcTypes = [n.CALC_TYPE.MAGIC, n.CALC_TYPE.FRACTION, n.CALC_TYPE.DAMAGED_HP], r.CounterAimingEffectedCalcTypes = _.without(_.values(n.CALC_TYPE), n.CALC_TYPE.HEAL, n.CALC_TYPE.STATUS_AILMENTS, n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS), r.RadiantShieldEffectedCalcTypes = [n.CALC_TYPE.ATTACK, n.CALC_TYPE.MAGIC, n.CALC_TYPE.FRACTION, n.CALC_TYPE.DAMAGED_HP, n.CALC_TYPE.FIXED_DAMAGE], r.RemovableGreasedLightningCalcTypes = [n.CALC_TYPE.ATTACK, n.CALC_TYPE.MAGIC, n.CALC_TYPE.FRACTION, n.CALC_TYPE.DAMAGED_HP, n.CALC_TYPE.FIXED_DAMAGE, n.CALC_TYPE.STATUS_AILMENTS], r.DamageBarrierEffectedCalcTypes = _.without(_.values(n.CALC_TYPE), n.CALC_TYPE.POISON, n.CALC_TYPE.HP_BARTER), r.Tutorial = {
        heroId: 10000200,
        specialAbilityId: 30131091,
        specialRound: 3,
        specialAbilityPosId: "04"
    }, r.EnemyAblityTag = {
        NegativeIncontrollable: "_DEFAULT_"
    }, r.MateriaBaseDamageFactor = 100, r.MateriaAllowableTypesConfig = {
        1: {
            exerciseTypes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.BLACK_MAGIC],
            calcTypes: [n.CALC_TYPE.ATTACK, n.CALC_TYPE.MAGIC]
        },
        2: {
            exerciseTypes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC],
            calcTypes: [n.CALC_TYPE.MAGIC]
        }
    }, r.MateriaParamConfig = {
        1511: [{
            paramName: "atk",
            rate: 5
        }],
        1512: [{
            paramName: "atk",
            rate: 10
        }],
        1513: [{
            paramName: "atk",
            rate: 15
        }],
        1514: [{
            paramName: "atk",
            rate: 20
        }],
        1515: [{
            paramName: "atk",
            rate: 13
        }],
        1521: [{
            paramName: "def",
            rate: 5
        }],
        1522: [{
            paramName: "def",
            rate: 10
        }],
        1523: [{
            paramName: "def",
            rate: 20
        }],
        1524: [{
            paramName: "def",
            rate: 25
        }],
        1531: [{
            paramName: "matk",
            rate: 5
        }],
        1532: [{
            paramName: "matk",
            rate: 2
        }],
        1533: [{
            paramName: "matk",
            rate: 10
        }],
        1534: [{
            paramName: "matk",
            rate: 15
        }],
        1535: [{
            paramName: "matk",
            rate: 20
        }],
        1536: [{
            paramName: "matk",
            rate: 13
        }],
        1541: [{
            paramName: "mdef",
            rate: 5
        }],
        1542: [{
            paramName: "mdef",
            rate: 20
        }],
        1551: [{
            paramName: "mnd",
            rate: 10
        }],
        1552: [{
            paramName: "mnd",
            rate: 20
        }],
        1553: [{
            paramName: "mnd",
            rate: 25
        }],
        2011: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: -10
        }],
        2021: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "mdef",
            rate: -10
        }],
        2031: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "atk",
            rate: -10
        }],
        2041: [{
            paramName: "def",
            rate: 10
        }, {
            paramName: "atk",
            rate: -10
        }],
        2051: [{
            paramName: "matk",
            rate: 20
        }, {
            paramName: "def",
            rate: -10
        }, {
            paramName: "mdef",
            rate: -10
        }],
        2052: [{
            paramName: "matk",
            rate: 40
        }, {
            paramName: "def",
            rate: -20
        }, {
            paramName: "mdef",
            rate: -20
        }],
        2061: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "def",
            rate: -10
        }],
        2062: [{
            paramName: "matk",
            rate: 15
        }, {
            paramName: "def",
            rate: -10
        }],
        2071: [{
            paramName: "mnd",
            rate: 20
        }, {
            paramName: "matk",
            rate: -20
        }],
        2511: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: 10
        }],
        2512: [{
            paramName: "atk",
            rate: 13
        }, {
            paramName: "def",
            rate: 13
        }],
        2521: [{
            paramName: "matk",
            rate: 10
        }, {
            paramName: "mnd",
            rate: 10
        }],
        2522: [{
            paramName: "matk",
            rate: 13
        }, {
            paramName: "mnd",
            rate: 13
        }],
        2531: [{
            paramName: "def",
            rate: 10
        }, {
            paramName: "mdef",
            rate: 10
        }],
        2532: [{
            paramName: "def",
            rate: 20
        }, {
            paramName: "mdef",
            rate: 20
        }],
        2541: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "matk",
            rate: 10
        }],
        2551: [{
            paramName: "matk",
            rate: 13
        }, {
            paramName: "mdef",
            rate: 13
        }],
        3011: [{
            paramName: "mnd",
            rate: 20
        }, {
            paramName: "atk",
            rate: -10
        }, {
            paramName: "matk",
            rate: -10
        }],
        3021: [{
            paramName: "atk",
            rate: 20
        }, {
            paramName: "def",
            rate: -10
        }, {
            paramName: "mdef",
            rate: -10
        }],
        5511: [{
            paramName: "atk",
            rate: 10
        }, {
            paramName: "def",
            rate: 10
        }, {
            paramName: "matk",
            rate: 10
        }, {
            paramName: "mdef",
            rate: 10
        }, {
            paramName: "mnd",
            rate: 10
        }]
    }, r.DeadTag = {
        1: "dead",
        2: "dead_boss",
        3: "apparent_dead",
        4: "escape"
    }, r.CancelCastStatusAilmentsTypes = [n.STATUS_AILMENTS_TYPE.SILENCE, n.STATUS_AILMENTS_TYPE.MAGIC_SEAL], r.BrkDefConfig = {}, r.BrkDefConfig.PARAM_NAME = {}, r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.ATK] = "atk", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.DEF] = "def", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MATK] = "matk", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MDEF] = "mdef", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.MND] = "mnd", r.BrkDefConfig.PARAM_NAME[n.BRK_DEF_TYPE.SPD] = "spd", r.BrkDefConfig.ADVANTAGE = {
        6: [n.ADVANTAGE.HALF, -50],
        11: [n.ADVANTAGE.VOID, -100]
    };
    var s = {};
    s[n.BOOST_TYPE.STATUS] = {
        atk: {
            upper: {
                threshold: 2.5,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: .3,
                b: 1
            },
            lower: {
                threshold: .35,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.1,
                b: 1
            }
        },
        def: {
            upper: {
                threshold: 4.5,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: 1.05,
                b: 1
            },
            lower: {
                threshold: .3,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.5,
                b: 1
            }
        },
        matk: {
            upper: {
                threshold: 2.5,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: .3,
                b: 1
            },
            lower: {
                threshold: .35,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.1,
                b: 1
            }
        },
        mdef: {
            upper: {
                threshold: 4.5,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: 1.05,
                b: 1
            },
            lower: {
                threshold: .3,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.5,
                b: 1
            }
        },
        mnd: {
            upper: {
                threshold: 2.5,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: .3,
                b: 1
            },
            lower: {
                threshold: .35,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.1,
                b: 1
            }
        },
        atkSaCoef: {
            upper: {
                threshold: 1,
                attenuationCurve: n.ATTENUATION_CURVE.LN,
                a: .3,
                b: 1
            },
            lower: {
                threshold: .35,
                attenuationCurve: n.ATTENUATION_CURVE.LOG,
                a: 1.1,
                b: 1
            }
        }
    }, s[n.BOOST_TYPE.RESULT] = {}, r.BoostRateAttenuationConfig = s;
    var o = {};
    o[n.BOOST_TYPE.STATUS] = {
        atk: {
            minVal: .3,
            maxVal: 3
        },
        def: {
            minVal: .2,
            maxVal: 9
        },
        matk: {
            minVal: .3,
            maxVal: 3
        },
        mdef: {
            minVal: .2,
            maxVal: 9
        },
        mnd: {
            minVal: .3,
            maxVal: 3
        },
        atkSaCoef: {
            minVal: .3,
            maxVal: 1
        },
        limitDefault: {
            minVal: .3,
            maxVal: 3
        }
    }, o[n.BOOST_TYPE.RESULT] = {}, r.BoostRateLimitConfig = o, r.EnemyCastTime = {}, r.EnemyCastTime[n.CAST_TIME_TYPE.NORMAL_1] = 1760, r.EnemyCastTime[n.CAST_TIME_TYPE.SLOW_1] = 3850, r.EnemyCastTime[n.CAST_TIME_TYPE.TEN_MINS] = 6e5, r.EnemyCastTime[n.CAST_TIME_TYPE.QUICK_1] = 1, r.CounterCustomConfig = {}, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.BLACK_AND_WHITE_MAGIC_ATTACK] = {
        exercises: [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC],
        damagedOnly: !0
    }, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.SKIP_IN_REFLECTION] = {
        exercises: [n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLACK_MAGIC],
        skipInReflection: !0
    }, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.COUNTER_AIMING] = {
        exercises: r.CounterAimingEffectedExerciseTypes,
        calcTypes: r.CounterAimingEffectedCalcTypes
    }, r.CounterCustomConfig[n.COUNTER_CONDTION_CUSTOM_TYPE.LIGHTNING_AND_PHYSICAL_ATTACK] = {
        exercises: [n.EXERCISE_TYPE.PHYSICAL],
        elements: [n.ELEMENT_TYPE.LIGHTNING],
        damageOnly: !0
    }, r.CounterPriority = {
        DEFAULT: 100,
        RECORD_MATERIA: 200,
        COUNTER_AIMING: 300
    }, r.MateriaCalcTypeCond = {
        damageReduceMateria: _.without(_.values(n.CALC_TYPE), n.CALC_TYPE.FRACTION, n.CALC_TYPE.SELF_DESTRUCTION, n.CALC_TYPE.ABILITY_PANEL, n.CALC_TYPE.FIXED_DAMAGE, n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS)
    }, r.ChangeCastTimeCond = {
        magicDamageAbilities: {
            exerciseTypes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLUE_MAGIC, n.EXERCISE_TYPE.SUMMON, n.EXERCISE_TYPE.INBORN],
            isPossibleContainMagicDamage: !0
        },
        physicalDamageAbilities: {
            exerciseTypes: []
        },
        defaultPhysicalDamageAbilities: {
            physicalDamageAbilities: {
                exerciseTypes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.INBORN]
            }
        },
        physicalDamageAbilitiesWithoutInborn: {
            physicalDamageAbilities: {
                exerciseTypes: [n.EXERCISE_TYPE.PHYSICAL]
            }
        },
        defaultMagicDamageAbilities: {
            magicDamageAbilities: {
                exerciseTypes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLUE_MAGIC, n.EXERCISE_TYPE.SUMMON, n.EXERCISE_TYPE.INBORN]
            }
        },
        magicDamageAbilitiesWithoutInborn: {
            magicDamageAbilities: {
                exerciseTypes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC, n.EXERCISE_TYPE.BLUE_MAGIC, n.EXERCISE_TYPE.SUMMON]
            }
        }
    }, r.ThresholdCastTimeNoneFactor = 9999999, r.MaxPartyNum = 5, r.ParamName = {}, r.ParamName[n.PARAM_ID_OF.ATK] = "atk", r.ParamName[n.PARAM_ID_OF.DEF] = "def", r.ParamName[n.PARAM_ID_OF.MATK] = "matk", r.ParamName[n.PARAM_ID_OF.MDEF] = "mdef", r.ParamName[n.PARAM_ID_OF.MND] = "mnd", r.ParamName[n.PARAM_ID_OF.SPD] = "spd", r.ExceptionalFlightAttackIds = [20080001, 20590001, 20830001, 20810005, 20830003, 22110001, 30181051, 20490003, 22030003, 20810002, 20080003, 20080004, 22030004, 30510430], r.ParamIgnoreTypeConfig = {}, r.ParamIgnoreTypeConfig[n.PARAM_IGNORE_TYPE.NONE] = {}, r.ParamIgnoreTypeConfig[n.PARAM_IGNORE_TYPE.DEF_IGNORED] = {
        defIgnored: !0
    }, r.ParamIgnoreTypeConfig[n.PARAM_IGNORE_TYPE.DEF_BOOST_IGNORED] = {
        defBoostIgnored: !0
    }, r.MO = {}, r.MO.BALLOON = {
        MAX_TEXT_LENGTH_FOR_NORMAL: FF.env.isWWRegion() ? 16 : 8
    }, r.MO.PatyNum2PosIdArray = {
        1: ["01", "02"],
        2: ["03", "04"],
        3: ["05", "06"],
        4: ["07", "08"]
    }, r.MO.MaxPartyNum = 8, r.PlayOnceReflectHitCond = {
        abilityLaunchTypes: [n.ABILITY_LAUNCH_TYPE.ONCE]
    };
    var u = t.extend({
            get: function() {
                var e = r;
                _.each(arguments, function(t) {
                    e = e[t]
                }, this);
                if (!e) throw new Error("config not found.");
                return e
            },
            set: function() {
                throw new Error("can not set config")
            }
        }),
        a = void 0;
    FF.ns.battle.Config = {
        getInstance: function() {
            return a || (a = new u), a
        }
    }
}), define("scenes/battle/ContinueBonus", ["lib/ClassBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = e.extend({
            _boostParam: function(e, t, n) {
                e.setBoost(t, n)
            },
            giveBonusAttack: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.ATTACK,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(["atk", "matk", "mnd"], function(t) {
                    this._boostParam(e, t, s)
                }, this)
            },
            giveBonusHp: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.HP,
                    i = this._getBoostFactor(r),
                    s = t * i,
                    o = Math.floor(e.get("maxHp") * (1 + s / 100));
                e.set("maxHp", o), e.set("hp", o)
            },
            giveBonusDefense: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.DEFENSE,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(["def", "mdef"], function(t) {
                    this._boostParam(e, t, s)
                }, this)
            },
            giveBonusAbility: function(e, t) {
                var r = n.Conf.CONTINUE_BONUS.ABILITY,
                    i = this._getBoostFactor(r),
                    s = t * i;
                _.each(e.getAbilityPanels(), function(e) {
                    e.addConsumableNum(s)
                }, this)
            },
            _getBoostFactor: function(e) {
                return n.Config.getInstance().get("ContinueBonus", e, "boostFactor")
            },
            exists: function() {
                return this._getBonusIds().length > 0
            },
            give: function() {
                var e = this.amountByBonusId();
                _.each(n.ActorMgr.getAllBuddies(), function(t) {
                    this._giveEachBuddy(t, e)
                }, this)
            },
            amountByBonusId: function() {
                return _.countBy(this._getBonusIds(), function(e) {
                    return e
                })
            },
            _getBonusIds: function() {
                var e = [],
                    t = n.BattleInfo.getInstance(),
                    r = t.getAllContinueTxns();
                return _.each(r, function(t) {
                    if (!t.isStatOf("DONE")) return;
                    e.push(t.get("bonusId"))
                }, this), e
            },
            _giveEachBuddy: function(e, t) {
                _.each(t, function(t, r) {
                    var i = n.Config.getInstance().get("ContinueBonus", r, "giveFuncName");
                    this[i](e, t)
                }, this)
            }
        }),
        i = void 0;
    FF.ns.battle.ContinueBonus = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/ContinueFsm", ["util", "lib/Cipher", "lib/NameConventionFsm"], function(e, t, n) {
    var r = FF.ns.battle,
        i = r.Conf;
    FF.ns.battle.ContinueFsm = n.extend({
        initialize: function() {
            n.prototype.initialize.call(this), this.changeState("IDLE")
        },
        begin: function() {
            r.BattleViewController.getInstance().startLose();
            var e = r.BattleInfo.getInstance().getLastContinueTxn();
            if (!e) {
                this.changeState("START");
                return
            }
            switch (e.get("stat")) {
                case i.CONTINUE_TXN_STAT.STARTED:
                    this.changeState("RECOVER");
                    break;
                case i.CONTINUE_TXN_STAT.CURED:
                    this.changeState("BONUS");
                    break;
                case i.CONTINUE_TXN_STAT.SELECTED:
                    this.changeState("PRE_CONTINUE");
                    break;
                case i.CONTINUE_TXN_STAT.DONE:
                    this.changeState("START");
                    break;
                case i.CONTINUE_TXN_STAT.CANCELED:
                    this.changeState("START");
                    break;
                default:
                    throw new Error("invalid judge")
            }
        },
        setParent: function(e) {
            this._parent = e
        },
        processForStateStartEntry: function() {
            var e = this;
            this._isDoneStart = !1, this._isRetryStart = !1, r.BattleViewController.getInstance().startOpeningWindow(), this._parent.saveResumeDataDeferred().then(function() {
                e._startContinueWizard()
            })
        },
        _startContinueWizard: function() {
            var t = this;
            t._isDoneStart = !1, t._isRetryStart = !1, $.when(r.Api.getContinueInfoDeferred({
                retryCount: 2
            }), r.Api.getBalanceDeferred(), r.util.DelayCallback.registerDeferred(1500)).done(function(n, s) {
                var o = e.camelizeDeep(_.first(n)),
                    u = o.info,
                    a = r.BattleInfo.getInstance().getExpiredAt() - o.currentTime;
                if (a <= 0) {
                    t.changeState("EXPIRE");
                    return
                }
                u.untilExpire = a;
                var f = function() {
                    t.changeState("RETIRE")
                };
                if (u.isFreeContinue) {
                    var l = t._makeCallbackOfFree(u);
                    u[r.Conf.CONTINUE_TYPE.SOUL_PIECE] = {
                        payCost: 0,
                        canConsume: !0
                    }, r.BattleViewController.getInstance().startFreeContinueWizard(u, l, f);
                    return
                }
                var c = t._makeCallbackOfSoulPiece(u);
                if (u.isMithrilOnly) {
                    r.BattleViewController.getInstance().startMithrilOnlyContinueWizard(u, c, f);
                    return
                }
                var h = s,
                    p = u[i.CONTINUE_TYPE.COIN].payCost,
                    d = h >= p;
                u[i.CONTINUE_TYPE.COIN].balance = h, u[i.CONTINUE_TYPE.COIN].canConsume = d;
                var v = t._makeCallbackOfCoin(u);
                r.BattleViewController.getInstance().startContinueWizard(u, c, v, f)
            }).fail(function(e, n, r, i) {
                t._onFail(e, n, r, i)
            })
        },
        _onFail: function(e, t, n, i) {
            var s = this;
            if (n && n.isPurchasingCanceled) {
                s.changeState("RECOVER");
                return
            }
            if (n && n.error) switch (n.error) {
                case "OAUTH_TOKEN_REVOKED":
                    r.BattleViewController.getInstance().showSystemWindow(r.Conf.SYSTEM_WINDOW.OAUTH_TOKEN_REVOKED);
                    return;
                case "EXISTS_ACTIVE_PAYMENT":
                    r.BattleViewController.getInstance().showSystemWindow(r.Conf.SYSTEM_WINDOW.PAYMENT_NETWORK);
                    return;
                case "CLOSE_VALIDATION_SESSION_EXPIRED":
                    r.BattleViewController.getInstance().showSystemWindow(r.Conf.SYSTEM_WINDOW.EXPIRE, function() {
                        FF.scene.redirectTop()
                    });
                    return;
                case "UNKNOWN":
                    break;
                default:
                    r.BattleViewController.getInstance().showSystemWindow(r.Conf.SYSTEM_WINDOW.ERROR);
                    return
            }
            if (i && i.isMaintenance) {
                r.BattleViewController.getInstance().notifyMaintenance(function() {
                    s.changeState("RECOVER")
                }, i);
                return
            }
            r.BattleViewController.getInstance().notifyCheckingNetwork(function() {
                s.changeState("RECOVER")
            })
        },
        _processStartFinally: function(e) {
            e.isStatOf("CURED") ? this._isDoneStart = !0 : this._isRetryStart = !0
        },
        processForStateStartUpdate: function() {
            var e = this;
            this._isDoneStart && this.changeState("BONUS"), this._isRetryStart && r.BattleViewController.getInstance().stopContinueWizardDeferred().then(function() {
                e._startContinueWizard()
            })
        },
        _makeCallbackOfSoulPiece: function(e) {
            var t = this,
                n = i.CONTINUE_TYPE.SOUL_PIECE,
                s = r.BattleInfo.getInstance().getAppInitDataSessionKey(),
                o = !1;
            return function() {
                if (o) return;
                o = !0;
                var i = new r.ContinueTxn;
                i.setInfo(n, e[n]), t.startDeferred(i, s).then(function() {
                    return t.closeDeferred(i, s)
                }).then(function() {
                    return t.inquireAndUpdateStatusDeferred(i, s)
                }).then(function() {
                    t._processStartFinally(i)
                }).fail(function(e, n, r, i) {
                    t._onFail(e, n, r, i)
                })
            }
        },
        _makeCallbackOfCoin: function(e) {
            var t = this,
                n = i.CONTINUE_TYPE.COIN,
                s = r.BattleInfo.getInstance().getAppInitDataSessionKey(),
                o = !1;
            return function() {
                if (o) return;
                o = !0;
                var i = new r.ContinueTxn;
                i.setInfo(n, e[n]), FF.env.isWWRegion() ? t._checkBeforeUseCoin(e, i, s) : t._useCoinProcess(i, s)
            }
        },
        _checkBeforeUseCoin: function(e, t, n) {
            var r = this,
                s = i.CONTINUE_TYPE.COIN,
                o = e[s].balance ? e[s].balance : 0,
                u = e[s].payCost,
                a = function() {
                    r._isRetryStart = !0, r._onFail(null, null, {
                        isPurchasingCanceled: !0
                    }, null)
                };
            if (!t.canConsume()) {
                r.startDeferred(t, n).then(function() {
                    return r._showBalanceErrorWindowDeferred(o, u)
                }).always(function() {
                    a.call(r)
                });
                return
            }
            r._confirmWithUserDeferred(o, u).then(function() {
                r._useCoinProcess(t, n)
            }).fail(function() {
                a.call(r)
            })
        },
        _useCoinProcess: function(e, t) {
            var n = this;
            n.startDeferred(e, t).then(function() {
                var n = {
                    id: e.get("paymentProductId"),
                    quantity: 1,
                    payment_context: {
                        continue_id: e.get("continueId"),
                        session_key: t
                    }
                };
                return r.Api.purchaseItemDeferred(n)
            }).then(function() {
                return n.inquireAndUpdateStatusDeferred(e, t)
            }).then(function() {
                n._processStartFinally(e)
            }).fail(function(e, t, r, i) {
                n._onFail(e, t, r, i)
            })
        },
        _makeCallbackOfFree: function(e) {
            var t = this,
                n = i.CONTINUE_TYPE.FREE,
                s = r.BattleInfo.getInstance().getAppInitDataSessionKey(),
                o = !1;
            return function() {
                if (t.isState("RETIRE")) return;
                if (o) return;
                o = !0;
                var i = new r.ContinueTxn;
                i.setInfo(n, e[n]), t.startDeferred(i, s).then(function() {
                    return t.closeDeferred(i, s)
                }).then(function() {
                    return t.inquireAndUpdateStatusDeferred(i, s)
                }).then(function() {
                    t._processStartFinally(i)
                }).fail(function(e, n, r, i) {
                    t._onFail(e, n, r, i)
                })
            }
        },
        _getAesKeyDeferred: function() {
            return t.getAesKeyDeferred()
        },
        _decryptResponseDeferred: function(n) {
            var r = n.results,
                i = $.Deferred();
            if (t.isClientAesKeyClientVersion() && !1) {
                var s = atob(r),
                    o = JSON.parse(s);
                o = e.camelizeDeep(o), i.resolve(o)
            } else t.decryptTextDeferred(r).then(function(t) {
                var n = JSON.parse(t);
                n = e.camelizeDeep(n), i.resolve(n)
            });
            return i.promise()
        },
        startDeferred: function(t, n) {
            var i = this,
                s = e.randomString(8),
                o = FF.env.userId;
            return this._getAesKeyDeferred().then(function(e) {
                return r.Api.startContinueDeferred(t.get("typeId"), n, s, e)
            }).then(this._decryptResponseDeferred.bind(this)).done(function(e) {
                return t.chkResult(e.digest, o, s), t.set("continueId", e.continueId), r.BattleInfo.getInstance().addNewContinueTxn(t), i._parent.saveResumeDataDeferred()
            }).fail(function(e, t, n, r) {
                return $.Deferred().reject(e, t, n).promise()
            })
        },
        closeDeferred: function(t, n) {
            var i = t.get("continueId"),
                s = t.get("typeId"),
                o = e.randomString(8),
                u = FF.env.userId,
                a = $.Deferred();
            return this._getAesKeyDeferred().then(function(e) {
                return r.Api.closeContinueDeferred(i, s, n, o, e)
            }).then(this._decryptResponseDeferred.bind(this)).done(function(e) {
                t.chkResult(e.digest, u, o), a.resolve()
            }).fail(function(e, t, n, r) {
                a.reject(e, t, n)
            }), a.promise()
        },
        inquireAndUpdateStatusDeferred: function(t, n) {
            var i = this,
                s = t.get("continueId"),
                o = t.get("typeId"),
                u = e.randomString(8),
                a = FF.env.userId;
            return this._getAesKeyDeferred().then(function(e) {
                return r.Api.inquireContinueStatusDeferred(s, o, n, u, e)
            }).then(this._decryptResponseDeferred.bind(this)).done(function(e) {
                return e.canContinue ? (t.chkResult(e.digest, a, u), t.chkInquireResult(e, n) ? t.changeStat("CURED") : t.changeStat("CANCELED")) : t.changeStat("CANCELED"), i._parent.saveResumeDataDeferred()
            }).fail(function(e, t, n, r) {
                i._onFail(e, t, n, r)
            })
        },
        processForStateRecoverEntry: function() {
            var e = this,
                t = r.BattleInfo.getInstance(),
                n = t.getLastContinueTxn(),
                i = t.getAppInitDataSessionKey();
            if (!n || n.isEnded()) {
                this.changeState("START");
                return
            }
            this.inquireAndUpdateStatusDeferred(n, i).then(function() {
                if (n.isStatOf("CURED")) e.changeState("BONUS");
                else {
                    if (!n.isStatOf("CANCELED")) throw new Error("invalid continue transaction stat in RECOVER. dump:" + n.makeDumpData());
                    e.changeState("START")
                }
            })
        },
        processForStateBonusEntry: function() {
            var e = this;
            kickmotor.platform.resetMobageDashboardListener();
            var t = function(t, n) {
                    var i = r.BattleInfo.getInstance().getLastContinueTxn();
                    i.fixBonusId(t), e._parent.saveResumeDataDeferred().then(function() {
                        n.resolve()
                    })
                },
                n = function() {
                    e.changeState("PRE_CONTINUE")
                };
            r.BattleViewController.getInstance().menuWindowView.showPowerUpWindow(t, n)
        },
        processForStatePreContinueEntry: function() {
            var e = this;
            this._isDonePreContinue = !1;
            var t = r.BattleInfo.getInstance().getLastContinueTxn();
            t.changeStat("DONE"), r.ActorMgr.resetBuddiesForContinue();
            var n = r.ContinueBonus.getInstance();
            n.exists() && n.give();
            var i = _.all(r.ActorMgr.getAllBuddies(), function(e) {
                return e.isAlive()
            });
            i || this._throwErrorOfCannotReviveAllBuddies(), this._parent.saveResumeDataDeferred().then(function() {
                var i = function() {
                        e._isDonePreContinue = !0
                    },
                    s = {
                        lastBonusId: t.get("bonusId"),
                        bonusAmount: n.amountByBonusId()
                    };
                r.BattleViewController.getInstance().showContinueDoneWindow(i, s)
            })
        },
        processForStatePreContinueUpdate: function() {
            this._isDonePreContinue && this.changeState("CONTINUE")
        },
        _throwErrorOfCannotReviveAllBuddies: function() {
            var e = r.ActorMgr.getDeadBuddies(),
                t = "deadNum:" + e.length;
            _.each(e, function(e) {
                t += ",pos:" + e.get("posId")
            });
            var n = r.BattleInfo.getInstance().toPlainObject().continueTxns;
            throw t += ",txns:" + JSON.stringify(n), new Error("cannot revive all buddies. " + t)
        },
        _showBalanceErrorWindowDeferred: function(e, t) {
            return r.BattleViewController.getInstance().showBalanceErrorWindowDeferred(e, t)
        },
        _confirmWithUserDeferred: function(e, t) {
            return r.BattleViewController.getInstance().confirmWithUserDeferred(e, t)
        }
    })
}), define("scenes/battle/ContinueTxn", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ContinueTxn = e.extend({
        initialize: function(t) {
            e.prototype.initialize.call(this), this.set("createdAt", (new Date).getTime())
        },
        setInfo: function(e, n) {
            _.extend(this._attributes, {
                continueId: void 0,
                typeId: e,
                name: n.name,
                stat: t.Conf.CONTINUE_TXN_STAT.STARTED,
                payTypeName: n.payTypeName,
                payCost: n.payCost,
                balance: n.balance ? n.balance : 0,
                bonusId: void 0,
                paymentTime: void 0,
                chkResults: []
            }), n.paymentProductId && this.set("paymentProductId", n.paymentProductId)
        },
        changeStat: function(e) {
            if (this.isEnded()) {
                var n = ["arg:", e, "stat", this.get("stat"), "resultData:", this.makeResultData()];
                throw new Error("this txn already has ended #" + JSON.stringify(n))
            }
            if (!_.has(t.Conf.CONTINUE_TXN_STAT, e)) throw new Error("unknown continueTxnStat." + e);
            var r = t.Conf.CONTINUE_TXN_STAT[e];
            this.set("stat", r);
            if (r === t.Conf.CONTINUE_TXN_STAT.CURED) {
                var i = t.BattleInfo.getInstance().get("actionTime");
                this.set("paymentTime", Math.floor(i / 1e3))
            }
        },
        isStatOf: function(e) {
            return this.get("stat") === t.Conf.CONTINUE_TXN_STAT[e]
        },
        isEnded: function() {
            return this.isStatOf("DONE") || this.isStatOf("CANCELED")
        },
        canConsume: function() {
            return this.get("balance") >= this.get("payCost")
        },
        fixBonusId: function(e) {
            if (!!this.get("bonusId") || !this.isStatOf("CURED")) {
                var n = ["arg:", e, "stat:", this.get("stat"), "resultData:", this.makeResultData(), "latestTransactionResults:"],
                    r = _.takeRight(t.BattleInfo.getInstance().getAllContinueTxns(), 10),
                    i = [];
                throw _.each(r, function(e) {
                    i.push(e.makeDumpData())
                }), n.push(i), new Error("this txn already fixed bonusId #" + JSON.stringify(n))
            }
            this.set("bonusId", e), this.changeStat("SELECTED")
        },
        chkResult: function(e, t, n) {
            var r = this.a(),
                i = this.b(),
                s = Chara.ZEROMUS(sprintf("%d:%s:%s", t, n, r), i).toString();
            this.get("chkResults").push(e === s)
        },
        chkInquireResult: function(e, t) {
            var n = _.all(["continueId", "typeId"], function(t) {
                return this.get(t) === +e[t]
            }, this);
            return n ? t !== e.sessionKey ? !1 : !0 : !1
        },
        chkNextTxnCreatedInDisallowTime: function(e) {
            var t = +this.get("createdAt") + 1e3;
            return e.get("createdAt") < t
        },
        a: function() {
            return FF.env.d
        },
        b: function() {
            return FF.env.e
        },
        makeResultData: function() {
            var e = this.get("chkResults"),
                n = e.length > 0 && _.all(e, function(e) {
                    return e
                });
            return {
                continue_id: this.get("continueId"),
                round_num: t.BattleInfo.getInstance().get("round"),
                enemy_info: t.EnemyPartyMgr.getInstance().makeResultData().current,
                continue_type: this.get("typeId"),
                bonus_type: this.get("bonusId"),
                action_time: this.get("paymentTime"),
                chk_result: n ? 1 : 0
            }
        },
        makeDumpData: function() {
            var e = this.makeResultData();
            return e.stat = this.get("stat"), e.createdAt = this.get("createdAt"), e
        },
        toPlainObject: function() {
            return {
                attributes: this._attributes
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes)
        }
    })
}), define("scenes/battle/Counters", ["util", "lib/ClassBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.Counters = t.extend({
        initialize: function(e) {
            t.prototype.initialize.call(this), this._actor = e, this._counterId = 1, this._counterInfos = {}
        },
        add: function(e, t, n, r, i) {
            var s = this._actor.get("paramId");
            return this.addWithParamId(s, e, t, n, r, i)
        },
        addWithParamId: function(t, r, i, s, o, u) {
            return u = e.option({
                isPossibleMultiCounter: !1,
                priority: n.Config.getInstance().get("CounterPriority", "DEFAULT")
            }, u), this._counterInfos[this._counterId] = {
                paramId: t,
                abilityId: r,
                rate: _.isNumber(o) ? o : 100,
                condition: {
                    type: i,
                    value: s
                },
                isPossibleMultiCounter: u.isPossibleMultiCounter,
                priority: u.priority
            }, this._counterId++
        },
        remove: function(e) {
            delete this._counterInfos[e]
        },
        evaluate: function(e) {
            var t = this,
                r = this._getCurrentInfos(),
                i = this._orderByPriorityCounterInfos(r),
                s = _.any(i, function(t) {
                    var r = {};
                    r.counterInfo = t;
                    if (!n.util.DamageCalculator.isEnableCounter(e, r)) return !1;
                    if (this._matches(t, e) && this._lot(t.rate)) {
                        var i = t.abilityId,
                            s = this._actor,
                            o = {
                                isCounter: !0
                            };
                        return n.Commander.getInstance().register(i, s, o, {
                            interruptCounter: !0
                        }), !0
                    }
                    return !1
                }, this);
            return s
        },
        _getCurrentInfos: function() {
            var e = this._actor.get("paramId");
            return _.filter(this._counterInfos, function(t) {
                return t.paramId === e
            })
        },
        _orderByPriorityCounterInfos: function(e) {
            return _.sortBy(e, function(e) {
                return -1 * e.priority
            })
        },
        _matches: function(e, t) {
            var r = e.condition,
                i = !1;
            switch (r.type) {
                case n.Conf.COUNTER_CONDTION_TYPE.ELEMENT:
                    r.value === t.element && (i = !0);
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.EXERCISE:
                    var s = t.ability.exerciseType();
                    r.value === s && (i = !0);
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.ALL:
                    i = !0;
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.CUSTOM:
                    i = this._matchesForCustom(r, t);
                    break;
                case n.Conf.COUNTER_CONDTION_TYPE.ABILITY_CATEGORY_ID:
                    var o = t.ability.get("abilityCategoryId");
                    r.value === o && (i = !0)
            }
            return i && (i = this._actor.matchesOptionalCounterCondition(e)), i
        },
        _matchesForCustom: function(e, t) {
            var r = !0,
                i = n.Config.getInstance().get("CounterCustomConfig");
            i = i[e.value];
            if (!i) throw new Error("invalid counter custom config id. " + e.value);
            var s = i.exercises,
                o = i.elements,
                u = !!i.damagedOnly,
                a = !!i.skipInReflection,
                f = i.calcTypes;
            if (s) {
                var l = t.ability.exerciseType();
                _.include(s, l) || (r = !1)
            }
            o && (_.include(o, t.element) || (r = !1)), r && u && (t.damage && t.damage > 0 || (r = !1)), a && this._actor.isInReflection() && (r = !1);
            if (f) {
                var c = t.type;
                _.include(f, c) || (r = !1)
            }
            return r
        },
        _lot: function(t) {
            return e.lotByFraction(t)
        },
        toPlainObject: function() {
            return {
                counterId: this._counterId,
                counterInfos: this._counterInfos,
                attributes: this._attributes
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.extend(this._attributes, e.attributes), this._counterId = e.counterId || 1, this._counterInfos = e.counterInfos
        }
    })
}), define("scenes/battle/DataConstructor", [], function() {
    var e = FF.ns.battle;
    FF.ns.battle.DataConstructor = {
        getActorInfo: function(t) {
            var n = this;
            if (_.isArray(t)) return _.map(t, function(e) {
                return n.getActorInfo(e)
            });
            if (!t) throw new Error("actor not found");
            var r = this._getActorCommonInfo(t),
                i = t.get("animationInfo");
            t.isBuddy() && (_.extend(r, {
                buddyAnimationInfo: i,
                weaponAnimationInfo: t.get("weapon").animationInfo,
                playTagList: this.getBuddyTagList(t),
                isSpecialReady: this.isSpecialReady(t),
                specialAuraType: this.getSpecialAuraType(t),
                isSupporterReady: this.isSupporterReady(t),
                handedness: t.get("handedness"),
                statusBonusFlgOf: t.getStatusBonusFlgOf(),
                statusBonusTypeOf: t.getStatusBonusTypeOf(),
                supporterInfo: this._getSupporterInfo(t)
            }), e.BattleInfo.getInstance().isMo() && (r.isMyBuddy = t.isMyBuddy(), r.isOperable = t.isOperable()));
            if (t.isEnemy()) {
                r.isSpEnemy = t.container.isSpEnemy(), r.isFinalEnemy = t.container.isAllDead(), r.hpGaugeSize = i.hpGaugeSize, r.isInvisible = n._isInvisibleHpGauge(t);
                if (r.isSpEnemy) {
                    r.deadAnimateType = t.getDeadAnimateType();
                    var s = i.path.split("_");
                    _.extend(r, {
                        mainAssetId: sprintf("boss-%s_%s", s[0], 1),
                        subAssetId: sprintf("boss-%s_%s", s[0], s[1]),
                        usesFixPos: i.usesFixPos
                    })
                } else _.extend(r, {
                    childPosId: t.get("childPosId") || 1,
                    offset: [i.offsetX, i.offsetY],
                    scale: i.scale,
                    spriteAssetId: sprintf("enemy-%s", i.path)
                })
            }
            return r
        },
        _getActorCommonInfo: function(e) {
            var t = _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]),
                n = e.getAbility(),
                r = n ? _.min([Math.floor(100 * e.get("elapsedCastTime") / n.get("castTime")), 100]) : 0,
                i = e.getAttributes(["childPosId", "hp", "dispName", "maxHp", "row"]);
            return _.extend(i, {
                atbRate: t,
                castRate: r,
                count: e.getCount(),
                isCount: e.statusAilments.isCount(),
                hasDoom: e.statusAilments.hasDoom(),
                doomCount: e.getCount(),
                isBuddy: e.isBuddy(),
                isDead: e.isDead(),
                isForceEscaped: e.isForceEscaped(),
                isEnemy: e.isEnemy(),
                isStateInCast: e.isStateInCast(),
                nodeNamePrefix: e.isBuddy() ? "player" : "enemy",
                posId: e.get("posId"),
                statusAilments: e.statusAilments.cloneIds(),
                uid: e.getUid(),
                posInfo: {
                    isEnemy: e.isEnemy(),
                    posId: e.get("posId"),
                    childPosId: e.get("childPosId") || 1
                }
            })
        },
        _getSupporterInfo: function(t) {
            if (t.isPossessedBySupporter()) {
                var n = e.ActorMgr.getSupporter();
                return {
                    buddyAnimationInfo: n.get("animationInfo"),
                    weaponAnimationInfo: n.get("weapon").animationInfo,
                    handedness: n.get("handedness"),
                    statusBonusFlgOf: n.getStatusBonusFlgOf(),
                    statusBonusTypeOf: n.getStatusBonusTypeOf()
                }
            }
            return void 0
        },
        getActorInfoByUid: function(t) {
            var n = e.ActorMgr.getByUid(t);
            return this.getActorInfo(n)
        },
        loadBuddyDrawInfo: function() {
            var t = e.ActorMgr.getAllBuddies();
            return this.getActorInfo(t)
        },
        loadEnemyDrawInfo: function() {
            var t = e.ActorMgr.getAliveEnemies();
            return this.getActorInfo(t)
        },
        getEnemyPosArrayByEnemyPosId: function(t) {
            var n = _.filter(e.ActorMgr.getAliveEnemies(), function(e) {
                return e.get("posId") === t
            });
            return _.map(n, function(e) {
                return "" + e.get("childPosId")
            })
        },
        getAbilityPanelInfo: function(t) {
            return _.map(t, function(t) {
                var n = !e.BattleInfo.getInstance().isEnded(),
                    r = t.isInfinity() ? e.TextMaster.getInstance().get("B10020") : "" + t.get("remainNum"),
                    i = sprintf("command_icon_%s", t.isDefensePanel() ? "defense" : t.get("abilityId")),
                    s = t.get("name");
                return {
                    posId: this.convPanelNoToPosId(t.get("panelNo")),
                    iconAssetId: i,
                    num: r,
                    name: s,
                    enabled: t.canRecept() && n,
                    visible: t.get("visible"),
                    highlighted: !!t.get("highlight")
                }
            }, this)
        },
        getSelectorAbilityPanelInfo: function() {
            var t = e.ActorMgr.getAbilityPanelSelector();
            if (!t) return;
            return {
                abilityPanelInfo: this.getAbilityPanelInfo(t.getAbilityPanels()),
                selector: this.getActorInfo(t),
                soulStrikeInfo: this.getSoulStrikeInfo(t),
                canSkipSelect: t.getSkip().canRecept()
            }
        },
        getSupporterSoulStrikeInfo: function() {
            var t = e.ActorMgr.getSupporter();
            if (!t) return;
            var n = t.get("animationInfo"),
                r = t.getSupporterSoulStrike(),
                i = e.BuddyPartyMgr.getInstance().canReceptSupporterSoulStrike(),
                s = e.BuddyPartyMgr.getInstance().isDuringSupporterSoulStrike();
            return {
                charaAssetId: "buddy-" + n.path,
                assetId: "command_icon_" + r.get("abilityId"),
                soulStrikeName: r.get("name"),
                enabled: i && !s,
                restCount: r.get("restCount")
            }
        },
        convPanelNoToPosId: function(t) {
            return e.Config.getInstance().get("PanelNoToPosId", t)
        },
        convPosIdToPanelNo: function(t) {
            return e.Config.getInstance().get("PosIdToPanelNo", t)
        },
        getAllPanelPosIds: function() {
            return _.keys(e.Config.getInstance().get("PosIdToPanelNo"))
        },
        getActionResultInfo: function(e) {
            var t = e.executer,
                n = e.ability,
                r = e.damageObjects;
            return {
                executerInfo: this.getActorInfo(t),
                abilityInfo: n ? this.getAbilityInfo(n) : {},
                receiverInfo: this.getDamageObjectInfo(r)
            }
        },
        getDamageObjectInfo: function(e) {
            var t = this;
            if (_.isArray(e)) return _.map(e, function(e) {
                return t.getDamageObjectInfo(e)
            });
            var n = e,
                r = _.extend(this.getActorInfo(n.receiver), {
                    advantage: n.advantage,
                    canHit: n.canHit,
                    damage: n.damage,
                    isNoeffect: n.isNoeffect,
                    isCritical: n.isCritical,
                    isRecovery: n.damage >= 0,
                    isAbilityPanel: !!n.isAbilityPanel,
                    isHpStock: !!n.isHpStock,
                    currHp: n.curr || n.currHp,
                    prevHp: n.prev || n.prevHp,
                    maxHp: n.max || n.maxHp,
                    reflector: n.reflector ? this.getActorInfo(n.reflector) : void 0,
                    absorber: n.absorber ? this.getActorInfo(n.absorber) : void 0,
                    absorbHp: n.absorbHp,
                    fakeDamage: n.fakeDamage,
                    hpStockDamage: n.hpStockDamage,
                    isNotShownHitMotion: n.isNotShownHitMotion,
                    isNotShownDamageMotion: n.isNotShownDamageMotion
                });
            return n.appendedStatusAilments && n.appendedStatusAilments.hasAtkStatusAilments && (r.appendedStatusAilments = {
                isNoeffect: n.appendedStatusAilments.isNoeffect,
                canHit: n.appendedStatusAilments.canHit
            }), r
        },
        getAbilityInfo: function(e) {
            var t = e.get("animationInfo") || {};
            return {
                abilityAnimationId: "" + t.id,
                atkMotion: t.atkMotion,
                launchType: t.launchType,
                shotType: t.shotType,
                hitType: t.hitType,
                hitArg: t.hitArg,
                missHit: t.missHit,
                launchBack: t.launchBack,
                hasLaunchEnd: t.hasLaunchEnd,
                returnType: t.returnType,
                returnShot: t.returnShot,
                returnHit: t.returnHit,
                returnMissHit: t.returnMissHit,
                reverseShot: t.reverseShot,
                reverseHit: t.reverseHit,
                charaOutTag: t.charaOut,
                charaInTag: t.charaIn,
                otherOutTag: t.otherOut,
                otherInTag: t.otherIn,
                damageTag: t.damageTag,
                recoveryTag: t.recoveryTag,
                launchNextTag: t.launchNextTag,
                shotNextTag: t.shotNextTag,
                hitNextTag: t.hitNextTag,
                hasHitTiming: t.hasHitTiming ? !0 : !1,
                launchSpriteNum: t.launchSpriteNum,
                shotSpriteNum: t.shotSpriteNum,
                hitSpriteNum: t.hitSpriteNum,
                landSpriteNum: t.landSpriteNum,
                launchParticleJson: t.launchParticleJson,
                shotParticleJson: t.shotParticleJson,
                hitParticleJson: t.hitParticleJson,
                landParticleJson: t.landParticleJson,
                dispName: e.get("name"),
                aliasName: e.get("aliasName"),
                skipMessage: e.get("skipMessage"),
                isSoulStrike: e.get("isSoulStrike") ? !0 : !1,
                isCounter: e.get("isCounter"),
                isInLongAction: this._checkLongActionAbility(e)
            }
        },
        _checkLongActionAbility: function(t) {
            return t.get("isSoulStrike") || t.get("isSupporterSoulStrike") ? !0 : t.get("exerciseType") === e.Conf.EXERCISE_TYPE.SUMMON ? !0 : !1
        },
        getCurrentAbility: function() {
            var t = e.BattleInfo.getInstance().getCurrentAbility();
            return t ? this.getAbilityInfo(t) : void 0
        },
        getSoulStrikeInfo: function(e) {
            var t = e.get("animationInfo"),
                n = e.getSoulStrike(),
                r = e.getSoulStrikePanels();
            return _.map(r, function(r) {
                return {
                    charaAssetId: "buddy-" + t.path,
                    assetId: "command_icon_" + r.get("abilityId"),
                    charaName: e.get("dispName"),
                    soulStrikeName: r.get("name"),
                    soulStrikeDispName: r.get("dispName"),
                    enabled: r.canRecept(),
                    point: n.get("point"),
                    consumePoint: r.get("consumeSoulStrikePoint"),
                    slot: r.get("slot")
                }
            })
        },
        getActiveTarget: function() {
            var t = e.ActorMgr.getActiveTarget();
            return t ? this.getActorInfo(t) : void 0
        },
        getSoulStrikePoint: function() {
            var t = e.ActorMgr.getAbilityPanelSelector();
            return t ? t.getSoulStrike().get("point") : 0
        },
        getBuddyTagList: function(t) {
            var n = ["idle"];
            if (t.isPossessedBySupporter()) return n;
            var r = t.statusAilments.cloneIds(),
                i = e.Config.getInstance().get("StatusAilments", "GRAPHIC_TAG"),
                s = _.filter(r, function(e) {
                    return i[e]
                }),
                o = _.map(s, function(e) {
                    return i[e]
                });
            t.isFatal() && n.push("fatal");
            if (t.isStateInCast()) {
                var u = t.getAbility().get("exerciseType"),
                    a = e.Config.getInstance().get("ExerciseTypeToCastTag"),
                    f = a[u];
                f && n.push(f)
            }
            return n = _.union(n, o), n
        },
        getSpecialAuraType: function(t) {
            return t.isAlive() && t.isStateInCast() ? t.getAbility().hasBrokenMaxDamageThreshold() ? e.Conf.SPECIAL_AURA_TYPE.BREAK_MAX_DAMAGE_THRESHOLD : t.getAbility().get("hasParamBooster") ? e.Conf.SPECIAL_AURA_TYPE.HAS_PARAM_BOOSTER : e.Conf.SPECIAL_AURA_TYPE.NORMAL : e.Conf.SPECIAL_AURA_TYPE.NONE
        },
        isSpecialReady: function(e) {
            return e.isAlive() && e.isStateInCast() && e.getAbility().get("isSoulStrike") ? !0 : !1
        },
        isSupporterReady: function(e) {
            return e.isStateInCast() && e.getAbility().get("isSupporterSoulStrike") ? !0 : !1
        },
        getDeformInfoByAnimationInfo: function(e) {
            var t = e.animationInfo.deformTag;
            if (t) {
                var n = e.enemyContainer,
                    r = n.get("deformAnimationInfo"),
                    i = _.find(r, function(e) {
                        return e.deformTag === t
                    });
                if (!i) throw new Error("deform info not found.tag=" + t);
                return e.animationInfo.options && _.extend(e, e.animationInfo.options), this._getDeformInfo(e, i)
            }
            var s = e.animationInfo.animationId;
            return this.getDeformInfo(_.extend(e, {
                animationId: s
            }))
        },
        getDeformInfo: function(e) {
            var t = e.enemyContainer,
                n = e.animationId,
                r = t.get("deformAnimationInfo"),
                i = _.find(r, function(e) {
                    return +e.id === +n
                });
            if (!i) throw new Error("deform info not found.id=" + n);
            return this._getDeformInfo(e, i)
        },
        _getDeformInfo: function(e, t) {
            var n = this,
                r = e.enemyContainer,
                i = _.map(t.state, function(e) {
                    return "" + e
                }),
                s = r.getChildren(),
                o = [],
                u = [];
            return _.each(s, function(e) {
                e.isDead() && o.push("" + e.get("childPosId")), n._isInvisibleHpGauge(e) && u.push("" + e.get("childPosId"))
            }), i = _.difference(i, o), {
                posId: "5_03",
                deformTag: t.deformTag,
                posArray: i,
                isRandom: t.isRandom,
                filteringDeformPosArray: e.filteringDeformPosArray,
                skipMainNodeDeform: e.skipMainNodeDeform,
                shouldDeformAllNodes: e.shouldDeformAllNodes,
                invisibleHpGaugePosArray: u,
                skipEnemyName: e.skipEnemyName,
                messageInfo: e.messageInfo,
                forceShowNamePosArray: e.forceShowNamePosArray
            }
        },
        getDropItemInfo: function(e) {
            return _.map(e, function(e) {
                return {
                    executerInfo: this.getActorInfo(e.executer),
                    receiverInfo: this.getDropItemObjectInfo(e.dropItemObjects),
                    item: this.getDropItemItemInfo(e.item)
                }
            }, this)
        },
        getDropItemObjectInfo: function(t) {
            var n = this;
            if (_.isArray(t)) return _.map(t, function(e) {
                return n.getDropItemObjectInfo(e)
            });
            var r = void 0;
            switch (t.item.type) {
                case e.Conf.DROP_ITEM_TYPE.POTION:
                case e.Conf.DROP_ITEM_TYPE.HI_POTION:
                case e.Conf.DROP_ITEM_TYPE.X_POTION:
                    r = this.getDamageObjectInfo(t);
                    break;
                case e.Conf.DROP_ITEM_TYPE.ETHER:
                case e.Conf.DROP_ITEM_TYPE.TURBO_ETHER:
                    r = _.extend({
                        damageNum: t.damage
                    }, this.getActorInfo(t.receiver));
                    break;
                default:
                    r = t
            }
            return r
        },
        getDropItemItemInfo: function(e) {
            return {
                assetId: sprintf("drop_item_%s_%s", e.type, e.rarity),
                type: e.type,
                rarity: e.rarity
            }
        },
        getDropMateriaInfo: function(e) {
            return {
                itemId: e.itemId,
                buddyPos: e.buddyPos,
                name: e.name
            }
        },
        getGil: function() {
            return e.BuddyPartyMgr.getInstance().get("gil")
        },
        getOrb: function() {
            return e.BuddyPartyMgr.getInstance().get("orb")
        },
        getTreasure: function() {
            return e.BuddyPartyMgr.getInstance().get("treasure")
        },
        getEventItem: function() {
            return e.BuddyPartyMgr.getInstance().get("eventItem")
        },
        getBattleBgm: function() {
            var t = e.BattleInfo.getInstance().getBattleParam();
            return t.bgm
        },
        getWinBgm: function() {
            return e.BattleInfo.getInstance().getBattleInitData().battle.winBgm || e.Conf.BGM_NAME.VICTORY
        },
        canOperateBattle: function() {
            var t = e.BattleInfo.getInstance();
            return t.canOperateBattle()
        },
        isJustEnded: function() {
            var t = e.BattleInfo.getInstance();
            return !!t.isJustEnded()
        },
        isAllEnded: function() {
            var t = e.BattleInfo.getInstance();
            return !!t.get("isAllEnded")
        },
        isAutoEnabled: function() {
            var t = e.BattleInfo.getInstance();
            return t.get("isClear") ? !1 : t.isEnded() && !t.isVictory() ? !1 : !0
        },
        isChangedBackground: function() {
            var t = e.BattleInfo.getInstance();
            for (var n = 1; n <= t.get("round"); n++) {
                var r = t.getBattleParam(n);
                if (r.backgroundChangeType === e.Conf.BACKGROUND_CHANGE_TYPE.WALK || r.backgroundChangeType === e.Conf.BACKGROUND_CHANGE_TYPE.STOP) return !0
            }
            return !1
        },
        judgePauseOrEscapeAvailable: function() {
            var t = _.filter(e.ActorMgr.getAllBuddies(), function(e) {
                return e.judgeDeath() ? !1 : e.isContinuousBattle() ? !0 : !1
            });
            return t.length > 0
        },
        getBattleSpeedIndex: function() {
            return e.BattleInfo.getInstance().getBattleSpeedIndex()
        },
        _isInvisibleHpGauge: function(e) {
            return e.isInvisible() || e.isDead() || e.isInvincible()
        },
        getMateriaBoostBuddies: function(e) {
            var t = {};
            return _.each(["exp", "gil"], function(n) {
                if (!_.has(e, n)) return;
                t[n] = this.getActorInfo(e[n])
            }, this), t
        },
        getBuddiesInfoByPartyNo: function(t) {
            var n = this.getActorInfo(e.ActorMgr.getAllBuddies()),
                r = this._getPosIdArrayByPartyNoForMo(t);
            return n = _.filter(n, function(e) {
                return r.indexOf(e.posId) >= 0
            }), n
        },
        _getPosIdArrayByPartyNoForMo: function(t) {
            var n = e.Config.getInstance().get("MO");
            return n.PatyNum2PosIdArray[t]
        },
        getNickNameByPartyIndexForMo: function(t) {
            return e.BattleInfo.getInstance().getPartyIndexToNickNameMap()[t]
        }
    }
}), define("scenes/battle/actorStats/StatsBase", ["underscore", "lib/ProtectParamsBase"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.StatsBase = t.extend({
        initialize: function() {
            t.prototype.initialize.call(this)
        },
        notify: function(e, t) {}
    }), FF.ns.battle.StatsBase
}), define("scenes/battle/actorStats/DamageReceiveCount", ["underscore", "./StatsBase"], function(e, t) {
    var n = FF.ns.battle,
        r = e.values(n.Conf.DAMAGE_RECEIVE_COUNT_TYPE);
    FF.ns.battle.DamageReceiveCount = t.extend({
        initialize: function(r) {
            var i = this;
            t.prototype.initialize.call(this), e.each(n.Conf.DAMAGE_RECEIVE_COUNT_TYPE, function(e) {
                i.set(e, 0)
            })
        },
        notify: function(e, t) {
            this.update(e, t), this.reset(e, t)
        },
        update: function(t, r) {
            var i = this;
            e.each(n.Conf.DAMAGE_RECEIVE_COUNT_TYPE, function(e) {
                var s = n.DamageReceiveCountConfig.getConfig(e);
                if (!s.damageCondition(t, r)) return;
                i.set(e, i.get(e) + 1)
            })
        },
        reset: function(t, r) {
            var i = this;
            e.each(n.Conf.DAMAGE_RECEIVE_COUNT_TYPE, function(e) {
                var s = n.DamageReceiveCountConfig.getConfig(e);
                if (!s.resetCondition(t, r)) return;
                i.set(e, 0)
            })
        },
        getProtectParams: function() {
            return r
        }
    })
}), define("scenes/battle/ActorStats", ["underscore", "lib/ClassBase", "./actorStats/DamageReceiveCount"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ActorStats = t.extend({
        initialize: function() {
            this._stats = {}, this._stats[n.Conf.ACTOR_STATS_TYPE.DAMAGE_RECEIVE_COUNT] = new n.DamageReceiveCount
        },
        notify: function(t, n) {
            e.each(this._stats, function(e) {
                e.notify(t, n)
            })
        },
        getStats: function(e) {
            return this._stats[e]
        },
        toPlainObject: function() {
            var t = {};
            return e.each(this._stats, function(e, n) {
                t[n] = e.toPlainObject()
            }), t
        },
        applyPlainObject: function(t) {
            var n = this;
            e.each(t, function(e, t) {
                n._stats[t].applyPlainObject(e)
            })
        }
    })
}), define("scenes/battle/actorStats/DamageReceiveCountConfig", ["util"], function(e) {
    var t = FF.ns.battle,
        n = {};
    n[t.Conf.DAMAGE_RECEIVE_COUNT_TYPE.STANDARD] = {
        damageCondition: function(e, n) {
            if (e !== t.Conf.ACTOR_STATS_NOTIFY_TYPE.APPLY_DAMAGE_OBJECT) return !1;
            var r = n.damageObject;
            if (!_.isNumber(r.damage) || r.damage <= 0) return !1;
            var i = [t.Conf.CALC_TYPE.ATTACK, t.Conf.CALC_TYPE.MAGIC, t.Conf.CALC_TYPE.FRACTION, t.Conf.CALC_TYPE.SELF_DESTRUCTION, t.Conf.CALC_TYPE.DAMAGED_HP, t.Conf.CALC_TYPE.FIXED_DAMAGE, t.Conf.CALC_TYPE.RADIANT_SHIELD],
                s = _.any(r.typeHistory, function(e) {
                    return _.include(i, e)
                });
            return s ? !0 : !1
        },
        resetCondition: function(e, n) {
            return e === t.Conf.ACTOR_STATS_NOTIFY_TYPE.DIE ? !0 : e === t.Conf.ACTOR_STATS_NOTIFY_TYPE.RESET_FOR_CONTINUE ? !0 : !1
        }
    }, FF.ns.battle.DamageReceiveCountConfig = {
        getConfig: function(e) {
            return n[e]
        }
    }
}), define("scenes/battle/DeathFsm", ["jquery", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf;
    FF.ns.battle.DeathFsm = t.extend({
        initialize: function(e) {
            t.prototype.initialize.apply(this, arguments), this._isDone = !1, this.data = e, this.changeState("IDLE")
        },
        processForStateIdleEntry: function() {
            var t = this;
            e.Deferred().resolve().promise().then(function() {
                return t._playDeadDeferred()
            }).then(function() {
                return t._playDropItemDeferred()
            }).then(function() {
                return t._playMateriaCutinDeferred()
            }).then(function() {
                t._isDone = !0
            })
        },
        processForStateIdleUpdate: function() {
            if (!this._isDone) return;
            this.changeState("END")
        },
        _playDeadDeferred: function() {
            var t = e.Deferred(),
                i = this.data.deadActors,
                s = this.data.judge,
                o = n.BattleViewController.getInstance().createAnimation({
                    animationType: r.ANIMATION_TYPE.DEAD,
                    actorInfo: i,
                    judge: s
                });
            return o.addCallbackOnce("end", function() {
                t.resolve()
            }), o.play(), t.promise()
        },
        _playDropItemDeferred: function() {
            var t = this.data.deadActors,
                i = this.data.judge,
                s = _.filter(t, function(e) {
                    return e.isEnemy()
                }),
                o = n.util.DropItem.give(s, i),
                u = e.Deferred(),
                a = n.BattleViewController.getInstance().createAnimation({
                    animationType: r.ANIMATION_TYPE.DROP_ITEM,
                    dropItemInfo: o
                });
            return a.addCallbackOnce("end", function() {
                n.util.DropItem.applyResult(o), u.resolve()
            }), a.play(), u.promise()
        },
        _playMateriaCutinDeferred: function() {
            if (this.data.judge !== n.Conf.JUDGE.VICTORY) return e.Deferred().resolve().promise();
            var t = n.BattleInfo.getInstance().getDropMaterias();
            if (t.length === 0) return e.Deferred().resolve().promise();
            FF.logger.debug("DROP_MATERIAS", t);
            var r = n.BattleViewController.getInstance().materiaDropView,
                i = e.Deferred().resolve();
            return _.each(t, function(e) {
                i = i.then(function() {
                    return r.showDeferred(n.DataConstructor.getDropMateriaInfo(e))
                })
            }), i.promise()
        }
    })
}), define("scenes/battle/Debug", ["util"], function(e) {
    var t = FF.ns.battle,
        n = 1e3,
        r = {
            _toggleDebugInfo: function() {
                this._debugNo = this._debugNo || 0, this._debugNo++, this._showDebugInfo() || (this._debugNo = 0)
            },
            _showDebugInfo: function() {
                var e = this._debugNo || 0;
                if (e === 0) return !1;
                var n = "";
                if (e === 1) n += "native info. fps:" + FF.scene.fps, this._showDebugNativeInfo(!0);
                else {
                    this._showDebugNativeInfo(!1);
                    var r = 2,
                        i;
                    n === "" && (i = this._makeActorBaseInfo(r), n = i.txt, r += i.pageNum), n === "" && (i = this._makeActorInfo(r), n = i.txt, r += i.pageNum), n === "" && (i = this._makeActorSaInfo(r), n = i.txt, r += i.pageNum), n === "" && (i = this._makeScoreInfo(r), n = i.txt, r += i.pageNum), n === "" && (i = this._makeAiInfo(r), n = i.txt, r += i.pageNum), n === "" && (i = this._showGeneralScore(r), n = i.txt, r += i.pageNum), n === "" && (i = this._makeDamageReceiveCountInfo(r), n = i.txt, r += i.pageNum)
                }
                return t.BattleViewController.getInstance().setDebugText(n), n !== ""
            },
            _makeActorBaseInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.ActorMgr.getAll(),
                    s = Math.ceil(i.length / 8),
                    o = (n - e) * 8;
                return i = i.slice(o, o + 8), _.each(i, function(e) {
                    r += this._getDebugBaseText(e)
                }, this), {
                    txt: r,
                    pageNum: s
                }
            },
            _makeActorInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.ActorMgr.getAll(),
                    s = Math.ceil(i.length / 3),
                    o = (n - e) * 3;
                return i = i.slice(o, o + 3), _.each(i, function(e) {
                    r += this._getDebugActorInfoText(e)
                }, this), {
                    txt: r,
                    pageNum: s
                }
            },
            _makeActorSaInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.ActorMgr.getAll(),
                    s = Math.ceil(i.length / 2),
                    o = (n - e) * 2;
                return i = i.slice(o, o + 2), i.length > 0 && (r += "--- StatusAilments --- {n}"), _.each(i, function(e) {
                    r += this._getDebugActorSaInfoText(e)
                }, this), {
                    txt: r,
                    pageNum: s
                }
            },
            _makeScoreInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.BattleInfo.getInstance().getBattleInitData().battle.score,
                    s = [].concat(_.values(i.general), _.values(i.specific)),
                    o = s.length,
                    u = n - e,
                    a = _.first(s.slice(u, u + 1));
                if (a) {
                    var f = t.Score.toPlainObject(),
                        l = void 0;
                    l || (l = f.general[a.no]), l || (l = f.specific[a.no]), r += JSON.stringify(_.extend({
                        type: a.type
                    }, l))
                }
                return this._debugNoForScore = n + 1, r === "" && (this._scoreInfoLength = s.length, this._debugNoForScore = 0), {
                    txt: r,
                    pageNum: o
                }
            },
            _showGeneralScore: function(e) {
                var n = "",
                    r = 1;
                if (this._debugNo !== e) return {
                    txt: n,
                    pageNum: r
                };
                var i = t.BattleInfo.getInstance().getBattleInitData().battle.score,
                    s = t.Score.toPlainObject();
                if (_.isEmpty(s.general)) return {
                    txt: n,
                    pageNum: r
                };
                n += "---  ---{n}";
                var o = s.general[1].results.val1;
                n += ": " + o + "{n}";
                var u = i.variousInfo.abilityNumDenominator;
                n += "(): " + u + "{n}";
                var a = o / u;
                n += "/: " + a + "{n}", n += "---  ---{n}";
                var f = s.general[2].results.val1;
                n += ": " + f + "{n}";
                var l = s.general[2].results.val2,
                    c = f / l;
                return n += ": " + c + "{n}", {
                    txt: n,
                    pageNum: r
                }
            },
            _makeAiInfo: function(e) {
                var n = this._debugNo || 0,
                    r = 1,
                    i = n - e,
                    s = "";
                return i === 0 && (s = "=== AI Info ==={n}{n}", _.each(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                    s += this._getDebugAiText(e)
                }, this)), {
                    txt: s,
                    pageNum: r
                }
            },
            _showDebugNativeInfo: function(e) {
                kickmotor.nativefn.call("showNativeInfo", {
                    isShow: e,
                    x: 4,
                    y: 20
                })
            },
            _makeDamageReceiveCountInfo: function(e) {
                var n = this._debugNo || 0,
                    r = "",
                    i = t.ActorMgr.getAll(),
                    s = Math.ceil(i.length / 8),
                    o = (n - e) * 8;
                return i = i.slice(o, o + 8), i.length > 0 && (r += "---  --- {n}"), _.each(i, function(e) {
                    r += this._getDebugDamageReceiveCountInfoText(e)
                }, this), {
                    txt: r,
                    pageNum: s
                }
            },
            _getDebugBaseText: function(e) {
                if (!FF.env.isDevelop()) return;
                var t = "";
                if (e.isBuddy()) {
                    var n = e.getSoulStrike();
                    t += sprintf("  [%s]: HP:%d/%d ATB:%d%% SS:%d{n}", e.get("dispName"), e.get("hp"), e.get("maxHp"), _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]), n ? n.get("point") : 0)
                } else t += sprintf("  [%s%d_%d]: Lv:%d HP:%d/%d ATB:%d%% SA:%s{n}", e.get("dispName"), e.get("no"), e.get("paramId"), e.get("lv"), e.get("hp"), e.get("maxHp"), _.min([Math.floor(100 * e.get("elapsedAtbTime") / e.getAtbTime()), 100]), e.statusAilments.getRefs().join("_"));
                return t
            },
            _getDebugAiText: function(e) {
                if (!FF.env.isDevelop()) return;
                var t = function(e) {
                        var t = "";
                        return _.isFunction(e.getDebugTextMap) && _.each(e.getDebugTextMap(), function(e, n) {
                            t += n + ": " + e + "{n}"
                        }), t
                    },
                    n = "";
                if (!_.isUndefined(e.stateMap)) {
                    var r = t(e.stateMap);
                    r !== "" && (n += "[GOD]{n}", n += r, n += "{n}")
                }
                return _.each(e.getChildren(), function(e) {
                    if (!_.isUndefined(e.stateMap)) {
                        var r = t(e.stateMap);
                        r !== "" && (n += sprintf("[%s%d_%d]{n}", e.get("dispName"), e.get("no"), e.getId()), n += r, n += "{n}")
                    }
                }), n
            },
            _getDebugActorInfoText: function(e) {
                var t = "";
                return e.isBuddy() ? t += sprintf("  [%s]:", e.get("dispName")) : t += sprintf("  [%s%d_%d]:", e.get("dispName"), e.get("no"), e.getId()), _.each(["atk", "def", "matk", "mdef", "mnd", "acc", "spd", "eva", "critical", "atkSaCoef"], function(n) {
                    t += sprintf("%s:%s ", n, e.get(n))
                }), t += sprintf("atkEl:%s ", e.get("atkElement")), t += sprintf("atkSa:%s ", this._objectToString(e.get("atkStatusAilments"))), t += sprintf("matkEl:%s ", this._objectToString(e.get("matkElementMap"))), t += sprintf("defAttr:%s ", this._objectToString(e.get("defAttributeMap"))), t += "{n}", t
            },
            _getDebugDamageReceiveCountInfoText: function(e) {
                var n = "",
                    r = e.actorStats.getStats(t.Conf.ACTOR_STATS_TYPE.DAMAGE_RECEIVE_COUNT),
                    i = "";
                return _.each(t.Conf.DAMAGE_RECEIVE_COUNT_TYPE, function(e) {
                    i += sprintf("[%s] : %d, ", e, r.get(e))
                }), n += sprintf("  [%s] %s\n", e.get("dispName"), i), n
            },
            _getDebugActorSaInfoText: function(e) {
                var t = "";
                e.isBuddy() ? t += sprintf("[%s]{n}", e.get("dispName")) : t += sprintf("[%s%d_%d]{n}", e.get("dispName"), e.get("no"), e.getId());
                var n = e.statusAilments.toPlainObject();
                return _.each(n.infoMap, function(e, n) {
                    t += sprintf("* %s : %s {n}", n, JSON.stringify(e))
                }), t
            },
            _objectToString: function(e) {
                return _.map(e, function(e, t) {
                    return t + ":" + e
                }).join(" ")
            },
            increaseSsGauge: function() {
                var e = t.ActorMgr.getAbilityPanelSelector();
                if (!e) return;
                var n = e.getSoulStrike(),
                    r = n.get("point"),
                    i = t.Config.getInstance().get("SoulStrike", "maxSsPoint");
                n.set("point", _.min([r + 50, i]))
            },
            redirectDebugScene: function() {
                var e = location.pathname || "/dff/debug/";
                e.match("debug") || (e = "/dff/debug/"), FF.scene.redirect(e)
            },
            killEnemies: function() {
                _.each(t.ActorMgr.getAliveEnemies(), function(e) {
                    e.set("hp", 0)
                })
            },
            _isProcessed: !1,
            _processOnce: function() {
                if (this._isProcessed) return;
                this._enableBattleDebugContinue(), this._isProcessed = !0
            },
            _enableBattleDebugContinue: function() {
                var n = t.BattleInfo.getInstance().getAppInitDataSessionKey();
                if (n === "debug") {
                    var r = FF.scene.battleEventMgr.battleProcessMgr.continueFsm;
                    r._makeCallbackOfSoulPiece = function(n) {
                        return function() {
                            var i = new t.ContinueTxn,
                                s = t.Conf.CONTINUE_TYPE.SOUL_PIECE;
                            i.setInfo(s, n[s]), i.set("continueId", e.getTime()), i.changeStat("CURED"), t.BattleInfo.getInstance().addNewContinueTxn(i), r._processStartFinally(i)
                        }
                    }
                }
            }
        };
    FF.ns.battle.Debug = {
        toggleInfo: function() {
            if (!FF.env.isDevelop()) return;
            r._toggleDebugInfo()
        },
        update: function() {
            if (!FF.env.isDevelop()) return;
            r._processOnce(), r._showDebugInfo()
        },
        increaseSsGauge: function() {
            if (!FF.env.isDevelop()) return;
            r.increaseSsGauge()
        },
        redirectDebugScene: function() {
            if (!FF.env.isDevelop()) return;
            r.redirectDebugScene()
        },
        openDebugForm: function() {
            if (!FF.env.isDevelop()) return
        },
        killEnemies: function() {
            if (!FF.env.isDevelop()) return;
            r.killEnemies()
        }
    }
}), define("scenes/battle/EnemyContainer", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle,
        n = 1;
    FF.ns.battle.EnemyContainer = e.extend({
        initialize: function(r, i) {
            e.prototype.initialize.apply(this, arguments), _.extend(this._attributes, r), this._children = i || {}, this._dropItemList = [], _.each(i, function(e) {
                e.container = this, this._dropItemList = this._dropItemList.concat(e.get("dropItemList"))
            }, this), this._shouldDeformAllNodesInAppearing = !1;
            var s = r.aiId;
            s && (this.stateMap = t.ai.StateMapBuilder.createById(s, this)), this.containerUid = n++, this.aiArg = new t.ai.AiArgument(r.aiArguments)
        },
        update: function() {
            this.stateMap && this.stateMap.update()
        },
        addChild: function(e) {
            var t = e.get("no");
            this._children[t] = e
        },
        getChild: function(e) {
            var t = this._children[e];
            if (!t) throw new Error("sp enemy child(enemy) not found.no=" + e);
            return t
        },
        getChildren: function() {
            return _.values(this._children)
        },
        getAliveChildren: function() {
            return _.filter(this.getChildren(), function(e) {
                return e.isAlive()
            })
        },
        getId: function() {
            return this.get("id") || 0
        },
        isSpEnemy: function() {
            return this.get("isSpEnemy")
        },
        isAllDead: function() {
            return _.all(this.getChildren(), function(e) {
                return e.isDead()
            })
        },
        getNos: function() {
            return _.keys(this._children)
        },
        getAppearanceAnimationId: function() {
            var e = _.find(this.get("deformAnimationInfo"), function(e) {
                return e.deformTag === "in"
            });
            return e ? e.id : void 0
        },
        getDropItemList: function() {
            return this._dropItemList
        },
        notifyJudgedDeath: function(e) {
            return this.stateMap ? this.stateMap.notifyJudgedDeath(e) : !0
        },
        notifyCommunicationToContainer: function(e) {
            if (!this.stateMap) throw new Error("god-ai is not found");
            return this._notifyCommunication(this.stateMap, e)
        },
        notifyCommunicationToChild: function(e, t) {
            var n = this.getChild(e);
            return this._notifyCommunication(n.stateMap, t)
        },
        _notifyCommunication: function(e, t) {
            if (!_.isString(t.commTag)) throw new Error('invalid "commTag" on params. ' + JSON.stringify({
                params: t
            }));
            var n = e.notifyCommunication(t);
            if (!_.isBoolean(n.isSuccess)) throw new Error('invalid "isSuccess" on result. ' + JSON.stringify({
                params: t,
                result: n
            }));
            return n
        },
        isContinuousBattle: function() {
            return _.any(this.getChildren(), function(e) {
                return e.isContinuousBattle()
            })
        },
        isBuddy: function() {
            return !1
        },
        isEnemy: function() {
            return !0
        },
        isContainer: function() {
            return !0
        },
        setEnabledShouldDeformAllNodesInAppearing: function() {
            this._shouldDeformAllNodesInAppearing = !0
        },
        shouldDeformAllNodesInAppearing: function() {
            return this._shouldDeformAllNodesInAppearing
        },
        getParamIdBySuffixNo: function(e) {
            return +("" + this.getId() + e)
        },
        getMessageIdBySuffixNo: function(e) {
            return +("" + this.getId() + e)
        }
    })
}), define("scenes/battle/EnemyParty", ["lib/ClassBase"], function(e) {
    FF.ns.battle.EnemyParty = e.extend({
        initialize: function() {}
    })
}), define("scenes/battle/EnemyPartyMgr", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = e.extend({
            initialize: function(e) {
                this.activeTarget = new t.ActiveTarget
            },
            setParent: function(e) {
                this.parent = e
            },
            load: function(e) {},
            update: function() {},
            makeResultData: function() {
                return this._allEnemyCsv || (this._allEnemyCsv = this._makeAllEnemyLogInfo()), {
                    current: _.map(t.ActorMgr.getAllEnemies(), function(e) {
                        return [t.BattleInfo.getInstance().get("round"), e.getId(), e.get("no"), e.getBaseParam().get("lv"), Math.floor(e.get("hp") / e.get("maxHp") * 100)]
                    }, this),
                    all: this._allEnemyCsv
                }
            },
            _makeAllEnemyLogInfo: function() {
                var e = [],
                    n = function(t, r, i) {
                        var s = r.shift(),
                            o = t[s];
                        for (var u = 0, a = o.length; u < a; u++) {
                            s === "rounds" && _.extend(i, {
                                round: o[u].round
                            }), s === "enemy" && _.extend(i, {
                                id: o[u].id
                            }), s === "children" && _.extend(i, {
                                no: o[u].no
                            });
                            if (r.length > 0) {
                                var f = [].concat(r);
                                n(o[u], f, i)
                            } else e.push([i.round, i.id, i.no, o[u].params[0].lv])
                        }
                    };
                return n(t.BattleInfo.getInstance().getBattleInitData().battle, ["rounds", "enemy", "children"], {}), e
            }
        }),
        r = void 0;
    FF.ns.battle.EnemyPartyMgr = {
        getInstance: function() {
            return r || (r = new n), r
        }
    }
}), define("scenes/battle/EventFsm", ["lib/ClassBase"], function(e) {
    FF.ns.battle.EventFsm = e.extend({
        initialize: function() {},
        update: function() {
            this.parent.battleUpdate()
        },
        setParent: function(e) {
            this.parent = e
        }
    })
}), define("scenes/battle/ExpireFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.ExpireFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.call(this), this.changeState("IDLE")
        },
        processForStateIdleEntry: function() {
            var e = t.BattleInfo.getInstance().isMo() ? t.Conf.SYSTEM_WINDOW.EXPIRE_MO : t.Conf.SYSTEM_WINDOW.EXPIRE;
            t.BattleViewController.getInstance().showSystemWindow(e, function() {
                t.BattleInfo.getInstance().set("isExpired", !0)
            })
        }
    })
}), define("scenes/battle/ExternalFunc", [], function() {
    var e = FF.ns.battle;
    FF.ns.battle.ExternalFunc = {
        openLoading: function() {
            e.BattleViewController.getInstance().loadingView.open()
        },
        closeLoading: function() {
            e.BattleViewController.getInstance().loadingView.close()
        }
    }
}), define("scenes/battle/ExternalUserAuth", ["jquery", "underscore", "lib/ExternalUserAuth"], function(e, t, n) {
    var r = FF.ns.battle;
    r.ExternalUserAuth = t.extend({}, n, {
        _callCreateHashApiDeferred: function(t) {
            var n = e.Deferred(),
                i = t.guestId,
                s = t.callbackUrl;
            return !i || !s ? n.reject().promise() : (r.Api.createExternalUserAuthHashDeffered(i, s).done(function(e) {
                t.inviteId = e.invite_id, t.hash = e.hash, n.resolve(t)
            }).fail(function() {
                n.reject()
            }), n.promise())
        }
    })
}), define("scenes/battle/MoSnsShareHelper", ["jquery", "underscore", "lib/MoRoomSnsShare"], function(e, t, n) {
    var r = FF.ns.battle;
    r.MoSnsShareHelper = t.extend({}, {
        checkAndClearForSnsShareDeferred: function() {
            return n.checkAndClearForSnsShareDeferred()
        }
    })
}), define("scenes/battle/LotteryBox", ["util", "lib/ClassBase"], function(e, t) {
    FF.ns.battle.LotteryBox = t.extend({
        initialize: function(t, n) {
            this._params = {
                lottery: e.cloneDeep(t)
            }, this.changeBox(n), this.resetBox()
        },
        lot: function() {
            var t = this._box,
                n = e.lot(t, function(e) {
                    return +e
                }, {
                    returnIndex: !0
                });
            return t[n]--, this._isBlank() && this.resetBox(), this._params.lottery[n]
        },
        lotWithout: function(e) {
            if (e.length === 0) return this.lot();
            var t = function(t) {
                    var n = e.indexOf(t) < 0;
                    return n
                },
                n = this._params.lottery,
                r = [];
            _.each(n, function(e, n) {
                if (!t(e)) return;
                r.push(n)
            }, this);
            if (r.length === 0) return FF.ns.battle.Conf.ABILITY_ID_OF.DO_NOTHING;
            var i = _.all(r, function(e) {
                var t = this._box[e];
                return +t <= 0
            }, this);
            if (i) {
                this.resetBox(), i = _.all(r, function(e) {
                    var t = this._box[e];
                    return +t <= 0
                }, this);
                if (i) return FF.ns.battle.Conf.ABILITY_ID_OF.DO_NOTHING
            }
            for (var s = 0; s < 20; s++) {
                var o = this.lot();
                if (!o) throw new Error("invalid box");
                if (t(o)) return o
            }
            var u = -1,
                a = 0,
                f = 0;
            _.each(r, function(e) {
                var t = this._box[e];
                a < t && (u = e, a = t, f = n[e])
            }, this);
            if (f === 0) throw new Error("enable ability is not found");
            return this._box[u]--, this._isBlank() && this.resetBox(), f
        },
        changeBox: function(e) {
            if (_.isEmpty(e) || !_.isArray(e)) throw new Error("invalid box data");
            this._params.box = e, this.resetBox()
        },
        resetBox: function() {
            this._box = e.cloneDeep(this._params.box)
        },
        getCandidates: function() {
            return this._params.lottery
        },
        _isBlank: function() {
            return _.all(this._box, function(e) {
                return +e <= 0
            })
        }
    })
}), define("scenes/battle/MateriaFactory", ["./Conf"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.MateriaFactory = {
        getInfo: function(e) {
            var t = _.find(this.typeMap, function(t) {
                return t.type === e
            }, this);
            if (!t) throw new Error("Materia Info not found.type=" + e);
            return t
        },
        createMateriaHolder: function(e, n) {
            var r = [];
            _.each(n, function(t) {
                var n = this.create(e, t);
                r.push(n)
            }, this);
            var i = new t.MateriaHolder(e, r);
            return i
        },
        create: function(e, n) {
            var r = n.effectType,
                i = this.getInfo(r),
                s = t.materia[i.className];
            if (!s) throw new Error("MateriaInfo not found.type=" + r);
            var o = new s(e, n);
            return o
        },
        typeMap: [{
            type: 1,
            className: "FirstAttackMateria"
        }, {
            type: 2,
            className: "PanelNumMateria"
        }, {
            type: 3,
            className: "ParamMateria"
        }, {
            type: 4,
            className: "ParamAndInflictSaMateria"
        }, {
            type: 5,
            className: "InflictSaMateria"
        }, {
            type: 6,
            className: "InflictSaWhenHpFallsMateria"
        }, {
            type: 7,
            className: "DamageBoostWhenWeaknessMateria"
        }, {
            type: 8,
            className: "DamageBoostByWeaponMateria"
        }, {
            type: 9,
            className: "DamageBoostAbilityMateria"
        }, {
            type: 10,
            className: "DamageBoostElementMateria"
        }, {
            type: 11,
            className: "HealBoostMateria"
        }, {
            type: 12,
            className: "CounterMateria"
        }, {
            type: 13,
            className: "PanelSwapMateria"
        }, {
            type: 14,
            className: "ParamBoostInBuddyDeadMateria"
        }, {
            type: 16,
            className: "ParamBoostInHpDecreaseMateria"
        }, {
            type: 17,
            className: "PanelRandomSwapMateria"
        }, {
            type: 18,
            className: "BlackMagicDamageBoostByWeaponMateria"
        }, {
            type: 19,
            className: "PanelNumMateriaByCategory"
        }, {
            type: 20,
            className: "MateriaBase"
        }, {
            type: 21,
            className: "DamageBoostByWeaponWithAllowableTypesMateria"
        }, {
            type: 22,
            className: "ParamBoostByArmorMateria"
        }, {
            type: 23,
            className: "SoulStrikePointFactorBoostMateria"
        }, {
            type: 24,
            className: "PanelNumMateriaByMultiCategory"
        }, {
            type: 25,
            className: "ParamBoostByWeaponMateria"
        }, {
            type: 26,
            className: "SeqActionByCategoryMateria"
        }, {
            type: 27,
            className: "MateriaBase"
        }, {
            type: 28,
            className: "PanelSwapAbilityInfoMateria"
        }, {
            type: 29,
            className: "DamageReduceMateria"
        }, {
            type: 30,
            className: "MateriaBase"
        }, {
            type: 31,
            className: "PanelSwapAndInflictSaMateria"
        }, {
            type: 32,
            className: "DamageBoostByEquipmentAndExerciseTypeMateria"
        }]
    }
}), define("scenes/battle/MateriaHolder", ["util", "lib/NameConventionFsm"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.MateriaHolder = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.call(this), this._actor = e, this._materias = {}, _.each(n, function(e) {
                this._materias[e.getSlot()] = e
            }, this)
        },
        update: function() {
            _.each(this._materias, function(e) {
                e.update()
            })
        },
        notify: function() {
            var e = arguments;
            _.each(this._materias, function(t) {
                t.notify.apply(t, e)
            })
        },
        getDamageFactorByElement: function(e) {
            var t = n.Config.getInstance().get("MateriaBaseDamageFactor"),
                r = t;
            return _.each(this._materias, function(n) {
                r = r * n.getDamageFactorByElement(e) / t
            }), r
        },
        toPlainObject: function() {
            var e = {};
            return _.each(this._materias, function(t, n) {
                e[n] = t.toPlainObject()
            }), {
                materias: e
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            _.each(this._materias, function(t, n) {
                var r = e.materias[n];
                !r, t.applyPlainObject(r)
            })
        }
    })
}), define("scenes/battle/materiaUnifier/UnifierBase", ["lib/EventBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return !1
        },
        mergeSkill: function(e, t) {},
        limitArgs: function(e) {}
    })
}), define("scenes/battle/materiaUnifier/BlackMagicDamageBoostByWeaponMateriaUnifier", ["./UnifierBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return e.arg2 === t.arg2
        },
        mergeSkill: function(e, t) {
            t.arg1 = 100 + (e.arg1 - 100) + (t.arg1 - 100)
        }
    })
}), define("scenes/battle/materiaUnifier/DamageBoostAbilityMateriaUnifier", ["./UnifierBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return e.arg2 === t.arg2 && e.arg3 === t.arg3
        },
        mergeSkill: function(e, t) {
            t.arg1 = 100 + (e.arg1 - 100) + (t.arg1 - 100)
        }
    })
}), define("scenes/battle/materiaUnifier/DamageBoostByWeaponMateriaUnifier", ["./UnifierBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return e.arg2 === t.arg2
        },
        mergeSkill: function(e, t) {
            t.arg1 = 100 + (e.arg1 - 100) + (t.arg1 - 100)
        }
    })
}), define("scenes/battle/materiaUnifier/DamageBoostWhenWeaknessMateriaUnifier", ["./UnifierBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return !0
        },
        mergeSkill: function(e, t) {
            t.arg1 = 100 + (e.arg1 - 100) + (t.arg1 - 100)
        }
    })
}), define("scenes/battle/materiaUnifier/HealBoostMateriaUnifier", ["./UnifierBase"], function(e) {
    return e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments)
        },
        isSameMateriaArgs: function(e, t) {
            return e.arg2 === t.arg2 && e.arg3 === t.arg3
        },
        mergeSkill: function(e, t) {
            t.arg1 = 100 + (e.arg1 - 100) + (t.arg1 - 100)
        }
    })
}), define("scenes/battle/MateriaUnifier", ["underscore", "./materiaUnifier/BlackMagicDamageBoostByWeaponMateriaUnifier", "./materiaUnifier/DamageBoostAbilityMateriaUnifier", "./materiaUnifier/DamageBoostByWeaponMateriaUnifier", "./materiaUnifier/DamageBoostWhenWeaknessMateriaUnifier", "./materiaUnifier/HealBoostMateriaUnifier"], function(e, t, n, r, i, s) {
    return FF.ns.battle.MateriaUnifier = {
        typeToUnifier: {
            7: i,
            8: r,
            9: n,
            11: s,
            18: t
        },
        unifySkillsIntoMateria: function(t, n) {
            if (!e.isArray(t)) return n;
            if (t.length === 0) return n;
            var r = this,
                i = e.clone(n);
            return e.each(t, function(e) {
                i = r._mergeSkill(e, i)
            }), i
        },
        _mergeSkill: function(t, n) {
            var r = this.typeToUnifier[t.effectType];
            if (!r) return n;
            var i = new r,
                s = e.find(n, function(e) {
                    return e.effectType !== t.effectType ? !1 : i.isSameMateriaArgs(t, e)
                });
            return s ? (i.mergeSkill(t, s), i.limitArgs(s), n) : this._pushNewSkill(t, n)
        },
        _pushNewSkill: function(t, n) {
            var r = e.clone(t);
            return r.slot = n.length + 1, n.push(r), n
        }
    }, FF.ns.battle.MateriaUnifier
}), define("scenes/battle/Message", ["util", "lib/Events", "lib/ClassBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = r.Conf,
        s = {},
        o = void 0,
        u = function(e) {
            var t = e.type,
                n = s[t];
            if (!n) throw new Error("invalid message type.t=" + t);
            return new n(e)
        },
        a = FF.ns.battle.Message = _.extend({
            load: function(e) {
                o = {}, _.each(e, function(e) {
                    o[e.id] = u(e)
                }, this), this._queue = [], this._showingMsgInfo = void 0
            },
            reset: function() {
                _.each(o, function(e) {
                    e.reset()
                })
            },
            getInstanceById: function(e) {
                var t = o[e];
                if (!t) throw new Error("invalid message id=" + e);
                return t
            }
        }, t),
        f = n.extend(_.extend({
            initialize: function(e) {
                this._initData = e, this._init(e), this._displayNum = 0
            },
            reset: function() {
                this._displayNum = 0
            },
            shouldShow: function() {
                if (this._initData.message.length < 1) return !1;
                var e = this._initData.displayType;
                switch (e) {
                    case i.MESSAGE_DISPLAY_TYPE.ONCE:
                        return this._displayNum <= 0;
                    case i.MESSAGE_DISPLAY_TYPE.REPEAT:
                        return !0;
                    default:
                        throw new Error("invalid message display type." + e)
                }
            },
            getMessageInfo: function(e) {
                return e = e || {}, {
                    message: this._initData.message,
                    messageId: this._initData.id ? this._initData.id : void 0,
                    callback: this.onShown.bind(this),
                    duration: e.duration ? e.duration : void 0,
                    showHook: this.onShowHook.bind(this)
                }
            },
            onShowHook: function() {
                this._displayNum++
            },
            onShown: function() {},
            _init: function() {}
        }, t));
    s[i.MESSAGE_TYPE.ACTOR_APPEARED] = f.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorMgr::registerBuddy", this._onRegister), this.listenTo(r.ActorMgr, "ActorMgr::registerEnemy", this._onRegister), this._condActorId = e.arg1
        },
        _onRegister: function(e) {
            this._condActorId === +e.getId() && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_DEAD] = f.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::die", this._onDead), this._condActorId = e.arg1
        },
        _onDead: function(e) {
            this._condActorId === +e.getId() && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_ABILITY] = f.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::changeState", this._onChangeState), this._condActorId = e.arg1, this._condAbilityId = e.arg2
        },
        _onChangeState: function(e, t, n) {
            var r = e.getAbility();
            t === "IN_ACTION" && this._condActorId === +e.getId() && this._condAbilityId === r.get("abilityId") && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_HP_DECREASED] = f.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::addDamage", this._onDamaged), this._condActorId = e.arg1, this._condHp = e.arg2
        },
        _onDamaged: function(e, t) {
            if (this._condActorId !== +e.getId()) return;
            var n = Math.round(e.get("hp") / e.get("maxHp") * 100);
            n < this._condHp && this._show()
        }
    }), s[i.MESSAGE_TYPE.ACTOR_LOOKING_CHANGED] = f.extend({
        _init: function(e) {
            this.listenTo(r.ActorMgr, "ActorBase::changeLooking", this._onChangeLooking), this._condLooking = e.arg1
        },
        _onChangeLooking: function(e, t, n) {
            t === this._condLooking && this._show()
        }
    }), s[i.MESSAGE_TYPE.PROGRAM] = f.extend({})
}), define("scenes/battle/PreBattleFsm", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.PreBattleFsm = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), _.bindAll(this, "_onAppearanceAnimEnd")
        },
        processForStateAppearanceEntry: function() {
            var e = t.BattleInfo.getInstance(),
                n = [];
            _.each(t.ActorMgr.getAliveEnemyContainers(), function(e) {
                var t = e.getAppearanceAnimationId();
                t && n.push({
                    enemyContainer: e,
                    animationId: t,
                    shouldDeformAllNodes: e.shouldDeformAllNodesInAppearing()
                })
            });
            var r = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.APPEARANCE,
                deformInfo: n,
                round: e.get("round"),
                roundNum: e.get("roundNum"),
                materiaBoostBuddies: this.getMateriaBoostBuddies()
            });
            r.addCallbackOnce("end", this._onAppearanceAnimEnd), r.play()
        },
        _onAppearanceAnimEnd: function() {
            this.changeState("END")
        },
        getMateriaBoostBuddies: function() {
            var e = t.BattleInfo.getInstance(),
                n = {};
            return n.exp = _.filter(e.getMateriaBoostExpBuddies(), function(t) {
                return e.get("round") !== 1 ? !1 : t.isAlive()
            }), n.gil = _.filter(e.getMateriaBoostGilBuddies(), function(t) {
                return e.get("round") !== 1 ? !1 : !0
            }), n
        }
    })
}), define("scenes/battle/RemoteLogger", ["lib/RemoteLogger"], function(e) {
    FF.ns.battle.RemoteLogger = e
}), define("scenes/battle/Score", ["lib/EventBase", "lib/Events"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf,
        i = e.extend({
            initialize: function(t) {
                e.prototype.initialize.apply(this, arguments), this._initData = t, this._results = {
                    no: this.getNo(),
                    val1: 0,
                    val2: 0,
                    val3: 0,
                    val4: 0,
                    val5: 0
                }, this._init(t)
            },
            _init: function() {},
            getNo: function() {
                return this._initData.no
            },
            getType: function() {
                return this._initData.type
            },
            makeResultData: function() {
                return this._results
            },
            toPlainObject: function() {
                return {
                    attributes: this._attributes,
                    results: this._results
                }
            },
            applyPlainObject: function(e) {
                _.extend(this._attributes, e.attributes), this._results = e.results
            }
        }),
        s = {};
    s[r.SCORE_TYPE.ACTION_NUM] = i.extend({
        _init: function() {
            this.listenTo(n.ActorMgr, "ActorBase::entryInAction", this._onEntryInAction)
        },
        _onEntryInAction: function(e) {
            if (!e.isBuddy()) return;
            this._results.val1++
        }
    }), s[r.SCORE_TYPE.DAMAGED_RATE] = i.extend({
        _init: function() {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(n.ActorMgr, "ActorMgr::registerBuddy", this._onRegisterBuddy), this.listenTo(n.Score, "Score::resetForContinue", this._onContinue)
        },
        _onRegisterBuddy: function(e) {
            this._results.val2 += e.get("maxHp")
        },
        _onDamage: function(e, t) {
            var n = t.actualDamage,
                r = t.receiver;
            if (!r || !r.isBuddy()) return;
            if (t.isRecovery) return;
            if (n <= 0) return;
            if (t.ignoreCalcDamagedRateScore) return;
            this._results.val1 += n
        },
        _onContinue: function() {
            this._results.val2 = 0, _.each(n.ActorMgr.getAllBuddies(), function(e) {
                this._results.val2 += e.get("maxHp")
            }, this)
        }
    }), s[r.SCORE_TYPE.DROP_NUM] = i.extend(), s[r.SCORE_TYPE.DEFEAT_NUM] = i.extend({
        _init: function() {
            this.set("defeated", this.get("defeated") || {}), this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this.listenTo(n.ActorMgr, "ActorBase::rise", this._onRise)
        },
        _onDie: function(e) {
            if (!e.isBuddy()) return;
            var t = this.get("defeated");
            t[e.getUid()] = !0, this._results.val1 = this._calcDefeatedNum()
        },
        _onRise: function(e) {
            if (!e.isBuddy()) return;
            var t = this.get("defeated");
            t[e.getUid()] = !1, this._results.val1 = this._calcDefeatedNum()
        },
        _calcDefeatedNum: function() {
            var e = 0,
                t = this.get("defeated");
            return _.each(t, function(t) {
                t && e++
            }), e
        }
    }), s[r.SCORE_TYPE.ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condElement = +e.arg2
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (t.element === this._condElement || _.contains(t.possibleElements, this._condElement)) this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condElement = +e.arg2, this._condLooking = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            if (t.element === this._condElement || _.contains(t.possibleElements, this._condElement)) this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condElement = +e.arg2, this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage)
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            t.isDamage && (t.element === this._condElement || _.contains(t.possibleElements, this._condElement)) && (this._results.val1 = 0)
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condElement = +e.arg2, this._condLooking = +e.arg3, this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage)
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            t.isDamage && (t.element === this._condElement || _.contains(t.possibleElements, this._condElement)) && (this._results.val1 = 0)
        }
    }), s[r.SCORE_TYPE.DAMAGE_REDUCED] = i.extend({
        _init: function(e) {
            this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condHalf = +e.arg3, this._condAbsorption = +e.arg4, this._condVoid = +e.arg5, this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage)
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                i = t.receiver,
                s = t.ability,
                o = t.advantage;
            if (!i || !i.isBuddy()) return;
            if (!n || !n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!s || s.get("abilityId") !== this._condAbilityId) return;
            this._condHalf && o === r.ADVANTAGE.HALF && (this._results.val1 = 1), this._condAbsorption && o === r.ADVANTAGE.ABSORPTION && (this._results.val1 = 1), this._condVoid && o === r.ADVANTAGE.VOID && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.WITHOUT_SPECIAL_EQUIPMENT] = i.extend({}), s[r.SCORE_TYPE.DEFEAT_BEFORE_ABILITY] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condNum = +e.arg3 || 1, this.set("num", this.get("num") || 0), this.listenTo(n.ActorMgr, "ActorBase::notifyAbilityBegun", this._onEntryInAction)
        },
        _onEntryInAction: function(e, t) {
            var n = t.executer;
            if (!n || !n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!t || t.get("abilityId") !== this._condAbilityId) return;
            this.set("num", this.get("num") + 1);
            if (this.get("num") < this._condNum) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.DEFEAT_BEFORE_LOOKING] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this.listenTo(n.ActorMgr, "ActorBase::changeBaseParam", this._onChangeParam), this.listenTo(n.ActorMgr, "ActorBase::set", this._onSet)
        },
        _onChangeParam: function(e, t, n) {
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 = 0
        },
        _onSet: function(e, t, n, r) {
            if (t !== "looking") return;
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("abilityId") !== this._condAbilityId) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condAbilityId = +e.arg2, this._condLooking = +e.arg3, this._condSuccess = +e.arg4
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("abilityId") !== this._condAbilityId) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_JUMP_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            if (!t.isFlightAttack) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyId = +e.arg1, this._condSaId = +e.arg2, this._condSaId2 = +e.arg3 || 0, this._condSaId3 = +e.arg4 || 0
        },
        _onStatusAilments: function(e, t) {
            var n = t.receiver,
                r = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            r = _.some([this._condSaId, this._condSaId2, this._condSaId3], function(e) {
                return this._match(e, t.statusAilments)
            }, this), r && (this._results.val1 = 1)
        },
        _match: function(e, t) {
            return e ? _.some(t, function(t) {
                return +t === e
            }) : !1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyId = +e.arg1, this._condSaId = +e.arg2, this._condLookings = [], this._condLookings.push(+e.arg3), e.arg4 && this._condLookings.push(+e.arg4), e.arg5 && this._condLookings.push(+e.arg5)
        },
        _onStatusAilments: function(e, t) {
            var n = t.receiver,
                r = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!_.contains(this._condLookings, n.get("looking"))) return;
            _.each(t.statusAilments, function(e) {
                if (+e === this._condSaId) return r = !0, !1
            }, this), r && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_EXERCISE_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condLooking = +e.arg3, this._condSuccess = +e.arg4
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_EXERCISE] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condSuccess = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.NOT_ENEMY_EXERCISE_TIMING] = i.extend({
        _init: function(e) {
            this._results.val1 = 1, this.listenTo(n.ActorMgr, "ActorBase::applyDamageObject", this._onDamage), this._condEnemyId = +e.arg1, this._condExerciseType = +e.arg2, this._condLooking = +e.arg3, this._condSuccess = +e.arg4
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (!r || r.get("exerciseType") !== this._condExerciseType) return;
            if (n.get("looking") !== this._condLooking) return;
            if (this._condSuccess && !t.canHit) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.NOT_DEFEAT] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._results.val1 = 1
        },
        _onDamage: function(e, t) {
            var n = t.receiver,
                r = t.executer;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyId) return;
            if (!n || !n.isBuddy()) return;
            if (n.hasReraise()) return;
            if (n.hasGuts()) return;
            t.prevHp > 0 && t.currHp <= 0 && (this._results.val1 = 0)
        }
    }), s[r.SCORE_TYPE.NOT_DEFEAT_IN_ROUND] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this._condRound = +e.arg1, this._results.val1 = 1
        },
        _onDie: function(e) {
            if (n.BattleInfo.getInstance().get("round") !== this._condRound) return;
            if (e.isEnemy()) return;
            this._results.val1 = 0
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_DAMAGED_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            if (i.get("isEffectOfStatusAilements")) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_ABILITY_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2, this._condAbilityId = +e.arg3
        },
        _onDamage: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = t.ability;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            if (!i || i.get("abilityId") !== this._condAbilityId) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_STATUS_AILMENTS_BY_ENEMY] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addStatusAilments", this._onStatusAilments), this._condEnemyExecuterId = +e.arg1, this._condEnemyReceiverId = +e.arg2, this._condSaId = +e.arg3
        },
        _onStatusAilments: function(e, t) {
            var n = t.executer,
                r = t.receiver,
                i = !1;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyExecuterId) return;
            if (!r.isEnemy()) return;
            if (r.getId() !== this._condEnemyReceiverId) return;
            _.each(t.statusAilments, function(e) {
                +e === this._condSaId && (i = !0)
            }, this), i && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.DEFEAT_ENEMY_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this.listenTo(n.ActorMgr, "ActorEnemy::dieForcibly", this._onDie), this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this._condDefeatNum = +e.arg3, this._results.val1 = 0
        },
        _onDie: function(e) {
            if (e.isBuddy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (e.get("looking") !== this._condLooking) return;
            this._results.val1 += 1
        }
    }), s[r.SCORE_TYPE.SUCCESS_ENEMY_CUSTOM_PARAM_DECREASE_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::setBoost", this._onSetBoost), this._condEnemyId = +e.arg1, this._condParamName = e.arg2, this._condLookings = [], e.arg3 && this._condLookings.push(+e.arg3), e.arg4 && this._condLookings.push(+e.arg4), e.arg5 && this._condLookings.push(+e.arg5)
        },
        _onSetBoost: function(e, t, n) {
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (this._condLookings.length && !_.contains(this._condLookings, e.get("looking"))) return;
            if (n >= 0) return;
            t === this._condParamName && (this._results.val1 = 1)
        }
    }), s[r.SCORE_TYPE.DEFEAT_ENEMY_ORDER] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::die", this._onDie), this.listenTo(n.ActorMgr, "ActorEnemy::dieForcibly", this._onDie), this._condEnemyId = +e.arg1, this._condFirstLookings = [], this._condLastLookings = [], e.arg2 && this._condFirstLookings.push(+e.arg2), e.arg3 && this._condFirstLookings.push(+e.arg3), e.arg4 && this._condLastLookings.push(+e.arg4), e.arg5 && this._condLastLookings.push(+e.arg5), this.set("defeatedLookings", []), this._results.val1 = 0
        },
        _onDie: function(e) {
            if (e.isBuddy()) return;
            if (e.getId() !== this._condEnemyId) return;
            var t = this.get("defeatedLookings");
            _.contains(t, e.get("looking")) || t.push(e.get("looking")), this.set("defeatedLookings", t)
        },
        makeResultData: function() {
            var e = this.get("defeatedLookings");
            if (this._condFirstLookings.length > 0) {
                var t = _.first(e, this._condFirstLookings.length),
                    n = _.intersection(this._condFirstLookings, t);
                if (n.length !== this._condFirstLookings.length) return this._results.val1 = 0, this._results
            }
            if (this._condLastLookings.length > 0) {
                var r = _.last(e, this._condLastLookings.length),
                    i = _.intersection(this._condLastLookings, r);
                if (i.length !== this._condLastLookings.length) return this._results.val1 = 0, this._results
            }
            return this._results.val1 = 1, this._results
        }
    }), s[r.SCORE_TYPE.HAS_BUDDY] = i.extend(), s[r.SCORE_TYPE.SUCCESS_ENEMY_SA_UNSET_TIMING] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::unsetStatusAilments", this._onUnsetSa), this._condEnemyId = +e.arg1, this._condSaId = +e.arg2, this._condLooking = void 0, +e.arg3 > 0 && (this._condLooking = +e.arg3)
        },
        _onUnsetSa: function(e, t) {
            if (!t.executer) return;
            if (!t.executer.isBuddy()) return;
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            if (!_.contains(t.intersectionUnsetSaIds, this._condSaId)) return;
            if (this._condLooking && e.get("looking") !== this._condLooking) return;
            this._results.val1 = 1
        }
    }), s[r.SCORE_TYPE.NOT_DEFEAT_BUDDY_NUM] = i.extend(), s[r.SCORE_TYPE.ENEMY_TIMING_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(n.ActorMgr, "ActorBase::set", this._onSet), this._condEnemyId = +e.arg1, this._condLooking = +e.arg2, this._condAttackNum = +e.arg3, this.set("resultAttackNum", 0), this.set("maxResultAttackNum", 0), this._results.val1 = 0
        },
        _onSet: function(e, t, n, r) {
            if (t !== "looking") return;
            if (!e.isEnemy()) return;
            if (e.getId() !== this._condEnemyId) return;
            var i = this.get("resultAttackNum");
            this.get("maxResultAttackNum") < i && this.set("maxResultAttackNum", i), this.set("resultAttackNum", 0)
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (n.get("looking") !== this._condLooking) return;
            var r = this.get("resultAttackNum") + 1;
            this.set("resultAttackNum", r)
        },
        makeResultData: function() {
            var e = Math.max(this.get("resultAttackNum"), this.get("maxResultAttackNum"));
            return e >= this._condAttackNum && (this._results.val1 = 1), this._results
        }
    }), s[r.SCORE_TYPE.ENEMY_ABILITY_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this.listenTo(n.ActorMgr, "ActorMgr::exitInAction", this._onExitInAction), this._condEnemyId = +e.arg1, this._condElement = +e.arg2, this._condAttackNum = +e.arg3, this._condLooking = void 0, +e.arg4 > 0 && (this._condLooking = +e.arg4), this.set("attackNum", 0), this.set("attackExecuted", !1), this._results.val1 = 0
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (t.element !== this._condElement) return;
            if (this._condLooking && n.get("looking") !== this._condLooking) return;
            this.set("attackExecuted", !0)
        },
        _onExitInAction: function() {
            var e = this.get("attackExecuted");
            e && (this.set("attackExecuted", !1), this.set("attackNum", this.get("attackNum") + 1))
        },
        makeResultData: function() {
            return this.get("attackNum") >= this._condAttackNum && (this._results.val1 = 1), this._results
        }
    }), s[r.SCORE_TYPE.SUCCESS_BUDDY_SA_UNSET_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::unsetStatusAilments", this._onStatusAilments), this._condNum = +e.arg1, this._condSaId = +e.arg2, this._condSaId2 = +e.arg3 || 0, this._condSaId3 = +e.arg4 || 0, this.set("unsetNum", 0), this._results.val1 = 0
        },
        _onStatusAilments: function(e, t) {
            var n = t.receiver;
            if (!n.isBuddy()) return;
            var r = t.unsetStatusAilments,
                i = _.some([this._condSaId, this._condSaId2, this._condSaId3], function(e) {
                    if (e === 0) return;
                    return _.some(r, function(t) {
                        return +t === e
                    })
                });
            i && this.set("unsetNum", this.get("unsetNum") + 1)
        },
        makeResultData: function() {
            return this.get("unsetNum") >= this._condNum && (this._results.val1 = 1), this._results
        }
    }), s[r.SCORE_TYPE.SUCCESS_BUDDY_RISE_NUM] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::rise", this._onRise), this.listenTo(n.ActorMgr, "ActorBase::reraise::rise", this._onRise), this._condNum = +e.arg1, this.set("riseNum", 0), this._results.val1 = 0
        },
        _onRise: function(e) {
            if (!e.isBuddy()) return;
            this.set("riseNum", this.get("riseNum") + 1)
        },
        makeResultData: function() {
            return this.get("riseNum") >= this._condNum && (this._results.val1 = 1), this._results
        }
    }), s[r.SCORE_TYPE.WITHOUT_CONTINUE] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorMgr::resetBuddiesForContinue", this._onContinue), this._results.val1 = 1
        },
        _onContinue: function() {
            this._results.val1 = 0
        }
    });
    var o = function(e) {
        var t = e.type,
            n = s[t];
        if (!n) throw new Error("invalid score type.t=" + t);
        return new n(e)
    };
    s[r.SCORE_TYPE.ENEMY_WEAKNESS] = i.extend({
        _init: function(e) {
            this.listenTo(n.ActorMgr, "ActorBase::addDamage", this._onDamage), this._condEnemyId = +e.arg1, this._condLookings = [], e.arg2 && this._condLookings.push(+e.arg2), e.arg3 && this._condLookings.push(+e.arg3), e.arg4 && this._condLookings.push(+e.arg4), e.arg5 && this._condLookings.push(+e.arg5), this._shouldReagardLookings = this._condLookings.length > 0, this._results.val1 = 0
        },
        _onDamage: function(e, t) {
            var n = t.receiver;
            if (!n.isEnemy()) return;
            if (n.getId() !== this._condEnemyId) return;
            if (this._shouldReagardLookings && !_.contains(this._condLookings, n.get("looking"))) return;
            t.isWeakness && (this._results.val1 = 1)
        }
    });
    var u = void 0;
    FF.ns.battle.Score = _.extend({
        TYPE: r.SCORE_TYPE,
        load: function(e) {
            var t = 0,
                n = 0;
            u = {}, _.each(["general", "specific"], function(r) {
                var i = e[r];
                u[r] = {};
                if (!i) return;
                for (t = 0, n = i.length; t < n; t++) u[r][i[t].no] = o(i[t])
            })
        },
        makeResultData: function() {
            var e = 0,
                t = 0,
                n = {};
            return _.each(u, function(e, t) {
                n[t] = [], _.each(e, function(e, r) {
                    n[t].push(e.makeResultData())
                })
            }), n
        },
        _getInstance: function(e, t) {
            return u[e][t]
        },
        _getInstanceMap: function() {
            return u
        },
        resetForContinue: function() {
            this.trigger("Score::resetForContinue")
        },
        toPlainObject: function() {
            var e = {},
                t = 0,
                n = 0;
            return _.each(u, function(t, n) {
                e[n] || (e[n] = {}), _.each(t, function(t, r) {
                    e[n][r] = t.toPlainObject()
                })
            }), e
        },
        applyPlainObject: function(e) {
            if (!e) return;
            var t = 0,
                n = 0;
            _.each(u, function(t, n) {
                _.each(t, function(t, r) {
                    if (!e[n] || !e[n][r]) throw new Error("invalid plain object data");
                    t.applyPlainObject(e[n][r])
                })
            })
        }
    }, t)
}), define("scenes/battle/StatusAilments", ["util", "lib/EventBase"], function(e, t) {
    function s(e, t) {
        for (var n = 0, r = e.length; n < r; ++n) {
            var i = e[n];
            if (t.indexOf(i) >= 0) return !0
        }
        return !1
    }

    function o(e, t, r, s, o) {
        if (n.BattleInfo.getInstance().isMo() && !n.BattleInfo.getInstance().isMoHost()) return;
        var u = n.StatusAilmentsConfig.getParam(t);
        if (!u.funcMap) return;
        var a = u.funcMap[r];
        if (!a) return;
        var f = i[a];
        if (!f) throw new Error("sa func not found.name=" + a);
        return f.call(e, t, e._infoMap[t], u, s, o)
    }

    function u(e, t, n, r) {
        var i = n.get("mnd"),
            s = r.get("mnd"),
            o = t.a,
            u = t.b,
            a = t.c,
            f = Math.floor(i * o + s * u + a);
        return FF.logger.info("SA_DURATION", f, "emnd", i, "emnd", s, "a", o, "b", u, "c", a), f
    }

    function a(e, t, r) {
        var i = n.Config.getInstance(),
            s = n.Conf;
        switch (r) {
            case "ALL":
                return !0;
            case "PHYSICAL":
                return e === n.Conf.EXERCISE_TYPE.PHYSICAL;
            case "MAGIC":
                return _.contains(i.get("MagicExerciseTypes"), e);
            case "BASIC_MAGIC":
                return _.contains(i.get("BasicMagicExerciseTypes"), e);
            case "SA_MIGHTY_GUARD":
                return _.contains(i.get("ExerciseTypesWithoutPhysical"), e) && _.contains(i.get("MightyGuardEffectedCalcTypes"), t);
            case "COUNTER_AIMING":
                return _.contains(i.get("CounterAimingEffectedExerciseTypes"), e) && _.contains(i.get("CounterAimingEffectedCalcTypes"), t);
            case "SA_MIRAGE":
                return _.any([{
                    exerciseTypes: [s.EXERCISE_TYPE.PHYSICAL],
                    calcTypes: [s.CALC_TYPE.ATTACK, s.CALC_TYPE.DAMAGED_HP, s.CALC_TYPE.FIXED_DAMAGE]
                }, {
                    exerciseTypes: [s.EXERCISE_TYPE.INBORN],
                    calcTypes: [s.CALC_TYPE.ATTACK, s.CALC_TYPE.FRACTION]
                }], function(n) {
                    return _.contains(n.exerciseTypes, e) && _.contains(n.calcTypes, t)
                });
            case "SA_RADIANT_SHIELD":
                return _.contains(i.get("RadiantShieldEffectedCalcTypes"), t);
            case "DAMAGE_BARRIER":
                return _.contains(i.get("DamageBarrierEffectedCalcTypes"), t)
        }
        return !1
    }

    function f(e, t, n) {
        return a(e, t, n)
    }
    var n = FF.ns.battle,
        r = n.Conf,
        i = {};
    i.updateTimerDefault = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= t.duration && this.unset(e)
    }, i.updateTimerPoison = function(e, t, i, s) {
        t.timer += s.dt, t.intervalTimer += s.dt, t.duration && t.timer >= t.duration ? this.unset(e) : t.intervalTimer >= i.interval && (n.Commander.getInstance().register(r.ABILITY_ID_OF.POISON, this._actor, {
            damageFactor: i.damageFactor,
            reasonStatusAilmentId: e
        }, {
            interruptStatusAilments: !0
        }), t.intervalTimer = 0)
    }, i.updateTimerDoom = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= n.interval && (t.count--, FF.logger.debug("DOOM", t.count), t.timer = 0)
    }, i.updateTimerMagicalMine = function(e, t, n, r) {
        i.updateTimerDoom.apply(this, arguments), t.count < 0 && this._actor.isInDefense() && this.unset(e)
    }, i.entryRage = function(e, t, n, r) {
        t.abilityIds = r.abilityIds.concat()
    }, i.exitActionRage = function(e, t, n, r) {
        var i = this._actor.getLastAbility();
        if (!i.get("isPositiveIncontrollable")) return;
        var s = t.abilityIds;
        s.shift(), 0 === s.length && this.unset(e)
    }, i.entryChangeCastTime = function(e, t, n, r) {
        var i = ["castTimeFactor", "validAbilityUseCountForChangeCastTime", "allAbilitiesForChangeCastTime", "abilityCategoryIdForChangeCastTime", "abilityCondNameForChangeCastTime", "abilityUseCountInfinityFlag"];
        _.each(i, function(e) {
            t[e] = t[e] || n[e]
        }), t.changeCastTimeFlag = !1
    }, i.entryCastAbilityUseCountForChangeCastTime = function(e, t, n, r) {
        t.changeCastTimeFlag = !0
    }, i.exitActionAbilityUseCountForChangeCastTime = function(e, t, n, r) {
        if (t.abilityUseCountInfinityFlag) {
            t.changeCastTimeFlag = !1;
            return
        }
        t.changeCastTimeFlag && t.validAbilityUseCountForChangeCastTime--, t.changeCastTimeFlag = !1, t.validAbilityUseCountForChangeCastTime <= 0 && this.unset(e)
    }, i.updateTimerChangeCastTimeByDuration = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= t.duration && this._actor.isStateIdle() && this.unset(e)
    }, i.entryAbilityUseCountForChangeFlightDuration = function(e, t, n, r) {
        t.countChangeFlightDuration = n.countChangeFlightDuration, t.flightDuration = n.flightDuration
    }, i.entryActionAbilityUseCountForChangeFlightDuration = function(e, t, n, r) {
        t.countChangeFlightDuration--
    }, i.exitActionAbilityUseCountForChangeFlightDuration = function(e, t, n, r) {
        t.countChangeFlightDuration <= 0 && this.unset(e)
    }, i.updateTimerRegen = function(e, t, i, s) {
        t.timer += s.dt, t.intervalTimer += s.dt, t.timer >= t.duration ? this.unset(e) : t.intervalTimer >= i.interval && (n.Commander.getInstance().register(r.ABILITY_ID_OF.REGEN, this._actor, {
            damageFactor: i.damageFactor,
            reasonStatusAilmentId: e
        }, {
            interruptStatusAilments: !0
        }), t.intervalTimer = 0)
    }, i.end = function(e, t) {
        this.unset(e)
    }, i.damagedForSleep = function(e, t, r, i) {
        var s = i.damageObj,
            o = s.ability;
        o && o.get("exerciseType") === n.Conf.EXERCISE_TYPE.PHYSICAL && !s.skipUnsetSleepWhenDamaged && this.unset(e)
    }, i.damagedForConfusion = function(e, t, r, i) {
        var s = i.damageObj,
            o = s.ability;
        o && o.get("exerciseType") === n.Conf.EXERCISE_TYPE.PHYSICAL && !s.skipUnsetConfusionWhenDamaged && this.unset(e)
    }, i.damagedForGreasedLightning = function(e, t, r, i) {
        var s = i.damageObj,
            o = s.type;
        if (!s.canHit) return;
        if (!_.contains(n.Config.getInstance().get("RemovableGreasedLightningCalcTypes"), o)) return;
        if (!s.actualDamage || s.actualDamage <= 0) return;
        this.unset(e)
    }, i.entryParamBooster = function(e, t, n, r, i) {
        this.startBoost(t, n, r, i)
    }, i.entryTrance = function(t, n, r, i) {
        var s = e.cloneDeep(r.boosts);
        for (var o = 0, u = s.length; o < u; o++) {
            var a = i && i.boosts && i.boosts[o] && i.boosts[o].rate;
            if (!(_.isNumber(a) && a > 0)) throw new Error("unexpected rate. idx:" + o + " rate:" + JSON.stringify(a));
            s[o].rate = a
        }
        r = _.extend({}, r, {
            boosts: s
        }), this.startBoost(n, r, i), this.swapSparePanel(n, r, i)
    }, i.updateTimerTrance = function(e, t, n, r) {
        t.timer += r.dt
    }, i.exitActionTrance = function(e, t, n, r) {
        t.timer >= t.duration && this.unset(e)
    }, i.exitTrance = function(e, t, n, r) {
        this.finishBoost(t), this.rewindSparePanel(t)
    }, i.updateTimerParamBooster = function(e, t, n, r) {
        t.timer += r.dt, t.timer >= t.duration && this.unset(e)
    }, i.exitParamBooster = function(e, t, n, r) {
        this.finishBoost(t)
    }, i.procChargeActionEntry = function(e, t, n, r) {
        this.startBoost(t, n, r), t.isBoost = !0
    }, i.procChargeActionExit = function(e, t, n) {
        t.isBoost && (this.finishBoost(t), this.unset(e))
    }, i.entryCounter = function(e, t, r, i) {
        var s = [],
            o = this._actor.counters,
            u = {};
        e === n.Conf.STATUS_AILMENTS_TYPE.COUNTER_AIMING && (u.isPossibleMultiCounter = !0, u.priority = n.Config.getInstance().get("CounterPriority", "COUNTER_AIMING")), _.each(r.counters, function(e) {
            var t = o.add(e.abilityId, e.conditionType, e.conditionValue, e.rate, u);
            s.push(t)
        }, this), t.counterIds = s
    }, i.exitCounter = function(e, t, n) {
        if (!t.counterIds) return;
        var r = this._actor.counters;
        _.each(t.counterIds, function(e) {
            r.remove(e)
        }, this)
    }, i.entryLimit = function(e, t) {
        t.count = 0
    }, i.damageCalculateHookForCanNotHitWithDamaged = function(e, t, n, r) {
        var i = r.damageObj,
            s = i.ability.get("exerciseType");
        if (!i) throw new Error("damage object required.");
        !i.canHit && f(s, i.type, n.canNotHit) && (t.count++, t.count >= n.limit && this.unset(e))
    }, i.entryHpStock = function(e, t, n, r) {
        this.consumeHpStockAction(e, t)
    }, i.setupNewBattleForHpStock = function(e, t, n, r) {
        this.consumeHpStockAction(e, t)
    }, i.damagedForHpStock = function(e, t, n, r) {
        this.consumeHpStockAction(e, t)
    }, i.decreaseDoomCount = function(e, t, n, r) {
        if (!this.hasPureDoom()) {
            this.unset(e);
            return
        }
        var i = this.havingPureDoomId(),
            s = this._infoMap[i];
        s.count -= n.decreaseCount, FF.logger.debug("DOOM", s.count), this.unset(e)
    }, i.setupNewBattleForRadiantShield = function(e, t, n, r) {
        t.radiantShieldQueue = []
    }, i.updateTimerRadiantShield = function(e, t, n, r) {
        this.registerRadiantShieldAction(e, t, n), i.updateTimerDefault.apply(this, arguments)
    }, i.damagedForRadiantShield = function(e, t, n, r) {
        this.addToRadiantShieldQueue(e, t, n, r)
    }, i.entryParamBoostAndChangeCastTime = function(e, t, n, r, s) {
        i.entryParamBooster.call(this, e, t, n, r, s), i.entryChangeCastTime.call(this, e, t, n, r)
    }, i.entryDamageBarrier = function(e, t, n, r) {
        var i = this._actor;
        t.damageBarrierRemainHp = Math.ceil(i.get("maxHp") * (n.damageBarrierRate / 100))
    }, i.updateSummoning = function(e, t, n, r) {
        this.hasTrance() || this.unset(e)
    }, FF.ns.battle.StatusAilments = t.extend({
        initialize: function(e) {
            this._actor = e, this._statusAilments = [], this._infoMap = {}
        },
        toPlainObject: function() {
            return {
                statusAilments: this._statusAilments,
                infoMap: this._infoMap
            }
        },
        applyPlainObject: function(e) {
            if (!e) return;
            this._statusAilments = e.statusAilments, this._infoMap = e.infoMap
        },
        set: function(e, t, i, s) {
            i = i || {}, s = s || {}, e = +e;
            if (!n.StatusAilmentsConfig.isDefinedStatus(e)) throw new Error("status ailments not found.id=" + e);
            if (!t) throw new Error("executer required.");
            e === r.STATUS_AILMENTS_TYPE.PETRIFACTION && this._actor.isEnemy() && (e = r.STATUS_AILMENTS_TYPE.INSTANT_DEATH), e === r.STATUS_AILMENTS_TYPE.DEATH && this.hasReraise() && (e = r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, i = {
                infoMap: {
                    hpRate: this.getHpRateFromParam(this.havingReraiseId())
                }
            });
            var a = this._statusAilments,
                f = 0,
                l = void 0,
                c = n.StatusAilmentsConfig.getParam(e);
            if (c.canNotOverwrite && this.has(e)) return !1;
            if (this._actor.isEnemy()) {
                if (!!c.canNotSetToEnemy) return !1
            } else if (!!c.canNotSetToBuddy) return !1;
            var h = [];
            for (f = 0; f < a.length; ++f) {
                l = a[f];
                var p = n.StatusAilmentsConfig.judgeExclusive(e, l);
                switch (p) {
                    case r.STATUS_AILMENTS_EXCLUSIVE.TOGETHER:
                        break;
                    case r.STATUS_AILMENTS_EXCLUSIVE.BLOCK:
                        return h = [], !1;
                    case r.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE:
                        h.push(l);
                        break;
                    default:
                        throw new Error("unknown exclusive judge")
                }
            }
            for (f = 0; f < h.length; ++f) this.unset(h[f]);
            c.resetActorWhenSet && (FF.logger.info("reset actor. inflicted sa." + e), this._actor.reset()), this.isCancelCast(e) && this._actor.isStateInCast() && this._actor.getAbility().isMagic() && (FF.logger.info("reset actor. inflicted silence in cast."), this._actor.reset()), e === r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE && this._actor.reset();
            var d = {
                timer: 0,
                intervalTimer: 0
            };
            if (c.duration) d.duration = u(e, c.duration, t, this._actor);
            else if (c.durationForSide) {
                var v;
                this._actor.isBuddy() ? v = c.durationForSide.buddy : this._actor.isEnemy() && (v = c.durationForSide.enemy);
                if (!v) throw new Error("missing duration setting");
                d.duration = u(e, v, t, this._actor)
            }
            return c.count > 0 && (d.count = c.count), c.substitutes && (d.substitutes = c.substitutes), c.isHpStock && (d.consumedHpStock = 0, d.maxConsumableHpStock = c.maxConsumableHpStock), e === r.STATUS_AILMENTS_TYPE.RADIANT_SHIELD && (d.radiantShieldQueue = []), e === r.STATUS_AILMENTS_TYPE.DAMAGE_BARRIER && (d.damageBarrierRemainHp = 0), i.infoMap && _.extend(d, i.infoMap), FF.logger.debug("SA_SET", e, d), this._infoMap[e] = d, this._statusAilments.push(e), o(this, e, "entry", i, s), this.trigger("StatusAilments::set", e), !0
        },
        unset: function(e) {
            e = +e;
            if (!e) throw new Error("sa id required");
            var t = this._statusAilments.indexOf(e);
            if (t < 0) return;
            var r = n.StatusAilmentsConfig.getParam(e);
            if (r.resetActorWhenUnset) {
                FF.logger.info("reset actor. inflicted sa." + e), this._actor.reset(), t = this._statusAilments.indexOf(e);
                if (t < 0) return
            }
            o(this, e, "exit"), this._statusAilments.splice(t, 1), delete this._infoMap[e], this.trigger("StatusAilments::unset", e)
        },
        has: function(e) {
            return this._statusAilments.indexOf(+e) >= 0
        },
        hasAnyByBundleId: function(e) {
            var t = n.StatusAilmentsConfig.getBundle(e),
                r = _.any(t, function(e) {
                    return this.has(e)
                }, this);
            return r
        },
        cloneIds: function() {
            return e.cloneDeep(this._statusAilments)
        },
        getRefs: function() {
            return this._statusAilments
        },
        getContinuanceIds: function() {
            var e = _.filter(this._statusAilments, function(e) {
                return n.StatusAilmentsConfig.isContinuanceStatus(e)
            });
            return this.has(r.STATUS_AILMENTS_TYPE.RERAISE_DEATH) && e.push(r.STATUS_AILMENTS_TYPE.DEATH), e
        },
        isHittable: function(e, t) {
            var r = void 0;
            for (var i = 0, s = this._statusAilments.length; i < s; i++) {
                r = n.StatusAilmentsConfig.getParam(this._statusAilments[i]);
                if (f(e, t, r.canNotHit)) return !1
            }
            return !0
        },
        isPossibleToTarget: function() {
            var e = [r.STATUS_AILMENTS_TYPE.INVISIBLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE, r.STATUS_AILMENTS_TYPE.ARM_CATCH];
            return !s(this._statusAilments, e)
        },
        canUseAllMagic: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotUseAllMagic) return !1
            }
            return !0
        },
        canDoAbility: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotDoAbility) return !1
            }
            return !0
        },
        canSelectAbility: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotSelectAbility) return !1
            }
            return this.canDoAbility()
        },
        canUseFlightAttack: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.canNotUseFlightAttack) return !1
            }
            return !0
        },
        shouldPendMoGuestCommandInput: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.shouldPendMoGuestCommandInput) return !0
            }
            return !1
        },
        getRefsOfAttachElementInfoMap: function() {
            var t = this.getAttachElementId();
            return t ? e.cloneDeep(this._infoMap[t]) : void 0
        },
        getAtbTimeFactor: function() {
            var e = 100,
                t = void 0;
            for (var r = 0, i = this._statusAilments.length; r < i; r++) {
                t = n.StatusAilmentsConfig.getParam(this._statusAilments[r]);
                if (_.isNumber(t.atbTimeFactor)) {
                    e = t.atbTimeFactor;
                    break
                }
            }
            return e
        },
        getCastTimeFactor: function(t) {
            var r = e.option({
                    abilityCategoryId: void 0,
                    exerciseType: void 0,
                    isPossibleContainMagicDamage: !1,
                    changeCastTimeCondList: []
                }, t),
                i = 1;
            for (var s = 0, o = this._statusAilments.length; s < o; s++) {
                var u = n.StatusAilmentsConfig.getParam(this._statusAilments[s]);
                if (_.isNumber(u.castTimeFactor)) {
                    var a = this._infoMap[this._statusAilments[s]];
                    u.isChangeCastTime ? a.changeCastTimeFlag && this._shouldApplyChangeCastTime(a, r) && (i *= a.castTimeFactor * .01) : i *= u.castTimeFactor * .01
                }
            }
            return Math.min(100 * i, n.Config.getInstance().get("ThresholdCastTimeNoneFactor"))
        },
        _shouldApplyChangeCastTime: function(e, t) {
            var n = e.allAbilitiesForChangeCastTime;
            if (n) return !0;
            var r = e.abilityCondNameForChangeCastTime && this._matchesCustomCondForChangeCastTime(e.abilityCondNameForChangeCastTime, t);
            if (r) return !0;
            var i = e.abilityCategoryIdForChangeCastTime && e.abilityCategoryIdForChangeCastTime === t.abilityCategoryId;
            return i ? !0 : !1
        },
        _matchesCustomCondForChangeCastTime: function(e, t) {
            var r = !0,
                i = n.Config.getInstance().get("ChangeCastTimeCond"),
                s = _.find(t.changeCastTimeCondList, function(t) {
                    return _.has(i[t], e)
                }),
                o = s ? i[s][e] : i[e];
            if (!o) throw new Error("invalid change cast time cond: " + e);
            var u = o.exerciseTypes,
                a = !!o.isPossibleContainMagicDamage;
            return u && (_.include(u, t.exerciseType) || (r = !1)), a && a !== t.isPossibleContainMagicDamage && (r = !1), r
        },
        getFlightDurationFactor: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                var i = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (i.flightDuration) {
                    e = i.flightDuration;
                    break
                }
            }
            return e
        },
        isContinuousBattle: function() {
            var e = void 0;
            for (var t = 0, r = this._statusAilments.length; t < r; t++) {
                e = n.StatusAilmentsConfig.getParam(this._statusAilments[t]);
                if (e.isNotContinuousBattle) return !1
            }
            return !0
        },
        isDead: function(t) {
            var n = e.option({
                    pureDeath: !1
                }, t),
                i = n.pureDeath ? [r.STATUS_AILMENTS_TYPE.DEATH, r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, r.STATUS_AILMENTS_TYPE.DISABLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE] : [r.STATUS_AILMENTS_TYPE.PETRIFACTION, r.STATUS_AILMENTS_TYPE.DEATH, r.STATUS_AILMENTS_TYPE.RERAISE_DEATH, r.STATUS_AILMENTS_TYPE.DISABLE, r.STATUS_AILMENTS_TYPE.FORCE_ESCAPE];
            return s(this._statusAilments, i)
        },
        judgeDeathByDoom: function() {
            var e = this.havingDoomId();
            return this.has(e) ? this._infoMap[e].count < 0 : !1
        },
        judgeTimeLimit: function() {
            var e = this.havingCountId();
            return this.has(e) ? this._infoMap[e].count < 0 : !1
        },
        getCount: function() {
            var e = this.havingCountId();
            return e ? this._infoMap[e].count : 0
        },
        havingDoomId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.doomIds, function(t) {
                return e.has(t)
            })
        },
        hasDoom: function() {
            return !!this.havingDoomId()
        },
        havingPureDoomId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.pureDoomIds, function(t) {
                return e.has(t)
            })
        },
        hasPureDoom: function() {
            return !!this.havingPureDoomId()
        },
        havingReraiseId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.reraiseIds, function(t) {
                return e.has(t)
            })
        },
        havingTranceId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.tranceIds, function(t) {
                return e.has(t)
            })
        },
        havingGutsId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.gutsIds, function(t) {
                return e.has(t)
            })
        },
        havingDamageBarrierId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.damageBarrierIds, function(t) {
                return e.has(t)
            })
        },
        havingChangeCriticalCoefficientId: function() {
            return _.find(n.StatusAilmentsConfig.changeCriticalCoefficientIds, function(e) {
                return this.has(e)
            }, this)
        },
        hasReraise: function() {
            return !!this.havingReraiseId()
        },
        hasTrance: function() {
            return !!this.havingTranceId()
        },
        hasGuts: function() {
            return !!this.havingGutsId()
        },
        hasDamageBarrier: function() {
            return !!this.havingDamageBarrierId()
        },
        hasChangeCriticalCoefficient: function() {
            return !!this.havingChangeCriticalCoefficientId()
        },
        havingCountId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.countIds, function(t) {
                return e.has(t)
            })
        },
        isCount: function() {
            return !!this.havingCountId()
        },
        getAttachElementId: function() {
            var e = this;
            return _.find(n.StatusAilmentsConfig.attachElementIds, function(t) {
                return e.has(t)
            })
        },
        getNextAbilityIdForRage: function() {
            var e = r.STATUS_AILMENTS_TYPE.RAGE;
            if (!this.has(e)) throw new Error("invalid call");
            return this._infoMap[e].abilityIds[0]
        },
        getHpRateFromParam: function(e) {
            var t = n.StatusAilmentsConfig.getParam(e);
            if (!t) throw new Error("sa param not found.id=" + e);
            return t.hpRate
        },
        getHpRateForReraise: function() {
            return this._infoMap[r.STATUS_AILMENTS_TYPE.RERAISE_DEATH].hpRate
        },
        getHpRateForGuts: function() {
            return this.getHpRateFromParam(this.havingGutsId())
        },
        startBoost: function(t, n, i, s) {
            var o = i && i.boost ? i.boost : {},
                u = i && i.brkDefRates ? i.brkDefRates : {};
            t.boosts = [];
            for (var a = 0, f = n.boosts.length; a < f; a++) {
                var l = e.cloneDeep(n.boosts[a]),
                    c = this._actor.get(l.paramName, {
                        usesSelfBaseParam: !0
                    }),
                    h = void 0;
                if (_.has(l, "rate")) {
                    var p = o.rate || l.rate;
                    if (p < 0 && u[l.paramName]) {
                        var d = u[l.paramName];
                        p = Math.floor(p * (100 + d) / 100)
                    }
                    l.rate = p;
                    var v = l.boostType || r.BOOST_TYPE.STATUS;
                    h = this._actor.setBoost(l.paramName, p, _.extend({
                        boostType: v
                    }, s))
                } else if (_.has(l, "attachElement")) {
                    if (_.has(t, "attachElementId")) l.attachElement[t.attachElementId] = t.defenseFactor || 0;
                    else {
                        var m = _.keys(l.attachElement);
                        for (var g = 0; g < m.length; g++) {
                            var y = m[g];
                            t.attachElementId = +y, l.attachElement[y] = t.defenseFactor || l.attachElement[y]
                        }
                    }
                    h = this._actor.setAttachElementBoost(l.paramName, l.attachElement, "attachElement")
                } else {
                    if (!_.has(l, "absolute")) throw new Error("invalid boostObj");
                    if (_.has(o, "rate")) throw new Error("not include rate in boostObj with absolute. param = " + l.paramName);
                    l.absolute = o.absolute || l.absolute, h = this._actor.setBoost(l.paramName, l.absolute, _.extend({
                        isAbsolute: !0
                    }, s))
                }
                l.holderId = h, t.boosts.push(l)
            }
        },
        finishBoost: function(e) {
            for (var t = 0, n = e.boosts.length; t < n; t++) {
                var r = e.boosts[t];
                this._actor.resetParam(r.holderId)
            }
        },
        swapSparePanel: function(t, n, r) {
            var i = r && r.spareReceptorIds || [];
            t.sparePanels = [];
            for (var s = 0, o = i.length; s < o; s++) {
                var u = e.cloneDeep(n.sparePanels[s]);
                i[s] && (u.spareReceptorId = i[s]);
                var a = {
                        highlight: !!u.highlight
                    },
                    f = this._actor.swapSparePanel(u.spareReceptorId, u.panelNo, a);
                f && (u.swappedReceptorId = f), t.sparePanels.push(u)
            }
        },
        rewindSparePanel: function(e, t, n) {
            for (var r = 0, i = e.sparePanels.length; r < i; r++) {
                var s = e.sparePanels[r],
                    o = s.swappedReceptorId;
                this._actor.rewindSparePanel(s.spareReceptorId, o)
            }
        },
        update: function(e) {
            var t = this._statusAilments.concat(),
                n = void 0;
            for (var r = 0; r < t.length; ++r) n = t[r], o(this, n, "update", {
                dt: e
            })
        },
        processForStateInCastEntry: function() {
            this._processForEvent("entryCast")
        },
        processForStateInActionEntry: function() {
            this._processForEvent("entryAction")
        },
        processForStateInActionExit: function() {
            this._processForEvent("exitAction")
        },
        processForDamaged: function(e) {
            this._processForEvent("damaged", {
                damageObj: e
            })
        },
        processForDamageCalculateHook: function(e) {
            this._processForEvent("damageCalculateHook", {
                damageObj: e
            })
        },
        processForSetupNewBattle: function() {
            this._processForEvent("setupNewBattle")
        },
        _processForEvent: function(e, t) {
            var n = this._statusAilments.concat(),
                r = void 0;
            for (var i = 0; i < n.length; ++i) r = n[i], o(this, r, e, t)
        },
        retrieveSubstituteTypes: function() {
            var e = [];
            return _.each(this._infoMap, function(t, n) {
                var r = this.getSubstitutesById(n);
                if (!r) return;
                e = e.concat(r)
            }, this), _.uniq(e)
        },
        getSubstitutesById: function(e) {
            var t = [],
                n = this._infoMap[e];
            return _.has(n, "substitutes") ? n.substitutes : t
        },
        retrieveDamageReverseSaIds: function() {
            var e = [];
            return _.each(this.getRefs(), function(t) {
                var r = n.StatusAilmentsConfig.getParam(t),
                    i = r.damageReverseTypes;
                if (!i) return;
                e = e.concat(i)
            }), _.uniq(e)
        },
        retrieveAdjustDamageConfigs: function() {
            var e = [],
                t = this;
            return _.each(this.getRefs(), function(r) {
                var i = t._infoMap[r] && t._infoMap[r].adjustDamage;
                if (_.isUndefined(i)) {
                    var s = n.StatusAilmentsConfig.getParam(r);
                    i = s && s.adjustDamage
                }
                if (!i) return;
                _.each([].concat(i), function(t) {
                    if (!(_.isNumber(t.factor) && t.factor >= 0)) throw new Error("Invalid adjustDamage Config. factor is invalid. factor:" + t.factor);
                    e.push(t)
                })
            }), e
        },
        retrieveExtraDefStatusAilmentConfig: function() {
            var e = {};
            return _.each(this.getRefs(), function(t) {
                var r = n.StatusAilmentsConfig.getParam(t),
                    i = r.extraDefStatusAilments;
                if (!i) return;
                _.each(i, function(t) {
                    var n = t.type;
                    e[n] = _.extend({}, t)
                })
            }), e
        },
        isCancelCast: function(e) {
            var t = n.Config.getInstance().get("CancelCastStatusAilmentsTypes");
            return _.contains(t, e) ? !0 : !1
        },
        isFaraway: function() {
            return _.any(this.getRefs(), function(e) {
                var t = n.StatusAilmentsConfig.getParam(e);
                return !!t.isFaraway
            })
        },
        isAntiFaraway: function() {
            return _.any(this.getRefs(), function(e) {
                var t = n.StatusAilmentsConfig.getParam(e);
                return !!t.isAntiFaraway
            })
        },
        consumeHpStockAction: function(e, t) {
            var i = this._actor,
                s = i.get("maxHp") - i.get("hp");
            if (s <= 0) return;
            n.Commander.getInstance().register(r.ABILITY_ID_OF.HP_STOCK, i, {
                reasonStatusAilmentId: e
            }, {
                interruptCounter: !0
            })
        },
        getActualConsumableHpStock: function(e) {
            if (!this.has(e)) return 0;
            var t = this._infoMap[e],
                n = this._actor,
                r = n.get("maxHp") - n.get("hp");
            return _.min([r, t.maxConsumableHpStock - t.consumedHpStock])
        },
        getDamageBarrierRemainHp: function(e) {
            var t = this._infoMap[e];
            return t.damageBarrierRemainHp
        },
        consumeDamageBarrier: function(e, t) {
            var r = n.StatusAilmentsConfig.getParam(e);
            if (!r.isDamageBarrier) throw new Error("Not DamageBarrier. id: " + e);
            var i = this._infoMap[e];
            i.damageBarrierRemainHp -= t, i.damageBarrierRemainHp <= 0 && this.unset(e)
        },
        setForce: function(e, t) {
            this._statusAilments = e, this._infoMap = t
        },
        getInfoMap: function() {
            return this._infoMap
        },
        getUsedAbilityCount: function(e) {
            var t = n.StatusAilmentsConfig.getParam(e);
            if (!t.isUsedAbilityCounter) throw new Error("Not UsedAbilityCounter. id: " + e);
            if (!this.has(e)) return 0;
            var r = this._infoMap[e];
            return r.abilityCount ? r.abilityCount : 0
        },
        getAbilityIndexForUsedAbilityCount: function(e) {
            var t = this.getUsedAbilityCount(e),
                r = n.StatusAilmentsConfig.getParam(e);
            if (!r.isUsedAbilityCounter || !r.abilitySettings) throw new Error("Invalid configuration as UsedAbilityCounter. id: " + e);
            var i = _.sortBy(r.abilitySettings, function(e) {
                    return -1 * e.threshold
                }),
                s = 0,
                o = _.find(i, function(e) {
                    return t >= e.threshold
                });
            return o ? o.abilityIndex : s
        },
        onEndConsumeHpStockAction: function(e, t) {
            if (!this.has(e)) return;
            var n = this._infoMap[e];
            n.consumedHpStock += t, n.consumedHpStock >= n.maxConsumableHpStock && this.unset(e)
        },
        registerRadiantShieldAction: function(e, t, i) {
            if (t.radiantShieldQueue.length <= 0) return;
            var s = _.first(t.radiantShieldQueue).uid,
                o = n.ActorMgr.getByUid(s);
            if (o.isDead()) {
                t.radiantShieldQueue = [];
                return
            }
            var u = _.map(t.radiantShieldQueue, function(e) {
                return Math.ceil(e.damage * i.curseRate / 100)
            });
            n.Commander.getInstance().register(r.ABILITY_ID_OF.RADIANT_SHIELD, o, {
                reasonStatusAilmentId: e,
                fixedDamages: u
            }, {
                interruptRadiantShield: !0
            }), t.radiantShieldQueue = []
        },
        addToRadiantShieldQueue: function(e, t, r, i) {
            var s = this._actor,
                o = i.damageObj,
                u = o.ability;
            if (!u) return;
            var f = u.get("exerciseType"),
                l = o.typeHistory,
                c = o.executer,
                h = o.actualDamage;
            if (!o.canHit) return;
            if (h <= 0) return;
            if (s.equals(o.executer)) return;
            var p = n.StatusAilmentsConfig.getParam(e),
                d = _.any(l, function(e) {
                    return _.any(p.targetReasons, function(t) {
                        return a(f, e, t)
                    })
                });
            if (!d) return;
            t.radiantShieldQueue.push({
                uid: c.getUid(),
                damage: h
            })
        },
        adjustCriticalCoefficient: function(e) {
            var t = this.havingChangeCriticalCoefficientId();
            if (!t) return e;
            var r = n.StatusAilmentsConfig.getParam(t),
                i = this._infoMap[t].criticalCoefficientRate || r.criticalCoefficientRate;
            return e + i * .1
        },
        getAllBoosts: function() {
            var e = [];
            return _.each(this._statusAilments, function(t) {
                var n = this._infoMap[t];
                _.has(n, "boosts") && (e = e.concat(n.boosts))
            }, this), e
        }
    }, {
        judgeHittabilityByReason: f
    })
}), define("scenes/battle/StatusAilmentsConfig", ["util", "./Conf", "./Config"], function(e) {
    function m(e) {
        var t = _.compact(_.map(s, function(t, n) {
            return t[e] ? +n : null
        }));
        _.each(t, function(e) {
            _.each(t, function(t) {
                if (e === t) return;
                s[e].exclusive.types.push(t)
            })
        })
    }
    var t = FF.ns.battle,
        n = t.Conf,
        r = n.STATUS_AILMENTS_TYPE,
        i = _.invert(r),
        s = {};
    s[r.DEATH] = {
        isContinuance: !0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, s[r.INSTANT_DEATH] = {
        exclusive: {
            types: [r.GUTS_1]
        }
    }, s[r.STOCK_BREAK] = {
        exclusive: {
            types: []
        }
    }, s[r.RERAISE_40] = {
        isReraise: !0,
        hpRate: 40,
        canNotSetToEnemy: !0,
        exclusive: {
            types: []
        }
    }, s[r.RERAISE_60] = {
        isReraise: !0,
        hpRate: 60,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.RERAISE_40]
        }
    }, s[r.RERAISE_80] = {
        isReraise: !0,
        hpRate: 80,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.RERAISE_40, r.RERAISE_60]
        }
    }, s[r.RERAISE_100] = {
        isReraise: !0,
        hpRate: 100,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.RERAISE_40, r.RERAISE_60, r.RERAISE_80]
        }
    }, s[r.RERAISE_DEATH] = {
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, s[r.GUTS_1] = {
        isGuts: !0,
        hpRate: 1,
        canNotSetToEnemy: !0,
        exclusive: {
            types: []
        }
    }, s[r.EXTREME_EVRAE_ALTANA] = {
        damageReverseTypes: [r.POISON],
        adjustDamage: [{
            calcTypes: [n.CALC_TYPE.MAGIC],
            exerciseTypes: [n.EXERCISE_TYPE.WHITE_MAGIC],
            factor: 300
        }]
    }, s[r.EXTREME_EVRAE_ALTANA_ZAKO] = {
        adjustDamage: [{
            calcTypes: [n.CALC_TYPE.MAGIC],
            exerciseTypes: [n.EXERCISE_TYPE.WHITE_MAGIC],
            factor: 300
        }]
    }, s[r.EXTREME_BAHAMUT] = {
        adjustDamage: [{
            calcTypes: [n.CALC_TYPE.MAGIC],
            exerciseTypes: [n.EXERCISE_TYPE.SUMMON],
            factor: 200
        }]
    }, s[r.ABYSS_TONBERRY_SLOW] = {
        extraDefStatusAilments: [{
            type: r.SLOW,
            addingAtkFactor: 100
        }]
    }, s[r.ABYSS_TONBERRY_STAN] = {
        extraDefStatusAilments: [{
            type: r.STAN,
            addingAtkFactor: 100
        }]
    }, s[r.ABYSS_TONBERRY_STOP] = {
        extraDefStatusAilments: [{
            type: r.STOP,
            addingAtkFactor: 100
        }]
    }, s[r.ABYSS_WAVE_CANNON_LOCK_ON_1] = {}, s[r.ABYSS_WAVE_CANNON_LOCK_ON_2] = {}, s[r.ABYSS_WAVE_CANNON_LOCK_ON_3] = {}, s[r.SWALLOWED_GEOSGAENO] = {}, s[r.ADJUST_DAMAGE_FOR_AI] = {}, s[r.ADJUST_DAMAGE_ZERO_ALL] = {
        adjustDamage: [{
            hitReasons: ["ALL"],
            damagedOnly: !0,
            factor: 0
        }]
    }, s[r.ADJUST_DAMAGE_ZERO_PHYSICAL] = {
        adjustDamage: [{
            hitReasons: ["PHYSICAL"],
            damagedOnly: !0,
            factor: 0
        }]
    }, s[r.ADJUST_DAMAGE_ZERO_MAGIC] = {
        adjustDamage: [{
            hitReasons: ["MAGIC"],
            damagedOnly: !0,
            factor: 0
        }]
    }, _.each([r.ABYSS_NEKURO_DOOM_ATK, r.ABYSS_NEKURO_DOOM_MATK, r.ABYSS_NEKURO_DOOM_DEF, r.ABYSS_NEKURO_DOOM_MDEF], function(e) {
        s[e] = {
            isDoom: !0,
            isPureDoom: !0,
            canNotOverwrite: !0,
            interval: 1e3,
            count: 20,
            funcMap: {
                update: "updateTimerDoom"
            },
            exclusive: {
                types: []
            }
        }
    }), s[r.POISON] = {
        isContinuance: !0,
        interval: 5e3,
        damageFactor: 4,
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            types: [r.REGEN, r.REGEN_MIDDLE, r.REGEN_STRONG, r.SAP]
        }
    }, s[r.SAP] = {
        interval: 2e3,
        damageFactor: 4,
        duration: {
            a: 0,
            b: 0,
            c: 4e4
        },
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            types: [r.REGEN, r.REGEN_MIDDLE, r.REGEN_STRONG, r.POISON]
        }
    }, s[r.SILENCE] = {
        isContinuance: !0,
        canNotUseAllMagic: !0,
        duration: {
            a: 25,
            b: -25,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, s[r.PARALYSIS] = {
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        duration: {
            a: 20,
            b: -20,
            c: 15e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [r.COUNTER_AIMING]
        }
    }, s[r.CONFUSION] = {
        canNotSelectAbility: !0,
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        duration: {
            a: 25,
            b: -25,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault",
            damaged: "damagedForConfusion"
        },
        exclusive: {
            types: [r.COUNTER_AIMING, r.RAGE]
        }
    }, s[r.HASTE] = {
        atbTimeFactor: 200,
        duration: {
            a: 25,
            b: 0,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [r.SLOW]
        }
    }, s[r.SLOW] = {
        atbTimeFactor: 50,
        duration: {
            a: .05,
            b: 0,
            c: 2e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [r.HASTE]
        }
    }, s[r.STOP] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        shouldPendMoGuestCommandInput: !0,
        duration: {
            a: 20,
            b: -20,
            c: 6e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: [r.COUNTER_AIMING]
        }
    }, s[r.PYRAMID] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            invert: !0,
            types: [r.DEATH],
            blocking: !0
        }
    }, s[r.PRISON_CAGE] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            invert: !0,
            types: [r.DEATH, r.REGEN, r.REGEN_MIDDLE, r.REGEN_STRONG],
            typesByFlags: ["isHpStock"],
            blocking: !0
        }
    }, s[r.WATER_BALL] = {
        interval: 1e3,
        damageFactor: 2,
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        funcMap: {
            update: "updateTimerPoison"
        },
        exclusive: {
            invert: !0,
            types: [r.DEATH],
            blocking: !0
        }
    }, s[r.SWALLOWED] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            invert: !0,
            types: [r.DEATH],
            blocking: !0
        }
    }, s[r.POSSESSION] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, s[r.PROTECT] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "def",
            rate: 100,
            boostType: n.BOOST_TYPE.RESULT
        }],
        exclusive: {
            types: []
        }
    }, s[r.SHELL] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "mdef",
            rate: 100,
            boostType: n.BOOST_TYPE.RESULT
        }],
        exclusive: {
            types: []
        }
    }, s[r.REFLECTION] = {
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, s[r.BLINDED] = {
        isContinuance: !0,
        durationForSide: {
            buddy: {
                a: 20,
                b: -20,
                c: 3e4
            },
            enemy: {
                a: 20,
                b: -20,
                c: 6e4
            }
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "acc",
            rate: -50
        }],
        exclusive: {
            types: [r.EYE_POWER_CHARM]
        }
    }, s[r.SLEEP] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        duration: {
            a: 20,
            b: -20,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault",
            damaged: "damagedForSleep"
        },
        exclusive: {
            types: [r.COUNTER_AIMING]
        }
    }, s[r.PETRIFACTION] = {
        isContinuance: !0,
        isBlocking: !0,
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, s[r.DOOM] = {
        isDoom: !0,
        isPureDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 60,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.DOOM_30] = {
        isDoom: !0,
        isPureDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 30,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.DOOM_45] = {
        isDoom: !0,
        isPureDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 45,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.DOOM_90] = {
        isDoom: !0,
        isPureDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 90,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.DOOM_120] = {
        isDoom: !0,
        isPureDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 120,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.MAGICAL_MINE] = {
        isDoom: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 20,
        funcMap: {
            update: "updateTimerMagicalMine"
        },
        exclusive: {
            types: []
        }
    }, s[r.DOOM_LIGHT_45] = {
        isDoom: !0,
        isPureDoom: !0,
        isDoomLight: !0,
        canNotOverwrite: !0,
        interval: 1e3,
        count: 45,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: [],
            blocking: !0
        }
    }, s[r.ZERO_FLIGHT_2] = {
        isChangeFlightDuration: !0,
        countChangeFlightDuration: 2,
        flightDuration: 10,
        funcMap: {
            entry: "entryAbilityUseCountForChangeFlightDuration",
            entryAction: "entryActionAbilityUseCountForChangeFlightDuration",
            exitAction: "exitActionAbilityUseCountForChangeFlightDuration"
        },
        exclusive: {
            types: []
        }
    }, s[r.ZERO_FLIGHT_3] = {
        isChangeFlightDuration: !0,
        countChangeFlightDuration: 3,
        flightDuration: 10,
        funcMap: {
            entry: "entryAbilityUseCountForChangeFlightDuration",
            entryAction: "entryActionAbilityUseCountForChangeFlightDuration",
            exitAction: "exitActionAbilityUseCountForChangeFlightDuration"
        },
        exclusive: {
            types: []
        }
    }, s[r.BERSERKER] = {
        resetActorWhenSet: !0,
        resetActorWhenUnset: !0,
        canNotSelectAbility: !0,
        duration: {
            a: 25,
            b: -25,
            c: 2e4
        },
        boosts: [{
            paramName: "atk",
            rate: 25
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: [r.COUNTER_AIMING, r.RAGE]
        }
    }, s[r.RAGE] = {
        resetActorWhenUnset: !0,
        canNotSelectAbility: !0,
        funcMap: {
            entry: "entryRage",
            exitAction: "exitActionRage"
        },
        exclusive: {
            types: [r.COUNTER_AIMING]
        }
    }, s[r.REGEN] = {
        interval: 3e3,
        duration: {
            a: 30,
            b: 0,
            c: 3e4
        },
        damageFactor: 3,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [r.ZOMBIE, r.POISON, r.SAP, r.REGEN_MIDDLE, r.REGEN_STRONG]
        }
    }, s[r.REGEN_MIDDLE] = {
        interval: 2500,
        duration: {
            a: 30,
            b: 0,
            c: 3e4
        },
        damageFactor: 4,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [r.ZOMBIE, r.POISON, r.SAP, r.REGEN, r.REGEN_STRONG]
        }
    }, s[r.REGEN_STRONG] = {
        interval: 2500,
        duration: {
            a: 30,
            b: 0,
            c: 35e3
        },
        damageFactor: 5,
        funcMap: {
            update: "updateTimerRegen"
        },
        exclusive: {
            types: [r.ZOMBIE, r.POISON, r.SAP, r.REGEN, r.REGEN_MIDDLE]
        }
    }, s[r.RADIANT_SHIELD] = {
        canNotSetToEnemy: !0,
        curseRate: 100,
        targetReasons: ["SA_RADIANT_SHIELD"],
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            setupNewBattle: "setupNewBattleForRadiantShield",
            damaged: "damagedForRadiantShield",
            update: "updateTimerRadiantShield"
        }
    }, s[r.DAMAGE_BARRIER_30] = {
        damageBarrierRate: 30,
        isDamageBarrier: !0,
        canNotSetToEnemy: !0,
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        funcMap: {
            entry: "entryDamageBarrier"
        }
    }, s[r.SUMMONING] = {
        canNotSetToEnemy: !0,
        funcMap: {
            update: "updateSummoning"
        },
        exclusive: {
            types: [r.BLACK_DRAGON_SUMMONING]
        }
    }, s[r.BLACK_DRAGON_SUMMONING] = {
        canNotSetToEnemy: !0,
        funcMap: {
            update: "updateSummoning"
        },
        exclusive: {
            types: [r.SUMMONING]
        }
    }, s[r.ARM_CATCH] = {
        atbTimeFactor: 0,
        castTimeFactor: 0,
        canNotDoAbility: !0,
        canNotUseAllMagic: !0,
        resetActorWhenSet: !0,
        isNotContinuousBattle: !0,
        exclusive: {
            types: []
        }
    }, s[r.REFLECTION_FULL_TIME] = {
        exclusive: {
            types: []
        }
    }, s[r.TARGET_BUDDY] = {}, s[r.INVISIBLE] = {}, s[r.FORCE_ESCAPE] = {
        exclusive: {
            all: !0,
            blocking: !0
        }
    }, s[r.DISABLE] = {}, s[r.CUSTOM_MATK] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_DEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_ACC] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_EVA] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "eva",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MDEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_DEF_MDEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_DEF_MDEF_NOT_IRON_WALL] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_MATK_DEF_MDEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_MATK] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_DEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MATK_20_MDEF_50] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 20
        }, {
            paramName: "mdef",
            rate: 50
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_MATK_DEF_MDEF_SPD_ACC_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "spd",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_SPD] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "spd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_DEF_MATK] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_MDEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MATK_MDEF] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MATK_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_DEF_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_DEF_MATK_MDEF_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MDEF_MND] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_CRITICAL_ABSOLUTE] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "critical",
            absolute: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_SA_COEF_FOR_ENEMY] = {
        canNotSetToBuddy: !0,
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atkSaCoef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_ATK_FOR_AI_TIMER] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MATK_FOR_AI_TIMER] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "matk",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_DEF_FOR_AI_TIMER] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "def",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    }, s[r.CUSTOM_MDEF_FOR_AI_TIMER] = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "mdef",
            rate: 0
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        }
    };
    var o = {
        isCustomParam: !0,
        exclusive: {
            types: []
        },
        boosts: [],
        funcMap: {
            entry: "entryParamBooster",
            exit: "exitParamBooster"
        }
    };
    s[r.CUSTOM_ATK_FOR_AI] = _.extend(_.clone(o), {
        boosts: [{
            paramName: "atk",
            rate: 0,
            boostType: n.BOOST_TYPE.RESULT
        }]
    }), s[r.CUSTOM_MATK_FOR_AI] = _.extend(_.clone(o), {
        boosts: [{
            paramName: "matk",
            rate: 0,
            boostType: n.BOOST_TYPE.RESULT
        }]
    }), s[r.CUSTOM_DEF_FOR_AI] = _.extend(_.clone(o), {
        boosts: [{
            paramName: "def",
            rate: 0,
            boostType: n.BOOST_TYPE.RESULT
        }]
    }), s[r.CUSTOM_MDEF_FOR_AI] = _.extend(_.clone(o), {
        boosts: [{
            paramName: "mdef",
            rate: 0,
            boostType: n.BOOST_TYPE.RESULT
        }]
    });
    var u = {
        isCustomParam: !0,
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    };
    s[r.CUSTOM_PARAM_MULTI_ATK_30_DEF_M30] = _.extend(_.clone(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: -30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_MATK_30_DEF_M30] = _.extend(_.clone(u), {
        boosts: [{
            paramName: "matk",
            rate: 30
        }, {
            paramName: "def",
            rate: -30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_DEF_30_MDEF_30] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: 30
        }, {
            paramName: "mdef",
            rate: 30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_MDEF_M30] = _.extend(_.clone(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "mdef",
            rate: -30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_MDEF_25_CRITICAL_50] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "mdef",
            rate: 25
        }, {
            paramName: "critical",
            absolute: 50
        }]
    }), s[r.CUSTOM_PARAM_MULTI_MATK_15_DEF_M15] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "matk",
            rate: 15
        }, {
            paramName: "def",
            rate: -15
        }]
    }), s[r.CUSTOM_PARAM_MULTI_MATK_15_MDEF_M15] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "matk",
            rate: 15
        }, {
            paramName: "mdef",
            rate: -15
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_MND_15_CRITICAL_50] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "mnd",
            rate: 15
        }, {
            paramName: "critical",
            absolute: 50
        }]
    }), s[r.CUSTOM_PARAM_MULTI_CRITICAL_50] = _.extend(e.cloneDeep(u), {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "critical",
            absolute: 50
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_DEF_30] = _.extend(e.cloneDeep(u), {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: 30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_15_DEF_M15] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "atk",
            rate: 15
        }, {
            paramName: "def",
            rate: -15
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_MDEF_30] = _.extend(e.cloneDeep(u), {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "mdef",
            rate: 30
        }]
    }), s[r.CUSTOM_PARAM_MULTI_ATK_30_DEF_50] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: 50
        }]
    }), s[r.CUSTOM_PARAM_MULTI_MATK_30_MDEF_M30] = _.extend(e.cloneDeep(u), {
        boosts: [{
            paramName: "matk",
            rate: 30
        }, {
            paramName: "mdef",
            rate: -30
        }]
    }), s[r.INVINCIBLE] = {
        canNotHit: "ALL"
    }, s[r.NULL_PHYSICAL] = {
        canNotHit: "PHYSICAL"
    }, s[r.NULL_MAGIC] = {
        canNotHit: "MAGIC"
    }, s[r.FARAWAY] = {
        isFaraway: !0
    }, s[r.ANTI_FARAWAY_LIMITED] = {
        isAntiFaraway: !0,
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.NULL_BASIC_MAGIC] = {
        canNotHit: "BASIC_MAGIC"
    }, s[r.TRIPLE] = {}, s[r.MATK_BOOSTER] = {
        duration: {
            a: 25,
            b: 0,
            c: 1e4
        },
        boosts: [{
            paramName: "matk",
            rate: 25
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.PROVOKE] = {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "def",
            rate: 200
        }],
        substitutes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.COUNTER_AIMING] = {
        duration: {
            a: 0,
            b: 0,
            c: 15e3
        },
        canNotHit: "COUNTER_AIMING",
        counters: [{
            abilityId: t.Conf.ABILITY_ID_OF.ATTACK,
            conditionType: t.Conf.COUNTER_CONDTION_TYPE.CUSTOM,
            conditionValue: t.Conf.COUNTER_CONDTION_CUSTOM_TYPE.COUNTER_AIMING,
            rate: 100
        }],
        funcMap: {
            entry: "entryCounter",
            update: "updateTimerDefault",
            exit: "exitCounter"
        },
        exclusive: {
            types: []
        }
    }, s[r.CHARGE] = {
        boosts: [{
            paramName: "atk",
            rate: 200
        }],
        funcMap: {
            entryAction: "procChargeActionEntry",
            exitAction: "procChargeActionExit"
        },
        exclusive: {
            types: []
        }
    }, s[r.RUNIC] = {
        exclusive: {
            types: [r.GRAND_CROSS]
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        substitutes: [n.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.GRAND_CROSS] = {
        exclusive: {
            types: [r.RUNIC]
        },
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        substitutes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.AIRFORCE_SPECK] = {
        exclusive: {
            types: []
        },
        substitutes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC],
        canNotHit: "BASIC_MAGIC"
    }, s[r.BASIC_MAGIC_BREAKER] = {
        exclusive: {
            types: []
        },
        substitutes: [n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC],
        canNotHit: "BASIC_MAGIC"
    }, s[r.RAID] = {
        isCustomParam: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        boosts: [{
            paramName: "atk",
            rate: 150
        }, {
            paramName: "def",
            rate: -50
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.DEFENSE] = {
        funcMap: {
            entryCast: "end"
        },
        exclusive: {
            types: []
        }
    }, s[r.LOCK_ON] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        },
        substitutes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.BLACK_MAGIC]
    }, s[r.OVER_DRIVE] = {
        duration: {
            a: 0,
            b: 0,
            c: 4e4
        },
        boosts: [{
            paramName: "atk",
            rate: 30
        }, {
            paramName: "def",
            rate: -30
        }, {
            paramName: "mdef",
            rate: -30
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.ROAR] = {
        duration: {
            a: 0,
            b: 0,
            c: 2e4
        },
        boosts: [{
            paramName: "atk",
            rate: 20
        }, {
            paramName: "matk",
            rate: 20
        }, {
            paramName: "def",
            rate: -20
        }, {
            paramName: "mdef",
            rate: -20
        }],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.MAGIC_SEAL] = {
        canNotUseAllMagic: !0,
        exclusive: {
            types: []
        }
    }, s[r.FLIGHT_SEAL] = {
        canNotUseFlightAttack: !0,
        exclusive: {
            types: []
        }
    }, s[r.IGNORE_INCONTROLLABLE] = {}, s[r.DO_NOTHING_FOR_ESNA] = {}, s[r.DO_NOTHING_FOR_DISPEL] = {}, s[r.MIRAGE_1] = {
        canNotHit: "SA_MIRAGE",
        limit: 1,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.MIRAGE_2, r.MIRAGE_3]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, s[r.MIRAGE_2] = {
        canNotHit: "SA_MIRAGE",
        limit: 2,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.MIRAGE_1, r.MIRAGE_3]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, s[r.MIRAGE_3] = {
        canNotHit: "SA_MIRAGE",
        limit: 3,
        canNotSetToEnemy: !0,
        exclusive: {
            types: [r.MIRAGE_1, r.MIRAGE_2]
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, s[r.NON_DAMAGE] = {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    }, s[r.INDOMITABLENESS] = {
        duration: {
            a: 0,
            b: 0,
            c: 3e4
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "atk",
            rate: 50
        }],
        exclusive: {
            invert: !0,
            types: [r.DEATH, r.INVISIBLE, r.DEFENSE, r.TARGET_BUDDY],
            blocking: !0
        }
    }, s[r.CHARM] = {
        boosts: [{
            paramName: "def",
            rate: 100
        }],
        substitutes: [n.EXERCISE_TYPE.PHYSICAL],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.MAGIC_CHARM] = {
        boosts: [{
            paramName: "mdef",
            rate: 100
        }],
        substitutes: [n.EXERCISE_TYPE.BLACK_MAGIC],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: []
        }
    }, s[r.STAN] = {
        resetActorWhenSet: !0,
        duration: {
            a: 0,
            b: 0,
            c: 1e3
        },
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.MIGHTY_GUARD_1] = {
        canNotHit: "SA_MIGHTY_GUARD",
        limit: 1,
        exclusive: {
            types: []
        },
        funcMap: {
            entry: "entryLimit",
            damageCalculateHook: "damageCalculateHookForCanNotHitWithDamaged"
        }
    }, s[r.SUCTION] = {
        canNotOverwrite: !0,
        interval: 1e3,
        count: 30,
        funcMap: {
            update: "updateTimerDoom"
        },
        exclusive: {
            types: []
        }
    }, s[r.FURY] = {
        exclusive: {
            types: []
        }
    };
    var a = {
        isChangeCastTime: !0,
        castTimeFactor: 100,
        validAbilityUseCountForChangeCastTime: 0,
        abilityUseCountInfinityFlag: !1,
        allAbilitiesForChangeCastTime: !1,
        abilityCategoryIdForChangeCastTime: void 0,
        abilityCondNameForChangeCastTime: void 0,
        funcMap: {
            entry: "entryChangeCastTime",
            entryCast: "entryCastAbilityUseCountForChangeCastTime",
            exitAction: "exitActionAbilityUseCountForChangeCastTime"
        }
    };
    s[r.CHANGE_CAST_TIME] = e.cloneDeep(a), s[r.CHANGE_CAST_TIME_200_3_CUSTOM_MAGIC_DAMAGE_ABILITIES] = _.extend(e.cloneDeep(a), {
        castTimeFactor: 200,
        validAbilityUseCountForChangeCastTime: 3,
        abilityCondNameForChangeCastTime: "magicDamageAbilities"
    }), s[r.CHANGE_CAST_TIME_200_4_CUSTOM_MAGIC_DAMAGE_ABILITIES] = _.extend(e.cloneDeep(a), {
        castTimeFactor: 200,
        validAbilityUseCountForChangeCastTime: 4,
        abilityCondNameForChangeCastTime: "magicDamageAbilities"
    }), s[r.CHANGE_CAST_TIME_200_5_CUSTOM_MAGIC_DAMAGE_ABILITIES] = _.extend(e.cloneDeep(a), {
        castTimeFactor: 200,
        validAbilityUseCountForChangeCastTime: 5,
        abilityCondNameForChangeCastTime: "magicDamageAbilities"
    }), s[r.CHANGE_CAST_TIME_MAX_1_ALL] = _.extend(e.cloneDeep(a), {
        castTimeFactor: t.Config.getInstance().get("ThresholdCastTimeNoneFactor"),
        validAbilityUseCountForChangeCastTime: 1,
        allAbilitiesForChangeCastTime: !0
    }), s[r.CHANGE_CAST_TIME_MAX_2_ALL] = _.extend(e.cloneDeep(a), {
        castTimeFactor: t.Config.getInstance().get("ThresholdCastTimeNoneFactor"),
        validAbilityUseCountForChangeCastTime: 2,
        allAbilitiesForChangeCastTime: !0
    }), s[r.CHANGE_CAST_TIME_MAX_1_PHYSICAL_DAMAGE_ABILITIES] = _.extend(e.cloneDeep(a), {
        castTimeFactor: t.Config.getInstance().get("ThresholdCastTimeNoneFactor"),
        validAbilityUseCountForChangeCastTime: 1,
        abilityCondNameForChangeCastTime: "physicalDamageAbilities"
    }), s[r.CHANGE_CAST_TIME_MAX_1_CUSTOM_MAGIC_DAMAGE_ABILITIES] = _.extend(e.cloneDeep(a), {
        castTimeFactor: t.Config.getInstance().get("ThresholdCastTimeNoneFactor"),
        validAbilityUseCountForChangeCastTime: 1,
        abilityCondNameForChangeCastTime: "magicDamageAbilities"
    }), s[r.CHANGE_CAST_TIME_200_4_ALL] = _.extend(e.cloneDeep(a), {
        castTimeFactor: 200,
        validAbilityUseCountForChangeCastTime: 4,
        allAbilitiesForChangeCastTime: !0
    });
    var f = _.extend(e.cloneDeep(a), {
            isCustomParam: !0,
            abilityUseCountInfinityFlag: !0,
            allAbilitiesForChangeCastTime: !0,
            funcMap: {
                entry: "entryParamBoostAndChangeCastTime",
                entryCast: "entryCastAbilityUseCountForChangeCastTime",
                exitAction: "exitActionAbilityUseCountForChangeCastTime",
                exit: "exitParamBooster"
            }
        }),
        l = _.extend(e.cloneDeep(f), {
            funcMap: _.extend(_.clone(f.funcMap), {
                damaged: "damagedForGreasedLightning"
            }),
            exclusive: {
                blocking: !0,
                types: []
            }
        });
    s[r.GREASED_LIGHTNING_1] = _.extend(e.cloneDeep(l), {
        castTimeFactor: 133,
        boosts: [{
            paramName: "atk",
            rate: 15
        }]
    }), s[r.GREASED_LIGHTNING_2] = _.extend(e.cloneDeep(l), {
        castTimeFactor: 200,
        boosts: [{
            paramName: "atk",
            rate: 30
        }],
        exclusive: {
            blocking: !0,
            types: [r.GREASED_LIGHTNING_1]
        }
    }), s[r.GREASED_LIGHTNING_3] = _.extend(e.cloneDeep(l), {
        castTimeFactor: 400,
        boosts: [{
            paramName: "atk",
            rate: 50
        }],
        exclusive: {
            blocking: !0,
            types: [r.GREASED_LIGHTNING_1, r.GREASED_LIGHTNING_2]
        }
    }), s[r.WILD_MODE] = _.extend(e.cloneDeep(f), {
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        castTimeFactor: 200,
        funcMap: _.extend(_.clone(f.funcMap), {
            update: "updateTimerChangeCastTimeByDuration"
        }),
        boosts: [{
            paramName: "def",
            rate: -40
        }, {
            paramName: "mdef",
            rate: -40
        }]
    });
    var c = _.extend(e.cloneDeep(a), {
        castTimeFactor: 300,
        abilityUseCountInfinityFlag: !0,
        allAbilitiesForChangeCastTime: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryChangeCastTime",
            entryCast: "entryCastAbilityUseCountForChangeCastTime",
            exitAction: "exitActionAbilityUseCountForChangeCastTime",
            update: "updateTimerChangeCastTimeByDuration"
        }
    });
    s[r.THUNDER_GOD_MODE] = e.cloneDeep(c);
    var h = {
        criticalCoefficientRate: 50,
        isChangeCriticalCoefficient: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            update: "updateTimerDefault"
        },
        exclusive: {
            types: []
        }
    };
    s[r.CHANGE_CRITICAL_COEFFICIENT] = e.cloneDeep(h), s[r.CHANGE_CRITICAL_COEFFICIENT_50] = e.cloneDeep(h);
    var p = {
        isHpStock: !0,
        maxConsumableHpStock: 2e3,
        canNotSetToEnemy: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryHpStock",
            damaged: "damagedForHpStock",
            setupNewBattle: "setupNewBattleForHpStock",
            update: "updateTimerDefault"
        },
        exclusive: {
            typesByFlags: ["isHpStock"]
        }
    };
    s[r.HP_STOCK] = e.cloneDeep(p), s[r.HP_STOCK_2000_25000] = e.cloneDeep(p);
    var d = {
        isAttachElement: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [],
        exclusive: {
            types: []
        }
    };
    s[r.ATTACH_ELEMENT_LIGHTNING_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_LIGHTNING_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_LIGHTNING_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_FIRE_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_FIRE_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_FIRE_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WIND_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                104: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WIND_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                104: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WIND_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                104: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_EARTH_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                103: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_EARTH_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                103: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_EARTH_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                103: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_DARK_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                107: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_DARK_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                107: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_DARK_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                107: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_HOLY_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                106: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_HOLY_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                106: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_HOLY_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                106: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WATER_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                105: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WATER_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                105: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WATER_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                105: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_ICE_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                101: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_ICE_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                101: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_ICE_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                101: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_POISON_WEAK] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                108: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_POISON_MIDDLE] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                108: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_POISON_STRONG] = _.extend(_.clone(d), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                108: 0
            }
        }]
    }), s[r.TRANCE] = {
        isTrance: !0,
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        boosts: [{
            paramName: "atk",
            rate: 0
        }, {
            paramName: "def",
            rate: 0
        }, {
            paramName: "matk",
            rate: 0
        }, {
            paramName: "mdef",
            rate: 0
        }, {
            paramName: "mnd",
            rate: 0
        }, {
            paramName: "acc",
            rate: 0
        }, {
            paramName: "eva",
            rate: 0
        }, {
            paramName: "spd",
            rate: 0
        }],
        sparePanels: [{
            panelNo: 1,
            spareReceptorId: 0,
            highlight: !0
        }, {
            panelNo: 4,
            spareReceptorId: 0,
            highlight: !0
        }],
        funcMap: {
            entry: "entryTrance",
            update: "updateTimerTrance",
            exitAction: "exitActionTrance",
            exit: "exitTrance"
        },
        exclusive: {
            types: []
        }
    }, s[r.EYE_POWER_CHARM] = {
        boosts: [{
            paramName: "def",
            rate: 200
        }, {
            paramName: "mdef",
            rate: 200
        }],
        substitutes: [n.EXERCISE_TYPE.PHYSICAL, n.EXERCISE_TYPE.BLACK_MAGIC, n.EXERCISE_TYPE.WHITE_MAGIC],
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        exclusive: {
            types: [r.BLINDED]
        }
    }, s[r.ATTACH_ELEMENT_AS_DISADVANTAGE] = {
        duration: {
            a: 0,
            b: 0,
            c: 0
        },
        funcMap: {
            entry: "entryParamBooster",
            update: "updateTimerParamBooster",
            exit: "exitParamBooster"
        },
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {}
        }]
    }, s[r.USED_ABILITY_COUNTER_WEAPON_MASTER] = {
        isUsedAbilityCounter: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        abilitySettings: [{
            abilityIndex: 0,
            threshold: 0
        }, {
            abilityIndex: 1,
            threshold: 1
        }, {
            abilityIndex: 2,
            threshold: 2
        }, {
            abilityIndex: 3,
            threshold: 3
        }, {
            abilityIndex: 4,
            threshold: 4
        }, {
            abilityIndex: 5,
            threshold: 5
        }, {
            abilityIndex: 6,
            threshold: 6
        }, {
            abilityIndex: 7,
            threshold: 7
        }],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.USED_ABILITY_COUNTER_TORAIN_COMBO] = {
        isUsedAbilityCounter: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        abilitySettings: [{
            abilityIndex: 0,
            threshold: 0
        }, {
            abilityIndex: 1,
            threshold: 1
        }, {
            abilityIndex: 2,
            threshold: 2
        }, {
            abilityIndex: 3,
            threshold: 3
        }, {
            abilityIndex: 4,
            threshold: 4
        }, {
            abilityIndex: 5,
            threshold: 5
        }, {
            abilityIndex: 6,
            threshold: 6
        }, {
            abilityIndex: 7,
            threshold: 7
        }],
        funcMap: {
            update: "updateTimerDefault"
        }
    };
    var v = {
        funcMap: {
            entry: "entryParamBooster",
            exit: "exitParamBooster"
        },
        boosts: []
    };
    s[r.ATTACH_ELEMENT_FIRE_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                100: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_ICE_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                101: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_LIGHTNING_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                102: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_WATER_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                105: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_EARTH_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                103: 0
            }
        }]
    }), s[r.ATTACH_ELEMENT_POISON_FOR_AI] = _.extend(e.cloneDeep(v), {
        boosts: [{
            paramName: "defAttributeMap",
            attachElement: {
                108: 0
            }
        }]
    }), s[r.USED_ABILITY_COUNTER_FLAME_CANNON] = {
        isUsedAbilityCounter: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        abilitySettings: [{
            abilityIndex: 0,
            threshold: 0
        }, {
            abilityIndex: 1,
            threshold: 1
        }, {
            abilityIndex: 2,
            threshold: 2
        }, {
            abilityIndex: 3,
            threshold: 3
        }, {
            abilityIndex: 4,
            threshold: 4
        }, {
            abilityIndex: 5,
            threshold: 5
        }, {
            abilityIndex: 6,
            threshold: 6
        }, {
            abilityIndex: 7,
            threshold: 7
        }],
        funcMap: {
            update: "updateTimerDefault"
        }
    }, s[r.DOOM_DECREASE_COUNT_3] = {
        decreaseCount: 3,
        funcMap: {
            entry: "decreaseDoomCount"
        }
    }, s[r.USED_ABILITY_COUNTER_THUNDER_FALL] = {
        isUsedAbilityCounter: !0,
        duration: {
            a: 0,
            b: 0,
            c: 25e3
        },
        abilitySettings: [{
            abilityIndex: 0,
            threshold: 0
        }, {
            abilityIndex: 1,
            threshold: 1
        }, {
            abilityIndex: 2,
            threshold: 2
        }, {
            abilityIndex: 3,
            threshold: 3
        }, {
            abilityIndex: 4,
            threshold: 4
        }],
        funcMap: {
            update: "updateTimerDefault"
        }
    };
    var g = {};
    _.each(s, function(e, t) {
        g[t] = e.isContinuance
    });
    var y = _.compact(_.map(s, function(e, t) {
            return e.isDoom ? +t : null
        })),
        b = _.compact(_.map(s, function(e, t) {
            return e.isPureDoom ? +t : null
        }));
    _.map(y, function(e) {
        _.map(y, function(t) {
            if (e === t) return;
            s[e].isDoomLight ? s[t].isDoomLight && s[e].exclusive.types.push(t) : s[e].exclusive.types.push(t)
        })
    }), _.map(y, function(e) {
        s[r.SUCTION].exclusive.types.push(e)
    });
    var w = _.compact(_.map(s, function(e, t) {
            return e.isReraise ? +t : null
        })),
        E = _.compact(_.map(s, function(e, t) {
            return e.isTrance ? +t : null
        })),
        S = _.compact(_.map(s, function(e, t) {
            return e.isGuts ? +t : null
        })),
        x = _.compact(_.map(s, function(e, t) {
            return e.isDamageBarrier ? +t : null
        })),
        T = _.compact(_.map(s, function(e, t) {
            return e.isChangeCriticalCoefficient ? +t : null
        })),
        N = _.compact(_.map(s, function(e, t) {
            return _.isNumber(e.count) ? +t : null
        })),
        C = _.compact(_.map(s, function(e, t) {
            return e.isAttachElement ? +t : null
        })),
        k = _.compact(_.map(s, function(e, t) {
            return e.isCustomParam ? +t : null
        })),
        L = _.compact(_.map(s, function(e, t) {
            return e.canNotSetToEnemy ? +t : null
        })),
        A = _.compact(_.map(s, function(e, t) {
            return e.canNotSetToBuddy ? +t : null
        })),
        O = _.compact(_.map(s, function(e, t) {
            return e.canNotHit === "SA_MIRAGE" ? +t : null
        }));
    m("isChangeCriticalCoefficient"), m("isChangeFlightDuration"),
        function() {
            var t = [],
                n = [];
            _.each(s, function(e, r) {
                if (!e.exclusive || !e.exclusive.typesByFlags) return;
                t = _.union(t, e.exclusive.typesByFlags), n.push(+r)
            });
            var r = {};
            _.each(s, function(e, n) {
                _.each(t, function(t) {
                    e[t] && (r[t] || (r[t] = []), r[t].push(+n))
                })
            }), _.each(n, function(e) {
                var t = s[e],
                    n = t.exclusive.types || [];
                _.each(t.exclusive.typesByFlags, function(t) {
                    n = _.union(n, _.without(r[t], e))
                }), t.exclusive.types = n
            })
        }();
    var M = {};
    M[n.STATUS_AILMENTS_BUNDLE.LOT] = [r.POISON, r.PARALYSIS, r.BLINDED, r.SILENCE, r.SLEEP, r.CONFUSION, r.PETRIFACTION, r.STOP], M[n.STATUS_AILMENTS_BUNDLE.ESNA] = [r.DO_NOTHING_FOR_ESNA, r.POISON, r.SILENCE, r.PARALYSIS, r.CONFUSION, r.BLINDED, r.SLEEP, r.PETRIFACTION, r.MINIMUM, r.TOAD, r.SUCTION, r.BERSERKER], M[n.STATUS_AILMENTS_BUNDLE.DISPEL] = [r.DO_NOTHING_FOR_DISPEL, r.HASTE, r.PROTECT, r.SHELL, r.REFLECTION, r.REGEN, r.REGEN_MIDDLE, r.REGEN_STRONG, r.TRIPLE], M[n.STATUS_AILMENTS_BUNDLE.DEBARIA] = [r.PROTECT, r.SHELL, r.REFLECTION, r.MIGHTY_GUARD_1], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_PARALYSIS] = [r.POISON, r.PARALYSIS], M[n.STATUS_AILMENTS_BUNDLE.PHOTON_WING] = [r.SLEEP, r.SILENCE, r.BLINDED, r.CONFUSION, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_BLINDED] = [r.POISON, r.BLINDED], M[n.STATUS_AILMENTS_BUNDLE.SILENCE_AND_STAN] = [r.SILENCE, r.STAN], M[n.STATUS_AILMENTS_BUNDLE.SERAPHIC_RAY] = _.uniq(k.concat(M[n.STATUS_AILMENTS_BUNDLE.DISPEL])), M[n.STATUS_AILMENTS_BUNDLE.BLINDED_AND_SILENCE] = [r.BLINDED, r.SILENCE], M[n.STATUS_AILMENTS_BUNDLE.CONFUSION_AND_SLEEP] = [r.CONFUSION, r.SLEEP], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_SILENCE_AND_BLINDED_AND_SLOW] = [r.POISON, r.SILENCE, r.BLINDED, r.SLOW], M[n.STATUS_AILMENTS_BUNDLE.PROTECT_AND_SHELL_AND_HASTE] = [r.PROTECT, r.SHELL, r.HASTE], M[n.STATUS_AILMENTS_BUNDLE.SLOW_AND_SLEEP] = [r.SLOW, r.SLEEP], M[n.STATUS_AILMENTS_BUNDLE.SLOW_AND_BLINDED_AND_POISON] = [r.SLOW, r.BLINDED, r.POISON], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_SLOW] = [r.POISON, r.SLOW], M[n.STATUS_AILMENTS_BUNDLE.CONFUSION_AND_SLEEP_AND_BLINDED] = [r.CONFUSION, r.SLEEP, r.BLINDED], M[n.STATUS_AILMENTS_BUNDLE.PARALYSIS_AND_SILENCE] = [r.PARALYSIS, r.SILENCE], M[n.STATUS_AILMENTS_BUNDLE.PROTECT_AND_SHELL] = [r.PROTECT, r.SHELL], M[n.STATUS_AILMENTS_BUNDLE.ALL_REGEN] = [r.REGEN, r.REGEN_MIDDLE, r.REGEN_STRONG], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_CUSTOM_DEF_MDEF] = [r.POISON, r.CUSTOM_DEF_MDEF], M[n.STATUS_AILMENTS_BUNDLE.REGEN_AND_CUSTOM_ATK_MATK] = [r.REGEN, r.CUSTOM_ATK_MATK], M[n.STATUS_AILMENTS_BUNDLE.PARALYSIS_AND_SLOW] = [r.PARALYSIS, r.SLOW], M[n.STATUS_AILMENTS_BUNDLE.SLEEP_AND_SAP] = [r.SLEEP, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.CONFUSION_AND_POISON] = [r.CONFUSION, r.POISON], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_BLINDED_AND_SILENCE_AND_SLEEP] = [r.POISON, r.BLINDED, r.SILENCE, r.SLEEP], M[n.STATUS_AILMENTS_BUNDLE.DOOMS] = y, M[n.STATUS_AILMENTS_BUNDLE.STAN_AND_STOP] = [r.STAN, r.STOP], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_STOP] = [r.POISON, r.STOP], M[n.STATUS_AILMENTS_BUNDLE.ESNA_AND_SLOW] = _.uniq([r.SLOW].concat(M[n.STATUS_AILMENTS_BUNDLE.ESNA])), M[n.STATUS_AILMENTS_BUNDLE.SLOW_AND_CUSTOM_ATK_DEF] = [r.SLOW, r.CUSTOM_ATK_DEF], M[n.STATUS_AILMENTS_BUNDLE.SLOW_AND_SAP] = [r.SLOW, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.DAMAGE_CALCULATE_PARAM_ADJUST_BY_RECEIVER_SA_NUM] = [n.STATUS_AILMENTS_TYPE.POISON, n.STATUS_AILMENTS_TYPE.SILENCE, n.STATUS_AILMENTS_TYPE.PARALYSIS, n.STATUS_AILMENTS_TYPE.CONFUSION, n.STATUS_AILMENTS_TYPE.BLINDED, n.STATUS_AILMENTS_TYPE.SLEEP, n.STATUS_AILMENTS_TYPE.BERSERKER, n.STATUS_AILMENTS_TYPE.SAP, n.STATUS_AILMENTS_TYPE.SLOW, n.STATUS_AILMENTS_TYPE.STOP], M[n.STATUS_AILMENTS_BUNDLE.BLINDED_AND_SAP] = [r.BLINDED, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.SLOW_AND_CUSTOM_ATK] = [r.SLOW, r.CUSTOM_ATK], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_PARALYSIS_AND_SLEEP_AND_SILENCE] = [r.POISON, r.PARALYSIS, r.SLEEP, r.SILENCE], M[n.STATUS_AILMENTS_BUNDLE.PARALYSIS_AND_SAP] = [r.PARALYSIS, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_BLINDED_AND_SILENCE_AND_CONFUSION] = [r.POISON, r.BLINDED, r.SILENCE, r.CONFUSION], M[n.STATUS_AILMENTS_BUNDLE.POISON_AND_BLINDED_AND_SILENCE_AND_PETRIFACTION] = [r.POISON, r.BLINDED, r.SILENCE, r.PETRIFACTION], M[n.STATUS_AILMENTS_BUNDLE.CONFUSION_AND_SLOW_AND_BLINDED_AND_DOOM_AND_BERSERKER_AND_SAP] = [r.CONFUSION, r.SLOW, r.BLINDED, r.DOOM, r.BERSERKER, r.SAP], M[n.STATUS_AILMENTS_BUNDLE.MIRAGES] = O, M[n.STATUS_AILMENTS_BUNDLE.GUTS_1_AND_CRITICAL_50] = [r.CUSTOM_PARAM_MULTI_CRITICAL_50, r.GUTS_1], FF.ns.battle.StatusAilmentsConfig = _.extend({
        doomIds: y,
        countIds: N,
        attachElementIds: C,
        reraiseIds: w,
        tranceIds: E,
        gutsIds: S,
        damageBarrierIds: x,
        changeCriticalCoefficientIds: T,
        pureDoomIds: b,
        getParam: function(e) {
            return s[e]
        },
        isContinuanceStatus: function(e) {
            return !!g[e]
        },
        judgeExclusive: function(e, t) {
            var r = s[e],
                i = s[t];
            if (!i || !r) throw new Error("invalid status param.id=" + e + "," + t);
            if (e === t) return n.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE;
            if (r.isAttachElement && i.isAttachElement) return n.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE;
            var o = this._judgeExclusive(r, t),
                u = this._judgeExclusive(i, e),
                a = i.exclusive ? !!i.exclusive.blocking : !1;
            return o && u ? a ? n.STATUS_AILMENTS_EXCLUSIVE.BLOCK : n.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE : o && !u ? n.STATUS_AILMENTS_EXCLUSIVE.EXTRUDE : !o && u ? n.STATUS_AILMENTS_EXCLUSIVE.BLOCK : n.STATUS_AILMENTS_EXCLUSIVE.TOGETHER
        },
        _judgeExclusive: function(e, t) {
            var n = e.exclusive || {};
            if (n.all) return !0;
            if (!_.isArray(n.types)) return !1;
            var r = n.types.indexOf(t) >= 0,
                i = n.invert ? !r : r;
            return i
        },
        isDefinedStatus: function(e) {
            return !!i[e]
        },
        getBundle: function(e, t) {
            t = t || {};
            var n = M[e];
            if (!n && !t.noThrow) throw new Error("unknown bundleId : " + e);
            return n
        },
        getCanNotSetToEnemyIdMap: function() {
            var e = {};
            return _.each(L, function(t) {
                e[t] = !0
            }), e
        },
        getCanNotSetToBuddyIdMap: function() {
            var e = {};
            return _.each(A, function(t) {
                e[t] = !0
            }), e
        }
    }, r)
}), define("scenes/battle/TextMaster", ["jquery", "lib/TextMaster", "lib/ClassBase"], function(e, t, n) {
    var r = n.extend({
            initialize: function() {
                this._libTxt = t.getInstance()
            },
            append: function(e) {
                this._libTxt.append(e)
            },
            get: function(e) {
                return this._libTxt.get(e)
            },
            getMobacoinUnit: function() {
                return this._libTxt.getMobacoinUnit()
            }
        }),
        i = void 0;
    FF.ns.battle.TextMaster = {
        getInstance: function() {
            return i || (i = new r), i
        }
    }
}), define("scenes/battle/ParameterEncoder", ["util"], function(e) {
    var t = ["init_hp", "soul_strike_gauge"],
        n = ["max_num", "num"],
        r = ["init_hp"],
        i = ["acc", "atk", "critical", "def", "eva", "matk", "mdef", "mnd", "spd"],
        s = ["hp", "ss_gauge", "sa", "panel1", "panel2", "panel3"],
        o = function(e) {
            var t = JSON.stringify(e),
                n = "";
            for (var r = 0; r < t.length; r++) {
                var i = t.charCodeAt(r) + 1;
                n += String.fromCharCode(i)
            }
            return n
        };
    FF.ns.battle.ParameterEncoder = {
        snapshotResponse: function(e) {
            var s = function(e) {
                    var n = e && e.params && e.params instanceof Array ? e.params[0] : null,
                        r = _.pick(n, i);
                    return r.ability_panels = u(e.ability_panels), _.extend(r, _.pick(e, t))
                },
                u = function(e) {
                    return _.map(e, function(e) {
                        return _.pick(e, n)
                    })
                },
                a = function(e) {
                    var t = {};
                    return t.enemy = _.map(e.enemy, function(e) {
                        return f(e)
                    }), t
                },
                f = function(e) {
                    var t = {};
                    return t.children = _.map(e.children, function(e) {
                        return l(e)
                    }), t
                },
                l = function(e) {
                    var t = {};
                    return t.params = _.map(e.params, function(e) {
                        return _.pick(e, i)
                    }), _.extend(t, _.pick(e, r))
                },
                c = {},
                h = e && e instanceof Object ? e.battle : null,
                p = h && h instanceof Object ? h.buddy : null,
                d = h && h instanceof Object ? h.rounds : null,
                v = h && h instanceof Object ? h.supporter : null;
            return p && (c.buddy = _.map(p, function(e) {
                return s(e)
            })), d && (c.rounds = _.map(d, function(e) {
                return a(e)
            })), v && v.length > 0 && v[0] instanceof Object && (c.supporter_ss_gauge = v[0].supporter_ss_gauge), o(c)
        },
        snapshotRequest: function(e) {
            var t = function(e) {
                    return _.reduce(e, function(e, t, n) {
                        return e[n] = _.pick(t, s), e
                    }, {})
                },
                n = {};
            return n.buddy = t(e.buddy), n.initChkResult = e.initChkResult, n.supporter_ss_gauge = e.supporter.supporter_ss_gauge, o(n)
        }
    }
}), define("scenes/battle/action/ActionBase", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.ActionBase = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.executer = n, this._attributes = _.extend({
                castTime: 200,
                dependsWeaponEffect: !1,
                actionResult: void 0
            }, r), this._isDone = !1, this._isSuspended = !1, this._isResumed = !1, this._isCanceledInterruptAbility = !1, this.helper = new t.action.ActionHelper(this), this.moHelper = new t.action.MoActionHelper(this), this.animationHelper = new t.action.AnimationHelper(this);
            var i = {},
                s = this.get("statusAilmentsId");
            s && (i[s] = this.get("statusAilmentsFactor")), this.set("atkStatusAilments", i);
            var o = t.Config.getInstance().get("MagicExerciseTypes");
            this._isMagic = _.contains(o, this.get("exerciseType"))
        },
        begin: function(e) {
            e = e || {}, e.additionalDamageObjects && this.moHelper.addAdditionalApplyDamageObjects(e.additionalDamageObjects);
            if (this.executer.isContainer()) {
                this.changeState("INIT");
                return
            }
            this.executer.notifyAbilityBegun(this);
            if (this.isEffectOfStatusAilements || this.isBossDeform) {
                this.changeState("INIT");
                return
            }
            this.executer.canDoAbility() ? this.isMagic() && !this.executer.canUseAllMagic() ? (this.set("invalidityType", t.Conf.INVALIDITY_TYPE.MAGIC), this.changeState("INVALIDITY")) : !!this.get("isFlightAttack") && !this.executer.canUseFlightAttack() ? (this.set("invalidityType", t.Conf.INVALIDITY_TYPE.FIGHT_ATTACK), this.changeState("INVALIDITY")) : this.changeState("INIT") : (this.set("invalidityType", t.Conf.INVALIDITY_TYPE.DO_ABILITY), this.changeState("INVALIDITY"))
        },
        processForStateInvalidityEntry: function() {
            var e = this;
            this.changeState("WAIT_ANIM");
            var n = this.helper.makeAndSetActionResult(this.executer, this, []),
                r = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.INVALIDITY,
                    action: this,
                    actionResult: n,
                    options: {
                        invalidityType: e.get("invalidityType")
                    }
                }).addCallbackOnce("end", function() {
                    e._isDone = !0
                }).play()
        },
        isMagic: function() {
            return this._isMagic
        },
        exerciseType: function() {
            return this.get("exerciseType")
        },
        getAttributes: function() {
            return this._attributes
        },
        getCastTime: function() {
            return this._attributes.castTime
        },
        detectTargets: function() {
            return FF.ns.battle.util.Targeting.search(this)
        },
        isDone: function() {
            return this._isDone
        },
        suspend: function() {
            this._isSuspended = !0, this._isResumed = !1
        },
        resume: function() {
            this._isSuspended = !1, this._isResumed = !0
        },
        isSuspended: function() {
            return this._isSuspended
        },
        isResumed: function() {
            return this._isResumed
        },
        forceQuit: function() {
            this._isDone = !0
        },
        cancelInterruptAbility: function() {
            this._isCanceledInterruptAbility = !0
        },
        isCanceledInterruptAbility: function() {
            return this._isCanceledInterruptAbility
        },
        hasBrokenMaxDamageThreshold: function() {
            return this.get("maxDamageThresholdType") !== t.Conf.DAMAGE_THRESHOLD_TYPE.DEFAULT
        }
    }), FF.ns.battle.action.ActionBase
}), define("scenes/battle/action/helper/ActionHelper", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ActionHelper = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this._ability = t
        },
        makeActionResult: function(e, t, n, r) {
            return _.extend({
                damageObjects: n,
                executer: e,
                ability: t
            }, r)
        },
        makeAndSetActionResult: function(e, t, n, r) {
            var i = this.makeActionResult(e, t, n, r);
            return this.setActionResult(t, i), i
        },
        setActionResult: function(e, t) {
            e.set("actionResult", t)
        },
        isBarrageDamageObjects: function(e) {
            return e.length === 0 ? !1 : _.isArray(_.first(e))
        },
        physicalAttackMutably: function(e, t) {
            var n = this._ability.get("barrageNum") || 1;
            if (n > 1) return this.physicalAttackMulti();
            if (n === 1) {
                var r = this.physicalAttack(e),
                    i = _.any(r.damageObjects, function(e) {
                        return e.canHit
                    });
                return {
                    actionResult: r,
                    isHit: i
                }
            }
            throw new Error("invalid barrageNum")
        },
        physicalAttack: function(e, r) {
            var i = this,
                s = this._ability,
                o = this._ability.executer,
                u = [];
            return r = t.option({
                skipStatusAilments: !1
            }, r), _.each(e, function(t) {
                var a = n.util.DamageCalculator.detectElementByTarget(s, t),
                    f = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.ATTACK,
                        executer: o,
                        target: t,
                        ability: s,
                        targetNum: e.length,
                        forceHit: s.get("forceHit"),
                        forceCritical: s.get("forceCritical"),
                        forceMiss: s.get("forceMiss"),
                        defIgnored: s.get("defIgnored"),
                        atkExponentialFactor: s.get("atkExponentialFactor"),
                        defBoostIgnored: s.get("defBoostIgnored"),
                        atkElement: a ? a.targetElement : void 0,
                        possibleElements: a ? a.possibleElements : []
                    });
                if (!r.skipStatusAilments) {
                    var l = s.get("atkStatusAilments"),
                        c = o.get("atkStatusAilments"),
                        h = _.isEmpty(l) ? c : l;
                    i._calculateStatusAilments({
                        target: t,
                        atkStatusAilments: h,
                        damageObject: f,
                        disableForceHit: !0
                    })
                }
                u.push(f)
            }), this.makeAndSetActionResult(o, s, u)
        },
        physicalAttackMulti: function(e) {
            e = t.option({
                skipStatusAilments: !1,
                targets: void 0
            }, e);
            var r = this,
                i = this._ability,
                s = this._ability.executer,
                o = i.get("barrageNum") || 1,
                u = i.get("isSameTarget"),
                a = e.targets,
                f = [],
                l, c = function(e) {
                    return e.canHit
                };
            for (var h = 1; h <= o; h++) {
                if (!u || !a) a = i.detectTargets();
                var p = this.physicalAttack(a, {
                    skipStatusAilments: e.skipStatusAilments
                });
                l || (l = _.any(p.damageObjects, c)), f.push(p.damageObjects)
            }
            n.util.DamageCalculator.recalculateHp(f);
            var d = this.makeAndSetActionResult(s, i, f);
            return {
                actionResult: d,
                isHit: l
            }
        },
        magicAttack: function(e, r) {
            var i = this,
                s = this._ability,
                o = this._ability.executer,
                u = [];
            return r = t.option({
                skipStatusAilments: !1
            }, r), _.each(e, function(e) {
                var t = n.util.DamageCalculator.detectElementByTarget(s, e),
                    a = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.MAGIC,
                        executer: o,
                        target: e,
                        ability: s,
                        defIgnored: s.get("defIgnored"),
                        defBoostIgnored: s.get("defBoostIgnored"),
                        matkExponentialFactor: s.get("matkExponentialFactor"),
                        matkElement: t ? t.targetElement : void 0,
                        possibleElements: t ? t.possibleElements : []
                    });
                r.skipStatusAilments || i._calculateStatusAilments({
                    target: e,
                    damageObject: a
                }), u.push(a)
            }), this.makeAndSetActionResult(o, s, u)
        },
        magicAttackMulti: function(e) {
            e = t.option({
                skipStatusAilments: !1,
                targets: void 0
            }, e);
            var n = this,
                r = this._ability,
                i = this._ability.executer,
                s = r.get("barrageNum") || 1,
                o = r.get("isSameTarget"),
                u = e.targets,
                a = [],
                f, l = function(e) {
                    return e.canHit
                };
            for (var c = 1; c <= s; c++) {
                if (!o || !u) u = r.detectTargets();
                var h = this.magicAttack(u, {
                    skipStatusAilments: e.skipStatusAilments
                });
                f || (f = _.any(h.damageObjects, l)), a.push(h.damageObjects)
            }
            this.recalculate(a);
            var p = this.makeAndSetActionResult(i, r, a);
            return {
                actionResult: p,
                isHit: f
            }
        },
        lotStatusAilments: function(e) {
            var t = this,
                n = this._ability,
                r = this._ability.executer,
                i = [];
            return _.each(e, function(e) {
                var n = t._calculateStatusAilments({
                    target: e
                });
                i.push(n)
            }), this.makeAndSetActionResult(r, n, i)
        },
        lotStatusAilmentsByLevel: function(e, t) {
            var n = this,
                r = this._ability,
                i = this._ability.executer,
                s = [];
            return _.each(e, function(e) {
                var r = {
                    target: e
                };
                n._judgeHittableByLevel(e, t) ? r.forceHit = !0 : r.forceMiss = !0;
                var i = n._calculateStatusAilments(r);
                s.push(i)
            }), this.makeAndSetActionResult(i, r, s)
        },
        applyActionResultMutably: function(e) {
            var t = this._ability.helper.isBarrageDamageObjects(e.damageObjects);
            return t ? this.applyActionResultForBarrage(e) : this.applyActionResult(e)
        },
        applyActionResult: function(e) {
            return this.applyDamageObjects(e.damageObjects)
        },
        applyActionResultForBarrage: function(e, n) {
            n = t.option({
                shouldReCalcCounterEnable: !1
            }, n), n.shouldReCalcCounterEnable && this.recalculateCounterEnableFlag(e.damageObjects), _.each(e.damageObjects, function(e) {
                this.applyDamageObjects(e)
            }, this)
        },
        applyDamageObjects: function(e) {
            _.each(e, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        mergeDamageObjects: function(e, t) {
            Array.prototype.push.apply(e, t)
        },
        mergeDamageObjectsForBarrage: function(e, t) {
            e.push(t)
        },
        filterByCanHitFromDamageObjects: function(e) {
            return _.filter(e, function(e) {
                return e.canHit
            })
        },
        makeTargetsFromHitDamageObjects: function(e) {
            var t = _.map(this.filterByCanHitFromDamageObjects(e), function(e) {
                return e.receiver
            });
            return n.util.Targeting.makeResult(t)
        },
        _calculateStatusAilments: function(e) {
            var t = this._ability,
                r = this._ability.executer,
                i = e.target,
                s = e.atkStatusAilments || t.get("atkStatusAilments"),
                o = e.forceHit || t.get("forceHit"),
                u = e.forceMiss || t.get("forceMiss"),
                a = e.damageObject,
                f = e.statusAilmentsOptions || t.get("statusAilmentsOptions");
            if (a && !a.canHit) return;
            if (a && a.hasReplacedCalcType) return;
            return n.util.DamageCalculator.calculate({
                type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: r,
                target: i,
                ability: t,
                atkStatusAilments: s,
                statusAilmentsOptions: f,
                forceHit: e.disableForceHit ? !1 : o,
                forceMiss: e.disableForceMiss ? !1 : u,
                damageObject: a
            })
        },
        _judgeHittableByLevel: function(e, t) {
            var n = e.receiver.get("level");
            return n % t === 0
        },
        detectDeformAnimationInfo: function() {
            var e = this._ability.executer;
            if (!e.isEnemy()) throw new Error("this function is useful for only enemy");
            if (e.isContainer()) throw new Error("not allow container execution");
            var t = void 0;
            t = this._ability.get("animationId");
            if (t) return {
                animationId: t
            };
            var n = e.get("no"),
                r = this._ability.get("abilityId"),
                i = e.container.get("abilityDeformMapTag") || {},
                s = i[n] && i[n][r];
            if (s) {
                var o = {};
                if (_.isString(s)) o.deformTag = s;
                else if (_.isObject(s)) {
                    if (!s.deformTag) throw new Error("Not found deformTag.");
                    o.deformTag = s.deformTag, o.options = s.options || {}
                }
                return o
            }
            var u = e.container.get("abilityDeformMap") || {};
            t = u[n] && u[n][r];
            if (t) return {
                animationId: t
            };
            throw new Error("not configure valid abilityDeformMap into AI")
        },
        calcFractionDamage: function(e, r) {
            var i = this._ability,
                s = i.executer;
            r = t.option({
                useMaxHp: !!i.get("useMaxHp"),
                statusAilmentsId: i.get("statusAilmentsId"),
                statusAilmentsFactor: i.get("statusAilmentsFactor"),
                forceHitWithoutSa: !!i.get("forceHitWithoutSa")
            }, r);
            var o = r.useMaxHp ? "maxHp" : "hp";
            return _.map(e, function(e) {
                return n.util.DamageCalculator.calculate(_.extend({
                    type: n.Conf.CALC_TYPE.FRACTION,
                    executer: s,
                    target: e,
                    ability: i,
                    numerator: e.receiver.get(o)
                }, r))
            })
        },
        fractionDamage: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcFractionDamage(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        calcForFixedDamage: function(e, r) {
            var i = this._ability;
            return r = t.option({
                fixedDamage: i.get("fixedDamage"),
                ignoreTargetCountDivision: i.get("ignoreTargetCountDivision"),
                targetCount: e.length
            }, r), this._calculateDamageByTargets({
                type: n.Conf.CALC_TYPE.FIXED_DAMAGE,
                targets: e,
                options: r
            })
        },
        fixedDamage: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForFixedDamage(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        fixedDamageWithSa: function(e, r) {
            var i = this,
                s = e.length,
                o = this._ability,
                u = this._ability.executer;
            r = t.option({
                skipStatusAilments: !1,
                statusAilmentsOptions: void 0
            }, r);
            var a = this.calcForFixedDamage(e, r);
            if (r.skipStatusAilments) return this.makeAndSetActionResult(u, o, a);
            var f = [];
            return _.each(a, function(e) {
                var t = n.util.Targeting.makeResult(e.executer);
                _.each(t, function(t) {
                    i._calculateStatusAilments({
                        target: t,
                        damageObject: e,
                        statusAilmentsOptions: r.statusAilmentsOptions
                    }), f.push(e)
                })
            }), this.makeAndSetActionResult(u, o, f)
        },
        fixedDamageMultiWithSa: function(e) {
            e = t.option({
                skipStatusAilments: !1,
                statusAilmentsOptions: void 0,
                targets: void 0
            }, e);
            var r = this,
                i = this._ability,
                s = this._ability.executer,
                o = i.get("barrageNum") || 1,
                u = i.get("isSameTarget"),
                a = e.targets,
                f = [],
                l, c = function(e) {
                    return e.canHit
                };
            for (var h = 1; h <= o; h++) {
                if (!u || !a) a = i.detectTargets();
                var p = this.fixedDamageWithSa(a, {
                    skipStatusAilments: e.skipStatusAilments,
                    statusAilmentsOptions: e.statusAilmentsOptions
                });
                l || (l = _.any(p.damageObjects, c)), f.push(p.damageObjects)
            }
            n.util.DamageCalculator.recalculateHp(f);
            var d = this.makeAndSetActionResult(s, i, f);
            return {
                actionResult: d,
                isHit: l
            }
        },
        calcForHealSa: function(e, r) {
            var i = this._ability;
            return r = t.option({
                hitRate: i.get("hitRate"),
                statusAilmentsIds: i.get("healStatusAilmentIds")
            }, r), this._calculateDamageByTargets({
                type: n.Conf.CALC_TYPE.HEAL_SA,
                targets: e,
                options: r
            })
        },
        calcForHpBarter: function(e) {
            e = t.option({}, e);
            var r = this._ability,
                i = this._ability.executer;
            return n.util.DamageCalculator.calculate({
                type: n.Conf.CALC_TYPE.HP_BARTER,
                executer: i,
                receiver: i,
                ability: r,
                isMultiplicandMaxHp: r.get("isMultiplicandMaxHp")
            })
        },
        healSa: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForHealSa(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        calcForInflictSa: function(e, r) {
            var i = this._ability;
            return r = t.option({
                atkStatusAilments: i.get("atkStatusAilments"),
                statusAilmentsOptions: i.get("statusAilmentsOptions"),
                forceHit: i.get("forceHit"),
                forceMiss: i.get("forceMiss"),
                damageObject: void 0
            }, r), this._calculateDamageByTargets({
                type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                targets: e,
                options: r
            })
        },
        inflictSa: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForInflictSa(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        calcForHealHp: function(e, r) {
            return r = t.option({}, r), this._calculateDamageByTargets({
                type: n.Conf.CALC_TYPE.HEAL,
                targets: e,
                options: r
            })
        },
        healHp: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForHealHp(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        calcForFractionalHealHp: function(e, r) {
            var i = this._ability,
                s = i.executer;
            r = t.option({}, r);
            var o = [];
            return _.each(e, function(e) {
                var t = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.FRACTION_HEAL,
                    executer: s,
                    target: e,
                    ability: i,
                    numerator: e.receiver.get("maxHp")
                });
                o.push(t)
            }), o
        },
        fractionalHealHp: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForFractionalHealHp(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        calcForReduceMp: function(e, r) {
            var i = this._ability,
                s = i.executer;
            return r = t.option({
                hitRate: this.get("hitRate"),
                damageFactor: this.get("damageFactor")
            }, r), _.map(e, function(e) {
                var t = void 0;
                e.receiver.isBuddy() && (t = n.util.PanelTargeting.search(e.receiver, {
                    receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: n.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS
                }));
                var o = t ? r.hitRate : 0;
                return n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.ABILITY_PANEL,
                    executer: s,
                    target: e,
                    ability: i,
                    abilityPanel: t,
                    isDecrease: !0,
                    damageFactor: r.damageFactor,
                    hitRate: o,
                    isRemainingBase: !0
                })
            })
        },
        reduceMp: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForReduceMp(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        dealSsPoint: function(e, t) {
            var r = this._ability,
                i = this._ability.executer,
                s = [];
            return _.each(e, function(e) {
                var t = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.DEALING_SS_POINT,
                    executer: i,
                    target: e,
                    ability: r,
                    ssPoint: r.get("ssPoint"),
                    dealType: r.get("dealType")
                });
                s.push(t)
            }), this.makeAndSetActionResult(i, r, s)
        },
        calcForShowAbilityEffect: function(e, r) {
            var i = this._ability,
                s = i.executer;
            return r = t.option({
                showReturnEffect: i.get("showReturnEffect")
            }, r), _.map(e, function(e) {
                var t = n.util.DamageCalculator.makeDamageObject(s, e.receiver, i, {
                    canHit: !0,
                    isCritical: !1
                });
                return r.showReturnEffect && (t.absorber = s, t.absorbHp = {
                    canHit: !0
                }), t
            })
        },
        showAbilityEffect: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForShowAbilityEffect(e, t);
            return this.makeAndSetActionResult(r, n, i)
        },
        _calculateDamageByTargets: function(e) {
            var t = this._ability,
                r = t.executer;
            return _.map(e.targets, function(i) {
                return n.util.DamageCalculator.calculate(_.extend({
                    type: e.type,
                    executer: r,
                    target: i,
                    ability: t
                }, e.options))
            })
        },
        recalculate: function(e) {
            n.util.DamageCalculator.recalculateHp(e), n.util.DamageCalculator.recalculateAbilityPanelNum(e)
        },
        setSkipUnsetFlagWhenDamagedByActionResult: function(e) {
            var t = {},
                r = e.ability.get("targetSaIdsByAttackDependedOnSa") || [];
            _.each(r, function(e) {
                e === n.Conf.STATUS_AILMENTS_TYPE.CONFUSION && (t.skipUnsetConfusionWhenDamaged = !0), e === n.Conf.STATUS_AILMENTS_TYPE.SLEEP && (t.skipUnsetSleepWhenDamaged = !0)
            });
            var i = function(e) {
                if (_.isArray(e)) {
                    _.each(e, i);
                    return
                }
                _.extend(e, t)
            };
            _.each(e.damageObjects, i)
        },
        recalculateCounterEnableFlag: function(e) {
            n.util.DamageCalculator.recalculateCounterEnableFlag(e)
        },
        makeChangeCastTimeInfoMap: function(e, t, r, i) {
            var s = {};
            return e === n.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME && (s.castTimeFactor = t, s.validAbilityUseCountForChangeCastTime = r, s.abilityCategoryIdForChangeCastTime = i, s.abilityCategoryIdForChangeCastTime || (s.allAbilitiesForChangeCastTime = !0)), s
        },
        calcFlightDuration: function(e) {
            var t = e.statusAilments.getFlightDurationFactor();
            return _.isNumber(t) ? t : this._ability.get("flightDuration")
        },
        setDamageCalculateTypeByAbility: function(e) {
            var t = n.Config.getInstance().get("ParamIgnoreTypeConfig", e);
            _.extend(this._ability._attributes, t)
        },
        setDamageCalculateParamAdjustConf: function(e, t) {
            if (!e) return;
            var r = n.Config.getInstance().get("DamageCalculateParamAdjusts", e),
                i = {};
            i[r] = {
                adjustType: e,
                adjustConds: t || []
            }, this._ability.set("damageCalculateParamAdjustConf", i)
        },
        makeBoostObject: function(e, n, r) {
            return r = r || {}, r = t.option({
                isAbsolute: !1
            }, r), r.isAbsolute ? {
                absolute: n
            } : {
                rate: n
            }
        },
        calcCritical: function(e) {
            var t = this._ability.executer;
            return e + t.get("critical")
        },
        calcCriticalCoefficient: function(e) {
            return _.isNumber(e) && e > 0 ? e : n.Config.getInstance().get("DamageCalculator", "DAMAGE", "criticalCoefficient")
        },
        includesHitDamageObject: function(e) {
            return _.any(e, function(e) {
                return _.isArray(e) ? this.includesHitDamageObject(e) : e.canHit
            }, this)
        },
        calcForFixedHealHp: function(e, r) {
            var i = this._ability,
                s = i.executer,
                o = i.get("fixedHealValue");
            r = t.option({}, r);
            var u = [];
            return _.each(e, function(e) {
                var t = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.FIXED_HEAL_HP,
                    executer: s,
                    receiver: e.receiver,
                    ability: i,
                    fixedHealValue: o
                });
                u.push(t)
            }), u
        },
        fixedHealHp: function(e, t) {
            var n = this._ability,
                r = n.executer,
                i = this.calcForFixedHealHp(e, t);
            return this.makeAndSetActionResult(r, n, i)
        }
    })
}), define("scenes/battle/action/helper/MoActionHelper", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.MoActionHelper = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this._ability = t, this._additionalApplyDamageObjects = [], this._beforeApplyDamageObjects = [], this._replaceApplyDamageObjects = []
        },
        addAdditionalApplyDamageObjects: function(e) {
            this._additionalApplyDamageObjects = this._additionalApplyDamageObjects.concat(e)
        },
        getAdditionalApplyDamageObjects: function() {
            return this._additionalApplyDamageObjects
        },
        hasAdditionalApplyDamageObjects: function() {
            return this._additionalApplyDamageObjects.length > 0
        },
        addBeforeApplyDamageObjects: function(e) {
            this._beforeApplyDamageObjects = this._beforeApplyDamageObjects.concat(e)
        },
        getBeforeApplyDamageObjects: function() {
            return this._beforeApplyDamageObjects
        },
        hasBeforeApplyDamageObjects: function() {
            return this._beforeApplyDamageObjects.length > 0
        },
        addReplaceApplyDamageObjects: function(e) {
            this._replaceApplyDamageObjects = this._replaceApplyDamageObjects.concat(e)
        },
        getReplaceApplyDamageObjects: function() {
            return this._replaceApplyDamageObjects
        },
        hasReplaceApplyDamageObjects: function() {
            return this._replaceApplyDamageObjects.length > 0
        },
        setCreateOptions: function(e) {
            this._createOptions = e
        },
        getCreateOptions: function() {
            return this._createOptions
        }
    })
}), define("scenes/battle/action/helper/AnimationHelper", ["lib/EventBase", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.AnimationHelper = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this._ability = t
        },
        playAnimationMutablyDeferred: function(e) {
            var t = this._ability.helper.isBarrageDamageObjects(e.damageObjects);
            return t ? this.playAnimationForBarrageDeferred(e) : this.playAnimationForNormalDeferred(e)
        },
        createAnimationForNormal: function(e, r) {
            var i = this._ability;
            return r = t.option({
                skipDamageMotion: !1,
                skipAttackMotion: !!i.get("skipAttackMotion")
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: i,
                actionResult: e,
                options: r
            })
        },
        playAnimationForNormalDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForNormal(e, t))
        },
        createAnimationForBarrage: function(e, r) {
            var i = this._ability;
            return r = t.option({
                skipDamageMotion: !1,
                skipDamageMotionCountMap: {},
                skipAttackMotion: !!i.get("skipAttackMotion")
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.BARRAGE,
                action: i,
                actionResult: e,
                options: r
            })
        },
        playAnimationForBarrageDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForBarrage(e, t))
        },
        createAnimationForDamage: function(e, r) {
            var i = this._ability;
            return r = t.option({
                skipDamageMotion: !1,
                normalDamageMotion: !1,
                isParallelPlayAnimation: !1
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.DAMAGE,
                action: i,
                actionResult: e,
                options: r
            })
        },
        playAnimationForDamageDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForDamage(e, t))
        },
        createAnimationForDamageBarrage: function(e, r) {
            var i = this._ability;
            return r = t.option({
                skipDamageMotion: !1,
                normalDamageMotion: !1,
                damageMotionMsec: void 0
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.DAMAGE_BARRAGE,
                action: i,
                actionResult: e,
                options: r
            })
        },
        playAnimationForDamageBarrageDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForDamageBarrage(e, t))
        },
        createAnimationForDeformAttack: function(e, r) {
            var i = this._ability,
                s = i.executer,
                o = s.container ? s.container : s;
            return r = t.option({
                shouldDeformAllNodes: !!i.get("shouldDeformAllNodes"),
                skipDamageMotion: !1,
                usesMainNode: !!i.get("usesMainNode")
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: i,
                actionResult: e,
                enemyContainer: o,
                animationInfo: i.helper.detectDeformAnimationInfo(),
                shouldDeformAllNodes: r.shouldDeformAllNodes,
                options: r
            })
        },
        playAnimationForDeformAttackDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForDeformAttack(e, t))
        },
        onDeformEndForDeformAttack: function(e) {
            this._onDeformEnd(e)
        },
        createAnimationForDeformBarrage: function(e, r) {
            var i = this._ability,
                s = i.executer,
                o = s.container ? s.container : s;
            return r = t.option({
                shouldDeformAllNodes: !!i.get("shouldDeformAllNodes"),
                skipDamageMotion: !1,
                usesMainNode: !!i.get("usesMainNode")
            }, r), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.DEFORM_BARRAGE,
                action: i,
                actionResult: e,
                enemyContainer: o,
                animationInfo: i.helper.detectDeformAnimationInfo(),
                shouldDeformAllNodes: r.shouldDeformAllNodes,
                options: r
            })
        },
        playAnimationForDeformBarrageDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForDeformBarrage(e, t))
        },
        createAnimationForWait: function(e, t) {
            var r = this._ability;
            return n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.WAIT,
                action: r,
                actionResult: e,
                options: t
            })
        },
        playAnimationForWaitDeferred: function(e, t) {
            return this._playAnimationDeferred(this.createAnimationForWait(e, t))
        },
        onDeformEndForDeformBarrage: function(e) {
            this._onDeformEnd(e)
        },
        _playAnimationDeferred: function(e) {
            var t = $.Deferred();
            return e.addCallbackOnce("end", function() {
                t.resolve()
            }).play(), t.promise()
        },
        _onDeformEnd: function(e) {
            var n = this._ability,
                r = n.executer,
                i = r.container ? r.container : r;
            e = t.option({
                looking: !!n.get("looking")
            }, e);
            var s = e.looking;
            s && i.set("looking", s)
        }
    })
}), define("scenes/battle/action/BuiltinHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.WHITE_MAGIC,
            ignoresReflection: !0,
            statusAilmentsId: n.STATUS_AILMENTS_TYPE.DEATH,
            targetDeath: n.TARGET_DEATH.INCLUDE,
            targetMethod: n.TARGET_METHOD.SA_RANDOM,
            targetRange: n.TARGET_RANGE.SINGLE,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinHealDeathAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargets: function(e) {
            var r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/BuiltinIncreaseMpAction", ["./ActionBase", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf,
        i = {
            activeTargetMethod: r.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
            exerciseType: r.EXERCISE_TYPE.INBORN,
            targetDeath: r.TARGET_DEATH.EXCLUDE,
            targetMethod: r.TARGET_METHOD.NOTHING,
            targetRange: r.TARGET_RANGE.ALL,
            targetSegment: r.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinIncreaseMpAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, i, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargetsAndParams: function(e, t) {
            var r = this,
                i = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = n.util.PanelTargeting.search(e.receiver, {
                    receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: t.remainNum,
                    usedNum: t.usedNum,
                    priorityType: t.priorityType
                }));
                var s = r ? t.hitRate : 0,
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !1,
                        damageFactor: t.damageFactor,
                        hitRate: s,
                        isRemainingBase: !1
                    });
                i.push(o)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, i)
        }
    })
}), define("scenes/battle/action/BuiltinInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
            exerciseType: n.EXERCISE_TYPE.INBORN,
            targetDeath: n.TARGET_DEATH.EXCLUDE,
            targetMethod: n.TARGET_METHOD.NOTHING,
            targetRange: n.TARGET_RANGE.SELF,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinInflictSaAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResultWithTargetsAndParams: function(e, r) {
            var i = [];
            return _.each(e, function(e) {
                var s = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: r.atkStatusAilments,
                    statusAilmentsOptions: r.statusAilmentsOptions,
                    forceMiss: r.forceMiss || !1
                });
                i.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, i)
        },
        makeActionResult: function(e) {
            var r = e && e.targets;
            r || (r = this.detectTargets());
            var i = [];
            return _.each(r, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("statusAilmentsOptions"),
                    forceHit: !!this.get("forceHit"),
                    forceMiss: !!this.get("forceMiss")
                });
                i.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, i)
        }
    })
}), define("scenes/battle/action/BuiltinHealHpByDamageSumAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.INBORN,
            targetDeath: n.TARGET_DEATH.EXCLUDE,
            targetMethod: n.TARGET_METHOD.NOTHING,
            targetRange: n.TARGET_RANGE.SELF,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE
        };
    FF.ns.battle.action.BuiltinHealHpByDamageSumAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        makeActionResultWithParams: function(e) {
            var n = this.detectTargets();
            this.set("healHpFactor", e.healHpFactor);
            var r = [],
                i = n.length;
            return _.each(n, function(n) {
                var s = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_HP_BY_DAMAGE_SUM,
                    executer: this.executer,
                    target: n,
                    ability: this,
                    damageSum: e.damageSum / i,
                    forceMiss: e.forceMiss
                });
                r.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/BuiltinHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.WHITE_MAGIC,
            ignoresReflection: !0,
            targetDeath: n.TARGET_DEATH.EXCLUDE,
            targetMethod: n.TARGET_METHOD.HP_RATIO_ASC,
            targetRange: n.TARGET_RANGE.ALL,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE,
            factor: 0,
            matkElement: t.Conf.ELEMENT_TYPE.NONE
        };
    FF.ns.battle.action.BuiltinHealHpAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        calcDamageObjects: function() {
            var e = this.detectTargets();
            return this.calcDamageObjectsWithTargets(e)
        },
        calcDamageObjectsWithTargets: function(e) {
            return this.helper.calcForHealHp(e)
        }
    })
}), define("scenes/battle/action/BuiltinEnemyMultipleAbilityAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.BuiltinEnemyMultipleAbilityAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            if (_.isUndefined(this.get("multipleAbilitySettings"))) throw new Error("multipleAbilitySettings is required");
            this.set("currAbility", null), this.set("abilityIdx", 0), this.set("tmpDamageObjects", [])
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            var e = this.get("currAbility");
            e && e.update()
        },
        processForStateInitUpdate: function() {
            this.changeState("WAIT_ANIM")
        },
        processForStateWaitAnimEntry: function() {
            this._registerCurrAbility()
        },
        processForStateWaitAnimUpdate: function() {
            var e = this.get("currAbility");
            if (!e) return;
            if (e.isDone()) {
                var t = e.get("actionResult"),
                    n = t ? t.damageObjects : [],
                    r = this.get("tmpDamageObjects");
                _.isArray(_.first(n)) ? r = r.concat(n) : r.push(n), this.set("tmpDamageObjects", r), this._shiftNextAbility() ? this._registerCurrAbility() : (this._setActionResult(), this._isDone = !0)
            }
        },
        _shiftNextAbility: function() {
            var e = this.get("multipleAbilitySettings"),
                t = this.get("abilityIdx") + 1;
            return this.set("abilityIdx", t), e.length <= t ? !1 : this._checkCurrCondition() ? !0 : this._shiftNextAbility()
        },
        _checkCurrCondition: function() {
            var e = this.get("multipleAbilitySettings"),
                t = e[this.get("abilityIdx")],
                n = this.get("tmpDamageObjects"),
                r = t.conditions || {},
                i = !0;
            return i && !!r.anyCanHit && (i = _.any(n, function(e) {
                return _.any(e, function(e) {
                    return e.canHit
                })
            })), i && !!r.noCanHit && (i = _.all(n, function(e) {
                return _.all(e, function(e) {
                    return !e.canHit
                })
            })), i
        },
        _registerCurrAbility: function() {
            var e = this.get("multipleAbilitySettings"),
                t = e[this.get("abilityIdx")],
                r = t.abilityId,
                i = _.extend({}, t.abilityOptions),
                s = this.executer,
                o = this.executer.isContainer() ? this.executer : this.executer.container,
                u = t.conditions || {};
            i.activeTargetId && (i.activeTarget = o.getChild(i.activeTargetId)), t.abilityTag && (r = s.getAbilityIdByTag(t.abilityTag)), u.targetType === n.Conf.ENEMY_BUILTIN_MULTIPLE_TARGET_TYPE.SAME_CAN_HIT && (i.forceTargets = this._canHitAllTargets());
            var a = n.AbilityFactory.create(r, s, i);
            this.set("currAbility", a), a.begin()
        },
        _setActionResult: function() {
            var e = this.executer,
                t = this,
                n = this.get("tmpDamageObjects"),
                r = {};
            this.helper.makeAndSetActionResult(e, t, n, r)
        },
        _canHitAllTargets: function() {
            var e = _.flatten(this.get("tmpDamageObjects")),
                t = this.helper.filterByCanHitFromDamageObjects(e),
                n = [];
            return _.each(t, function(e) {
                if (_.any(n, function(t) {
                        return t.equals(e.receiver)
                    })) return;
                n.push(e.receiver)
            }), n
        }
    })
}), define("scenes/battle/action/BuiltinFractionalHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.INBORN,
            ignoresReflection: !0,
            targetDeath: n.TARGET_DEATH.EXCLUDE,
            targetMethod: n.TARGET_METHOD.HP_RATIO_ASC,
            targetRange: n.TARGET_RANGE.ALL,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE,
            factor: 0,
            matkElement: t.Conf.ELEMENT_TYPE.NONE
        };
    FF.ns.battle.action.BuiltinFractionalHealHpAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        getActionResult: function() {
            var e = this.detectTargets(),
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: n.CALC_TYPE.FRACTION_HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    numerator: e.receiver.get("maxHp")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/BuiltinHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {
            activeTargetMethod: n.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE,
            exerciseType: n.EXERCISE_TYPE.WHITE_MAGIC,
            targetDeath: n.TARGET_DEATH.EXCLUDE_PURE_DEATH,
            targetMethod: n.TARGET_METHOD.SA_RANDOM,
            targetRange: n.TARGET_RANGE.ALL,
            targetSegment: n.TARGET_SEGMENT.COLLEAGUE,
            hitRate: 100
        };
    FF.ns.battle.action.BuiltinHealSaAction = e.extend({
        initialize: function(t, n) {
            n = _.extend({}, r, n), e.prototype.initialize.call(this, t, n)
        },
        calcDamageObjects: function() {
            var e = this.detectTargets();
            return this.calcDamageObjectsWithTargets(e)
        },
        calcDamageObjectsWithTargets: function(e) {
            return this.helper.calcForHealSa(e)
        }
    })
}), define("scenes/battle/action/CustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.CustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg2")
                }
            }), this.set("forceHit", !!this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM"), this.playAnimationDeferred(r).then(function() {
                e.helper.applyActionResult(r), e.onAnimationEndHook(), e._isDone = !0
            })
        },
        playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e, {
                skipDamageMotion: !0
            })
        },
        onAnimationEndHook: function() {}
    }), FF.ns.battle.action.CustomParamAction
}), define("scenes/battle/action/CustomParamDeformAction", ["./CustomParamAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.CustomParamDeformAction = e.extend({
        playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e, {
                skipDamageMotion: !0
            })
        },
        onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/CustomParamAndSelfDestructAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamAndSelfDestructAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg2")
                }
            }), this.set("deathRate", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = this.executer,
                i = this.detectTargets(),
                s = this.helper.lotStatusAilments(this.detectTargets()),
                o = e.lotByFraction(this.get("deathRate"));
            this.changeState("WAIT_ANIM");
            var u = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: s,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResult(s), o && r.statusAilments.set(n.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, r), t._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/CustomParamAndInflictHpStockAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.CustomParamAndInflictHpStockAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("arg1"),
                n = this.get("arg2");
            this.set("forceHit", !!this.get("arg3"));
            var r = this.get("statusAilmentId");
            this.set("statusAilmentsOptions", {
                boost: this.helper.makeBoostObject(r, t),
                infoMap: {
                    duration: n
                }
            }), this._hpStockParam = this._makeHpStockParam()
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = _.map(n, function(t) {
                    return e.helper._calculateStatusAilments({
                        target: t
                    })
                }),
                i = [];
            _.each(r, function(n) {
                if (n.canHit) {
                    var r = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: e._hpStockParam.atkStatusAilments,
                        statusAilmentsOptions: e._hpStockParam.statusAilmentsOptions,
                        forceHit: !0
                    });
                    i.push(r)
                }
            });
            var s = this.helper.makeAndSetActionResult(this.executer, this, i);
            t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(r), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForNormalDeferred(s).then(function() {
                e.helper.mergeDamageObjects(s.damageObjects, r), e.helper.recalculateCounterEnableFlag(s.damageObjects), e.helper.applyActionResult(s), e._isDone = !0
            })
        },
        _makeHpStockParam: function() {
            var e = this.get("arg4"),
                t = {};
            return t[e] = 100, {
                atkStatusAilments: t,
                statusAilmentsOptions: {
                    infoMap: {
                        duration: this.get("arg5"),
                        maxConsumableHpStock: this.get("arg6")
                    }
                }
            }
        }
    })
}), define("scenes/battle/action/DoNothingAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DoNothingAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._isDone = !0
        }
    })
}), define("scenes/battle/action/DoNothingStrictlyAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DoNothingStrictlyAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            this._isDone = !0
        }
    })
}), define("scenes/battle/action/DamagedHpAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DamagedHpAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.DAMAGED_HP,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/DealSsPointAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DealSsPointAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dealType", this.get("arg1")), this.set("ssPoint", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                n = this.helper.dealSsPoint(t);
            this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForNormal(n, {
                skipDamageMotion: !0
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/DefenseAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.DefenseAction = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.set("name", t.TextMaster.getInstance().get("B10040"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = t.util.DamageCalculator.makeDamageObject(this.executer, this.executer, this);
            n.statusAilments = [t.Conf.STATUS_AILMENTS_TYPE.DEFENSE];
            var r = this.helper.makeAndSetActionResult(this.executer, this, [n]);
            this.helper.applyActionResult(r), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForWaitDeferred(r).then(function() {
                e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/DeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3;
    FF.ns.battle.action.DeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), _.bindAll(this, "onDeformEnd"), this.set("messageId", n.messageId), !n.messageSuffixNo || this.set("messageId", this.executer.getMessageIdBySuffixNo(n.messageSuffixNo)), this.set("animationId", n.animationId), this.set("looking", n.looking), this.set("shouldDeformAllNodes", !!n.shouldDeformAllNodes), this.set("filteringDeformPosArray", n.filteringDeformPosArray), this.set("skipMainNodeDeform", !!n.skipMainNodeDeform), this.isBossDeform = !0
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.changeState("WAIT_ANIM");
            var r = $.Deferred(),
                i = function() {
                    r.resolve()
                },
                s = $.Deferred(),
                o = function() {
                    s.resolve()
                },
                u = function() {
                    i(), o()
                },
                a = this.get("messageId") ? !0 : !1,
                f = this.get("animationId") || this.get("deformTag");
            a && !f ? (t.util.DelayCallback.register(n, i), this._showMessage(o)) : f ? this._showDeform(u, a) : (FF.logger.error("DEFORM :nothing to do"), t.util.DelayCallback.register(n, i), o()), $.when(r.promise(), s.promise()).then(function() {
                e.onDeformEnd()
            })
        },
        _showMessage: function(e) {
            var n = this.get("messageId"),
                r = this._getMessageInfo(n);
            if (r) {
                var i = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.MESSAGE,
                    messageInfo: r
                });
                i.addCallbackOnce("end", e), i.play()
            } else FF.logger.debug("should not show"), e()
        },
        _showDeform: function(e, n) {
            var r = this.executer.container ? this.executer.container : this.executer;
            FF.logger.debug("DEFORM", {
                animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                enemyContainer: r,
                animationInfo: {
                    animationId: this.get("animationId"),
                    deformTag: this.get("deformTag")
                },
                messageId: this.get("messageId")
            });
            var i = void 0;
            n && (i = this._getMessageInfo(this.get("messageId")));
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                enemyContainer: r,
                animationInfo: {
                    animationId: this.get("animationId"),
                    deformTag: this.get("deformTag")
                },
                filteringDeformPosArray: this.get("filteringDeformPosArray"),
                shouldDeformAllNodes: this.get("shouldDeformAllNodes"),
                messageInfo: i
            });
            s.addCallbackOnce("end", e), s.play()
        },
        _getMessageInfo: function(e) {
            var n = t.Message.getInstanceById(e),
                r = n.shouldShow();
            return r ? n.getMessageInfo() : void 0
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/DeformMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3,
        r = {
            SET_SA: function(e) {
                t.ai.AiUtil.builtinSetSa(this.executer, e)
            },
            UNSET_SA: function(e) {
                t.ai.AiUtil.builtinUnsetSa(this.executer, e)
            },
            UNSET_ALL_SA: function(e) {
                t.ai.AiUtil.builtinUnsetAllSa(this.executer, e)
            },
            ENABLE: function(e) {
                t.ai.AiUtil.builtinEnable(this.executer, e)
            },
            RECOVER: function(e) {
                t.ai.AiUtil.builtinRecover(this.executer, e)
            },
            CLEAR_TARGET: function(e) {
                t.ai.AiUtil.builtinClearTarget(this.executer, e)
            },
            CANCEL_INTERRUPT_ABILITY: function(e) {
                t.ai.AiUtil.builtinCancelInterruptAbility(this.executer, e)
            },
            DIFF_ENABLE: function(e) {
                t.ai.AiUtil.builtinDiffEnable(this.executer, e)
            },
            CHANGE_PARAM: function(e) {
                t.ai.AiUtil.builtinChangeParam(this.executer, e)
            },
            RESET: function(e) {
                t.ai.AiUtil.builtinReset(this.executer, e)
            },
            RESET_CAST_ABILITY: function(e) {
                t.ai.AiUtil.builtinResetCastAbility(this.executer, e)
            },
            SHUFFLE_ATB: function(e) {
                t.ai.AiUtil.builtinShuffleAtb(this.executer, e)
            },
            WAIT: function(e) {
                var n = e.waitMsec || 1,
                    r = $.Deferred();
                return t.util.DelayCallback.registerForBattle(n, function() {
                    r.resolve()
                }), r.promise()
            },
            DIE_FORCIBLY: function(e) {
                t.ai.AiUtil.builtinDieForcibly(this.executer, e)
            }
        };
    FF.ns.battle.action.DeformMultiAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("sequence", n.sequence), this.set("filteringDeformPosArray", n.filteringDeformPosArray), this.set("skipMainNodeDeform", !!n.skipMainNodeDeform), this.set("shouldDeformAllNodes", !!n.shouldDeformAllNodes), this.set("skipEnemyName", !!n.skipEnemyName), this.set("forceShowNamePosArray", n.forceShowNamePosArray), this.isBossDeform = !0
        },
        processForStateInitUpdate: function() {
            var e = this;
            this.changeState("WAIT_ANIM");
            var t = this.get("sequence"),
                n = $.Deferred().resolve();
            _.each(t, function(t) {
                n = n.then(function() {
                    var n = [];
                    for (var r = 0, i = t.length; r < i; r++) n.push(e._executeDeferred(t[r]));
                    return $.when.apply($, n)
                })
            }), n.then(function() {
                e._isDone = !0
            })
        },
        _executeDeferred: function(e) {
            return FF.logger.debug("DEFORM_MULTI", e), e.messageId || e.messageSuffixNo ? this._executeMessageDeferred(e) : e.animationId || e.deformTag ? this._executeAnimationDeferred(e) : e.builtin ? this._executeBuiltinDeferred(e) : (FF.logger.error("DEFORM MULTI:nothing to do"), $.Deferred().resolve().promise())
        },
        _executeMessageDeferred: function(e) {
            var n = e.messageId;
            e.messageSuffixNo && (n = this.executer.getMessageIdBySuffixNo(e.messageSuffixNo));
            var r = e.buddyId,
                i = e.buddyIds,
                s = e.enemyNo,
                o = !!e.isAny,
                u = !0,
                a = void 0;
            r && (a = _.find(t.ActorMgr.getAllBuddies(), function(e) {
                return e.getId() === r
            }));
            if (i) {
                var f = _.map(t.ActorMgr.getAliveBuddies(), function(e) {
                    return e.getId()
                });
                o ? _.any(i, function(e) {
                    return _.contains(f, e)
                }) || (u = !1) : _.all(i, function(e) {
                    return _.contains(f, e)
                }) || (u = !1)
            }
            var l = this.executer.container ? this.executer.container : this.executer,
                c = void 0;
            s && (c = l.getChild(s)), r && !a && (u = !1), s && !c && (u = !1), a && a.isDead() && (u = !1), c && c.isDead() && (u = !1);
            var h = $.Deferred(),
                p = t.Message.getInstanceById(n);
            if (u && p.shouldShow()) {
                var d = p.getMessageInfo({
                        duration: e.duration
                    }),
                    v = t.BattleViewController.getInstance().createAnimation({
                        animationType: t.Conf.ANIMATION_TYPE.MESSAGE,
                        messageInfo: d
                    });
                v.addCallbackOnce("end", function() {
                    h.resolve()
                }), v.play()
            } else FF.logger.debug("should not show"), h.resolve();
            return h.promise()
        },
        _executeAnimationDeferred: function(e) {
            var n = e.animationId,
                r = e.deformTag,
                i = this.executer.container ? this.executer.container : this.executer,
                s = _.isUndefined(e.shouldDeformAllNodes) ? this.get("shouldDeformAllNodes") : !!e.shouldDeformAllNodes,
                o = _.isUndefined(e.filteringDeformPosArray) ? this.get("filteringDeformPosArray") : e.filteringDeformPosArray,
                u = _.isUndefined(e.skipMainNodeDeform) ? this.get("skipMainNodeDeform") : !!e.skipMainNodeDeform,
                a = _.isUndefined(e.skipEnemyName) ? this.get("skipEnemyName") : !!e.skipEnemyName,
                f = _.isUndefined(e.forceShowNamePosArray) ? this.get("forceShowNamePosArray") : e.forceShowNamePosArray,
                l = $.Deferred(),
                c = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM,
                    enemyContainer: i,
                    animationInfo: {
                        animationId: n,
                        deformTag: r
                    },
                    filteringDeformPosArray: o,
                    skipMainNodeDeform: u,
                    shouldDeformAllNodes: s,
                    skipEnemyName: a,
                    forceShowNamePosArray: f
                });
            return c.addCallbackOnce("end", function() {
                l.resolve()
            }), c.play(), l.promise()
        },
        _executeBuiltinDeferred: function(e) {
            var t = r[e.builtin],
                n = t.call(this, e);
            return n ? n : $.Deferred().resolve().promise()
        }
    })
}), define("scenes/battle/action/EnemyJumpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.EnemyJumpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", t.Conf.ATK_TYPE.INDIRECT)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.ENEMY_JUMP,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalAttackByHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipAttackMotion: !!this.get("skipAttackMotion")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get("hp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FractionalAttackByHpAction
}), define("scenes/battle/action/FractionalAttackByMaxHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByMaxHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get("maxHp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalAttackByHpWithoutSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageRate", this.get("arg1")), this.set("useMaxHp", !!this.get("arg2")), this.set("forceHitWithoutSa", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this.get("useMaxHp") ? "maxHp" : "hp",
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    statusAilmentsId: this.get("statusAilmentsId"),
                    statusAilmentsFactor: this.get("statusAilmentsFactor"),
                    numerator: e.receiver.get(n),
                    forceHitWithoutSa: this.get("forceHitWithoutSa")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    }), FF.ns.battle.action.FractionalAttackByHpWithoutSaAction
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAndInflictSaAction", ["./FractionalAttackByHpWithoutSaAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpWithoutSaAndInflictSaAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r),
                s = [];
            _.each(i.damageObjects, function(n) {
                if (n.canHit) {
                    var r = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: e.get("atkStatusAilments"),
                        statusAilmentsOptions: e.get("statusAilmentsOptions"),
                        forceHit: !!e.get("arg3")
                    });
                    s.push(r)
                }
            }), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s), this.changeState("WAIT_ANIM");
            var o = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                _.each(s, function(e) {
                    i.damageObjects.push(e)
                }), e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this);
            var i = {};
            this.get("arg6") && (i.boost = {
                rate: this.get("arg6")
            }), this.get("arg7") && (i.infoMap = {
                duration: this.get("arg7")
            }), this.set("damageRate", this.get("arg1")), this.set("useMaxHp", !!this.get("arg2")), this.set("forceHitWithoutSa", !0), this.set("forceHit", !!this.get("arg5")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", i), this.set("hitRate", this.get("arg8"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.fractionDamage(n),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForInflictSa(i),
                o = this.helper.calcForHealSa(i);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(s), this.moHelper.addAdditionalApplyDamageObjects(o)), this._playAnimationDeferred(r).then(function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.mergeDamageObjects(r.damageObjects, o), e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction
}), define("scenes/battle/action/FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAndDeformAction", ["./FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this);
            var i = {};
            this.get("arg6") && (i.boost = {
                rate: this.get("arg6")
            }), this.get("arg7") && (i.infoMap = {
                duration: this.get("arg7")
            }), this.set("damageRate", this.get("arg1")), this.set("useMaxHp", !!this.get("arg2")), this.set("statusAilmentsFactorForFractionalAttack", this.get("arg3")), this.set("forceHit", !!this.get("arg5")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", i), this.set("hitRate", this.get("arg8"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.fractionDamage(n, {
                    statusAilmentsId: t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH,
                    statusAilmentsFactor: this.get("statusAilmentsFactorForFractionalAttack")
                }),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForInflictSa(i),
                o = this.helper.calcForHealSa(i);
            t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(s), this.moHelper.addAdditionalApplyDamageObjects(o)), this.changeState("WAIT_ANIM"), this._playAnimationDeferred(r).then(function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.mergeDamageObjects(r.damageObjects, o), e.helper.recalculateCounterEnableFlag(r.damageObjects), e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction
}), define("scenes/battle/action/FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAndDeformAction", ["./FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/FractionalHealByHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalHealByHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION_HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    numerator: e.receiver.get("maxHp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FractionalHealByHpAction
}), define("scenes/battle/action/FractionalHealByHpAndInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FractionalHealByHpAndInflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = [];
            _.each(r.damageObjects, function(n) {
                if (!n.canHit) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: n,
                    ability: e,
                    atkStatusAilments: e.get("atkStatusAilments"),
                    statusAilmentsOptions: e.get("statusAilmentsOptions")
                });
                i.push(r)
            }), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i), this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                r.damageObjects = r.damageObjects.concat(i), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FRACTION_HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    numerator: e.receiver.get("maxHp")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FractionalHealByHpAction
}), define("scenes/battle/action/PhysicalAttackElementAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkElement", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg5")
                },
                infoMap: {
                    duration: this.get("arg6") || 25e3
                }
            }), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1")), this.set("hpFactor", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/ReraiseRiseAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 500;
    FF.ns.battle.action.ReraiseRiseAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0, this.set("hitRate", 100)
        },
        processForStateInitUpdate: function() {
            var e = this,
                r = t.util.Targeting.makeResult(t.ActorMgr.getReraiseDeathBuddies()),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.RERAISE_RISE,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            });
            t.util.DelayCallback.registerForBattle(n, function() {
                s.play()
            })
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = e.receiver.statusAilments.getHpRateForReraise();
                this.set("hpFactor", r || 1);
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    hpFactor: this.get("hpFactor")
                });
                n.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/GutsRiseAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 500;
    FF.ns.battle.action.GutsRiseAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                r = t.util.Targeting.makeResult(t.ActorMgr.getGutsRiseBuddies()),
                i = this._calc(r),
                s = this._calcHealSaDamageObjects(r);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s);
            var o = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.GUTS_RISE,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.mergeDamageObjects(i.damageObjects, s), e.helper.applyActionResult(i), e._isDone = !0
            });
            t.util.DelayCallback.registerForBattle(n, function() {
                o.play()
            })
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = e.receiver.statusAilments.getHpRateForGuts() || 1,
                    i = e.receiver.get("maxHp"),
                    s = Math.ceil(i * r / 100),
                    o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.FIXED_HEAL_HP,
                        executer: this.executer,
                        receiver: e.receiver,
                        ability: this,
                        fixedHealValue: s
                    });
                n.push(o)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        },
        _calcHealSaDamageObjects: function(e) {
            var t = [];
            return _.each(e, function(e) {
                var n = e.receiver.statusAilments.havingGutsId(),
                    r = this.helper.calcForHealSa([e], {
                        hitRate: 100,
                        statusAilmentsIds: [n]
                    });
                Array.prototype.push.apply(t, r)
            }, this), t
        }
    })
}), define("scenes/battle/action/HealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.HealHpAction
}), define("scenes/battle/action/HealHpAndCustomParamAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"));
            var t = this.get("statusAilmentsId"),
                n = this.get("arg4"),
                r = this.get("arg6");
            this.set("statusAilmentsOptions", {
                boost: this.helper.makeBoostObject(t, n, {
                    isAbsolute: r
                }),
                infoMap: {
                    duration: this.get("arg5")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = [];
            _.each(r.damageObjects, function(n) {
                if (n.canHit) {
                    var r = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: e.get("atkStatusAilments"),
                        statusAilmentsOptions: e.get("statusAilmentsOptions")
                    });
                    i.push(r)
                }
            }), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i), this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                _.each(i, function(e) {
                    r.damageObjects.push(e)
                }), e.helper.recalculateCounterEnableFlag(r.damageObjects), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndInflictSaAndSelfCustomParamAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndInflictSaAndSelfCustomParamAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = this.get("arg4"),
                r = {};
            _.each([{
                id: this.get("arg5"),
                value: this.get("arg6")
            }], function(e) {
                if (!e.id) return;
                if (r[e.id]) throw new Error("duplicate status ailments id: " + e.id);
                r[e.id] = {
                    atkStatusAilments: _.object([
                        [e.id, 100]
                    ]),
                    statusAilmentsOptions: {
                        boost: t.helper.makeBoostObject(e.id, e.value),
                        infoMap: {
                            duration: n
                        }
                    }
                }
            }), this.set("customParamConfs", _.values(r))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = [];
            _.each(r.damageObjects, function(n) {
                if (!n.canHit) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: n,
                    ability: e,
                    atkStatusAilments: e.get("atkStatusAilments"),
                    statusAilmentsOptions: e.get("statusAilmentsOptions")
                });
                i.push(r)
            }), _.each(this.get("customParamConfs"), function(n) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: _.first(t.util.Targeting.makeResult(e.executer)),
                    ability: e,
                    atkStatusAilments: n.atkStatusAilments,
                    statusAilmentsOptions: n.statusAilmentsOptions,
                    forceHit: !0
                });
                i.push(r)
            }), this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                r.damageObjects = r.damageObjects.concat(i), e.helper.recalculateCounterEnableFlag(r.damageObjects), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndInflictSaMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpAndInflictSaMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this);
            var i = {};
            this.get("arg6") && (i.boost = {
                rate: this.get("arg6")
            }), this.get("arg7") && (i.infoMap = {
                duration: this.get("arg7")
            }), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("forceHit", !!this.get("arg5")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", i), this.set("hitRate", this.get("arg8"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.healHp(n),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForInflictSa(i),
                o = this.helper.calcForHealSa(i);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(s), this.moHelper.addAdditionalApplyDamageObjects(o)), this._playAnimationDeferred(r).then(function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.mergeDamageObjects(r.damageObjects, o), e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.HealHpAndInflictSaMultiAndHealSaMultiAction
}), define("scenes/battle/action/HealHpAndInflictSaMultiAndHealSaMultiAndDeformAction", ["./HealHpAndInflictSaMultiAndHealSaMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndInflictSaMultiAndHealSaMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/HealHpAndHealSaMultiAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = [],
                s = this.get("healStatusAilmentIds"),
                o = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAll(), function(t) {
                    return t.isColleague(e.executer) && t.isAlive({
                        pureDeath: !0
                    })
                }));
            _.each(o, function(e) {
                var n = e.receiver,
                    r = _.intersection(s, n.statusAilments.getRefs()),
                    o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: r.length > 0 ? 100 : 0,
                        statusAilmentsIds: r
                    });
                i.push(o), FF.logger.info("HEAL_SA_MULTI", "ids", r)
            }, this), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i), this.changeState("WAIT_ANIM");
            var u = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                r.damageObjects = r.damageObjects.concat(i), e.helper.recalculateCounterEnableFlag(r.damageObjects), e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndHealSaAction", ["./HealHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = _.filter(n, function(e) {
                    return e.receiver.isAlive()
                }),
                i = n,
                s = this._calc(r),
                o = [],
                u = this.get("healStatusAilmentIds");
            _.each(i, function(e) {
                var n = e.receiver,
                    r = _.intersection(u, n.statusAilments.getRefs()),
                    i = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: r.length > 0 ? 100 : 0,
                        statusAilmentsIds: r
                    });
                o.push(i), FF.logger.info("HEAL_SA_MULTI", "ids", r)
            }, this), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(o), this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: s
            }).addCallbackOnce("end", function() {
                s.damageObjects = s.damageObjects.concat(o), e.helper.recalculateCounterEnableFlag(s.damageObjects), e.helper.applyActionResult(s), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealSaAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                r = this._calc(t);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var t = [];
            return _.each(e, function(e) {
                var r = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    statusAilmentsIds: this.get("healStatusAilmentIds")
                });
                t.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealSaLotAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaLotAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(t) {
            var r = [],
                i = n.StatusAilmentsConfig.getBundle(n.Conf.STATUS_AILMENTS_BUNDLE.LOT);
            return _.each(t, function(t) {
                var s = t.receiver,
                    o = _.intersection(i, s.statusAilments.getRefs()),
                    u = void 0;
                o.length && (u = e.lot(o, function() {
                    return 100
                }));
                var a = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: t,
                    ability: this,
                    hitRate: u ? 100 : 0,
                    statusAilmentsIds: [u]
                });
                r.push(a), FF.logger.info("HEAL_SA_LOT", "id", u)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/HealSaMultiAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaMultiAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForNormal(r, {
                skipDamageMotion: !0
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var t = [],
                r = this.get("healStatusAilmentIds");
            return _.each(e, function(e) {
                var i = e.receiver,
                    s = _.intersection(r, i.statusAilments.getRefs()),
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: s.length > 0 ? 100 : 0,
                        statusAilmentsIds: s
                    });
                t.push(o), FF.logger.info("HEAL_SA_MULTI", "ids", s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealAndInflictSaAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealAndInflictSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg1"));
            var e = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(t) {
                r[t] = e
            }, this), this.set("atkStatusAilments", r), this.set("forceHit", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                r = this._calcHeal(t),
                i = this.helper.lotStatusAilments(t);
            n.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i.damageObjects), this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calcHeal: function(e) {
            var t = [];
            return _.each(e, function(e) {
                var r = n.util.DamageCalculator.calculate({
                    type: n.Conf.CALC_TYPE.HEAL_SA,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: this.get("hitRate"),
                    statusAilmentsIds: [this.get("statusAilmentsId")]
                });
                t.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/HealHpAndInflictHpStockAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndInflictHpStockAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.tmpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer), this.tmpAbility.set("atkStatusAilments", _.extend({}, this.get("atkStatusAilments"))), this.tmpAbility.set("statusAilmentsOptions", {
                infoMap: {
                    duration: this.get("arg5"),
                    maxConsumableHpStock: this.get("arg6")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.calcForHealHp(r),
                s = [];
            _.each(i, function(e) {
                e.canHit ? (this.tmpAbility.set("forceHit", !0), this.tmpAbility.set("forceMiss", !1)) : (this.tmpAbility.set("forceHit", !1), this.tmpAbility.set("forceMiss", !0));
                var n = this.tmpAbility.makeActionResult({
                    targets: t.util.Targeting.makeResult(e.receiver)
                });
                s = s.concat(n.damageObjects)
            }, this);
            var o = [];
            this.helper.mergeDamageObjectsForBarrage(o, i), this.helper.mergeDamageObjectsForBarrage(o, s);
            var u = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationMutablyDeferred(u).then(function() {
                e.helper.applyActionResultMutably(u), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/InflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r);
            var i = this.get("arg6") || 0;
            i > 0 && this.set("statusAilmentsOptions", {
                infoMap: {
                    duration: i
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipAttackMotion: !!this.get("skipAttackMotion"),
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/InflictSaAndFallbackMagicAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndFallbackMagicAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.get("statusAilmentsId"),
                i = _.filter(n, function(e) {
                    var t = e.receiver.get("defAttributeMap");
                    return t[r] ? !1 : !0
                }),
                s = _.difference(n, i),
                o = this.helper.lotStatusAilments(i),
                u = this.helper.magicAttack(s).damageObjects;
            o.damageObjects = o.damageObjects.concat(u), this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/InflictSaAndIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2")), this.set("remainNum", this.get("arg3")), this.set("usedNum", this.get("arg4"));
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = [],
                s = this.helper.lotStatusAilments(r);
            i.push(s.damageObjects);
            var o = this._calcIncreaseMpDamgageObjects(r);
            i.push(o);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u,
                options: {
                    skipDamageMotionCountMap: {
                        1: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        },
        _calcIncreaseMpDamgageObjects: function(e) {
            var n = this,
                r = [];
            return _.each(e, function(e) {
                var i = void 0;
                e.receiver.isBuddy() && (i = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: n.get("remainNum"),
                    usedNum: n.get("usedNum")
                }));
                var s = i ? n.get("hitRate") : 0,
                    o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: n.executer,
                        target: e,
                        ability: n,
                        abilityPanel: i,
                        isDecrease: !1,
                        damageFactor: n.get("damageFactor"),
                        hitRate: s,
                        isRemainingBase: !1
                    });
                r.push(o)
            }), r
        }
    })
}), define("scenes/battle/action/InflictSaHitAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.InflictSaHitAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.InflictSaHitAction
}), define("scenes/battle/action/InflictSaHitAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaHitAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0);
            var r = this.get("statusAilmentsFactor"),
                i = this.get("atkStatusAilmentIds"),
                s = {};
            _.each(i, function(e) {
                s[e] = r
            }, this), this.set("checkCanExecAbilityFlag", this.get("arg5")), this.set("atkStatusAilments", s)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.lotStatusAilments(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        }
    })
}), define("scenes/battle/action/JumpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.JumpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", t.Conf.ATK_TYPE.INDIRECT), this.set("flightDuration", this.get("arg2")), this.set("atkElement", this.get("arg3")), this.get("arg4") > 0 && this.set("critical", this.helper.calcCritical(this.get("arg4"))), this.get("arg5") > 0 && this.set("absorbHpFactor", this.get("arg5")), this.get("arg6") > 0 && (this.set("barrageNum", this.get("arg6")), this.set("isSameTarget", !!this.get("arg7")));
            var n = this.get("arg8");
            this.helper.setDamageCalculateParamAdjustConf(n, [this.get("arg9"), this.get("arg10"), this.get("arg11"), this.get("arg12"), this.get("arg13")])
        },
        forceQuit: function() {
            this.isState("INIT") && this._callbackId && (t.util.DelayCallback.clear(this._callbackId), this.resume())
        },
        begin: function() {
            e.prototype.begin.apply(this, arguments)
        },
        processForStateInitEntry: function() {
            var e = this,
                n = this.executer,
                r = t.util.DamageCalculator.makeDamageObject(n, n, this, {
                    statusAilments: [t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE]
                });
            n.applyDamageObject(r);
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.JUMP_OUT,
                action: this
            }).addCallbackOnce("end", function() {
                e.suspend(), e._callbackId = t.util.DelayCallback.registerForBattle(e.helper.calcFlightDuration(n), function() {
                    e.resume()
                })
            }).play()
        },
        processForStateInitUpdate: function() {
            var e = this.executer;
            if (this.isResumed()) {
                var n = t.util.DamageCalculator.makeDamageObject(e, e, this, {
                    unsetStatusAilments: [t.Conf.STATUS_AILMENTS_TYPE.INVISIBLE]
                });
                e.applyDamageObject(n), this.changeState("FALL")
            }
        },
        processForStateFallUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttackMutably(r),
                s = i.actionResult,
                o = this.has("barrageNum") && this.get("barrageNum") > 1 ? t.Conf.ANIMATION_TYPE.JUMP_IN_AND_BARRAGE : t.Conf.ANIMATION_TYPE.JUMP_IN;
            this.changeState("WAIT_ANIM");
            var u = t.BattleViewController.getInstance().createAnimation({
                animationType: o,
                action: this,
                actionResult: s
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultMutably(s), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("selfSaBundleId", this.get("arg7")), this.set("ignoresAttackHit", !!this.get("arg8")), this.set("dependsWeaponEffect", !0);
            var n = {},
                r = t.StatusAilmentsConfig.getBundle(this.get("selfSaBundleId"));
            _.each(r, function(e) {
                n[e] = 100
            }), this.set("selfStatusAilments", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("ignoresAttackHit"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = e.helper.includesHitDamageObject(l.damageObjects)), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = this.helper.makeAndSetActionResult(n, this, u),
                h = void 0;
            if (a || o) h = e._calcSelfSa();
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && h && this.moHelper.addAdditionalApplyDamageObjects([h]);
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c
            }).addCallbackOnce("end", function() {
                h && c.damageObjects.push([h]), e.helper.applyActionResultForBarrage(c), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: e.executer,
                    target: _.first(t.util.Targeting.makeResult(e.executer)),
                    ability: e,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
            return n
        }
    })
}), define("scenes/battle/action/WrappedAbilityActionBase", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.action.WrappedAbilityActionBase = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("wrappedAbilityId", 0), this.set("continuousStatusAilment", 0), this.set("continuousStatusAilmentInfo", {}), this.set("wrappedAbility", null), this.set("additionalDamageObj", null), this.set("isExtendedWrappedAbility", !0)
        },
        update: function() {
            t.prototype.update.apply(this, arguments);
            var e = this.get("wrappedAbility");
            e && e.update()
        },
        processForStateInitUpdate: function() {
            var e = this.executer,
                t = this.get("wrappedAbilityId"),
                r = n.AbilityFactory.create(t, e, this.moHelper.getCreateOptions());
            _.each(["activeTarget", "isAbilityPanel", "isSoulStrike", "receptorId"], function(e) {
                this.has(e) && r.set(e, this.get(e))
            }, this), this.has("isSupporterSoulStrike") && r.set("isSupporterSoulStrikeWrapped", this.get("isSupporterSoulStrike")), this.set("wrappedAbility", r);
            var i = this.get("continuousStatusAilment"),
                s = this.get("continuousStatusAilmentOptions");
            if (i) {
                var o = n.util.DamageCalculator.makeDamageObject(e, e, this, {
                    statusAilments: [i],
                    statusAilmentsOptions: s
                });
                this.set("additionalDamageObj", o)
            }
            this.changeState("WAIT_ANIM")
        },
        processForStateWaitAnimEntry: function() {
            var e = this.get("wrappedAbility");
            if (!e) return;
            var t = this.get("additionalDamageObj"),
                r = {};
            n.BattleInfo.getInstance().isMo() && t && (r.additionalDamageObjects = [t]), e.begin(r)
        },
        processForStateWaitAnimUpdate: function() {
            var e = this.executer,
                t = this.get("wrappedAbility");
            if (!t) return;
            t.isDone() && (this._isDone = !0, this.helper.setActionResult(this, t.get("actionResult")), this.onWrappedAbilityDone())
        },
        onWrappedAbilityDone: function() {
            var e = this.executer,
                t = this.get("additionalDamageObj");
            t && e.applyDamageObject(t)
        }
    }), FF.ns.battle.action.WrappedAbilityActionBase
}), define("scenes/battle/action/LotAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.LotAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = [];
            _.each([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(t) {
                var n = this.get(sprintf("arg%d", t));
                n && e.push(n)
            }, this), this.set("lotAbilityIds", e)
        },
        processForStateInitUpdate: function() {
            var n = this.get("lotAbilityIds"),
                r = e.lot(n, function() {
                    return 100
                }, {});
            this.set("wrappedAbilityId", r), t.prototype.processForStateInitUpdate.apply(this, arguments)
        }
    })
}), define("scenes/battle/action/MagicAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipAttackMotion: !!this.get("skipAttackMotion")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndAbsorbHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndAbsorbHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("absorbHpFactor", this.get("arg4")), this.helper.setDamageCalculateTypeByAbility(this.get("arg5")), this.set("matkExponentialFactor", this.get("arg6"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("matkExponentialFactor", this.get("arg4")), this.set("defIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefIgnoredAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefIgnoredAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("matkExponentialFactor", this.get("arg4")), this.set("defIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndDefBoostIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndDefBoostIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("defBoostIgnored", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    return FF.ns.battle.action.MagicAttackMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("situationalRecalculateDamageHookType", this.get("arg7"));
            var t = this.get("arg8");
            this.helper.setDamageCalculateParamAdjustConf(t, [this.get("arg9"), this.get("arg10"), this.get("arg11"), this.get("arg12")]), this.helper.setDamageCalculateTypeByAbility(this.get("arg13")), this.set("matkExponentialFactor", this.get("arg14"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.get("barrageNum") || 1,
                r = void 0,
                i = this.get("isSameTarget"),
                s = [];
            for (var o = 1; o <= n; o++) {
                if (!i || !r) r = this.detectTargets();
                var u = this.helper.magicAttack(r);
                s.push(u.damageObjects)
            }
            this.helper.recalculate(s);
            var a = this.helper.makeAndSetActionResult(t, this, s);
            this.changeState("WAIT_ANIM"), this._playAnimationDeferred(a).then(function() {
                e.helper.applyActionResultForBarrage(a), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForBarrageDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.MagicAttackMultiAction
}), define("scenes/battle/action/MagicAttackMultiAndDeformAction", ["./MagicAttackMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformBarrageDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {},
                n = this.get("statusAilmentsFactor");
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                t[e] = n
            }), this.set("atkStatusAilments", t)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            this.helper.recalculate(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                matkElement: this.get("arg2"),
                minDamageFactor: this.get("arg3"),
                targetSegment: t.Conf.TARGET_SEGMENT.OPPONENT,
                targetRange: t.Conf.TARGET_RANGE.ALL
            }, this._healParams = {
                factor: this.get("arg4"),
                matkElement: this.get("arg5")
            }
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = void 0,
                i = [];
            _.extend(this._attributes, this._atkParams), r = this.detectTargets();
            var s = this.helper.magicAttack(r);
            i.push(s.damageObjects), _.extend(this._attributes, this._healParams), r = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(e) {
                return e.isColleague(n)
            }));
            var o = this._calc(r);
            i.push(o);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), n
        }
    })
}), define("scenes/battle/action/MagicAttackAndHealSelfHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.MagicAttackAndHealSelfHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this._healSelfHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_HP, this.executer, {
                targetRange: t.Conf.TARGET_RANGE.SELF,
                factor: this.get("arg4"),
                matkElement: this.get("arg5")
            }), this.set("checkHitDamage", !!this.get("arg6"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                n = this.helper.magicAttack(t),
                r = this.helper.makeTargetsFromHitDamageObjects(n.damageObjects),
                i = [];
            if (!this.get("checkHitDamage") || 0 < r.length) i = this._healSelfHpAbility.calcDamageObjects();
            n.damageObjects = [n.damageObjects, i], this.changeState("WAIT_ANIM"), this._playAnimationDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForBarrageDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.MagicAttackAndHealSelfHpAction
}), define("scenes/battle/action/MagicAttackAndHealSelfHpAndDeformAction", ["./MagicAttackAndHealSelfHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndHealSelfHpAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformBarrageDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformBarrage()
        }
    })
}), define("scenes/battle/action/MagicAttackAndPhysicalAttackElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndPhysicalAttackElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("magicalAttackDamageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("physicalAttackDamageFactor", this.get("arg3")), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this.set("atkElement", this.get("arg6")), this.set("dependsWeaponEffect", !0), this.set("isSameTarget", !!this.get("arg7"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("isSameTarget"),
                i = [],
                s = this.detectTargets();
            this.set("damageFactor", this.get("magicAttackDamageFactor"));
            var o = this.helper.magicAttack(s);
            i.push(o.damageObjects), r || (s = this.detectTargets()), this.set("damageFactor", this.get("physicalAttackDamageFactor")), o = this.helper.physicalAttack(s), i.push(o.damageObjects), this.helper.recalculate(i);
            var u = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: u
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("isSameTarget", !!this.get("arg4")), this.set("minDamageFactor", this.get("arg8"));
            var t = !!this.get("arg10"),
                n = this.get("arg5"),
                r = {};
            r[n] = 1, this.set("partyStatusAilments", r), this.set("partyStatusAilmentsOptions", {
                boost: t ? {
                    absolute: this.get("arg6")
                } : {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg7")
                }
            });
            var i = this.get("arg13");
            this.helper.setDamageCalculateParamAdjustConf(i, [this.get("arg14"), this.get("arg15")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            this.helper.recalculate(o);
            var f = this._calcCustomParam();
            o.push(f);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcCustomParam: function() {
            var e = this,
                n = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(t) {
                    return t.isColleague(e.executer)
                })),
                r = [];
            return _.each(n, function(e) {
                var n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("partyStatusAilments"),
                    statusAilmentsOptions: this.get("partyStatusAilmentsOptions"),
                    forceHit: !0
                });
                r.push(n)
            }, this), r
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndInflictSaMultiAndHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndInflictSaMultiAndHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {};
            this.get("statusAilmentsId") && this.get("statusAilmentsFactor") && (t[this.get("statusAilmentsId")] = this.get("statusAilmentsFactor")), this.get("arg6") && this.get("arg7") && (t[this.get("arg6")] = this.get("arg7")), this.get("arg8") && this.get("arg9") && (t[this.get("arg8")] = this.get("arg9"));
            if (this.get("arg13") && this.get("arg14")) {
                var n = this.get("arg14");
                _.each(this.get("atkStatusAilmentIds"), function(e) {
                    t[e] = n
                })
            }
            this.set("atkStatusAilments", t), this.set("hitRate", this.get("arg11") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            this.helper.recalculate(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = this.helper.makeTargetsFromHitDamageObjects(_.flatten(f.damageObjects)),
                c = this.helper.calcForHealSa(l);
            t.BattleInfo.getInstance().isMo() && c.length > 0 && this.moHelper.addAdditionalApplyDamageObjects(c), this.changeState("WAIT_ANIM");
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                c.length > 0 && f.damageObjects.push(c), e.helper.recalculateCounterEnableFlag(f.damageObjects), e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndInflictSaAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndInflictSaAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", this.get("arg4")), this.set("skipSaAnimation", !!this.get("arg12")), this._enemyCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                targetRange: t.Conf.TARGET_RANGE.SINGLE,
                targetSegment: t.Conf.TARGET_SEGMENT.OPPONENT,
                statusAilmentsId: this.get("arg5"),
                statusAilmentsFactor: this.get("arg6"),
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg7")
                    },
                    infoMap: {
                        duration: this.get("arg8")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = this.get("isSameTarget"),
                s = {},
                o = this.helper.magicAttackMulti(),
                u = o.actionResult,
                a = o.isHit,
                f = [];
            if (a) {
                var l = this.helper.makeTargetsFromHitDamageObjects(_.flatten(u.damageObjects)),
                    c = {
                        atkStatusAilments: this._enemyCustomParamAbility.get("atkStatusAilments"),
                        statusAilmentsOptions: this._enemyCustomParamAbility.get("statusAilmentsOptions")
                    },
                    h = this._enemyCustomParamAbility.getActionResultWithTargetsAndParams(l, c);
                f = h.damageObjects, this.get("skipSaAnimation") || (this.helper.mergeDamageObjectsForBarrage(u.damageObjects, f), s[r + 1] = !0), t.BattleInfo.getInstance().isMo() && this.get("skipSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects(f)
            }
            this.changeState("WAIT_ANIM");
            var p = this.animationHelper.createAnimationForBarrage(u, {
                skipDamageMotionCountMap: s
            }).addCallbackOnce("end", function() {
                e.get("skipSaAnimation") && e.helper.mergeDamageObjectsForBarrage(u.damageObjects, f), e.helper.applyActionResultForBarrage(u), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndHealHpAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndHealHpAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                barrageNum: this.get("arg3"),
                isSameTarget: !!this.get("arg6")
            };
            var n = {
                factor: this.get("arg4"),
                matkElement: this.get("arg5"),
                targetRange: this.get("arg8")
            };
            this._healHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_HP, this.executer, n), this._inflictsCustomParam = this.get("arg9") > 0;
            if (this._inflictsCustomParam) {
                var r = {
                    forceHit: !0,
                    targetRange: this.get("arg12"),
                    targetSegment: this.get("arg13"),
                    statusAilmentsId: this.get("arg9"),
                    statusAilmentsFactor: 0,
                    statusAilmentsOptions: {
                        boost: {
                            rate: this.get("arg10")
                        },
                        infoMap: {
                            duration: this.get("arg11")
                        }
                    }
                };
                this._customParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, r)
            }
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer;
            _.extend(this._attributes, this._atkParams);
            var n = this.get("barrageNum"),
                r = this.helper.magicAttackMulti(),
                i = r.actionResult,
                s = this._healHpAbility.calcDamageObjects();
            this.helper.mergeDamageObjectsForBarrage(i.damageObjects, s);
            var o = {};
            if (this._inflictsCustomParam) {
                var u = this._customParamAbility.makeActionResult();
                this.helper.mergeDamageObjectsForBarrage(i.damageObjects, u.damageObjects), o[n + 2] = !0
            }
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(i, {
                skipDamageMotionCountMap: o
            }).then(function() {
                e.helper.recalculateCounterEnableFlag(i.damageObjects), e.helper.applyActionResultForBarrage(i), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2"));
            var t = {},
                n = this.get("statusAilmentsFactor");
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                t[e] = n
            }), this.set("atkStatusAilments", t), this.set("dependsWeaponEffect", !0), this.helper.setDamageCalculateTypeByAbility(this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ParamBoosterAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ParamBoosterAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("forceHit", !0), this.set("statusAilmentsOptions", {
                infoMap: {
                    duration: this.get("arg1")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.lotStatusAilments(n);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3"));
            var t = this.get("arg4");
            this.helper.setDamageCalculateParamAdjustConf(t), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.PhysicalAttackAction
}), define("scenes/battle/action/PhysicalAttackAndAbsorbHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndAbsorbHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("absorbHpFactor", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this.helper.physicalAttack(n);
            this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForNormal(r).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndAbsorbHpAndReduceMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndAbsorbHpAndReduceMpAction = e.extend({
        initialize: function() {
            if (t.BattleInfo.getInstance().isMo()) throw new Error("cannot use in MO battle");
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("absorbHpFactor", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("damageFactorForReduceMp", this.get("arg5")), this.set("hitRateForReduceMp", this.get("arg6"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                n = this.helper.physicalAttack(t),
                r = this.helper.makeTargetsFromHitDamageObjects(n.damageObjects),
                i = this.helper.calcForReduceMp(r, {
                    hitRate: this.get("hitRateForReduceMp"),
                    damageFactor: this.get("damageFactorForReduceMp")
                });
            i = this.helper.filterByCanHitFromDamageObjects(i);
            var s = this.helper.makeActionResult(this.executer, this, i);
            this.changeState("WAIT_ANIM"), e.animationHelper.playAnimationForNormalDeferred(n).then(function() {
                return e.animationHelper.playAnimationForDamageDeferred(s, {
                    normalDamageMotion: !0
                })
            }).then(function() {
                e.helper.mergeDamageObjects(n.damageObjects, i), e.helper.applyActionResult(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this.helper.physicalAttack(n);
            this.changeState("WAIT_ANIM"), this.playAnimationDeferred(r).then(function() {
                e.helper.applyActionResult(r), e.onAnimationEndHook(), e._isDone = !0
            })
        },
        playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        onAnimationEndHook: function() {}
    }), FF.ns.battle.action.PhysicalAttackAndCustomParamAction
}), define("scenes/battle/action/PhysicalAttackAndCustomParamDeformAction", ["./PhysicalAttackAndCustomParamAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndCustomParamDeformAction = e.extend({
        playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndDefIgnoredAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackAndDefIgnoredAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkExponentialFactor", this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("defIgnored", !0), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this.helper.physicalAttack(n);
            this.changeState("WAIT_ANIM"), this._playAnimationDeferred(r).then(function() {
                e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.PhysicalAttackAndDefIgnoredAction
}), define("scenes/battle/action/PhysicalAttackMultiAndHpBarterAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndHpBarterAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barterRate", this.get("arg2")), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this.set("barrageNum", this.get("arg6")), this.set("isSameTarget", !!this.get("arg7")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HP_BARTER,
                    executer: n,
                    receiver: n,
                    ability: e
                }),
                s = this.helper.physicalAttackMutably(r),
                o = s.actionResult;
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addBeforeApplyDamageObjects([i]), this.animationHelper.playAnimationMutablyDeferred(o).then(function() {
                e.helper.applyDamageObjects([i]), e.helper.applyActionResultMutably(o), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackCriticalOrMissAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackCriticalOrMissAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("critical", this.helper.calcCritical(this.get("arg2"))), this.set("atkType", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = this.executer,
                i = this.detectTargets(),
                s = e.lotByFraction(this.get("critical"));
            this.set("forceCritical", s), this.set("forceMiss", !s);
            var o = this.helper.physicalAttack(i);
            this.changeState("WAIT_ANIM");
            var u = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResult(o), t._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkElement", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this);
            var i = {};
            this.get("arg6") && (i.boost = {
                rate: this.get("arg6")
            }), this.get("arg7") && (i.infoMap = {
                duration: this.get("arg7")
            }), this.set("damageFactor", this.get("arg1")), this.set("atkElement", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("dependsWeaponEffect", !0), this.set("forceHitForInflictSa", !!this.get("arg5")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", i), this.set("hitRate", this.get("arg8"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.physicalAttack(n, {
                    skipStatusAilments: !0
                }),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForHealSa(i),
                o = this.helper.calcForInflictSa(i, {
                    forceHit: this.get("forceHitForInflictSa")
                });
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(s), this.moHelper.addAdditionalApplyDamageObjects(o)), this._playAnimationDeferred(r).then(function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.mergeDamageObjects(r.damageObjects, o), e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction
}), define("scenes/battle/action/PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAndDeformAction", ["./PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/PhysicalAttackHitAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackHitAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("dependsWeaponEffect", !0), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.get("arg7") > 0 && this.set("critical", this.helper.calcCritical(this.get("arg7")));
            var t = this.get("arg8");
            this.helper.setDamageCalculateParamAdjustConf(t, [this.get("arg10"), this.get("arg11"), this.get("arg12"), this.get("arg13"), this.get("arg15")]), this.set("situationalRecalculateDamageHookType", this.get("arg9")), this.helper.setDamageCalculateTypeByAbility(this.get("arg14")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiParamsAction", ["underscore", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiParamsAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this._paramsList = [{
                damageFactor: this.get("arg1"),
                barrageNum: this.get("arg2"),
                atkType: this.get("arg3"),
                forceHit: this.get("arg4"),
                targetRange: this.get("arg5")
            }, {
                barrageNum: this.get("arg7") ? this.get("arg7") : 1,
                atkType: this.get("arg8") ? this.get("arg8") : 2,
                forceHit: this.get("arg9") ? this.get("arg9") : 1,
                targetRange: this.get("arg10") ? this.get("arg10") : n.Conf.TARGET_RANGE.ALL,
                damageFactor: this.get("arg11") ? this.get("arg11") : 210
            }], this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var t = this,
                r = [];
            e.each(this._paramsList, function(e) {
                r = r.concat(t._calcWithParams(e))
            }), n.util.DamageCalculator.recalculateHp(r);
            var i = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.changeState("WAIT_ANIM"), n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                t.helper.applyActionResultForBarrage(i), t._isDone = !0
            }).play()
        },
        _calcWithParams: function(t) {
            e.extend(this._attributes, t);
            var n = [],
                r = this.get("barrageNum"),
                i, s, o = this.get("isSameTarget");
            for (var u = 1; u <= r; u++) {
                if (!o || !i) i = this.detectTargets();
                s = this.helper.physicalAttack(i), n.push(s.damageObjects)
            }
            return n
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0);
            var t = {},
                n = this.get("statusAilmentsFactor");
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                t[e] = n
            }), this.set("atkStatusAilments", t), this.helper.setDamageCalculateTypeByAbility(this.get("arg8")), this.set("atkExponentialFactor", this.get("arg9")), this.helper.setDamageCalculateParamAdjustConf(this.get("arg11"), [this.get("arg12"), this.get("arg13"), this.get("arg14"), this.get("arg15")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("selfSaId", this.get("arg7")), this.set("ignoresAttackHit", !!this.get("arg8")), this.set("hasColleagueSaAnimation", !!this.get("arg9")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u || (u = e.helper.includesHitDamageObject(f.damageObjects)), o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = this.helper.makeAndSetActionResult(n, this, o),
                c = this.get("healStatusAilmentIds"),
                h = _.intersection(c, n.statusAilments.getRefs()),
                p = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_SA,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    statusAilmentsIds: h,
                    hitRate: h.length > 0 ? 100 : 0
                }),
                d = void 0;
            if (u || this.get("ignoresAttackHit")) d = e._calcSelfSa();
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (e.get("hasColleagueSaAnimation") || this.moHelper.addAdditionalApplyDamageObjects([d]), this.moHelper.addAdditionalApplyDamageObjects([p]));
            var v = {};
            this.get("hasColleagueSaAnimation") && (l.damageObjects.push([d]), v[r + 1] = !0);
            var m = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: v
                }
            }).addCallbackOnce("end", function() {
                e.get("hasColleagueSaAnimation") || l.damageObjects.push([d]), l.damageObjects.push([p]), e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = {};
            n[this.get("selfSaId")] = 1;
            var r = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: e.executer,
                target: _.first(t.util.Targeting.makeResult(e.executer)),
                ability: e,
                atkStatusAilments: n,
                forceHit: !0
            });
            return r
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithoutAimingBySaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithoutAimingBySaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        detectTargets: function() {
            var e = this.get("statusAilmentsId"),
                n = _.filter(t.ActorMgr.getAll(), function(t) {
                    return !t.statusAilments.has(e)
                });
            return FF.ns.battle.util.Targeting.search(this, {
                actors: n
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                });
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5")), this.set("atkElement", this.get("arg6")), this.set("ignoresAttackHit", !!this.get("arg7")), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                s = _.any(i.damageObjects, function(e) {
                    return e.canHit
                }),
                o = void 0;
            if (s || this.get("ignoresAttackHit")) {
                var u = this._selfCustomParamAbility.detectTargets(),
                    a = {
                        atkStatusAilments: this.get("atkStatusAilments"),
                        statusAilmentsOptions: this.get("statusAilmentsOptions")
                    };
                o = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(u, a)
            }
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && o && this.moHelper.addAdditionalApplyDamageObjects(o.damageObjects);
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), o && e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("atkType", this.get("arg4")), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = void 0,
                i = [];
            _.extend(this._attributes, this._atkParams), r = this.detectTargets();
            var s = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                o = _.any(s.damageObjects, function(e) {
                    return e.canHit
                });
            i.push(s.damageObjects);
            if (o) {
                _.extend(this._attributes, this._healParams), r = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(e) {
                    return e.isColleague(n)
                }));
                var u = this._calc(r);
                i.push(u)
            }
            var a = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM");
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: a,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(a), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("statusAilmentsOptions")
                });
                n.push(r)
            }, this), n
        }
    })
}), define("scenes/battle/action/MagicAttackAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg4")
                },
                infoMap: {
                    duration: this.get("arg5")
                }
            }), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r, {
                    skipStatusAilments: !0
                }),
                s = this._selfCustomParamAbility.detectTargets(),
                o = {
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("statusAilmentsOptions")
                },
                u = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(s, o);
            t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(u.damageObjects), this.changeState("WAIT_ANIM");
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e.helper.applyActionResult(u), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/CustomParamBidirectionallyAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.CustomParamBidirectionallyAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg1")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            }), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg2")
                },
                infoMap: {
                    duration: this.get("arg3")
                }
            });
            var n = this.get("arg4");
            _.contains(_.values(t.Conf.ATK_TYPE), n) ? (this.set("atkType", n), this._availableCalcType = t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS) : this._availableCalcType = t.Conf.CALC_TYPE.STATUS_AILMENTS, this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this._calc(this.detectTargets());
            this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForBarrage(t, {
                skipDamageMotion: !0
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(t), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = !1;
            _.each(e, function(e) {
                var o = t.util.DamageCalculator.calculate({
                    type: n._availableCalcType,
                    executer: r,
                    target: e,
                    ability: n,
                    atkStatusAilments: n.get("atkStatusAilments"),
                    statusAilmentsOptions: n.get("statusAilmentsOptions"),
                    forceHit: n.get("forceHit")
                });
                o.canHit && (s = !0), i.push([o])
            });
            if (s) {
                var o = t.util.DamageCalculator.calculate({
                    type: n._availableCalcType,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("atkStatusAilments"),
                    statusAilmentsOptions: this.get("selfStatusAilmentsOptions"),
                    forceHit: !0
                });
                i.push([o])
            }
            return this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/PhysicalInflictSaBidirectionallyAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalInflictSaBidirectionallyAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("arg1"),
                n = {};
            n[t] = this.get("statusAilmentsFactor"), this.set("atkStatusAilments", n);
            var r = this.get("arg2"),
                i = {};
            i[r] = this.get("statusAilmentsFactor"), this.set("selfStatusAilments", i), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this._calc(this.detectTargets());
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = !1;
            _.each(e, function(e) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: e,
                    ability: n,
                    atkStatusAilments: n.get("atkStatusAilments"),
                    forceHit: n.get("forceHit")
                });
                o.canHit && (s = !0), i.push([o])
            });
            if (s) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.PHYSICAL_STATUS_AILMENTS,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                i.push([o])
            }
            return this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndInflictSaAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndInflictSaAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5"));
            var t = {};
            t[this.get("arg6")] = this.get("arg7");
            var n = {
                atkStatusAilments: t,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            };
            this.set("customParamConfs", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("customParamConfs"),
                u = [];
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                u.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var l = this.helper.makeAndSetActionResult(n, this, u),
                c = [];
            _.each(i, function(r) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: r,
                    ability: e,
                    atkStatusAilments: o.atkStatusAilments,
                    statusAilmentsOptions: o.statusAilmentsOptions
                });
                c.push(i)
            }), l.damageObjects.push(c), this.changeState("WAIT_ANIM");
            var h = {};
            h[r + 1] = !0;
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: h
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.set("saHitRate", this.get("arg8")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = [];
            _.each(_.flatten(o), function(e) {
                if (!e.canHit) return;
                var t = e.receiver;
                l.push(t)
            });
            var c = [];
            if (l.length > 0) {
                var h = t.util.Targeting.makeResult(l),
                    p = this.get("healStatusAilmentIds");
                _.each(h, function(r) {
                    var i = r.receiver,
                        s = _.intersection(p, i.statusAilments.getRefs()),
                        o = t.util.DamageCalculator.calculate({
                            type: t.Conf.CALC_TYPE.HEAL_SA,
                            executer: n,
                            target: r,
                            ability: e,
                            hitRate: s.length > 0 ? e.get("saHitRate") : 0,
                            statusAilmentsIds: s
                        });
                    o.canHit || (o.counterEnable = !1), c.push(o)
                })
            }
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(c);
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                c.length > 0 && f.damageObjects.push(c), e.helper.applyActionResultForBarrage(f, {
                    shouldReCalcCounterEnable: !0
                }), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6"));
            var n = this.get("arg7"),
                r = {};
            r[n] = 0, this.set("selfStatusAilments", r), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg8"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg9")
                    },
                    infoMap: {
                        duration: this.get("arg10")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
            f.damageObjects.push([l]);
            var c = this._selfCustomParamAbility.makeActionResult();
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(c.damageObjects);
            var h = {};
            h[r + 1] = !0;
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f,
                options: {
                    skipDamageMotionCountMap: h
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e.helper.applyActionResult(c), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ReduceMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ReduceMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS
                }));
                var i = r ? this.get("hitRate") : 0,
                    s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !0,
                        damageFactor: this.get("damageFactor"),
                        hitRate: i,
                        isRemainingBase: !0
                    });
                n.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/IncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.IncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("hitRate", this.get("arg2")), this.set("remainNum", this.get("arg3")), this.set("usedNum", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: this.get("remainNum"),
                    usedNum: this.get("usedNum")
                }));
                var i = r ? this.get("hitRate") : 0,
                    s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !1,
                        damageFactor: this.get("damageFactor"),
                        hitRate: i,
                        isRemainingBase: !1
                    });
                n.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/IncreaseFixedMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.IncreaseFixedMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1")), this.set("hitRate", this.get("arg2")), this.set("remainNum", this.get("arg3")), this.set("usedNum", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationMutablyDeferred(r).then(function() {
                e.helper.applyActionResult(r), e._isDone = !0
            })
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = void 0;
                e.receiver.isBuddy() && (r = t.util.PanelTargeting.search(e.receiver, {
                    receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                    remainNum: this.get("remainNum"),
                    usedNum: this.get("usedNum")
                }));
                var i = r ? this.get("hitRate") : 0,
                    s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.ABILITY_PANEL_FIXED_DAMAGE,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        abilityPanel: r,
                        isDecrease: !1,
                        fixedDamage: this.get("fixedDamage"),
                        hitRate: i,
                        isRemainingBase: !1
                    });
                n.push(s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/SaPoisonAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SaPoisonAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = n,
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.POISON,
                    executer: n,
                    receiver: n,
                    ability: this
                });
            this.changeState("WAIT_ANIM"), this._isDone = !0;
            if (!i.canHit) return;
            this.helper.applyDamageObjects([i]), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DAMAGE,
                action: this,
                actionResult: this.helper.makeAndSetActionResult(n, this, [i]),
                options: {
                    isParallelPlayAnimation: !0
                }
            }).play()
        }
    })
}), define("scenes/battle/action/SaRegenAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SaRegenAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = n,
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.REGEN,
                    executer: n,
                    receiver: n,
                    ability: this
                });
            this.changeState("WAIT_ANIM"), this._isDone = !0;
            if (!i.canHit) return;
            this.helper.applyDamageObjects([i]);
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DAMAGE,
                action: this,
                actionResult: this.helper.makeAndSetActionResult(n, this, [i]),
                options: {
                    isParallelPlayAnimation: !0
                }
            }).play()
        }
    })
}), define("scenes/battle/action/SaHpStockAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SaHpStockAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = n;
            this.changeState("WAIT_ANIM");
            var i = this.get("reasonStatusAilmentId"),
                s = n.statusAilments.getActualConsumableHpStock(i);
            if (s <= 0) {
                this._onEnd(i, 0);
                return
            }
            var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_HEAL_HP,
                    executer: n,
                    receiver: n,
                    ability: this,
                    fixedHealValue: s
                }),
                u = [o];
            this.helper.applyDamageObjects(u);
            var a = -1 * o.damage;
            this._onEnd(i, a);
            var f = n.statusAilments.has(i) ? 0 : 100;
            t.util.DelayCallback.register(f, function() {
                var t = e.helper.makeAndSetActionResult(n, e, u);
                e.animationHelper.playAnimationForDamageDeferred(t, {
                    isParallelPlayAnimation: !0
                })
            })
        },
        _onEnd: function(e, t) {
            this._isDone = !0, t > 0 && this.executer.statusAilments.onEndConsumeHpStockAction(e, t)
        }
    })
}), define("scenes/battle/action/SaRadiantShieldAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = 500;
    FF.ns.battle.action.SaRadiantShieldAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.isEffectOfStatusAilements = !0
        },
        processForStateInitUpdate: function() {
            var e = this,
                r = this.executer;
            if (!r.isPossibleToTarget()) {
                e._isDone = !0;
                return
            }
            var i = _.map(this.get("fixedDamages"), function(n) {
                return [t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.RADIANT_SHIELD,
                    executer: r,
                    receiver: r,
                    ability: e,
                    fixedDamage: n
                })]
            });
            this.helper.recalculate(i);
            var s = this.helper.makeAndSetActionResult(r, this, i);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForDamageBarrageDeferred(s, {
                normalDamageMotion: !0,
                damageMotionMsec: n
            }).then(function() {
                e._isDone = !0, e.helper.applyActionResultMutably(s)
            })
        }
    })
}), define("scenes/battle/action/SelfDestructAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SelfDestructAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e.executer.statusAilments.set(t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, e.executer), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.SELF_DESTRUCTION,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/SelfDestructAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.SelfDestructAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                n = this.get("looking");
            n && e.set("looking", n), this.executer.statusAilments.set(t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH, this.executer), this._isDone = !0
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.SELF_DESTRUCTION,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/FixedDamageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        }
    })
}), define("scenes/battle/action/FixedDamageMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this._calc(i);
                o.push(a)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), r
        }
    })
}), define("scenes/battle/action/FixedDamageMultiAndCustomParamAndInflictSaMultiAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.FixedDamageMultiAndCustomParamAndInflictSaMultiAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4"));
            var n = this.get("arg5"),
                r = this.get("arg6");
            if (r) {
                var i = this.get("arg7"),
                    s = !!this.get("arg8"),
                    o = t.helper.makeBoostObject(r, i, {
                        isAbsolute: s
                    }),
                    u = {};
                u[r] = this.get("statusAilmentsFactor"), this.set("atkStatusAilments", u), this.set("statusAilmentsOptions", {
                    boost: o,
                    infoMap: {
                        duration: n
                    }
                })
            }
            this.set("forceHit", !!this.get("arg10"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.fixedDamageMultiWithSa({
                    statusAilmentsOptions: this.get("statusAilmentsOptions")
                }),
                n = t.actionResult;
            this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForBarrage(n).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FixedDamageAndHealSaMultiAndInflictSaAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageAndHealSaMultiAndInflictSaAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0), this.set("hitRate", this.get("arg4") || 0);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r), this.set("forceHit", !!this.get("arg5"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.fixedDamage(n),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForHealSa(i),
                o = this.helper.calcForInflictSa(i);
            t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(s), this.moHelper.addAdditionalApplyDamageObjects(o)), this.changeState("WAIT_ANIM"), this.animationHelper.createAnimationForDeformAttack(r).addCallbackOnce("end", function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.mergeDamageObjects(r.damageObjects, o), e.helper.applyActionResult(r), e.animationHelper.onDeformEndForDeformAttack(), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FixedDamageAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedDamageAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedDamage", this.get("arg1") || 0), this.set("ignoreTargetCountDivision", !!this.get("arg2")), this.get("fixedDamage") || this.set("fixedDamage", this.get("optionalFixedDamage") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        _calc: function(e) {
            var n = e.length,
                r = [];
            return _.each(e, function(e) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    fixedDamage: this.get("fixedDamage"),
                    targetCount: n,
                    ignoreTargetCountDivision: this.get("ignoreTargetCountDivision")
                });
                r.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, r)
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/LvInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.LvInflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            if (this.executer.isBuddy()) throw new Error("not allowed buddy executing");
            this.set("baseLevel", this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.lotStatusAilmentsByLevel(this.detectTargets(), this.get("baseLevel"));
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg4")
                },
                infoMap: {
                    duration: this.get("arg5")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/FixedHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FixedHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedHp", this.get("arg1"));
            var n = this.get("arg2");
            _.contains(_.values(t.Conf.ATK_TYPE), n) && this.set("atkType", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = Math.max(0, e.receiver.get("hp") - this.get("fixedHp")),
                    i = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.FIXED_DAMAGE,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        fixedDamage: r,
                        targetCount: 1
                    });
                n.push(i)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.FixedHpAction
}), define("scenes/battle/action/FixedHpAndDeformAction", ["./FixedHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FixedHpAndDeformAction = e.extend({
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/MagicAttackAndHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndHealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = {
                exerciseType: this.get("exerciseType"),
                hitRate: 100,
                hpFactor: this.get("arg4")
            };
            this._raiseAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.HEAL_DEATH, this.executer, n), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer;
            this._raiseAbility.set("activeTarget", this.get("activeTarget"));
            var r = this._raiseAbility.detectTargets(),
                i = this._raiseAbility.getActionResultWithTargets(r),
                s = this.detectTargets(),
                o = this.helper.magicAttack(s),
                u = o.damageObjects,
                a = [].concat(u);
            _.each(i.damageObjects, function(e, n) {
                if (!e.canHit) return;
                var r = t.util.DamageCalculator.makeDamageObject(this.executer, this.executer, this, {
                    canHit: !0,
                    isNotShownHitMotion: !0,
                    isNotShownDamageMotion: !0
                });
                r.absorber = e.receiver, r.absorbHp = e, a.push(r)
            }, this), o.damageObjects = a, this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (this.moHelper.addReplaceApplyDamageObjects(u), this.moHelper.addReplaceApplyDamageObjects(i.damageObjects)), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                o.damageObjects = u, e.helper.applyActionResult(o), e._raiseAbility.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("hitRate", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.get("hitRate"),
                s = this.get("statusAilmentsId"),
                o = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                u = [];
            _.each(o.damageObjects, function(r) {
                if (r.canHit) {
                    var o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: n,
                        target: r,
                        ability: e,
                        hitRate: i,
                        statusAilmentsIds: [s]
                    });
                    u.push(o)
                }
            }), this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(u);
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                _.each(u, function(e) {
                    o.damageObjects.push(e)
                }), e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6")), this.helper.setDamageCalculateTypeByAbility(this.get("arg8")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var l = this.executer.container ? this.executer.container : this.executer,
                c = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_BARRAGE,
                    action: this,
                    actionResult: f,
                    enemyContainer: l,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    shouldDeformAllNodes: !!this.get("shouldDeformAllNodes"),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResultForBarrage(f), e._isDone = !0
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndDeformAction = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    shouldDeformAllNodes: !!this.get("shouldDeformAllNodes"),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/ShowAbilityEffectAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ShowAbilityEffectAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("showReturnEffect", !!this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipAttackMotion: !!this.get("skipAttackMotion"),
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            return this.helper.showAbilityEffect(e)
        }
    })
}), define("scenes/battle/action/PhysicalDamagedHpAttackAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalDamagedHpAttackAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.DAMAGED_HP,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3"));
            var t = this.get("arg4"),
                n = {};
            n[t] = 100, this.set("selfStatusAilments", n);
            var r = {
                infoMap: {}
            };
            _.extend(r.infoMap, this.helper.makeChangeCastTimeInfoMap(t, this.get("arg5"), this.get("arg6"), this.get("arg7"))), this.set("skipSelfSaAnimation", !!this.get("arg8")), this.set("selfSaOptions", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = [],
                s = this.helper.physicalAttack(r);
            i.push(s.damageObjects);
            var o = _.any(s.damageObjects, function(e) {
                    return e.canHit
                }),
                u = void 0;
            o && (u = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: n,
                target: _.first(t.util.Targeting.makeResult(n)),
                ability: this,
                atkStatusAilments: this.get("selfStatusAilments"),
                statusAilmentsOptions: this.get("selfSaOptions"),
                forceHit: !0
            }), this.get("skipSelfSaAnimation") || i.push([u]));
            var a = this.helper.makeAndSetActionResult(n, this, i);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && o && e.get("skipSelfSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects([u]);
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: a,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                o && e.get("skipSelfSaAnimation") && a.damageObjects.push([u]), e.helper.applyActionResultForBarrage(a), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndColleagueSaAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndColleagueSaAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("hasColleagueSaAnimation", !!this.get("arg9"));
            var n = {};
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                if (!e) return;
                n[e] = 0
            }), this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: t.Conf.TARGET_RANGE.ALL,
                targetSegment: t.Conf.TARGET_SEGMENT.COLLEAGUE
            }), this._inflictSaAbility.set("atkStatusAilments", n);
            var r = this.get("arg10");
            if (r) {
                var i = {};
                i[r] = 0;
                var s = {};
                s.forceHit = !0, this.get("arg13") && (s.targetRange = this.get("arg13")), this.get("arg14") && (s.targetSegment = this.get("arg14")), this._customParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, s), this._customParamAbility.set("atkStatusAilments", i), this._customParamAbility.set("statusAilmentsOptions", {
                    boost: this.helper.makeBoostObject(r, this.get("arg11")),
                    infoMap: {
                        duration: this.get("arg12")
                    }
                })
            }
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u = !!this._customParamAbility;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.physicalAttack(i);
                o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = this.helper.makeAndSetActionResult(n, this, o),
                c = this._inflictSaAbility.makeActionResult(),
                h = u ? this._customParamAbility.makeActionResult() : void 0;
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && (this.get("hasColleagueSaAnimation") || this.moHelper.addAdditionalApplyDamageObjects(c.damageObjects), u && this.moHelper.addAdditionalApplyDamageObjects(h.damageObjects));
            var p = {};
            this.get("hasColleagueSaAnimation") && (l.damageObjects.push(c.damageObjects), p[r + 1] = !0);
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: p
                }
            }).addCallbackOnce("end", function() {
                e.get("hasColleagueSaAnimation") || l.damageObjects.push(c.damageObjects), u && l.damageObjects.push(h.damageObjects), e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("selfSaId", this.get("arg7")), this.set("ignoresAttackHit", !!this.get("arg8")), this.set("hasSelfSaAnimation", !!this.get("arg10"));
            var t = this.get("arg12");
            this.helper.setDamageCalculateParamAdjustConf(t, [this.get("arg13"), this.get("arg14")]);
            var n = this.get("selfSaId"),
                r = {
                    infoMap: {}
                },
                i = this.get("arg9") || 0;
            i > 0 && (r.infoMap.duration = i), this.set("selfSaOptions", r), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("ignoresAttackHit"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = e.helper.includesHitDamageObject(l.damageObjects)), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = this.helper.makeAndSetActionResult(n, this, u),
                h = void 0,
                p = {};
            if (a || o) h = e._calcSelfSa(), this.get("hasSelfSaAnimation") && (this.helper.mergeDamageObjectsForBarrage(c.damageObjects, [h]), p[r + 1] = !0);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && h && !e.get("hasSelfSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects([h]);
            var d = this.animationHelper.createAnimationForBarrage(c, {
                skipDamageMotionCountMap: p
            }).addCallbackOnce("end", function() {
                h && !e.get("hasSelfSaAnimation") && e.helper.mergeDamageObjectsForBarrage(c.damageObjects, [h]), e.helper.applyActionResultForBarrage(c), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = {};
            n[this.get("selfSaId")] = 1;
            var r = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: e.executer,
                target: _.first(t.util.Targeting.makeResult(e.executer)),
                ability: e,
                atkStatusAilments: n,
                statusAilmentsOptions: e.get("selfSaOptions"),
                forceHit: !0
            });
            return r
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg7")
                },
                infoMap: {
                    duration: this.get("arg8")
                }
            }), this.set("dependsWeaponEffect", !0), this._healSaBundleId = this.get("arg10"), this._healSaBundleId > 0 && (this._healSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_SA, this.executer, {
                targetRange: this.get("arg11"),
                targetSegment: this.get("arg12"),
                hitRate: this.get("arg13"),
                healStatusAilmentIds: this.get("healStatusAilmentIds")
            }))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            if (this._healSaBundleId) {
                var l = this._healSaAbility.calcDamageObjects();
                this.helper.mergeDamageObjectsForBarrage(f.damageObjects, l)
            }
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            }), this.set("forceHit", !0), this.set("dependsWeaponEffect", !0), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u, a = function(e) {
                    return e.canHit
                };
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                u || (u = _.any(l.damageObjects, a)), o.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var c = this.helper.makeAndSetActionResult(n, this, o),
                h = void 0;
            if (u) {
                var p = this._selfCustomParamAbility.detectTargets();
                h = this._selfCustomParamAbility.makeActionResult()
            }
            t.BattleInfo.getInstance().isMo() && h && this.moHelper.addAdditionalApplyDamageObjects(h.damageObjects), this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(c), h && e.helper.applyActionResult(h), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamWithEffectAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndSelfCustomParamWithEffectAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            }), this.set("forceHit", !!this.get("arg10")), this.set("dependsWeaponEffect", !0), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = this.helper.physicalAttackMulti(),
                s = i.actionResult,
                o = i.isHit,
                u = void 0;
            o || this._selfCustomParamAbility.set("forceMiss", !0), u = this._selfCustomParamAbility.makeActionResult(), s.damageObjects.push(u.damageObjects), this.changeState("WAIT_ANIM");
            var a = {};
            a[r + 1] = !0;
            var f = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: s,
                options: {
                    skipDamageMotionCountMap: a
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(s), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg7")
                }
            });
            var n = this.get("arg8"),
                r = {};
            r[n] = 100, this.set("selfStatusAilments", r), this.set("forceHit", !!this.get("arg9")), this.set("ignoresAttackHit", !!this.get("arg10")), this.set("skipSelfSaAnimation", !!this.get("arg11")), this.set("dependsWeaponEffect", !0), this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = this.helper.physicalAttackMulti(),
                s = i.actionResult,
                o = i.isHit,
                u = void 0,
                a = t.util.Targeting.makeResult(this.executer),
                f = {
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceMiss: !o && !this.get("ignoresAttackHit") ? !0 : !1
                };
            u = this._inflictSaAbility.getActionResultWithTargetsAndParams(a, f);
            var l = {};
            this.get("skipSelfSaAnimation") || (this.helper.mergeDamageObjectsForBarrage(s.damageObjects, u.damageObjects), l[r + 1] = !0), t.BattleInfo.getInstance().isMo() && this.get("skipSelfSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects(u.damageObjects), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(s, {
                skipDamageMotionCountMap: l
            }).then(function() {
                e.get("skipSelfSaAnimation") && e.helper.mergeDamageObjectsForBarrage(s.damageObjects, u.damageObjects), e.helper.applyActionResultForBarrage(s), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfAttachElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfAttachElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("isSameTarget", !!this.get("arg5")), this.set("selfSaId", this.get("arg12")), this.set("forceHit", !0), this.set("dependsWeaponEffect", !0);
            var n = {
                    infoMap: {
                        swapAbilityId: this.get("arg7"),
                        normalAbilityDamageFactor: this.get("arg8"),
                        soulStrikeDamageFactor: this.get("arg9"),
                        defenseFactor: this.get("arg10")
                    }
                },
                r = this.get("arg11") || 0;
            r > 0 && (n.infoMap.duration = r), this._selfAttachElementAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg6"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: n
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this.helper.makeAndSetActionResult(n, this, o);
            this.set("actionResult", f);
            var l = this._selfAttachElementAbility.makeActionResult(),
                c = {};
            if (this.get("selfSaId")) {
                var h = e._calcSelfSa();
                this.helper.mergeDamageObjectsForBarrage(f.damageObjects, [h]), c[r + 1] = !0
            }
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(l.damageObjects);
            var p = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: f,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                o.push(l.damageObjects), e.helper.applyActionResultForBarrage(f), e._isDone = !0
            }).play()
        },
        _calcSelfSa: function() {
            var e = this,
                n = {};
            n[this.get("selfSaId")] = 1;
            var r = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: e.executer,
                target: _.first(t.util.Targeting.makeResult(e.executer)),
                ability: e,
                atkStatusAilments: n,
                statusAilmentsOptions: e.get("selfSaOptions"),
                forceHit: !0
            });
            return r
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("ignoresAttackHit", !!this.get("arg11")), this.set("criticalCoefficient", this.helper.calcCriticalCoefficient(this.get("arg13")));
            var n = !!this.get("arg10");
            this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: n ? {
                        absolute: this.get("arg8")
                    } : {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.get("barrageNum") || 1,
                n = this.helper.physicalAttackMulti(),
                r = n.actionResult,
                i = n.isHit,
                s = void 0;
            !i && !this.get("ignoresAttackHit") && (this._selfCustomParamAbility.set("forceMiss", !0), this._selfCustomParamAbility.set("forceHit", !1)), s = this._selfCustomParamAbility.makeActionResult(), r.damageObjects.push(s.damageObjects), this.changeState("WAIT_ANIM");
            var o = {};
            o[t + 1] = !0, this.animationHelper.playAnimationForBarrageDeferred(r, {
                skipDamageMotionCountMap: o
            }).then(function() {
                e.helper.applyActionResultForBarrage(r), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this._increaseMpParams = {
                damageFactor: this.get("arg10"),
                hitRate: this.get("arg11"),
                remainNum: this.get("arg12"),
                usedNum: this.get("arg13"),
                priorityType: this.get("arg14")
            }, this._increaseMpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.INCREASE_MP, this.executer, {
                targetRange: this.get("arg15") || t.Conf.TARGET_RANGE.SELF
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.physicalAttackMulti().actionResult,
                n = this._increaseMpAbility.getActionResultWithTargetsAndParams(this._increaseMpAbility.detectTargets(), this._increaseMpParams),
                r = t.damageObjects;
            r.push(n.damageObjects);
            var i = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(i).then(function() {
                e.helper.applyActionResultForBarrage(i), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/InflictSaAndCustomProbabilityDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.InflictSaAndCustomProbabilityDeformAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = {};
            _.each([
                [1, 2],
                [3, 4],
                [5, 6],
                [7, 8],
                [9, 10]
            ], function(e) {
                var r = t.get(sprintf("arg%d", e[0]));
                r && (n[r] = t.get(sprintf("arg%d", e[1])))
            }), t.set("atkStatusAilments", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.lotStatusAilments(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        }
    })
}), define("scenes/battle/action/ShowAbilityEffectDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ShowAbilityEffectDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("showReturnEffect", !!this.get("arg1"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n),
                i = this.executer.container ? this.executer.container : this.executer;
            this.get("checkCanExecAbilityFlag") && !n.length ? this.changeState("INVALIDITY") : (this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                action: this,
                actionResult: r,
                enemyContainer: i,
                animationInfo: this.helper.detectDeformAnimationInfo(),
                options: {
                    skipDamageMotion: !0,
                    usesMainNode: !!this.get("usesMainNode")
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play())
        },
        _calc: function(e) {
            return this.helper.showAbilityEffect(e)
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("barrageNum", this.get("arg7")), this.set("isSameTarget", !!this.get("arg8")), this.set("dependsWeaponEffect", !0);
            var n = {
                    exerciseType: t.Conf.EXERCISE_TYPE.INBORN,
                    factor: this.get("arg5"),
                    matkElement: this.get("arg6")
                },
                r = !!this.get("arg9");
            r && (n.targetRange = t.Conf.TARGET_RANGE.SELF), this._healHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_HP, this.executer, n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.physicalAttackMulti(),
                n = t.actionResult,
                r = this._healHpAbility.calcDamageObjects();
            this.helper.mergeDamageObjectsForBarrage(n.damageObjects, r), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/CustomParamMultiAndInflictSaMultiAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamMultiAndInflictSaMultiAction = e.extend({
        initialize: function() {
            var n = this;
            e.prototype.initialize.apply(this, arguments);
            var r = this.get("statusAilmentsFactor"),
                i = this.get("atkStatusAilmentIds"),
                s = {};
            _.each(i, function(e) {
                s[e] = r
            }, this), this.set("atkStatusAilments", s);
            var o = [],
                u = !!this.get("arg11"),
                a = this.get("arg1");
            _.each([2, 4, 6, 12], function(e) {
                var r = n.get(t("arg%d", e));
                if (r) {
                    var i = u && e === 12,
                        s = n.get(t("arg%d", e + 1)),
                        f = n.helper.makeBoostObject(r, s, {
                            isAbsolute: i
                        }),
                        l = 100,
                        c = {};
                    c[r] = l, o.push({
                        atkSa: c,
                        statusAilmentsOptions: {
                            boost: f,
                            infoMap: {
                                duration: a
                            }
                        }
                    })
                }
            }), this.set("customParamConfs", o), this.set("forceHit", !!this.get("arg14"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.lotStatusAilments(this.detectTargets()),
                r = [];
            _.each(t.damageObjects, function(t) {
                t.canHit && _.each(e.get("customParamConfs"), function(i) {
                    var s = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: t,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: !0
                    });
                    r.push(s)
                })
            }), n.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(r), this.changeState("WAIT_ANIM");
            var i = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: t,
                options: {
                    skipAttackMotion: !!this.get("skipAttackMotion"),
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                _.each(r, function(e) {
                    t.damageObjects.push(e)
                }), e.helper.recalculateCounterEnableFlag(t.damageObjects), e.helper.applyActionResult(t), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/RageAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.RageAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = this.get("arg1"),
                r = this.get("arg2"),
                i = this.get("arg3"),
                s = [];
            for (var o = 1; o < e; o++) s.push(i);
            this.set("wrappedAbilityId", r), this.set("continuousStatusAilment", n.Conf.STATUS_AILMENTS_TYPE.RAGE), this.set("continuousStatusAilmentOptions", {
                abilityIds: s
            })
        }
    })
}), define("scenes/battle/action/TranceAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.TranceAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = this.get("arg1");
            this.set("wrappedAbilityId", e), this._replaceChangeCastTimeCond(this.executer, e);
            var n = this.get("arg7"),
                r = this.get("arg8");
            this.set("continuousStatusAilment", this.get("statusAilmentsId")), this.set("continuousStatusAilmentOptions", {
                spareReceptorIds: [this.get("arg3"), this.get("arg5")],
                infoMap: {
                    duration: this.get("arg6")
                },
                boosts: [{
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: n
                }, {
                    rate: r
                }]
            }), this.set("optionalSelfSaId", this.get("arg9"))
        },
        onWrappedAbilityDone: function() {
            t.prototype.onWrappedAbilityDone.apply(this, arguments);
            var e = this.get("optionalSelfSaId");
            if (!e) return;
            var n = this.executer;
            n.setStatusAilments([e])
        },
        _replaceChangeCastTimeCond: function(e, t) {
            var r = n.AbilityFactory.create(t, e, this.moHelper.getCreateOptions());
            this.set("isPossibleContainMagicDamage", r.get("isPossibleContainMagicDamage")), this.set("changeCastTimeCondList", r.get("changeCastTimeCondList"))
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementAndInflictSaAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.action.PhysicalAttackAndInflictSaAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("targetRange", n.TARGET_RANGE.SINGLE), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("forceHit", !!this.get("arg3")), this.set("atkElement", this.get("arg4"));
            var t = this.get("arg5"),
                r = {};
            r[t] = this.get("arg6"), this.set("opponentStatusAilments", r);
            var i = this.get("arg7"),
                s = {};
            s[i] = 1, this.set("selfStatusAilments", s)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: r,
                options: {
                    skipDamageMotionCountMap: {
                        2: !0,
                        3: !0
                    }
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = this,
                r = this.executer,
                i = [],
                s = !1;
            _.each(e, function(e) {
                var o = n.helper.physicalAttack([e]);
                i.push(o.damageObjects);
                var u = _.first(o.damageObjects).canHit;
                if (u) {
                    var a = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: r,
                        target: e,
                        ability: n,
                        atkStatusAilments: n.get("opponentStatusAilments")
                    });
                    i.push([a]), a.canHit && (s = !0)
                }
            });
            if (s) {
                var o = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: r,
                    target: _.first(t.util.Targeting.makeResult(r)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                i.push([o])
            }
            return this.helper.recalculateCounterEnableFlag(i), this.helper.makeAndSetActionResult(r, this, i)
        }
    })
}), define("scenes/battle/action/AttachElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.AttachElementAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = this.get("atkStatusAilmentIds"),
                r = this.get("statusAilmentsFactor"),
                i = {};
            _.each(n, function(e) {
                i[e] = r
            }, this), this.set("atkStatusAilments", i), this.set("statusAilmentsOptions", {
                infoMap: {
                    swapAbilityId: this.get("arg2"),
                    normalAbilityDamageFactor: this.get("arg3"),
                    soulStrikeDamageFactor: this.get("arg4"),
                    defenseFactor: this.get("arg5"),
                    duration: this.get("arg6")
                }
            });
            var s = [];
            _.each([7, 8], function(e) {
                var n = t.get(sprintf("arg%d", e));
                if (n) {
                    var i = {};
                    i[n] = r, s.push({
                        atkSa: i,
                        statusAilmentsOptions: {}
                    })
                }
            }), this.set("optionalStatusAilmentsConfs", s);
            var o = [],
                u = this.get("statusAilmentsId");
            if (u) {
                var a = {};
                a[u] = r, o.push({
                    atkSa: a,
                    statusAilmentsOptions: {
                        boost: {
                            rate: this.get("arg9")
                        },
                        infoMap: {
                            duration: this.get("arg10")
                        }
                    }
                })
            }
            this.set("customParamConfs", o), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.lotStatusAilments(this.detectTargets()),
                r = [];
            _.each(n.damageObjects, function(n) {
                _.each(e.get("optionalStatusAilmentsConfs"), function(i) {
                    var s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: !0
                    });
                    r.push(s)
                })
            });
            var i = [];
            _.each(n.damageObjects, function(n) {
                _.each(e.get("customParamConfs"), function(r) {
                    var s = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: n,
                        ability: e,
                        atkStatusAilments: r.atkSa,
                        statusAilmentsOptions: r.statusAilmentsOptions,
                        forceHit: !0
                    });
                    i.push(s)
                })
            }), t.BattleInfo.getInstance().isMo() && (this.moHelper.addAdditionalApplyDamageObjects(r), this.moHelper.addAdditionalApplyDamageObjects(i)), this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                _.each(r, function(e) {
                    n.damageObjects.push(e)
                }), _.each(i, function(e) {
                    n.damageObjects.push(e)
                }), e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/CustomParamMultiAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamMultiAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = [],
                r = {},
                i = this.get("arg1"),
                s = this.get("arg2");
            this.set("forceHit", !!this.get("arg3"));
            var o = [{
                id: this.get("arg4"),
                value: this.get("arg5"),
                isAbsolute: !!this.get("arg10")
            }, {
                id: this.get("arg6"),
                value: this.get("arg7"),
                isAbsolute: !!this.get("arg11")
            }, {
                id: this.get("arg8"),
                value: this.get("arg9"),
                isAbsolute: !!this.get("arg12")
            }];
            _.each(o, function(e) {
                var o = e.id,
                    u = e.value,
                    a = e.isAbsolute;
                if (!o) return;
                if (r[o]) throw new Error("duplicate entry status_ailment_id." + o);
                r[o] = 1;
                var f = {};
                f[o] = s, n.push({
                    atkSa: f,
                    statusAilmentsOptions: {
                        boost: t.helper.makeBoostObject(o, u, {
                            isAbsolute: a
                        }),
                        infoMap: {
                            duration: i
                        }
                    }
                })
            }), this.set("customParamConfs", n)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                r = [];
            _.each(t, function(t) {
                _.each(e.get("customParamConfs"), function(i) {
                    var s = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.STATUS_AILMENTS,
                        executer: e.executer,
                        target: t,
                        ability: e,
                        atkStatusAilments: i.atkSa,
                        statusAilmentsOptions: i.statusAilmentsOptions,
                        forceHit: e.get("forceHit")
                    });
                    r.push(s)
                })
            });
            var i = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.changeState("WAIT_ANIM");
            var s = n.BattleViewController.getInstance().createAnimation({
                animationType: n.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: i,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(i), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var n = this.get("arg7"),
                r = {};
            r[n] = this.get("arg8"), this.set("selfStatusAilments", r), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg9")
                },
                infoMap: {
                    duration: this.get("arg10")
                }
            }), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer), this.set("ignoresAttackHit", !!this.get("arg11"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("ignoresAttackHit"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = e.helper.includesHitDamageObject(l.damageObjects)), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = this.helper.makeAndSetActionResult(n, this, u),
                h = void 0;
            if (a || o) {
                var p = this._selfCustomParamAbility.detectTargets(),
                    d = {
                        atkStatusAilments: this.get("selfStatusAilments"),
                        statusAilmentsOptions: this.get("selfStatusAilmentsOptions")
                    };
                h = this._selfCustomParamAbility.getActionResultWithTargetsAndParams(p, d)
            }
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && h && this.moHelper.addAdditionalApplyDamageObjects(h.damageObjects);
            var v = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: c
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(c), h && e.helper.applyActionResult(h), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var t = !!this.get("arg10"),
                n = this.get("arg7"),
                r = {};
            r[n] = 1, this.set("partyStatusAilments", r), this.set("partyStatusAilmentsOptions", {
                boost: t ? {
                    absolute: this.get("arg8")
                } : {
                    rate: this.get("arg8")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            });
            var i = this.get("arg11"),
                s = {};
            s[i] = 0, this.set("selfSaId", i), this.set("selfStatusAilments", s)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._calcCustomParam();
            o.push(f);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcCustomParam: function() {
            var e = this,
                n = t.util.Targeting.makeResult(_.filter(t.ActorMgr.getAliveActors(), function(t) {
                    return t.isColleague(e.executer)
                })),
                r = [];
            _.each(n, function(e) {
                var n = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    atkStatusAilments: this.get("partyStatusAilments"),
                    statusAilmentsOptions: this.get("partyStatusAilmentsOptions"),
                    forceHit: !0
                });
                r.push(n)
            }, this);
            if (this.get("selfSaId")) {
                var i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: this.executer,
                    target: _.first(t.util.Targeting.makeResult(this.executer)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    forceHit: !0
                });
                r.push(i)
            }
            return r
        }
    })
}), define("scenes/battle/action/PhysicalAttackWithMultiHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackWithMultiHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("atkType", this.get("arg2")), this.set("hitRate", this.get("arg3")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.get("hitRate"),
                s = this.get("healStatusAilmentIds"),
                o = this.helper.physicalAttack(r, {
                    skipStatusAilments: !0
                }),
                u = [];
            _.each(o.damageObjects, function(r) {
                if (r.canHit) {
                    var o = t.util.DamageCalculator.calculate({
                        type: t.Conf.CALC_TYPE.HEAL_SA,
                        executer: n,
                        target: r,
                        ability: e,
                        hitRate: i,
                        statusAilmentsIds: s
                    });
                    u.push(o)
                }
            }), this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(u);
            var a = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                _.each(u, function(e) {
                    o.damageObjects.push(e)
                }), e.helper.recalculateCounterEnableFlag(o.damageObjects), e.helper.applyActionResult(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ChangeCastTimeAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.ChangeCastTimeAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("statusAilmentsOptions", {
                infoMap: this.helper.makeChangeCastTimeInfoMap(this.get("statusAilmentsId"), this.get("arg1"), this.get("arg2"), this.get("arg3"))
            }), this.set("forceHit", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.lotStatusAilments(this.detectTargets());
            this.changeState("WAIT_ANIM");
            var r = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: n,
                options: {
                    skipDamageMotion: !0
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(n), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/HealHpAndHealDeathAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpAndHealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("hpFactor", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this._calc(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        },
        _calc: function(e) {
            var n = [];
            return _.each(e, function(e) {
                if (e.receiver.isDead()) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), _.each(e, function(e) {
                if (e.receiver.isAlive()) return;
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_DEATH,
                    executer: this.executer,
                    target: e,
                    ability: this,
                    hitRate: 100,
                    hpFactor: this.get("hpFactor")
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        }
    }), FF.ns.battle.action.HealHpAndHealDeathAction
}), define("scenes/battle/action/HealHpOrHealDeathAction", ["./WrappedAbilityActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.HealHpOrHealDeathAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("healHpAbilityId", this.get("arg1")), this.set("healDeathAbilityId", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var t = this._decideExecAbilityId();
            this.set("wrappedAbilityId", t), e.prototype.processForStateInitUpdate.apply(this, arguments)
        },
        _decideExecAbilityId: function() {
            var e = _.first(this.detectTargets());
            return e && e.receiver.isDead() ? this.get("healDeathAbilityId") : this.get("healHpAbilityId")
        }
    }), FF.ns.battle.action.HealHpAndHealDeathAction
}), define("scenes/battle/action/MagicAttackMultiAndSelfSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndSelfSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("isSameTarget", !!this.get("arg4")), this.set("selfSaId", this.get("arg5")), this.set("hasSelfSaAnimation", !!this.get("arg11"));
            var t = {
                    infoMap: {}
                },
                n = this.get("arg6") || 0;
            n > 0 && (t.infoMap.duration = n), _.extend(t.infoMap, this.helper.makeChangeCastTimeInfoMap(this.get("selfSaId"), this.get("arg7"), this.get("arg8"), this.get("arg9"))), this.set("selfSaOptions", t);
            var r = this.get("arg13");
            this.helper.setDamageCalculateParamAdjustConf(r, [this.get("arg14"), this.get("arg15")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            this.helper.recalculate(o);
            var f = this.helper.makeAndSetActionResult(n, this, o),
                l = this._calcSelfSa(),
                c = {};
            this.get("hasSelfSaAnimation") && (this.helper.mergeDamageObjectsForBarrage(f.damageObjects, [l]), c[r + 1] = !0), this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects([l]), this.animationHelper.playAnimationForBarrageDeferred(f, {
                skipDamageMotionCountMap: c
            }).then(function() {
                e.get("hasSelfSaAnimation") || e.helper.mergeDamageObjectsForBarrage(f.damageObjects, [l]), e.helper.applyActionResultForBarrage(f), e._isDone = !0
            })
        },
        _calcSelfSa: function() {
            var e = this,
                n = {};
            n[this.get("selfSaId")] = 1;
            var r = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: e.executer,
                target: _.first(t.util.Targeting.makeResult(e.executer)),
                ability: e,
                atkStatusAilments: n,
                statusAilmentsOptions: e.get("selfSaOptions"),
                forceHit: !0
            });
            return r
        }
    })
}), define("scenes/battle/action/MagicAttackAndInflictSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndInflictSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3"));
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this), this.set("atkStatusAilments", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.magicAttack(n);
            this.changeState("WAIT_ANIM"), t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackAndInflictSaMultiAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.MagicAttackAndInflictSaMultiAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this.get("statusAilmentsFactor"),
                n = this.get("atkStatusAilmentIds"),
                r = {};
            _.each(n, function(e) {
                r[e] = t
            }, this);
            var i = {};
            this.get("arg6") && (i.boost = {
                rate: this.get("arg6")
            }), this.get("arg7") && (i.infoMap = {
                duration: this.get("arg7")
            }), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.helper.setDamageCalculateTypeByAbility(this.get("arg11")), this.set("forceHit", this.get("arg5")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", i), this.set("hitRate", this.get("arg8"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.magicAttack(n),
                i = this.helper.makeTargetsFromHitDamageObjects(r.damageObjects),
                s = this.helper.calcForHealSa(i);
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s), this._playAnimationDeferred(r).then(function() {
                e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.applyActionResult(r), e._onAnimationEndHook(), e._isDone = !0
            })
        },
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForNormalDeferred(e)
        },
        _onAnimationEndHook: function() {}
    }), FF.ns.battle.action.MagicAttackAndInflictSaMultiAndHealSaMultiAction
}), define("scenes/battle/action/MagicAttackAndInflictSaMultiAndHealSaMultiAndDeformAction", ["./MagicAttackAndInflictSaMultiAndHealSaMultiAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndInflictSaMultiAndHealSaMultiAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/MagicAttackAndAbsorbHpAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackAndAbsorbHpAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("absorbHpFactor", this.get("arg4"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.magicAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/HealSaMultiAndDeformAction", ["util", "./ActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.HealSaMultiAndDeformAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.detectTargets(),
                i = this._calc(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = n.BattleViewController.getInstance().createAnimation({
                    animationType: n.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode"),
                        skipDamageMotion: !0
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        },
        _calc: function(e) {
            var t = [],
                r = this.get("healStatusAilmentIds");
            return _.each(e, function(e) {
                var i = e.receiver,
                    s = _.intersection(r, i.statusAilments.getRefs()),
                    o = n.util.DamageCalculator.calculate({
                        type: n.Conf.CALC_TYPE.HEAL_SA,
                        executer: this.executer,
                        target: e,
                        ability: this,
                        hitRate: s.length > 0 ? 100 : 0,
                        statusAilmentsIds: s
                    });
                t.push(o), FF.logger.info("HEAL_SA_MULTI_AND_DEFORM", "ids", s)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, t)
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndAbsorbHpAndDeformAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndAbsorbHpAndDeformAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("absorbHpFactor", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = this.helper.physicalAttack(r);
            this.changeState("WAIT_ANIM");
            var s = this.executer.container ? this.executer.container : this.executer,
                o = t.BattleViewController.getInstance().createAnimation({
                    animationType: t.Conf.ANIMATION_TYPE.DEFORM_ATTACK,
                    action: this,
                    actionResult: i,
                    enemyContainer: s,
                    animationInfo: this.helper.detectDeformAnimationInfo(),
                    options: {
                        usesMainNode: !!this.get("usesMainNode")
                    }
                }).addCallbackOnce("end", function() {
                    e.helper.applyActionResult(i), e.onDeformEnd()
                }).play()
        },
        onDeformEnd: function() {
            var e = this.executer.container ? this.executer.container : this.executer,
                t = this.get("looking");
            t && e.set("looking", t), this._isDone = !0
        }
    })
}), define("scenes/battle/action/FractionalAttackByHpOnAttackerHpAction", ["./FractionalAttackByHpAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalAttackByHpOnAttackerHpAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments);
            var n = this.executer;
            this.set("damageRate", n.getDamagedHpRate())
        }
    })
}), define("scenes/battle/action/HealHpAndIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3")), this.set("increaseMpDamageFactor", this.get("arg5")), this.set("increaseMpHitRate", this.get("arg6")), this.set("remainNum", this.get("arg7")), this.set("usedNum", this.get("arg8")), this._increaseMpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.INCREASE_MP, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = {},
                r = this.executer,
                i = [],
                s = this.detectTargets(),
                o = this._calcHealHp(s),
                u = [],
                a = [];
            _.each(o.damageObjects, function(e) {
                var t = e.receiver;
                e.canHit ? u.push(t) : a.push(t)
            });
            var f = u.length ? t.util.Targeting.makeResult(u) : void 0,
                l = this._calcIncreaseMp(f),
                c = a.length ? t.util.Targeting.makeResult(a) : void 0,
                h = this._calcIncreaseMp(c, {
                    hitRate: 0
                });
            i.push(o.damageObjects), i.push([].concat(l.damageObjects, h.damageObjects));
            var p = this.helper.makeAndSetActionResult(r, this, i);
            this.changeState("WAIT_ANIM");
            var d = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: p
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(p), e._isDone = !0
            }).play()
        },
        _calcHealHp: function(e) {
            var n = [];
            return _.each(e, function(e) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: this.executer,
                    target: e,
                    ability: this
                });
                n.push(r)
            }, this), this.helper.makeAndSetActionResult(this.executer, this, n)
        },
        _calcIncreaseMp: function(e, t) {
            var n = {
                damageFactor: this.get("increaseMpDamageFactor"),
                hitRate: this.get("increaseMpHitRate"),
                remainNum: this.get("remainNum"),
                usedNum: this.get("usedNum")
            };
            return _.extend(n, t), this._increaseMpAbility.getActionResultWithTargetsAndParams(e, n)
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiDependedOnSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    return FF.ns.battle.action.PhysicalAttackMultiDependedOnSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1"));
            var t = this.get("arg2");
            this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg11")), this.set("barrageNum", this.get("arg7")), this.set("isSameTarget", !!this.get("arg8"));
            var r = [];
            this.get("arg4") && r.push(this.get("arg4")), this.get("arg5") && r.push(this.get("arg5")), this.get("arg6") && r.push(this.get("arg6"));
            var i = this.get("statusAilmentsFactor"),
                s = this.get("atkStatusAilmentIds"),
                o = {};
            _.each(s, function(e) {
                o[e] = i
            }, this), this.set("atkStatusAilments", o), this.helper.setDamageCalculateParamAdjustConf(n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA, [].concat(t, r)), this.set("targetSaIdsByAttackDependedOnSa", r), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                n = this.detectTargets(),
                r = this.helper.physicalAttackMutably(n),
                i = r.actionResult;
            this.helper.setSkipUnsetFlagWhenDamagedByActionResult(i), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationMutablyDeferred(i).then(function() {
                e.helper.applyActionResultMutably(i), e._isDone = !0
            })
        }
    }), FF.ns.battle.action.PhysicalAttackDependedOnSaAction
}), define("scenes/battle/action/PhysicalAttackMultiAndCustomParamAndPartyCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndCustomParamAndPartyCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("atkElement", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                boost: {
                    rate: this.get("arg6")
                },
                infoMap: {
                    duration: this.get("arg9")
                }
            }), this._partyCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: t.Conf.TARGET_RANGE.ALL,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            }), this.set("forceHit", !0), this.set("dependsWeaponEffect", !0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._partyCustomParamAbility.makeActionResult();
            o.push(f.damageObjects);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = {};
            c[r + 1] = !0;
            var h = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l,
                options: {
                    skipDamageMotionCountMap: c
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/ExecAbilityBySelfSaAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ExecAbilityBySelfSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("defaultAbilityId", this.get("arg1"));
            var e = _.compact([this.get("arg4"), this.get("arg7"), this.get("arg10")]),
                n = [this.get("arg2"), this.get("arg5"), this.get("arg8")],
                r = [this.get("arg3"), this.get("arg6"), this.get("arg9")],
                i = _.map(_.range(0, e.length), function(t) {
                    if (n[t] === 0 && r[t] === 0) throw new Error("saId or SaBundle Id should be defined for abilityId: " + e[t]);
                    return {
                        abilityId: e[t],
                        saId: n[t],
                        saBundleId: r[t]
                    }
                });
            this.set("abilityIdConditionMaps", i)
        },
        processForStateInitUpdate: function() {
            var e = this._decideExecAbilityId();
            this.set("wrappedAbilityId", e), t.prototype.processForStateInitUpdate.apply(this, arguments)
        },
        _decideExecAbilityId: function() {
            var e = this.get("abilityIdConditionMaps"),
                t = this.executer.statusAilments.cloneIds(),
                r = _.find(e, function(e) {
                    if (e.saId > 0 && _.contains(t, e.saId)) return !0;
                    if (e.saBundleId > 0) {
                        var r = _.find(n.StatusAilmentsConfig.getBundle(e.saBundleId), function(e) {
                            if (_.contains(t, e)) return !0
                        });
                        if (r) return !0
                    }
                    return !1
                });
            return r ? r.abilityId : this.get("defaultAbilityId")
        }
    })
}), define("scenes/battle/action/ExecAbilityByStatusAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle,
        r = 1;
    FF.ns.battle.action.ExecAbilityByStatusAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = n.Config.getInstance().get("ParamName", this.get("arg1"));
            this.set("paramName", e);
            var i = _.compact([this.get("arg2"), this.get("arg4"), this.get("arg6"), this.get("arg8"), this.get("arg10")]),
                s = _.compact([r, this.get("arg3"), this.get("arg5"), this.get("arg7"), this.get("arg9")]),
                o = _.object(i, s),
                u = _.map(o, function(e, t) {
                    if (t && !e) throw new Error("threshold not found for abilityId: " + t);
                    if (!t && e) throw new Error("abilityId not found for threshold: " + e);
                    return {
                        abilityId: t,
                        threshold: e
                    }
                });
            this.set("abilityIdThresholdMaps", u)
        },
        processForStateInitUpdate: function() {
            var e = this._decideExecAbilityId(this.executer, this.get("paramName"), this.get("abilityIdThresholdMaps"));
            this.set("wrappedAbilityId", e), t.prototype.processForStateInitUpdate.apply(this, arguments)
        },
        _decideExecAbilityId: function(e, t, n) {
            var r = e.get(t);
            n = _.sortBy(n, function(e) {
                return -1 * e.threshold
            });
            var i = _.find(n, function(e) {
                return r >= e.threshold
            });
            return i ? i.abilityId : this.get("arg2")
        }
    })
}), define("scenes/battle/action/ExecAbilityByUsedAbilityCountAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ExecAbilityByUsedAbilityCountAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = _.compact(_.map(_.range(1, 11), function(e) {
                return this.get("arg" + e)
            }, this));
            this.set("abilityIds", e)
        },
        processForStateInitUpdate: function() {
            var e = this.get("statusAilmentsId"),
                n = this.get("abilityIds"),
                r = this.executer.statusAilments.getAbilityIndexForUsedAbilityCount(e),
                i = n[r];
            this.set("wrappedAbilityId", i), this.set("continuousStatusAilment", e);
            var s = this.executer.statusAilments.getUsedAbilityCount(e) + 1;
            this.set("continuousStatusAilmentOptions", {
                infoMap: {
                    abilityCount: s
                }
            }), t.prototype.processForStateInitUpdate.apply(this, arguments)
        }
    })
}), define("scenes/battle/action/ExecAbilityByCondThresholdAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle,
        r = {};
    r[1] = "_buddiesSex", r[2] = "_damageReceiveCount", FF.ns.battle.action.ExecAbilityByCondThresholdAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("condType", this.get("arg1")), this.set("defaultAbility", this.get("arg3"));
            var e = _.compact([this.get("arg5"), this.get("arg7"), this.get("arg9")]),
                n = _.compact([this.get("arg4"), this.get("arg6"), this.get("arg8")]);
            if (e.length !== n.length) throw new Error("abilityIds.length should be equal to thresholds.length abilityId:" + this.get("abilityId"));
            var r = _.object(e, n),
                i = _.map(r, function(e, t) {
                    return {
                        abilityId: t,
                        threshold: e
                    }
                });
            this.set("abilityIdThresholdMaps", i)
        },
        processForStateInitUpdate: function() {
            var e = this._decideExecAbilityId();
            this.set("wrappedAbilityId", e), t.prototype.processForStateInitUpdate.apply(this, arguments)
        },
        _decideExecAbilityId: function() {
            var e = r[this.get("condType")];
            if (!this[e]) throw new Error("invalid condType: " + this.get("condType"));
            var t = this[e](),
                n = _.sortBy(this.get("abilityIdThresholdMaps"), function(e) {
                    return -1 * e.threshold
                }),
                i = _.find(n, function(e) {
                    return t >= e.threshold
                });
            return i ? i.abilityId : this.get("defaultAbility")
        },
        _buddiesSex: function() {
            var e = this.get("arg2"),
                t = _.filter(n.ActorMgr.getAllBuddies(), function(t) {
                    return t.get("sex") === e
                });
            return t.length
        },
        _damageReceiveCount: function() {
            var e = this.get("arg2"),
                t = this.executer.actorStats.getStats(n.Conf.ACTOR_STATS_TYPE.DAMAGE_RECEIVE_COUNT),
                r = t.get(e);
            if (r === undefined) throw new Error("undefined damage receive count type : " + e);
            return r
        }
    })
}), define("scenes/battle/action/ExecAbilityWithNoEffectSelfCustomParamAndSelfSaAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ExecAbilityWithNoEffectSelfCustomParamAndSelfSaAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = this.get("arg1");
            this.set("wrappedAbilityId", e), this._inflictSaAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer);
            var r = this.get("arg7");
            this._customParam = this._makeCustomParam(r), this._statusAilmentsParam = {
                atkStatusAilments: this._makeStatusAilments(r)
            }
        },
        onWrappedAbilityDone: function() {
            t.prototype.onWrappedAbilityDone.apply(this, arguments);
            var e = n.util.Targeting.makeResult(this.executer),
                r = [];
            if (this._customParam) {
                var i = this._inflictSaAbility.getActionResultWithTargetsAndParams(e, this._customParam);
                this.helper.mergeDamageObjects(r, i.damageObjects)
            }
            if (this._statusAilmentsParam.atkStatusAilments) {
                var s = this._inflictSaAbility.getActionResultWithTargetsAndParams(e, this._statusAilmentsParam);
                this.helper.mergeDamageObjects(r, s.damageObjects)
            }
            n.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(r), this.helper.applyDamageObjects(r)
        },
        _makeCustomParam: function(e) {
            var t = this.get("arg2"),
                n = this.get("arg3"),
                r = this.get("arg4");
            if (!t) return void 0;
            var i = {};
            i[t] = e;
            var s = {
                atkStatusAilments: i,
                statusAilmentsOptions: {
                    boost: this.helper.makeBoostObject(t, n),
                    infoMap: {
                        duration: r
                    }
                }
            };
            return s
        },
        _makeStatusAilments: function(e) {
            var t = this,
                n = this.get("atkStatusAilmentIds"),
                r = {};
            return _.each(n, function(t) {
                r[t] = e
            }), _.isEmpty(r) ? void 0 : r
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndHealHpByHitDamageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndHealHpByHitDamageAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("dependsWeaponEffect", !0), this._healParams = {
                healHpFactor: this.get("arg7"),
                damageSum: 1,
                forceMiss: !1
            }, this._healHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.HEAL_HP_BY_DAMAGE_SUM, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.physicalAttack(i);
                o.push(a.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var f = this._calcHealHpByHitDamage(o);
            o.push(f.damageObjects);
            var l = this.helper.makeAndSetActionResult(n, this, o);
            this.changeState("WAIT_ANIM");
            var c = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        },
        _calcHealHpByHitDamage: function(e) {
            var t = 0;
            _.each(e, function(e) {
                _.each(e, function(e) {
                    t += e.damage
                })
            });
            var n = t > 0 ? !1 : !0,
                r = {
                    damageSum: t,
                    forceMiss: n
                };
            return _.extend(this._healParams, r), this._healHpAbility.makeActionResultWithParams(this._healParams)
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndHealHpByHitDamageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndHealHpByHitDamageAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6")), this.set("minDamageFactor", this.get("arg7")), this._healParams = {
                healHpFactor: this.get("arg8"),
                damageSum: 1,
                forceMiss: !1
            }, this._healHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.HEAL_HP_BY_DAMAGE_SUM, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.magicAttackMulti().actionResult,
                n = this._calcHealHpByHitDamage(t.damageObjects);
            this.helper.mergeDamageObjectsForBarrage(t.damageObjects, n.damageObjects);
            var r = this.helper.makeAndSetActionResult(this.executer, this, t.damageObjects);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(r).then(function() {
                e.helper.applyActionResultForBarrage(r), e._isDone = !0
            })
        },
        _calcHealHpByHitDamage: function(e) {
            var t = 0;
            _.each(e, function(e) {
                _.each(e, function(e) {
                    t += e.damage
                })
            });
            var n = t > 0 ? !1 : !0,
                r = {
                    damageSum: t,
                    forceMiss: n
                };
            return _.extend(this._healParams, r), this._healHpAbility.makeActionResultWithParams(this._healParams)
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndAttachElementAsDisadvantageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndAttachElementAsDisadvantageAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg6"));
            var n = {},
                r = this.get("statusAilmentsId");
            r && (n[r] = this.get("statusAilmentsFactor")), this.set("atkStatusAilments", n), this.set("statusAilmentsOptions", {
                infoMap: {
                    attachElementId: this.get("arg7"),
                    defenseFactor: this.get("arg8"),
                    duration: this.get("arg9")
                }
            });
            var i = this.get("arg10");
            this.helper.setDamageCalculateParamAdjustConf(i, [this.get("arg11"), this.get("arg12"), this.get("arg13"), this.get("arg14")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = this.get("isSameTarget"),
                s = this.helper.physicalAttackMulti(),
                o = s.actionResult;
            this.changeState("WAIT_ANIM");
            var u = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: o
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(o), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiWithMultiElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiWithMultiElementAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("minDamageFactor", this.get("arg2")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this.helper.setDamageCalculateTypeByAbility(this.get("arg10")), this.set("matkExponentialFactor", this.get("arg11"));
            var n = this.get("arg12");
            this.helper.setDamageCalculateParamAdjustConf(n, [this.get("arg13"), this.get("arg14")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.magicAttackMulti();
            this.changeState("WAIT_ANIM");
            var n = t.actionResult;
            this.animationHelper.playAnimationForBarrageDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiElementAction = e.extend({
        initialize: function() {
            var t = this;
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("criticalCoefficient", this.helper.calcCriticalCoefficient(this.get("arg10"))), this.set("dependsWeaponEffect", !0);
            var n = this.get("arg11");
            this.helper.setDamageCalculateParamAdjustConf(n, [this.get("arg12"), this.get("arg13"), this.get("arg14"), this.get("arg15")])
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.physicalAttackMulti();
            this.changeState("WAIT_ANIM");
            var n = t.actionResult;
            this.animationHelper.playAnimationForBarrageDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndSelfAttachElementAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndSelfAttachElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("isSameTarget", !!this.get("arg4")), this.set("minDamageFactor", this.get("arg5")), this._selfAttachElementAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg6"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    infoMap: {
                        swapAbilityId: this.get("arg7"),
                        normalAbilityDamageFactor: this.get("arg8"),
                        soulStrikeDamageFactor: this.get("arg9"),
                        defenseFactor: this.get("arg10")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.helper.magicAttackMulti(),
                i = r.actionResult,
                s = this._selfAttachElementAbility.makeActionResult();
            this.set("actionResult", i), this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s.damageObjects), this.animationHelper.playAnimationForBarrageDeferred(i).then(function() {
                i.damageObjects.push(s.damageObjects), e.helper.applyActionResultForBarrage(i), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/CustomParamMultiAndHpBarterAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamMultiAndHpBarterAction = e.extend({
        initialize: function() {
            var n = this;
            e.prototype.initialize.apply(this, arguments);
            var r = [],
                i = {},
                s = this.get("arg1"),
                o = this.get("arg2");
            this.set("forceHit", !!this.get("arg3")), _.each([4, 6, 8], function(e) {
                var u = n.get(t("arg%d", e));
                if (!u) return;
                if (i[u]) throw new Error("duplicate entry status_ailment_id." + u);
                i[u] = 1;
                var a = {};
                a[u] = o, r.push({
                    atkSa: a,
                    statusAilmentsOptions: {
                        boost: {
                            rate: n.get(t("arg%d", e + 1))
                        },
                        infoMap: {
                            duration: s
                        }
                    }
                })
            }), this.set("customParamConfs", r), this.set("barterRate", this.get("arg10")), this.set("isMultiplicandMaxHp", !!this.get("arg11"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.executer,
                r = this.helper.calcForHpBarter(),
                i = this.detectTargets(),
                s = [];
            _.each(e.get("customParamConfs"), function(t) {
                var n = e.helper.calcForInflictSa(i, {
                    atkStatusAilments: t.atkSa,
                    statusAilmentsOptions: t.statusAilmentsOptions
                });
                e.helper.mergeDamageObjects(s, n)
            });
            var o = this.helper.makeAndSetActionResult(this.executer, this, s);
            this.changeState("WAIT_ANIM"), n.BattleInfo.getInstance().isMo() && this.moHelper.addBeforeApplyDamageObjects([r]), this.animationHelper.playAnimationForNormalDeferred(o, {
                skipDamageMotion: !0
            }).then(function() {
                e.helper.applyDamageObjects([r]), e.helper.applyActionResult(o), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndSelfSaAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndSelfSaAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("isSameTarget", !!this.get("arg4")), this.set("minDamageFactor", this.get("arg5"));
            var n = {},
                r = this.get("arg6"),
                i = this.get("arg11");
            n[r] = 0, i && (n[i] = 0), this.set("selfStatusAilments", n), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg8")
                    },
                    infoMap: {
                        duration: this.get("arg9")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.helper.magicAttackMulti(),
                i = r.actionResult,
                s = _.first(t.util.Targeting.makeResult(n)),
                o = this.helper.calcForInflictSa([s], {
                    forceHit: !0,
                    atkStatusAilments: this.get("selfStatusAilments")
                });
            i.damageObjects.push(o);
            var u = this._selfCustomParamAbility.makeActionResult(),
                a = {},
                f = this.get("barrageNum");
            a[f + 1] = !0, this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(u.damageObjects), this.animationHelper.playAnimationForBarrageDeferred(i, {
                skipDamageMotionCountMap: a
            }).then(function() {
                e.helper.applyActionResultForBarrage(i), e.helper.applyActionResult(u), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndHpBarterAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndHpBarterAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("barterRate", this.get("arg7"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.detectTargets(),
                i = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HP_BARTER,
                    executer: n,
                    receiver: n,
                    ability: e
                }),
                s = this.helper.magicAttackMulti(r),
                o = s.actionResult;
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addBeforeApplyDamageObjects([i]), this.animationHelper.playAnimationForBarrageDeferred(o).then(function() {
                e.helper.applyDamageObjects([i]), e.helper.applyActionResultForBarrage(o), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackAndDefIgnoredAndDeformAction", ["./PhysicalAttackAndDefIgnoredAction"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackAndDefIgnoredAndDeformAction = e.extend({
        _playAnimationDeferred: function(e) {
            return this.animationHelper.playAnimationForDeformAttackDeferred(e)
        },
        _onAnimationEndHook: function() {
            this.animationHelper.onDeformEndForDeformAttack()
        }
    })
}), define("scenes/battle/action/CustomParamAndInflictSaDirectionSelectiveAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamAndInflictSaDirectionSelectiveAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this;
            this.set("forceHit", !0), this.set("dependsWeaponEffect", !0);
            var r = [],
                i = [{
                    customParamArg: 1,
                    saArgs: [4],
                    saForTargeting: this.get("arg5"),
                    factor: this.get("arg6"),
                    targetRange: this.get("arg7"),
                    targetSegment: this.get("arg8"),
                    targetMethod: this.get("arg9"),
                    activeTargetMethod: this.get("activeTargetMethod")
                }, {
                    customParamArg: 10,
                    saArgs: [13],
                    saForTargeting: this.get("arg14"),
                    factor: this.get("arg15"),
                    targetRange: this.get("targetRange"),
                    targetSegment: this.get("targetSegment"),
                    targetMethod: this.get("targetMethod"),
                    activeTargetMethod: n.Conf.ACTIVE_TARGET_METHOD.BOTH_DISABLE
                }];
            _.each(i, function(e) {
                var i = {},
                    s = e.factor;
                i._customParamAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, t.executer, {
                    targetRange: e.targetRange,
                    targetSegment: e.targetSegment,
                    targetMethod: e.targetMethod,
                    statusAilmentsId: e.saForTargeting,
                    activeTargetMethod: e.activeTargetMethod,
                    activeTarget: t.get("activeTarget")
                }), i._customParam = t._makeCustomParam(e.customParamArg, s), i._statusAilments = t._makeStatusAilments(e.saArgs, s), r.push(i)
            }), this.set("customParamConfs", r)
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = [];
            _.each(this.get("customParamConfs"), function(n) {
                var r = n._customParamAbility.detectTargets(),
                    i = [];
                if (n._customParam) {
                    var s = n._customParamAbility.getActionResultWithTargetsAndParams(r, n._customParam);
                    e.helper.mergeDamageObjects(i, s.damageObjects)
                }
                if (n._statusAilments) {
                    var o = {
                            atkStatusAilments: n._statusAilments
                        },
                        u = n._customParamAbility.getActionResultWithTargetsAndParams(r, o);
                    e.helper.mergeDamageObjects(i, u.damageObjects)
                }
                t.push(i)
            });
            var n = this.helper.makeAndSetActionResult(this.executer, this, t);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(n, {
                skipDamageMotion: !0
            }).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        },
        _makeCustomParam: function(e, n) {
            var r = this.get(t("arg%d", e));
            if (!r) return void 0;
            var i = {};
            i[r] = n;
            var s = {
                atkStatusAilments: i,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get(t("arg%d", e + 1))
                    },
                    infoMap: {
                        duration: this.get(t("arg%d", e + 2))
                    }
                }
            };
            return s
        },
        _makeStatusAilments: function(e, n) {
            var r = this,
                i = {};
            return _.each(e, function(e) {
                var s = r.get(t("arg%d", e));
                if (!s) return void 0;
                i[s] = n
            }), _.isEmpty(i) ? void 0 : i
        }
    })
}), define("scenes/battle/action/AttachElementAsDisadvantageAndCustomParamAndInflictSaDirectionSelectiveAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.AttachElementAsDisadvantageAndCustomParamAndInflictSaDirectionSelectiveAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this;
            this.set("forceHit", !0), this.set("dependsWeaponEffect", !0);
            var r = {},
                i = this.get("arg1");
            if (i) {
                r._attachElementAsDisadvantageAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                    targetRange: this.get("arg6"),
                    targetSegment: this.get("arg7"),
                    targetMethod: this.get("arg8")
                });
                var s = this.get("arg2"),
                    o = {};
                o[i] = s, r._attachElementAsDisadvantageAbility.set("atkStatusAilments", o), r._attachElementAsDisadvantageAbility.set("statusAilmentsOptions", {
                    infoMap: {
                        attachElementId: this.get("arg3"),
                        defenseFactor: this.get("arg4"),
                        duration: this.get("arg5")
                    }
                })
            }
            var u = this.get("arg9"),
                a = this.get("arg14");
            if (u) {
                r._customParamAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                    targetRange: this.get("targetRange"),
                    targetSegment: this.get("targetSegment"),
                    targetMethod: this.get("targetMethod")
                });
                var f = this.get("arg10"),
                    l = {};
                l[u] = a, r._customParamAbility.set("atkStatusAilments", l), r._customParamAbility.set("statusAilmentsOptions", {
                    boost: this.helper.makeBoostObject(u, f),
                    infoMap: {
                        duration: this.get("arg11")
                    }
                })
            }
            var c = this.get("arg12"),
                h = this.get("arg13");
            if (c || h) {
                r._statusAilmentsAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                    targetRange: this.get("targetRange"),
                    targetSegment: this.get("targetSegment"),
                    targetMethod: this.get("targetMethod")
                });
                var p = {};
                c && (p[c] = a), h && (p[h] = a), r._statusAilmentsAbility.set("atkStatusAilments", p)
            }
            this.internalAbilities = r
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = [],
                n = this.internalAbilities,
                r = n._attachElementAsDisadvantageAbility.makeActionResult();
            t.push(r.damageObjects);
            var i = [];
            if (n._customParamAbility) {
                var s = n._customParamAbility.makeActionResult();
                this.helper.mergeDamageObjects(i, s.damageObjects)
            }
            if (n._statusAilmentsAbility) {
                var o = n._statusAilmentsAbility.makeActionResult();
                this.helper.mergeDamageObjects(i, o.damageObjects)
            }
            t.push(i);
            var u = this.helper.makeAndSetActionResult(this.executer, this, t);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(u, {
                skipDamageMotion: !0
            }).then(function() {
                e.helper.applyActionResultForBarrage(u), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/CustomParamAndInflictSaAndSelfAttachElementAction", ["./ActionBase", "sprintf"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.CustomParamAndInflictSaAndSelfAttachElementAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._inflictSaAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer), this._customParam = this._makeCustomParam(), this._statusAilmentsParam = {
                atkStatusAilments: this._makeStatusAilments()
            }, this._selfAttachElementAbility = n.AbilityFactory.create(n.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg7"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    infoMap: {
                        swapAbilityId: this.get("arg8"),
                        normalAbilityDamageFactor: this.get("arg9"),
                        soulStrikeDamageFactor: this.get("arg10"),
                        defenseFactor: this.get("arg11")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                r = [];
            if (this._customParam) {
                var i = this._inflictSaAbility.getActionResultWithTargetsAndParams(t, this._customParam);
                this.helper.mergeDamageObjects(r, i.damageObjects)
            }
            if (this._statusAilmentsParam.atkStatusAilments) {
                var s = this._inflictSaAbility.getActionResultWithTargetsAndParams(t, this._statusAilmentsParam);
                this.helper.mergeDamageObjects(r, s.damageObjects)
            }
            var o = this.helper.makeAndSetActionResult(this.executer, this, r),
                u = this._selfAttachElementAbility.makeActionResult();
            n.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(u.damageObjects), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForNormalDeferred(o, {
                skipAttackMotion: !!this.get("skipAttackMotion"),
                skipDamageMotion: !0
            }).then(function() {
                e.helper.mergeDamageObjects(o.damageObjects, u.damageObjects), e.helper.applyActionResult(o), e._isDone = !0
            })
        },
        _makeCustomParam: function() {
            var e = this.get("arg1"),
                t = this.get("arg2"),
                n = this.get("arg3"),
                r = this.get("arg6");
            if (!e) return void 0;
            var i = {};
            i[e] = r;
            var s = {
                atkStatusAilments: i,
                statusAilmentsOptions: {
                    boost: this.helper.makeBoostObject(e, t),
                    infoMap: {
                        duration: n
                    }
                }
            };
            return s
        },
        _makeStatusAilments: function() {
            var e = this,
                t = {},
                n = ["arg4", "arg5"],
                r = this.get("arg6");
            return _.each(n, function(n) {
                var i = e.get(n);
                if (!i) return void 0;
                t[i] = r
            }), _.isEmpty(t) ? void 0 : t
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndAttachElementAsDisadvantageAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndAttachElementAsDisadvantageAction = e.extend({
        initialize: function() {
            var n = this;
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("isSameTarget", !!this.get("arg5"));
            var r = {},
                i = this.get("statusAilmentsId");
            i && (r[i] = this.get("statusAilmentsFactor")), this.set("atkStatusAilments", r), this.set("statusAilmentsOptions", {
                infoMap: {
                    attachElementId: this.get("arg7"),
                    defenseFactor: this.get("arg8"),
                    duration: this.get("arg9")
                }
            });
            var s = this.get("arg11");
            s > 0 && (this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: s,
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg12")
                    },
                    infoMap: {
                        duration: this.get("arg13")
                    }
                }
            }));
            var o = this.get("arg14");
            !o || (this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer), this._inflictSaParam = {
                atkStatusAilments: this._makeStatusAilments()
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = this.get("isSameTarget"),
                s = void 0,
                o = this.helper.magicAttackMulti(),
                u = o.actionResult,
                a = this.helper.makeTargetsFromHitDamageObjects(_.flatten(u.damageObjects)),
                f = {};
            if (this._selfCustomParamAbility) {
                var l = this._selfCustomParamAbility.makeActionResult();
                this.helper.mergeDamageObjectsForBarrage(u.damageObjects, l.damageObjects), f[r + 1] = !0
            }
            this._inflictSaAbility && (s = this._inflictSaAbility.getActionResultWithTargetsAndParams(a, this._inflictSaParam), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s.damageObjects)), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(u, {
                skipDamageMotionCountMap: f
            }).then(function() {
                s && e.helper.mergeDamageObjectsForBarrage(u.damageObjects, s.damageObjects), e.helper.applyActionResultForBarrage(u), e._isDone = !0
            })
        },
        _makeStatusAilments: function() {
            var e = this,
                t = {},
                n = ["arg14"],
                r = this.get("arg15");
            return _.each(n, function(n) {
                var i = e.get(n);
                if (!i) return;
                t[i] = r
            }), t
        }
    })
}), define("scenes/battle/action/MagicAttackMultiWithMultiElementAndFractionalHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiWithMultiElementAndFractionalHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("minDamageFactor", this.get("arg2")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this._fractionalHealHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_FRACTIONAL_HEAL_HP, this.executer, {
                factor: this.get("arg10")
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.magicAttackMulti(),
                n = t.actionResult,
                r = this._fractionalHealHpAbility.getActionResult();
            this.helper.mergeDamageObjectsForBarrage(n.damageObjects, r.damageObjects), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndColleagueSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndColleagueSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("matkElement", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this.set("minDamageFactor", this.get("arg8")), this.set("skipColleagueSaAnimation", !!this.get("arg10"));
            var n = {};
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                if (!e) return;
                n[e] = 100
            }), this.set("additionalAtkStatusAilments", n), this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: t.Conf.TARGET_RANGE.ALL,
                targetSegment: t.Conf.TARGET_SEGMENT.COLLEAGUE
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [];
            for (var u = 1; u <= r; u++) {
                if (!s || !i) i = this.detectTargets();
                var a = this.helper.magicAttack(i);
                o.push(a.damageObjects)
            }
            this.helper.recalculate(o);
            var f = this.helper.calcForInflictSa(this._inflictSaAbility.detectTargets(), {
                    atkStatusAilments: this.get("additionalAtkStatusAilments"),
                    forceHit: this._inflictSaAbility.get("forceHit")
                }),
                l = this.helper.makeAndSetActionResult(n, this, o),
                c = {};
            this.get("skipColleagueSaAnimation") || (this.helper.mergeDamageObjectsForBarrage(l.damageObjects, f), c[r + 1] = !0), t.BattleInfo.getInstance().isMo() && this.get("skipColleagueSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects(f), this.changeState("WAIT_ANIM");
            var h = this.animationHelper.createAnimationForBarrage(l, {
                skipDamageMotionCountMap: c
            }).addCallbackOnce("end", function() {
                e.get("skipColleagueSaAnimation") && e.helper.mergeDamageObjectsForBarrage(l.damageObjects, f), e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("minDamageFactor", this.get("arg3")), this.set("barrageNum", this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("skipSelfSaAnimation", !!this.get("arg6")), this._selfCustomParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                statusAilmentsId: this.get("arg8"),
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg9")
                    },
                    infoMap: {
                        duration: this.get("arg10")
                    }
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.magicAttackMulti(),
                r = n.actionResult,
                i = n.isHit,
                s = void 0,
                o = {};
            if (i) {
                s = this._selfCustomParamAbility.makeActionResult();
                if (!this.get("skipSelfSaAnimation")) {
                    this.helper.mergeDamageObjectsForBarrage(r.damageObjects, s.damageObjects);
                    var u = this.get("barrageNum") || 1;
                    o[u + 1] = !0
                }
            }
            t.BattleInfo.getInstance().isMo() && i && this.get("skipSelfSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects(s.damageObjects), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(r, {
                skipDamageMotionCountMap: o
            }).then(function() {
                i && e.get("skipSelfSaAnimation") && e.helper.mergeDamageObjectsForBarrage(r.damageObjects, s.damageObjects), e.helper.applyActionResultForBarrage(r), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndColleagueSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndColleagueSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("skipColleagueSaAnimation", !!this.get("arg10"));
            var n = this.get("arg13") || 0;
            n > 0 && this.set("statusAilmentsOptions", {
                infoMap: {
                    duration: n
                }
            });
            var r = this.get("arg14");
            this.helper.setDamageCalculateParamAdjustConf(r, [this.get("arg15")]);
            var i = {};
            _.each(this.get("atkStatusAilmentIds"), function(e) {
                if (!e) return;
                i[e] = 100
            }), this.set("additionalAtkStatusAilments", i), this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: t.Conf.TARGET_RANGE.ALL,
                targetSegment: t.Conf.TARGET_SEGMENT.COLLEAGUE
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.get("barrageNum") || 1,
                r = this.helper.physicalAttackMulti(),
                i = r.actionResult,
                s = this.helper.calcForInflictSa(this._inflictSaAbility.detectTargets(), {
                    statusAilmentsOptions: this.get("statusAilmentsOptions"),
                    atkStatusAilments: this.get("additionalAtkStatusAilments"),
                    forceHit: this._inflictSaAbility.get("forceHit")
                }),
                o = {};
            this.get("skipColleagueSaAnimation") || (this.helper.mergeDamageObjectsForBarrage(i.damageObjects, s), o[n + 1] = !0), t.BattleInfo.getInstance().isMo() && e.get("skipColleagueSaAnimation") && this.moHelper.addAdditionalApplyDamageObjects(s), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(i, {
                skipDamageMotionCountMap: o
            }).then(function() {
                e.get("skipColleagueSaAnimation") && e.helper.mergeDamageObjectsForBarrage(i.damageObjects, s), e.helper.applyActionResultForBarrage(i), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiAndAttachElementAsDisadvantageWithMultiElement", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiAndAttachElementAsDisadvantageWithMultiElement = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this.set("statusAilmentsOptions", {
                infoMap: {
                    attachElementId: this.get("arg6"),
                    defenseFactor: this.get("arg7"),
                    duration: this.get("arg8")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.helper.physicalAttackMulti(),
                n = t.actionResult;
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(n).then(function() {
                e.helper.applyActionResultForBarrage(n), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/PhysicalAttackMultiWithMultiElementAndFractionalHealHpAndHealSaMultiAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackMultiWithMultiElementAndFractionalHealHpAndHealSaMultiAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("isSameTarget", !!this.get("arg5")), this._fractionalHealHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_FRACTIONAL_HEAL_HP, this.executer, {
                factor: this.get("arg10"),
                targetRange: this.get("arg11")
            }), this._healSaBundleId = this.get("arg12"), this._healSaBundleId > 0 && (this._healSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_SA, this.executer, {
                targetRange: this.get("arg13"),
                targetSegment: this.get("arg14"),
                hitRate: this.get("arg15"),
                healStatusAilmentIds: this.get("healStatusAilmentIds")
            }))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.helper.physicalAttackMulti(),
                r = n.actionResult,
                i = this._fractionalHealHpAbility.getActionResult();
            this.helper.mergeDamageObjectsForBarrage(r.damageObjects, i.damageObjects);
            var s = void 0;
            this._healSaBundleId && (s = this._healSaAbility.calcDamageObjects(), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s)), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(r).then(function() {
                s && e.helper.mergeDamageObjectsForBarrage(r.damageObjects, s), e.helper.applyActionResultForBarrage(r), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/HealHpAndSelfCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealHpAndSelfCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("matkElement", this.get("arg2")), this.set("damageFactor", this.get("arg3"));
            var t = this.get("statusAilmentsId"),
                n = this.get("arg4"),
                r = this.get("arg6");
            this.set("statusAilmentsOptions", {
                boost: this.helper.makeBoostObject(t, n, {
                    isAbsolute: r
                }),
                infoMap: {
                    duration: this.get("arg5")
                }
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = [],
                i = [];
            _.each(n, function(n) {
                var r = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL,
                    executer: e.executer,
                    target: n,
                    ability: e
                });
                i.push(r)
            }), r.push(i);
            var s = t.util.DamageCalculator.calculate({
                type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                executer: this.executer,
                target: _.first(t.util.Targeting.makeResult(this.executer)),
                ability: this,
                atkStatusAilments: this.get("atkStatusAilments"),
                statusAilmentsOptions: this.get("statusAilmentsOptions")
            });
            r.push([s]);
            var o = this.helper.makeAndSetActionResult(this.executer, this, r);
            this.changeState("WAIT_ANIM");
            var u = {};
            u[2] = !0, this.animationHelper.playAnimationForBarrageDeferred(o, {
                skipDamageMotionCountMap: u
            }).then(function() {
                e.helper.recalculateCounterEnableFlag(o.damageObjects), e.helper.applyActionResultForBarrage(o), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/FractionalHealByHpAndHealSaMultiAndCustomParamAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.FractionalHealByHpAndHealSaMultiAndCustomParamAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1"));
            var n = this.get("arg2");
            n > 0 && (this._customParamAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                statusAilmentsId: n,
                forceHit: !0,
                statusAilmentsFactor: 0,
                statusAilmentsOptions: {
                    boost: {
                        rate: this.get("arg3")
                    },
                    infoMap: {
                        duration: this.get("arg4")
                    }
                }
            }));
            var r = this.get("arg5");
            r > 0 && (this._healSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_SA, this.executer, {
                healStatusAilmentIds: this.get("healStatusAilmentIds")
            }))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.fractionalHealHp(n),
                i = void 0;
            this._customParamAbility && (i = this._customParamAbility.makeActionResult({
                targets: n
            }), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(i.damageObjects));
            var s = void 0;
            this._healSaAbility && (s = this._healSaAbility.calcDamageObjects(), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(s)), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForNormalDeferred(r).then(function() {
                i && e.helper.mergeDamageObjects(r.damageObjects, i.damageObjects), s && e.helper.mergeDamageObjects(r.damageObjects, s), e.helper.applyActionResult(r), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiAndHealHpAndInflictSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiAndHealHpAndInflictSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                minDamageFactor: this.get("arg2"),
                barrageNum: this.get("arg3"),
                isSameTarget: !!this.get("arg4")
            };
            var n = this.get("arg8");
            this._healHpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_HP, this.executer, {
                factor: this.get("arg5"),
                matkElement: this.get("arg6"),
                targetRange: n
            });
            var r = this.get("arg9"),
                i = {};
            i[r] = 0, this._inflictSaAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_INFLICT_SA, this.executer, {
                forceHit: !0,
                targetRange: n,
                targetSegment: t.Conf.TARGET_SEGMENT.COLLEAGUE
            }), this._inflictSaAbility.set("atkStatusAilments", i)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer;
            _.extend(this._attributes, this._atkParams);
            var r = this.get("barrageNum"),
                i = this.helper.magicAttackMulti(),
                s = i.actionResult,
                o = this._healHpAbility.detectTargets(),
                u = this._healHpAbility.calcDamageObjectsWithTargets(o);
            this.helper.mergeDamageObjectsForBarrage(s.damageObjects, u);
            var a = this._inflictSaAbility.makeActionResult({
                targets: o
            });
            t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects(a.damageObjects), this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(s, {}).then(function() {
                e.helper.mergeDamageObjectsForBarrage(s.damageObjects, a.damageObjects), e.helper.recalculateCounterEnableFlag(s.damageObjects), e.helper.applyActionResultForBarrage(s), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/FixedHealHpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.action.FixedHealHpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("fixedHealValue", this.get("arg1") || 0), this.get("fixedHealValue") || this.set("fixedHealValue", this.get("optionalFixedHealValue") || 0)
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.detectTargets(),
                r = this.helper.fixedHealHp(n);
            this.changeState("WAIT_ANIM");
            var i = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.NORMAL,
                action: this,
                actionResult: r
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResult(r), e._isDone = !0
            }).play()
        }
    }), FF.ns.battle.action.FixedHealHpAction
}), define("scenes/battle/action/ExecAbilityByTargetWeaknessAction", ["util", "./WrappedAbilityActionBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.action.ExecAbilityByTargetWeaknessAction = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("defaultAbilityId", this.get("arg1")), this.set("triggerableAbilityId", this.get("arg2"))
        },
        processForStateInitUpdate: function() {
            var e = this.get("defaultAbilityId"),
                r = this.moHelper.getCreateOptions();
            r.ignoresReflection = !0;
            var i = n.AbilityFactory.create(e, this.executer, r),
                s = i.detectTargets(),
                o = i.get("elementConfs"),
                u = n.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE"),
                a = _.map(o, function(e) {
                    return e.element
                });
            !i.get("atkElement") || a.push(i.get("atkElement")), !i.get("matkElement") || a.push(i.get("matkElement"));
            var f = _.any(a, function(e) {
                return _.any(s, function(t) {
                    var r = t.receiver.get("defAttributeMap");
                    return r[e] ? u[r[e]][0] === n.Conf.ADVANTAGE.WEAK : !1
                })
            }) ? this.get("triggerableAbilityId") : e;
            s.length === 1 && this.set("activeTarget", s[0].receiver), this.set("wrappedAbilityId", f), t.prototype.processForStateInitUpdate.apply(this, arguments)
        }
    })
}), define("scenes/battle/action/MagicAttackElementMultiAndSelfIncreaseMpAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackElementMultiAndSelfIncreaseMpAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this._atkParams = {
                damageFactor: this.get("arg1"),
                minDamageFactor: this.get("arg2"),
                barrageNum: this.get("arg3"),
                isSameTarget: !!this.get("arg4")
            }, this._increaseMpParams = {
                damageFactor: this.get("arg10"),
                hitRate: this.get("arg11"),
                remainNum: this.get("arg12"),
                usedNum: this.get("arg13"),
                priorityType: this.get("arg14")
            }, this._increaseMpAbility = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.INCREASE_MP, this.executer)
        },
        processForStateInitUpdate: function() {
            var e = this;
            _.extend(this._attributes, this._atkParams);
            var n = this.helper.magicAttackMulti().actionResult,
                r = this._increaseMpAbility.getActionResultWithTargetsAndParams(t.util.Targeting.makeResult(this.executer), this._increaseMpParams);
            this.helper.mergeDamageObjectsForBarrage(n.damageObjects, r.damageObjects);
            var i = this.helper.makeAndSetActionResult(this.executer, this, n.damageObjects);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(i).then(function() {
                e.helper.applyActionResultForBarrage(i), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/HealSaMultiDirectionSelectiveAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.HealSaMultiDirectionSelectiveAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("hitRate", this.get("arg2"));
            var n = this.get("arg3"),
                r = FF.ns.battle.StatusAilmentsConfig.getBundle(n);
            this._healSaAbilityB = t.AbilityFactory.create(t.Conf.ABILITY_ID_OF.BUILTIN_HEAL_SA, this.executer, {
                targetRange: this.get("arg4"),
                targetSegment: this.get("arg5"),
                hitRate: this.get("arg6"),
                healStatusAilmentIds: r
            })
        },
        processForStateInitUpdate: function() {
            var e = this,
                t = this.detectTargets(),
                n = this.helper.calcForHealSa(t),
                r = this._healSaAbilityB.calcDamageObjects(),
                i = [n, r],
                s = this.helper.makeAndSetActionResult(this.executer, this, i);
            this.changeState("WAIT_ANIM"), this.animationHelper.playAnimationForBarrageDeferred(s, {
                skipDamageMotion: !0
            }).then(function() {
                e.helper.applyActionResultForBarrage(s), e._isDone = !0
            })
        }
    })
}), define("scenes/battle/action/MagicAttackMultiWithHealSaAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.MagicAttackMultiWithHealSaAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("damageFactor", this.get("arg1")), this.set("minDamageFactor", this.get("arg2")), this.set("barrageNum", this.get("arg3")), this.set("isSameTarget", !!this.get("arg4")), this.set("hitRate", this.get("arg7"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = [],
                u;
            for (var a = 1; a <= r; a++) {
                if (!s || !i) i = this.detectTargets();
                var f = this.helper.magicAttack(i);
                u || (u = e.helper.includesHitDamageObject(f.damageObjects)), o.push(f.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(o);
            var l = this.helper.makeAndSetActionResult(n, this, o),
                c = this.get("healStatusAilmentIds"),
                h = this.get("hitRate"),
                p = _.intersection(c, n.statusAilments.getRefs()),
                d = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.HEAL_SA,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    statusAilmentsIds: p,
                    hitRate: h
                });
            this.changeState("WAIT_ANIM"), t.BattleInfo.getInstance().isMo() && this.moHelper.addAdditionalApplyDamageObjects([d]);
            var v = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: l
            }).addCallbackOnce("end", function() {
                l.damageObjects.push([d]), e.helper.applyActionResultForBarrage(l), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/ai/AiUtil", ["util"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.AiUtil = {
        setDebugTextMapFunc: function(e, t) {},
        getContainer: function(e) {
            return e.isContainer() ? e : e.container
        },
        getActors: function(e, t) {
            var n = [];
            if (t) {
                var r = this.getContainer(e);
                _.each(t, function(e) {
                    n.push(r.getChild(e))
                })
            } else {
                if (!!e.isContainer()) throw new Error("actor is not specified");
                n.push(e)
            }
            return n
        },
        getActorsByUid: function(e, n) {
            var r = [];
            if (n) _.each(n, function(e) {
                r.push(t.ActorMgr.getByUid(e))
            });
            else {
                if (!!e.isContainer()) throw new Error("actor is not specified");
                r.push(e)
            }
            return r
        },
        getActor: function(e, t) {
            if (t) {
                var n = this.getContainer(e);
                return n.getChild(t)
            }
            if (!e.isContainer()) return e;
            throw new Error("actor is not specified")
        },
        retrieveParamIdFromConf: function(e, t) {
            return t.paramSuffixNo ? e.getParamIdBySuffixNo(t.paramSuffixNo) : t.paramId
        },
        retrieveMessageIdFromConf: function(e, t) {
            return t.messageSuffixNo ? e.getMessageIdBySuffixNo(t.messageSuffixNo) : t.messageId
        },
        retrieveHpRateFromConf: function(e, t) {
            return t.hpRateAiArg ? e.container.aiArg.getNumber(t.hpRateAiArg) : t.hpRate
        },
        getAbilityTagById: function(e, t, n) {
            if (_.isArray(t)) return _.map(t, function(e) {
                return this.getAbilityTagById(e, n)
            }, this);
            var r = _.filter(n, function(n) {
                return e.getAbilityIdByTag(n) === t
            });
            if (r.length === 0) throw new Error("invalid id [" + t + "]");
            if (r.length !== 1) throw new Error("some tags are found. id [" + t + "] tags [" + r.join(",") + "]");
            return r[0]
        },
        getEventNameOfApplyDamageObject: function(e) {
            var t = void 0;
            switch (e) {
                case "SET_SA":
                    t = "ActorBase::addStatusAilments";
                    break;
                case "UNSET_SA":
                    t = "ActorBase::unsetStatusAilments";
                    break;
                case "ANY":
                    t = "ActorBase::applyDamageObject";
                    break;
                default:
                    t = "ActorBase::addDamage"
            }
            return t
        },
        getEventNameOfBoost: function() {
            return "ActorBase::setBoost"
        },
        checkConditionForDamageObject: function(e, n, r) {
            var i = r.ability;
            if (e.counter && !t.util.DamageCalculator.isEnableCounter(r)) return !1;
            var s = !0;
            e.canHit && (r.canHit || (s = !1)), e.elements && (_.any(e.elements, function(e) {
                return e === r.element
            }) || (s = !1)), e.exercises && (_.any(e.exercises, function(e) {
                return !!i && e === i.get("exerciseType")
            }) || (s = !1)), t.util.DamageCalculator.isCalcTypeRadiantShield(r.type) && (s = !1);
            if (e.damagedOnly)
                if (e.ignorePoison === !0 && t.util.DamageCalculator.isCalcTypePoison(r.type)) s = !1;
                else if (_.isNumber(r.damage)) {
                var o = e.damagedOnlyOptions || {},
                    u = !1;
                _.isNumber(o.under) ? u = r.damage < o.under : _.isNumber(o.underOrEqual) ? u = r.damage <= o.underOrEqual : _.isNumber(o.over) ? u = r.damage > o.over : _.isNumber(o.overOrEqual) ? u = r.damage >= o.overOrEqual : u = r.damage > 0, u || (s = !1)
            } else s = !1;
            return s
        },
        checkConditionForDiffValue: function(e) {
            var t = e.under || e.underOrEqual || e.over || e.overOrEqual || 0;
            if (t === 0) throw new Error("invalid arguments");
            var n = e.baseValue + t,
                r = e.currValue,
                i = !1;
            return e.under ? i = r < n : e.underOrEqual ? i = r <= n : e.over ? i = r > n : e.overOrEqual && (i = r >= n), i
        },
        isBuiltinAbility: function(e) {
            return FF.ns.battle.AbilityInfoMgr.getInstance().isBuiltinAbility(e)
        },
        getAbilityIdFromConf: function(e, t) {
            return t.abilityId ? t.abilityId : e.getAbilityIdByTag(t.abilityTag)
        },
        existsShouldResetAbilityConf: function(e, t) {
            return t = _.isArray(t) ? t : [t], _.any(t, function(t) {
                var n = this.getAbilityIdFromConf(e, t);
                return !this.isBuiltinAbility(n)
            }, this)
        },
        isThereEnableAbilityTarget: function(e, n) {
            var r = this.getAbilityIdFromConf(e, n),
                i = n.abilityOptions || {};
            return t.util.EnemyTargeting.isThereEnableAbilityTarget(e, r, {
                forceIgnoresReflection: !1,
                forceTargets: i.forceTargets,
                activeTarget: i.activeTarget
            })
        },
        isThereEnableAbilityTargetWithCondReflection: function(e, n) {
            var r = this.getAbilityIdFromConf(e, n),
                i = n.abilityOptions || {};
            return t.util.EnemyTargeting.isThereEnableAbilityTargetWithCondReflection(e, r, {
                forceIgnoresReflection: !1,
                forceTargets: i.forceTargets,
                activeTarget: i.activeTarget
            })
        },
        checkTurnForceAbilityConf: function(t, n) {
            n = e.option({
                turn: void 0,
                intervalTurn: 0
            }, n);
            if (t < n.turn) return !1;
            if (t === n.turn) return !0;
            if (n.intervalTurn === 0) return !1;
            var r = (t - n.turn) % n.intervalTurn;
            return r !== 0 ? !1 : !0
        },
        existsRegisteredInterruptAbility: function(e) {
            return e || (e = {
                upperEqualBoss: !0
            }), t.AbilityMgr.getInstance().existsRegisteredInterruptAbility(e)
        },
        retrieveMainAbilityId: function(e) {
            return e.get("castTimeAbilityId") || e.get("abilityId")
        },
        registerDummyAbiityWithCastTime: function(e, n) {
            var r = t.AbilityInfoMgr.getInstance(),
                i = r.getById(n);
            e.registerAbility(t.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY, {
                castTime: i.options.castTime,
                castTimeAbilityId: n
            })
        },
        registerMultipleAbiityWithCastTime: function(e, n, r) {
            var i = t.AbilityInfoMgr.getInstance(),
                s = i.getById(n);
            e.registerAbility(t.Conf.ABILITY_ID_OF.BUILTIN_ENEMY_MULTIPLE_ABILITY, {
                castTime: s.options.castTime,
                castTimeAbilityId: n,
                multipleAbilitySettings: r
            })
        },
        lotByIntroMessageConf: function(t) {
            var n = !0;
            return n && !_.isUndefined(t.rate) && (n = e.lotByFraction(t.rate)), n
        },
        lotByIntroMessageConfWithAiArg: function(t, n) {
            var r = !0,
                i = n.rate;
            if (_.isUndefined(i) && !_.isUndefined(n.rateAiArg)) {
                var s = t.container.aiArg;
                i = s.getNumber(n.rateAiArg)
            }
            return r && !_.isUndefined(i) && (r = e.lotByFraction(i)), r
        },
        findIntroMessageConfByAbilityConf: function(e, t, n) {
            var r = this.getAbilityIdFromConf(e, n);
            return _.find(t, function(t) {
                var n = this.getAbilityIdFromConf(e, t);
                return n === r
            }, this)
        },
        registerAbilityWithIntroMessageByConf: function(e, n, r) {
            var i = [];
            if (!!n && this.lotByIntroMessageConfWithAiArg(e, n)) {
                var s = this.retrieveMessageIdFromConf(e, n);
                i.push({
                    abilityId: t.Conf.ABILITY_ID_OF.DEFORM_MULTI,
                    abilityOptions: {
                        sequence: [
                            [{
                                messageId: s
                            }]
                        ]
                    }
                })
            }
            i.push(r);
            var o = this.getAbilityIdFromConf(e, r);
            this.registerMultipleAbiityWithCastTime(e, o, i)
        },
        registerAbilityWithIntroMessageByConfs: function(e, t, n) {
            var r = this.findIntroMessageConfByAbilityConf(e, t, n);
            this.registerAbilityWithIntroMessageByConf(e, r, n)
        },
        withoutAndLotAndRegisterAbilityWithIntroMessage: function(e, n) {
            var r = e.getWithoutAbilityList({
                    forceIgnoresReflection: !1
                }),
                i = e.lotAbilityWithout(r),
                s = {
                    abilityId: i
                };
            t.ai.AiUtil.registerAbilityWithIntroMessageByConfs(e, n, s)
        },
        getElapsedBattleTime: function() {
            return Math.floor(FF.scene.elapsedBattleTime)
        },
        getBpIdxWithHpRate: function(e, t, n) {
            var r = n || 0;
            for (var i = r + 1; i < e.length; i++) {
                var s = e[i];
                if (s.hpRate < t) break;
                r = i
            }
            return r
        },
        getBpIdxWithHpRateWithActor: function(e, t, n, r) {
            var i = r || 0;
            for (var s = i + 1; s < t.length; s++) {
                var o = t[s],
                    u = this.retrieveHpRateFromConf(e, o);
                if (u < n) break;
                i = s
            }
            return i
        },
        makeCounterCondition: function(e) {
            return {
                "class": "DamageTransitCondition",
                args: _.extend({
                    scope: "ANY",
                    counter: !0
                }, e)
            }
        },
        makeAbilityOptionsForSubEffect: function(e) {
            return _.extend({
                skipMessage: !0,
                skipAttackMotion: !0,
                skipStepCnt: !0
            }, e)
        },
        getIgnoresReflectionByAbilityId: function(e, n) {
            var r = t.AbilityInfoMgr.getInstance(),
                i = r.getById(n);
            return t.util.Targeting.getIgnoresReflectionByAbilityInfo(i, e, {
                ignoresReflection: r.getIgnoresReflection(n)
            })
        },
        builtinSetSa: function(n, r) {
            var i = e.option({
                    sa: void 0,
                    saChildNos: void 0,
                    saOptions: void 0
                }, r),
                s = t.ai.AiUtil.getActors(n, i.saChildNos);
            _.each(s, function(e) {
                e.setStatusAilments(i.sa, i.saOptions)
            })
        },
        builtinUnsetSa: function(n, r) {
            var i = e.option({
                    sa: void 0,
                    saChildNos: void 0,
                    saChildUids: void 0
                }, r),
                s = [];
            i.saChildUids ? s = t.ai.AiUtil.getActorsByUid(n, i.saChildUids) : s = t.ai.AiUtil.getActors(n, i.saChildNos), _.each(s, function(e) {
                e.unsetStatusAilments(i.sa)
            })
        },
        builtinUnsetAllSa: function(n, r) {
            var i = e.option({
                    saChildNos: void 0
                }, r),
                s = t.ai.AiUtil.getActors(n, i.saChildNos);
            s = _.filter(s, function(e) {
                return e.isAlive()
            }), _.each(s, function(e) {
                var t = e.statusAilments.cloneIds();
                e.unsetStatusAilments(t)
            })
        },
        builtinEnable: function(t, n) {
            var r = e.option({
                    visibleNo: void 0
                }, n.visible),
                i = t,
                s = {};
            _.each(r.visibleNo, function(e) {
                s[e] = !0
            }), _.each(i.getNos(), function(e) {
                var t = i.getChild(e);
                t.setEnable(!!s[e])
            })
        },
        builtinRecover: function(n, r) {
            var i = e.option({
                    recoverNo: void 0,
                    rate: void 0
                }, r.recover),
                s = t.ai.AiUtil.getActors(n, i.recoverNo);
            _.each(s, function(e) {
                var t = e.get("maxHp");
                i.rate > 0 && (t = Math.ceil(t * (i.rate / 100))), e.set("hp", t), e.rise()
            })
        },
        builtinClearTarget: function(n, r) {
            var i = e.option({
                    ctChildNos: void 0
                }, r),
                s = t.ActorMgr.getActiveTarget();
            if (!s) return;
            var o = t.ai.AiUtil.getActors(n, i.ctChildNos);
            _.any(o, function(e) {
                if (s.equals(e)) return t.ActorMgr.clearActiveTarget(), !0
            })
        },
        builtinCancelInterruptAbility: function(n, r) {
            var i = e.option({
                    cancelIAChildNos: void 0
                }, r),
                s = t.ai.AiUtil.getActors(n, i.cancelIAChildNos);
            _.any(s, function(e) {
                e.cancelInterruptAbility()
            })
        },
        builtinDiffEnable: function(n, r) {
            var i = e.option({
                addEnableChildNos: void 0,
                reduceEnableChildNos: void 0
            }, r);
            if (i.addEnableChildNos) {
                var s = t.ai.AiUtil.getActors(n, i.addEnableChildNos);
                _.each(s, function(e) {
                    e.setEnable(!0)
                })
            }
            if (i.reduceEnableChildNos) {
                var o = t.ai.AiUtil.getActors(n, i.reduceEnableChildNos);
                _.each(o, function(e) {
                    e.setEnable(!1)
                })
            }
        },
        builtinChangeParam: function(n, r) {
            var i = e.option({
                    id: void 0,
                    paramId: void 0,
                    paramSuffixNo: void 0
                }, r),
                s = t.ai.AiUtil.getActor(n, i.id),
                o = t.ai.AiUtil.retrieveParamIdFromConf(s, i);
            s.changeBaseParam(o)
        },
        builtinReset: function(n, r) {
            var i = e.option({
                    resetChildNos: void 0
                }, r),
                s = t.ai.AiUtil.getActors(n, i.resetChildNos);
            _.each(s, function(e) {
                e.isAlive() && e.reset()
            })
        },
        builtinResetCastAbility: function(n, r) {
            var i = e.option({
                    resetCAChildNos: void 0
                }, r),
                s = t.ai.AiUtil.getActors(n, i.resetCAChildNos);
            _.each(s, function(e) {
                e.isAlive() && e.resetCastAbility()
            })
        },
        builtinShuffleAtb: function(t, n) {
            var r = e.option({
                    shuffleChildNos: void 0
                }, n),
                i = t.isContainer() ? t : t.container;
            _.each(r.shuffleChildNos, function(t) {
                var n = i.getChild(t),
                    r = e.randomInt(n.getAtbTime() - 1);
                n.set("elapsedAtbTime", r)
            })
        },
        builtinSetOtionalCounterCheckType: function(t, n) {
            var r = e.option({
                optionalCounterCheckType: void 0
            }, n);
            if (_.isNumber(r.optionalCounterCheckType)) {
                if (t.isContainer()) throw new Error("in enemy container, argument type must be object.");
                t.setOptionalCounterCheckType(r.optionalCounterCheckType)
            } else {
                if (!_.isObject(r.optionalCounterCheckType)) throw new Error("argument type must be number or object.");
                var i = this.getContainer(t);
                _.each(r.optionalCounterCheckType, function(e, t) {
                    var n = i.getChild(t);
                    if (!n) throw new Error("undefined actorNo. NO:" + t);
                    n.setOptionalCounterCheckType(e)
                })
            }
        },
        builtinDieForcibly: function(n, r) {
            var i = e.option({
                    dieNos: void 0,
                    isInvisibleDeath: !1
                }, r),
                s = t.ai.AiUtil.getActors(n, i.dieNos);
            _.each(s, function(e) {
                e.dieForcibly({
                    isInvisibleDeath: i.isInvisibleDeath
                })
            })
        },
        makeSequenceForRevive: function(t) {
            t = e.option({
                nos: void 0,
                deformTag: void 0,
                skipEnemyName: !1,
                forceShowNamePosArray: void 0,
                shouldDeformAllNodes: !1,
                filteringDeformPosArray: void 0,
                shouldReset: !1
            }, t);
            var n = [
                [{
                    builtin: "DIFF_ENABLE",
                    addEnableChildNos: t.nos
                }],
                [{
                    builtin: "UNSET_ALL_SA",
                    saChildNos: t.nos
                }],
                [{
                    builtin: "RECOVER",
                    recover: {
                        recoverNo: t.nos
                    }
                }],
                [{
                    builtin: "WAIT",
                    waitMsec: 1
                }],
                [{
                    deformTag: t.deformTag,
                    filteringDeformPosArray: t.filteringDeformPosArray || t.nos,
                    skipEnemyName: t.skipEnemyName,
                    forceShowNamePosArray: t.forceShowNamePosArray,
                    shouldDeformAllNodes: t.shouldDeformAllNodes
                }]
            ];
            return t.shouldReset && (n = n.concat([
                [{
                    builtin: "RESET",
                    resetChildNos: t.nos
                }]
            ])), n
        },
        makeSequenceForDisableDead: function(t) {
            return t = e.option({
                nos: void 0,
                deformTag: void 0,
                filteringDeformPosArray: void 0
            }, t), [
                [{
                    builtin: "DIE_FORCIBLY",
                    dieNos: t.nos
                }],
                [{
                    deformTag: t.deformTag,
                    filteringDeformPosArray: t.filteringDeformPosArray || t.nos
                }]
            ]
        },
        makeSequenceForInvisibleDead: function(n) {
            n = e.option({
                nos: void 0,
                deformTag: void 0,
                shouldDeath: !0,
                skipMainNodeDeform: !1
            }, n);
            var r = [
                [{
                    builtin: "DIE_FORCIBLY",
                    dieNos: n.nos,
                    isInvisibleDeath: !0
                }],
                [{
                    builtin: "WAIT",
                    waitMsec: 1
                }],
                [{
                    deformTag: n.deformTag,
                    filteringDeformPosArray: n.nos,
                    skipMainNodeDeform: n.skipMainNodeDeform
                }],
                [{
                    builtin: "RECOVER",
                    recover: {
                        recoverNo: n.nos
                    }
                }]
            ];
            return n.shouldDeath && (r = r.concat([
                [{
                    builtin: "SET_SA",
                    sa: [t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH],
                    saChildNos: n.nos
                }]
            ])), r
        },
        makeSequenceForBeforeDyingAbility: function(n) {
            return n = e.option({
                childNos: void 0
            }, n), [
                [{
                    builtin: "SET_SA",
                    sa: t.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE,
                    saChildNos: n.childNos
                }],
                [{
                    builtin: "CANCEL_INTERRUPT_ABILITY",
                    cancelIAChildNos: n.childNos
                }],
                [{
                    builtin: "WAIT",
                    waitMsec: 1
                }]
            ]
        },
        makeConditionFlagHashForTurn: function(e, t) {
            return {
                conditionFlagTag: e,
                condition: {
                    "class": "TurnTransitCondition",
                    args: {
                        id: t,
                        turn: 1
                    }
                }
            }
        }
    }
}), define("scenes/battle/ai/AiArgument", ["util", "lib/EventBase"], function(e, t) {
    var n = FF.ns.battle,
        r = function(e) {
            return +e
        },
        i = function(e) {
            return e.length === 0 ? [] : _.map(e.split(","), function(e) {
                return +e
            })
        },
        s = function(e) {
            return e
        },
        o = function(e) {
            return e.length === 0 ? [] : e.split(",")
        },
        u = {};
    u[n.Conf.AI_ARG_TYPE.NUMBER] = r, u[n.Conf.AI_ARG_TYPE.NUMBER_LIST] = i, u[n.Conf.AI_ARG_TYPE.STRING] = s, u[n.Conf.AI_ARG_TYPE.STRING_LIST] = o, u[n.Conf.AI_ARG_TYPE.MESSAGE_ID] = r, u[n.Conf.AI_ARG_TYPE.MESSAGE_ID_LIST] = i, u[n.Conf.AI_ARG_TYPE.ABILITY_TAG] = s, u[n.Conf.AI_ARG_TYPE.ABILITY_TAG_LIST] = o;
    var a = function(e) {
        var t = {};
        return _.each(e, function(e) {
            var n = e.tag,
                r = e.argType,
                i = e.argValue;
            t[n] = {
                argType: r,
                argValue: u[r](i)
            }
        }, this), t
    };
    FF.ns.battle.ai.AiArgument = t.extend({
        initialize: function(e) {
            t.prototype.initialize.apply(this, arguments), this._attributes = a(e)
        },
        getNumber: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.NUMBER)
        },
        getNumberList: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.NUMBER_LIST)
        },
        getString: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.STRING)
        },
        getStringList: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.STRING_LIST)
        },
        getMessageId: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.MESSAGE_ID)
        },
        getMessageIdList: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.MESSAGE_ID_LIST)
        },
        getAbilityTag: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.ABILITY_TAG)
        },
        getAbilityTagList: function(e) {
            return this._checkAndGetData(e, n.Conf.AI_ARG_TYPE.ABILITY_TAG_LIST)
        },
        _checkAndGetData: function(t, n) {
            var r = this.get(t);
            if (r.argType !== n) throw new Error("unexpected argType");
            return _.isArray(r.argValue) ? e.cloneDeep(r.argValue) : r.argValue
        }
    })
}), define("scenes/battle/ai/Constraint", ["util", "lib/EventBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.ENEMY_CONSTRAINT_TYPE,
        i = n.Conf.ENEMY_CONSTRAINT_FORCE_OPTIONS,
        s = {
            currTurn: 1,
            abilityMap: {}
        },
        o = {
            lastExecTurn: 0,
            usedCnt: 0
        },
        u = {},
        a = function(t) {
            return t = _.sortBy(e.cloneDeep(t), function(e) {
                return e.priority
            }), _.each(t, function(e) {
                var t = u[e.constraintType];
                e.constraintValue = t.convertData(e.constraintValue), 0 < e.options.length ? e.options = e.options.split(",") : e.options = []
            }), t
        },
        f = function(e) {
            return !e.enemyStatusId
        },
        l = function(e) {
            return _.contains(e.options, i.STRICT)
        },
        c = function(e) {
            var t = u[e.constraintType];
            return t.judgeForcelyMap ? l(e) ? t.judgeForcelyMap.strict : t.judgeForcelyMap.normal : void 0
        },
        h = function(e) {
            var t = u[e.constraintType];
            return t.judgeWithoutlyMap ? t.judgeWithoutlyMap.normal : void 0
        },
        p = function(e) {
            return +e
        },
        d = function(e) {
            return String(e)
        },
        v = {
            normal: function(e, t, n, r) {
                throw new Error("override plz.")
            },
            strict: function(e, t, n, r) {
                throw new Error("override plz.")
            }
        },
        m = _.extend({}, v, {
            normal: function(e, t, n, r) {
                return n.currTurn < t.constraintValue ? !1 : r.lastExecTurn < t.constraintValue
            },
            strict: function(e, t, n, r) {
                return n.currTurn === t.constraintValue
            }
        }),
        g = _.extend({}, v, {
            normal: function(e, t, n, r) {
                if (!r.lastExecTurn) return !1;
                var i = n.currTurn - r.lastExecTurn;
                return t.constraintValue <= i
            },
            strict: function(e, t, n, r) {
                if (!r.lastExecTurn) return !1;
                var i = n.currTurn - r.lastExecTurn;
                return t.constraintValue === i
            }
        }),
        y = _.extend({}, v, {
            normal: function(e, t, n, r) {
                var i = e.parent.getAbilityIdByTag(t.constraintValue),
                    s = n.abilityMap[i] || o;
                return s.lastExecTurn ? r.lastExecTurn < s.lastExecTurn : !1
            },
            strict: function(e, t, n, r) {
                var i = e.parent.getAbilityIdByTag(t.constraintValue),
                    s = n.abilityMap[i] || o;
                return s.lastExecTurn ? n.currTurn - s.lastExecTurn === 1 : !1
            }
        }),
        b = _.extend({}, v, {
            normal: function(e, t, n, r) {
                return r.lastExecTurn ? !1 : t.constraintValue <= n.currTurn
            },
            strict: function(e, t, n, r) {
                return r.lastExecTurn ? !1 : t.constraintValue === n.currTurn
            }
        }),
        w = _.extend({}, v, {
            normal: function(e, t, n, r) {
                var i = e.parent.getRemainingHpRate();
                return r.lastExecTurn ? !1 : i <= t.constraintValue
            },
            strict: function(e, t, n, r) {
                var i = e.parent.getRemainingHpRate();
                return r.lastExecTurn ? !1 : i === t.constraintValue
            }
        });
    u[r.FORCE_BY_TURN] = {
        convertData: p,
        judgeForcelyMap: m
    }, u[r.FORCE_BY_INTERVAL_TURN] = {
        convertData: p,
        judgeForcelyMap: g
    }, u[r.FORCE_BY_PREV_ABILITY] = {
        convertData: d,
        judgeForcelyMap: y
    }, u[r.FORCE_BY_TURN_WITH_NOT_USED] = {
        convertData: p,
        judgeForcelyMap: b
    }, u[r.FORCE_BY_HP_RATE_WITH_NOT_USED] = {
        convertData: p,
        judgeForcelyMap: w
    };
    var E = {
            normal: function(e, t, n, r) {
                throw new Error("override plz.")
            }
        },
        S = _.extend({}, E, {
            normal: function(e, t, n, r) {
                return n.currTurn < t.constraintValue
            }
        }),
        x = _.extend({}, E, {
            normal: function(e, t, n, r) {
                if (!r.lastExecTurn) return !1;
                var i = n.currTurn - r.lastExecTurn;
                return i < t.constraintValue
            }
        }),
        T = _.extend({}, E, {
            normal: function(e, t, n, r) {
                return t.constraintValue <= r.usedCnt
            }
        }),
        N = _.extend({}, E, {
            normal: function(e, t, n, r) {
                var i = e.parent.getRemainingHpRate();
                return t.constraintValue <= i
            }
        }),
        C = _.extend({}, E, {
            normal: function(e, t, n, r) {
                var i = e.parent.getRemainingHpRate();
                return i <= t.constraintValue
            }
        });
    u[r.WITHOUT_BY_UNLOCK_TURN] = {
        convertData: p,
        judgeWithoutlyMap: S
    }, u[r.WITHOUT_BY_INTERVAL_TURN] = {
        convertData: p,
        judgeWithoutlyMap: x
    }, u[r.WITHOUT_BY_USED_CNT] = {
        convertData: p,
        judgeWithoutlyMap: T
    }, u[r.WITHOUT_BY_HP_RATE_UPPER] = {
        convertData: p,
        judgeWithoutlyMap: N
    }, u[r.WITHOUT_BY_HP_RATE_LOWER] = {
        convertData: p,
        judgeWithoutlyMap: C
    };
    var k = "totalParamAttributes",
        L = "currParamAttributes",
        A = [k, L];
    FF.ns.battle.ai.Constraint = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.apply(this, arguments), this.parent = e, this.set("confs", a(n)), this.resetAllParamAttributes(), this.listenTo(e, "ActorBase::changeBaseParam", this._changeParamId), this.listenTo(e, "ActorBase::notifyAbilityBegun", this._notifyAbilityBegun)
        },
        _changeParamId: function(e, t) {
            if (e === t) return;
            this.resetCurrParamAttributes()
        },
        _notifyAbilityBegun: function(e, t) {
            var n = t.get("abilityId");
            if (t.get("skipStepCnt")) return;
            this.stepTurn(n)
        },
        resetCurrParamAttributes: function() {
            this.set(L, e.cloneDeep(s))
        },
        resetAllParamAttributes: function() {
            _.each(A, function(t) {
                this.set(t, e.cloneDeep(s))
            }, this)
        },
        stepTurn: function(t) {
            _.each(A, function(n) {
                var r = this.get(n);
                r.abilityMap[t] || (r.abilityMap[t] = e.cloneDeep(o)), r.abilityMap[t].lastExecTurn = r.currTurn, r.abilityMap[t].usedCnt++, r.currTurn++
            }, this)
        },
        stepTurnByDummy: function() {
            this.stepTurn(n.Conf.ACTION_ID_OF.DO_NOTHING_STRICTLY_STEP)
        },
        getForceAbilityId: function() {
            var e = this._getCurrFilteredConfs(),
                t = _.find(e, function(e) {
                    var t = c(e);
                    if (!_.isFunction(t)) return !1;
                    var r = this._detectParamAttributesByConf(e),
                        s = this.parent.getAbilityIdByTag(e.abilityTag),
                        u = r.abilityMap[s] || o;
                    if (!t(this, e, r, u)) return !1;
                    if (_.contains(e.options, i.REFLECTION)) {
                        var a = n.ai.AiUtil.isThereEnableAbilityTargetWithCondReflection(this.parent, {
                            abilityTag: e.abilityTag
                        });
                        if (!a) return !1
                    }
                    if (_.contains(e.options, i.SMART)) {
                        var f = n.ai.AiUtil.isThereEnableAbilityTarget(this.parent, {
                            abilityTag: e.abilityTag
                        });
                        if (!f) return !1
                    }
                    return !0
                }, this);
            return t ? this.parent.getAbilityIdByTag(t.abilityTag) : void 0
        },
        getWithoutAbilityIdList: function() {
            var e = this._getCurrFilteredConfs(),
                t = _.filter(e, function(e) {
                    var t = h(e);
                    if (!_.isFunction(t)) return !1;
                    var n = this._detectParamAttributesByConf(e),
                        r = this.parent.getAbilityIdByTag(e.abilityTag),
                        i = n.abilityMap[r] || o;
                    return t(this, e, n, i)
                }, this),
                n = _.map(t, function(e) {
                    return this.parent.getAbilityIdByTag(e.abilityTag)
                }, this);
            return _.uniq(n)
        },
        _getCurrFilteredConfs: function() {
            var e = this.parent.get("paramId");
            return _.filter(this.get("confs"), function(t) {
                return f(t) ? !0 : e === t.enemyStatusId
            })
        },
        _detectParamAttributesByConf: function(e) {
            return e.enemyStatusId ? this.get(L) : this.get(k)
        }
    })
}), define("scenes/battle/action/PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction", ["./ActionBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.action.PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.set("dependsWeaponEffect", !0), this.set("damageFactor", this.get("arg1")), this.set("barrageNum", this.get("arg2")), this.set("atkType", this.get("arg3")), this.set("forceHit", !!this.get("arg4")), this.set("atkElement", this.get("arg5")), this.set("isSameTarget", !!this.get("arg6"));
            var t = this.get("arg7"),
                n = {};
            n[t] = this.get("arg8"), this.set("selfStatusAilments", n), this.set("selfStatusAilmentsOptions", {
                boost: {
                    rate: this.get("arg9")
                },
                infoMap: {
                    duration: this.get("arg10")
                }
            }), this.set("ignoresAttackHit", !!this.get("arg11"))
        },
        processForStateInitUpdate: function() {
            var e = this,
                n = this.executer,
                r = this.get("barrageNum") || 1,
                i = void 0,
                s = this.get("isSameTarget"),
                o = this.get("ignoresAttackHit"),
                u = [],
                a;
            for (var f = 1; f <= r; f++) {
                if (!s || !i) i = this.detectTargets();
                var l = this.helper.physicalAttack(i);
                a || (a = e.helper.includesHitDamageObject(l.damageObjects)), u.push(l.damageObjects)
            }
            t.util.DamageCalculator.recalculateHp(u);
            var c = [];
            if (a || o) {
                var h = t.util.DamageCalculator.calculate({
                    type: t.Conf.CALC_TYPE.STATUS_AILMENTS,
                    executer: n,
                    target: _.first(t.util.Targeting.makeResult(n)),
                    ability: this,
                    atkStatusAilments: this.get("selfStatusAilments"),
                    statusAilmentsOptions: this.get("selfStatusAilmentsOptions"),
                    forceHit: !0
                });
                c.push(h)
            }
            u.push(c);
            var p = this.helper.makeAndSetActionResult(n, this, u);
            this.changeState("WAIT_ANIM");
            var d = {};
            d[r + 1] = !0;
            var v = t.BattleViewController.getInstance().createAnimation({
                animationType: t.Conf.ANIMATION_TYPE.BARRAGE,
                action: this,
                actionResult: p,
                options: {
                    skipDamageMotionCountMap: d
                }
            }).addCallbackOnce("end", function() {
                e.helper.applyActionResultForBarrage(p), e._isDone = !0
            }).play()
        }
    })
}), define("scenes/battle/ai/StateSnippet", ["util"], function(e) {
    var t = FF.ns.battle;
    t.ai.StateSnippet = {
        CountupWithGlobalRegister: {
            TAG_NAME: "snippet_countup_turn",
            INIT_TURN: 1,
            reset: function(e, t) {
                e.parent.globalRegister[t] = this.INIT_TURN
            },
            get: function(e, t) {
                return e.parent.globalRegister[t]
            },
            add: function(e, t) {
                e.parent.globalRegister[t]++
            },
            check: function(e) {
                return e.getConditionFlagInFrame(this.TAG_NAME)
            },
            update: function(e, t) {
                e.getConditionFlagInFrame(this.TAG_NAME) && e.parent.globalRegister[t]++
            },
            getConditionFlagHash: function(e) {
                return {
                    conditionFlagTag: this.TAG_NAME,
                    condition: {
                        "class": "TurnTransitCondition",
                        args: {
                            id: e,
                            turn: 1
                        }
                    }
                }
            }
        },
        AbilityWithIntroMessage: {
            TAG_NAME: "snippet_ability_with_intro_message",
            GLOBAL_REGISTER_KEY: "snippetAbilityWithIntroMessageMaps",
            initializeGlobalRegister: function(e, n, r) {
                var i = this,
                    s = {};
                e.parent.globalRegister[this.GLOBAL_REGISTER_KEY] = s, _.each(r, function(e) {
                    var o = e.id || 0,
                        u = r.abilityId;
                    if (e.abilityTag) {
                        var a = t.ai.AiUtil.getActor(n, o);
                        u = a.getAbilityIdByTag(e.abilityTag)
                    }
                    if (!u) throw new Error("abilityId is required.");
                    if (!e.messageId) throw new Error("messageId is required.");
                    var f = e.rate;
                    e.rate === void 0 && (f = 100), s[o] || (s[o] = []), s[o].push({
                        tagName: i._getTagName(o),
                        abilityId: u,
                        abilityOptions: {},
                        messageId: e.messageId,
                        rate: f,
                        isRegisterPreAbility: !1
                    })
                })
            },
            lotAndRegisterPreAbility: function(e, n) {
                var r = this,
                    i = e.parent.globalRegister[this.GLOBAL_REGISTER_KEY];
                _.each(_.keys(i), function(i) {
                    i = Number(i);
                    var s = t.ai.AiUtil.getActor(n, i);
                    if (!s.isReadyToSelectAbility()) return;
                    var o = s.getWithoutAbilityList(),
                        u = s.lotAbilityWithout(o),
                        a = r.registerPreAbilityIfMatch(e, n, {
                            id: i,
                            abilityId: u
                        });
                    a || s.registerAbility(u)
                })
            },
            registerPreAbilityIfMatch: function(e, n, r) {
                var i = r.id || 0,
                    s = r.abilityId,
                    o = e.parent.globalRegister[this.GLOBAL_REGISTER_KEY];
                _.each(o[i], function(e) {
                    e.isRegisteredPreAbility = !1
                });
                var u = _.find(o[i], function(e) {
                    return e.abilityId === s
                });
                if (!u) return !1;
                var a = t.ai.AiUtil.getActor(n, i);
                return a.registerAbility(t.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY), u.isRegisterPreAbility = !0, u.abilityOptions = r.abilityOptions || {}, !0
            },
            registerAbilityIfPreAbilityDone: function(n, r) {
                var i = n.parent.globalRegister[this.GLOBAL_REGISTER_KEY];
                _.each(_.keys(i), function(s) {
                    s = Number(s);
                    var o = t.ai.AiUtil.getActor(r, s),
                        u = _.find(i[s], function(e) {
                            return e.isRegisterPreAbility
                        });
                    if (!u) return;
                    if (!n.getConditionFlagInFrame(u.tagName)) return;
                    e.lotByFraction(u.rate) && o.registerInterruptAbility(t.Conf.ABILITY_ID_OF.DEFORM, {
                        messageId: u.messageId
                    }), o.registerInterruptAbility(u.abilityId, u.abilityOptions), u.isRegisterPreAbility = !1
                })
            },
            getConditionFlags: function(e) {
                var t = this;
                return e ? _.map(e, function(e) {
                    return t._getConditionFlagHash(e)
                }) : [t._getConditionFlagHash()]
            },
            _getConditionFlagHash: function(e) {
                return {
                    conditionFlagTag: this._getTagName(e),
                    condition: {
                        "class": "AbilityCountTransitCondition",
                        args: {
                            id: e,
                            abilityId: t.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY,
                            whenDone: !0,
                            count: 1
                        }
                    }
                }
            },
            _getTagName: function(e) {
                return e ? this.TAG_NAME + "_" + e : this.TAG_NAME
            }
        },
        CustomInterruptMultipleAbility: {
            makeInState: function(e) {
                return function(t) {
                    var n = this._memberValues;
                    n.abilityCount = 0, n.abilitySettingMap = {}, e.apply(this, arguments), t()
                }
            },
            makeMemberValues: function(e) {
                return _.extend({
                    nextStateId: void 0,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }, e)
            },
            makeUpdateTransition: function(n) {
                return n = e.option({
                        funcForNextStateId: void 0
                    }, n),
                    function() {
                        var e = t.ai.state.InterruptMultipleAbility.prototype.updateTransition.apply(this, arguments);
                        if (e && _.isFunction(n.funcForNextStateId)) {
                            var r = n.funcForNextStateId(this);
                            if (!!r) return r
                        }
                        return e
                    }
            },
            addAbility: function(e, t) {
                var n = e._memberValues;
                n.abilitySettingMap[++n.abilityCount] = _.extend({}, t)
            },
            addDeformMulti: function(e, n, r) {
                this.addAbility(e, {
                    abilityId: t.Conf.ABILITY_ID_OF.DEFORM_MULTI,
                    abilityOptions: {
                        sequence: n
                    },
                    options: r
                })
            },
            setInterruptBeforeCounter: function(e) {
                var t = e._memberValues;
                _.each(t.abilitySettingMap, function(e) {
                    e.options = {
                        interruptBeforeCounter: !0
                    }
                })
            }
        }
    }
}), define("scenes/battle/ai/stateSnippet/HpRateTransition", [], function() {
    var e = FF.ns.battle;
    e.ai.stateSnippet.HpRateTransition = {}, e.ai.stateSnippet.HpRateTransition.helper = {
        stateIdMap: {
            STATE_INIT: 10,
            STATE_INT_HELLO: 11,
            STATE_NORMAL: 12,
            STATE_INT_CHANGE_PARAM: 22,
            STATE_INT_DEAD: 98,
            STATE_DEAD: 99
        },
        resetType: {
            NONE: 1,
            RESET: 2,
            RESET_CAST_ABILITY: 3
        },
        bpIdx: {
            BP1: 0,
            BP2: 1,
            BP3: 2,
            BP4: 3,
            BP5: 4
        },
        resetByResetType: function(e, t) {
            var n = e._executer;
            switch (t) {
                case this.resetType.NONE:
                    break;
                case this.resetType.RESET:
                    n.reset();
                    break;
                case this.resetType.RESET_CAST_ABILITY:
                    n.resetCastAbility();
                    break;
                default:
                    throw new Error(sprintf("invalid resetType [%d]", t))
            }
        },
        countupSnippet: function() {
            return e.ai.StateSnippet.CountupWithGlobalRegister
        },
        decideResetTypeByInterruptAbilityConfs: function(t, n) {
            var r = t._executer,
                i = e.ai.AiUtil.existsShouldResetAbilityConf(r, n);
            return i ? this.resetType.RESET : this.resetType.RESET_CAST_ABILITY
        },
        retrieveParamIdFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.retrieveParamIdFromConf(r, n)
        },
        retrieveHpRateFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.retrieveHpRateFromConf(r, n)
        },
        getAbilityIdFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.getAbilityIdFromConf(r, n)
        },
        isThereEnableAbilityTarget: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.isThereEnableAbilityTarget(r, n)
        },
        isThereEnableAbilityTargetWithCondReflection: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.isThereEnableAbilityTargetWithCondReflection(r, n)
        },
        getCurrBattlePhaseIdx: function(e) {
            var t = e.parent.globalRegister;
            return t.currBattlePhaseIdx
        },
        getCurrBattlePhaseConf: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs;
            return n[t.currBattlePhaseIdx]
        },
        getForceAbilityConfByTurn: function(t, n) {
            var r = this.countupSnippet().get(t, "currBattlePhaseTurn");
            return _.find(n, function(n) {
                return e.ai.AiUtil.checkTurnForceAbilityConf(r, n) ? this.isThereEnableAbilityTargetWithCondReflection(t, n) : !1
            }, this)
        },
        getInterruptAbilityConfsForHello: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf;
            return n.helloInterruptAbilityConfs
        },
        getResetTypeForHello: function(e, t) {
            return this.decideResetTypeByInterruptAbilityConfs(e, t)
        },
        getInterruptAbilityConfsForDead: function(e) {
            var t = e.globalRegister,
                n = t.conf;
            return n.deadInterruptAbilityConfs
        },
        getNextBattlePhaseIndex: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs,
                r = e._executer,
                i = r.getRemainingHpRate(),
                s = t.currBattlePhaseIdx,
                o = s;
            for (var u = o + 1; u < n.length; u++) {
                var a = n[u],
                    f = this.retrieveHpRateFromConf(e, a);
                if (f < i) break;
                o = u;
                if (a.forceStop) break
            }
            return o
        },
        shouldChangeBattlePhase: function(e) {
            var t = e.parent.globalRegister;
            if (!t.canTransit) return !1;
            var n = t.currBattlePhaseIdx,
                r = this.getNextBattlePhaseIndex(e);
            return n < r
        },
        changeBattlePhase: function(e, t) {
            var n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[t];
            n.currBattlePhaseIdx = t, this.countupSnippet().reset(e, "currBattlePhaseTurn"), n.canTransit = !0, i.forceStop && (n.canTransit = !1)
        },
        getInterruptAbilityConfsForChangeParam: function(e, t) {
            var n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[t],
                s = i.interruptAbilityConfs,
                o = [];
            return _.each(s, function(t) {
                if (!this.isThereEnableAbilityTargetWithCondReflection(e, t)) return;
                o.push(t)
            }, this), o
        },
        getResetTypeForChangeParam: function(e, t, n) {
            var r = e.parent.globalRegister,
                i = r.conf.battlePhaseConfs,
                s = i[n],
                o = this.retrieveParamIdFromConf(e, s),
                u = this.decideResetTypeByInterruptAbilityConfs(e, t);
            return !o && u === this.resetType.RESET_CAST_ABILITY && (u = this.resetType.NONE), u
        },
        multipleAttack: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[n.currBattlePhaseIdx],
                s = t.getWithoutAbilityList({
                    forceIgnoresReflection: !1
                });
            _.times(i.multipleAttackCnt - 1, function() {
                var e = t.lotAbilityWithout(s);
                t.registerInterruptAbility(e)
            })
        },
        updateEveryFrame: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister;
            this.countupSnippet().update(e, "totalBattlePhaseTurn"), this.countupSnippet().update(e, "currBattlePhaseTurn"), this.updateCanTransit(e)
        },
        updateCanTransit: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister;
            n.canTransit || t.isReadyToSelectAbility() && (n.canTransit = !0)
        },
        getForceAbilityConf: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs,
                r = n[t.currBattlePhaseIdx];
            return this.getForceAbilityConfByTurn(e, r.turnForceAbilityConfs)
        },
        getAbilityWithoutListForLot: function(e) {
            var t = e._executer;
            return t.getWithoutAbilityList({
                forceIgnoresReflection: !1
            })
        },
        retrieveRegisterAbilityConf: function(e) {
            var t = e._executer,
                n = this.getForceAbilityConf(e);
            if (!n) {
                var r = this.getAbilityWithoutListForLot(e),
                    i = t.lotAbilityWithout(r);
                return {
                    abilityId: i,
                    abilityOptions: {}
                }
            }
            return n
        },
        registerAbility: function(e) {
            var t = e._executer,
                n = this.retrieveRegisterAbilityConf(e),
                r = this.getAbilityIdFromConf(e, n);
            t.registerAbility(r, n.abilityOptions)
        },
        updateTurnByInterruptAbility: function(e) {
            var t = e._executer;
            t.reset(), this.countupSnippet().add(e, "totalBattlePhaseTurn"), this.countupSnippet().add(e, "currBattlePhaseTurn")
        }
    };
    var t = {
            battlePhaseConfs: void 0,
            helper: {},
            initMemberValues: {},
            initGlobalRegister: {},
            helloInterruptAbilityConfs: [],
            deadInterruptAbilityConfs: [],
            abilityDeformMapTag: {}
        },
        n = {
            hpRate: void 0,
            hpRateAiArg: void 0,
            paramId: void 0,
            paramSuffixNo: void 0,
            forceStop: !1,
            multipleAttackCnt: 1,
            interruptAbilityConfs: [],
            turnForceAbilityConfs: []
        },
        r = {
            turn: void 0,
            abilityId: void 0,
            abilityTag: void 0,
            abilityOptions: {},
            intervalTurn: 0
        };
    e.ai.stateSnippet.HpRateTransition.makeJson = function(i) {
        var s = _.extend({}, t, i);
        s.helper = _.extend({}, this.helper, i.helper), s.battlePhaseConfs = _.map(i.battlePhaseConfs, function(e) {
            var t = _.map(e.turnForceAbilityConfs, function(e) {
                return _.extend({}, r, e)
            });
            return _.extend({}, n, e, {
                turnForceAbilityConfs: t
            })
        });
        var o = s.helper,
            u = s.battlePhaseConfs,
            a = s.initMemberValues,
            f = s.initGlobalRegister,
            l = s.abilityDeformMapTag,
            c = o.countupSnippet();
        return {
            startStateId: o.stateIdMap.STATE_INIT,
            globalRegister: _.extend({
                conf: s,
                currBattlePhaseIdx: o.bpIdx.BP1,
                totalBattlePhaseTurn: c.INIT_TURN,
                currBattlePhaseTurn: c.INIT_TURN,
                canTransit: !0,
                deadInterruptAbilityConfs: []
            }, f),
            notifyJudgedDeath: function() {
                var e = this.globalRegister;
                if (this.isCurrentState(o.stateIdMap.STATE_DEAD)) return !0;
                if (this.isCurrentState(o.stateIdMap.STATE_INT_DEAD)) return !1;
                var t = o.getInterruptAbilityConfsForDead(this);
                return 0 < t.length ? (e.deadInterruptAbilityConfs = t, this.changeState(o.stateIdMap.STATE_INT_DEAD), !1) : (this.changeState(o.stateIdMap.STATE_DEAD), !0)
            },
            states: [{
                id: o.stateIdMap.STATE_INIT,
                "class": "InitState",
                memberValues: _.extend({
                    nextStateId: o.stateIdMap.STATE_INT_HELLO,
                    paramId: u[o.bpIdx.BP1].paramId,
                    paramSuffixNo: u[o.bpIdx.BP1].paramSuffixNo,
                    abilityDeformMapTag: l,
                    optionalCounterCheckType: e.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.SMART
                }, a)
            }, {
                id: o.stateIdMap.STATE_INT_HELLO,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = o.getInterruptAbilityConfsForHello(this),
                        r = o.getResetTypeForHello(this, n),
                        i = 0,
                        s = {};
                    _.each(n, function(e) {
                        s[++i] = e
                    }), i === 0 && (s[++i] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), this._memberValues.abilityCount = i, this._memberValues.abilitySettingMap = s, this._resetType = r, r === o.resetType.RESET && o.resetByResetType(this, r), t()
                }],
                outState: [function(e) {
                    o.resetByResetType(this, this._resetType), e()
                }],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_NORMAL,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_NORMAL,
                update: function() {
                    var t = this._executer;
                    if (t.isIncontrollable()) return;
                    o.updateEveryFrame(this), c.check(this) && o.multipleAttack(this);
                    if (e.AbilityMgr.getInstance().existsRegisteredInterruptAbility({
                            upperEqualBoss: !0
                        })) return;
                    if (!t.canDoAbility()) return;
                    if (o.shouldChangeBattlePhase(this)) {
                        this.setNextStateId(o.stateIdMap.STATE_INT_CHANGE_PARAM);
                        return
                    }
                    if (!t.isReadyToSelectAbility()) return;
                    o.registerAbility(this)
                },
                transitions: [{
                    "class": "NextStateIdTransition"
                }],
                conditionFlags: [c.getConditionFlagHash()]
            }, {
                id: o.stateIdMap.STATE_INT_CHANGE_PARAM,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = this._executer,
                        r = o.getNextBattlePhaseIndex(this),
                        i = u[r],
                        s = o.retrieveParamIdFromConf(this, i),
                        a = o.getInterruptAbilityConfsForChangeParam(this, r),
                        f = o.getResetTypeForChangeParam(this, a, r),
                        l = 0,
                        c = {};
                    _.each(a, function(e) {
                        c[++l] = e
                    }), l === 0 && (c[++l] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), this._memberValues.abilityCount = l, this._memberValues.abilitySettingMap = c, this._resetType = f, o.changeBattlePhase(this, r), !s || n.changeBaseParam(s), t()
                }],
                outState: [function(e) {
                    o.resetByResetType(this, this._resetType), e()
                }],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_NORMAL,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_INT_DEAD,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = this.parent.globalRegister,
                        r = n.deadInterruptAbilityConfs,
                        i = 0,
                        s = {};
                    _.each(r, function(e) {
                        s[++i] = e
                    }), i === 0 && (s[++i] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), _.each(s, function(e) {
                        e.options || (e.options = {
                            interruptBeforeCounter: !0
                        })
                    }), this._memberValues.abilityCount = i, this._memberValues.abilitySettingMap = s, t()
                }, "CANCEL_INTERRUPT_ABILITY", "SET_SA"],
                memberValues: {
                    sa: [e.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE],
                    nextStateId: o.stateIdMap.STATE_DEAD,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_DEAD
            }]
        }
    }
}), define("scenes/battle/ai/stateSnippet/HpRateTransitionV2", [], function() {
    var e = FF.ns.battle;
    e.ai.stateSnippet.HpRateTransitionV2 = {}, e.ai.stateSnippet.HpRateTransitionV2.helper = {
        stateIdMap: {
            STATE_INIT: 10,
            STATE_INT_HELLO: 11,
            STATE_NORMAL: 12,
            STATE_INT_CHANGE_PARAM: 22,
            STATE_INT_DEAD: 98,
            STATE_DEAD: 99
        },
        resetType: {
            NONE: 1,
            RESET: 2,
            RESET_CAST_ABILITY: 3,
            RESET_AND_SHUFFLE_ATB: 4
        },
        bpIdx: {
            BP1: 0,
            BP2: 1,
            BP3: 2,
            BP4: 3,
            BP5: 4
        },
        resetByResetType: function(e, t) {
            var n = e._executer;
            switch (t) {
                case this.resetType.NONE:
                    break;
                case this.resetType.RESET:
                    n.reset();
                    break;
                case this.resetType.RESET_CAST_ABILITY:
                    n.resetCastAbility();
                    break;
                case this.resetType.RESET_AND_SHUFFLE_ATB:
                    n.resetAndShuffleAtb();
                    break;
                default:
                    throw new Error(sprintf("invalid resetType [%d]", t))
            }
        },
        countupSnippet: function() {
            return e.ai.StateSnippet.CountupWithGlobalRegister
        },
        decideResetTypeByInterruptAbilityConfs: function(t, n) {
            var r = t._executer,
                i = e.ai.AiUtil.existsShouldResetAbilityConf(r, n);
            return i ? this.resetType.RESET : this.resetType.RESET_CAST_ABILITY
        },
        retrieveParamIdFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.retrieveParamIdFromConf(r, n)
        },
        retrieveHpRateFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.retrieveHpRateFromConf(r, n)
        },
        getAbilityIdFromConf: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.getAbilityIdFromConf(r, n)
        },
        isThereEnableAbilityTarget: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.isThereEnableAbilityTarget(r, n)
        },
        isThereEnableAbilityTargetWithCondReflection: function(t, n) {
            var r = t._executer;
            return e.ai.AiUtil.isThereEnableAbilityTargetWithCondReflection(r, n)
        },
        getCurrBattlePhaseIdx: function(e) {
            var t = e.parent.globalRegister;
            return t.currBattlePhaseIdx
        },
        getCurrBattlePhaseConf: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs;
            return n[t.currBattlePhaseIdx]
        },
        getForceAbilityConfByTurn: function(t, n) {
            var r = this.countupSnippet().get(t, "currBattlePhaseTurn");
            return _.find(n, function(n) {
                return e.ai.AiUtil.checkTurnForceAbilityConf(r, n) ? this.isThereEnableAbilityTargetWithCondReflection(t, n) : !1
            }, this)
        },
        getInterruptAbilityConfsForHello: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf;
            return n.helloInterruptAbilityConfs
        },
        getResetTypeForHello: function(e, t) {
            return this.decideResetTypeByInterruptAbilityConfs(e, t)
        },
        getInterruptAbilityConfsForDead: function(e) {
            var t = e.globalRegister,
                n = t.conf;
            return n.deadInterruptAbilityConfs
        },
        getNextBattlePhaseIndex: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs,
                r = e._executer,
                i = r.getRemainingHpRate(),
                s = t.currBattlePhaseIdx,
                o = s;
            for (var u = o + 1; u < n.length; u++) {
                var a = n[u],
                    f = this.retrieveHpRateFromConf(e, a);
                if (f < i) break;
                o = u;
                if (a.forceStop) break
            }
            return o
        },
        shouldChangeBattlePhase: function(e) {
            var t = e.parent.globalRegister;
            if (!t.canTransit) return !1;
            var n = t.currBattlePhaseIdx,
                r = this.getNextBattlePhaseIndex(e);
            return n < r
        },
        changeBattlePhase: function(e, t) {
            var n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[t];
            n.currBattlePhaseIdx = t, this.countupSnippet().reset(e, "currBattlePhaseTurn"), n.canTransit = !0, i.forceStop && (n.canTransit = !1)
        },
        getInterruptAbilityConfsForChangeParam: function(e, t) {
            var n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[t],
                s = i.interruptAbilityConfs,
                o = [];
            return _.each(s, function(t) {
                if (!this.isThereEnableAbilityTargetWithCondReflection(e, t)) return;
                o.push(t)
            }, this), o
        },
        getResetTypeForChangeParam: function(e, t, n) {
            var r = e.parent.globalRegister,
                i = r.conf.battlePhaseConfs,
                s = i[n],
                o = this.retrieveParamIdFromConf(e, s),
                u = this.decideResetTypeByInterruptAbilityConfs(e, t);
            return !o && u === this.resetType.RESET_CAST_ABILITY && (u = this.resetType.NONE), u
        },
        multipleAttack: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister,
                r = n.conf.battlePhaseConfs,
                i = r[n.currBattlePhaseIdx];
            _.times(i.multipleAttackCnt - 1, function() {
                var e = t.smartLotAbility();
                t.registerInterruptAbility(e)
            })
        },
        updateEveryFrame: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister;
            this.countupSnippet().update(e, "totalBattlePhaseTurn"), this.countupSnippet().update(e, "currBattlePhaseTurn"), this.updateCanTransit(e)
        },
        updateCanTransit: function(e) {
            var t = e._executer,
                n = e.parent.globalRegister;
            n.canTransit || t.isReadyToSelectAbility() && (n.canTransit = !0)
        },
        getForceAbilityConf: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf.battlePhaseConfs,
                r = n[t.currBattlePhaseIdx];
            return this.getForceAbilityConfByTurn(e, r.turnForceAbilityConfs)
        },
        getAbilityWithoutListForLot: function(e) {
            var t = e._executer;
            return t.getExcludedAbilityListBySmartLot()
        },
        retrieveRegisterAbilityConf: function(e) {
            var t = e._executer,
                n = this.getForceAbilityConf(e);
            if (!n) {
                var r = this.getAbilityWithoutListForLot(e),
                    i = t.lotAbilityWithout(r);
                return {
                    abilityId: i,
                    abilityOptions: {}
                }
            }
            return n
        },
        registerAbility: function(e) {
            var t = e._executer,
                n = this.retrieveRegisterAbilityConf(e),
                r = this.getAbilityIdFromConf(e, n);
            t.registerAbility(r, n.abilityOptions)
        },
        updateTurnByInterruptAbility: function(e) {
            var t = e._executer;
            t.reset(), this.countupSnippet().add(e, "totalBattlePhaseTurn"), this.countupSnippet().add(e, "currBattlePhaseTurn")
        },
        getShouldWaitForInterruptAbilityToFinish: function(e) {
            var t = this.getCurrBattlePhaseConf(e);
            return t.shouldWaitForInterruptAbilityToFinish
        }
    };
    var t = {
            battlePhaseConfs: void 0,
            helper: {},
            initMemberValues: {},
            initGlobalRegister: {},
            helloInterruptAbilityConfs: [],
            deadInterruptAbilityConfs: []
        },
        n = {
            hpRateAiArg: void 0,
            paramSuffixNo: void 0,
            forceStop: !1,
            shouldWaitForInterruptAbilityToFinish: !1,
            multipleAttackCnt: 1,
            interruptAbilityConfs: [],
            turnForceAbilityConfs: []
        },
        r = {
            turn: void 0,
            abilityTag: void 0,
            abilityOptions: {},
            intervalTurn: 0
        };
    e.ai.stateSnippet.HpRateTransitionV2.makeJson = function(i) {
        var s = _.extend({}, t, i);
        s.helper = _.extend({}, this.helper, i.helper), s.battlePhaseConfs = _.map(i.battlePhaseConfs, function(e) {
            var t = _.map(e.turnForceAbilityConfs, function(e) {
                return _.extend({}, r, e)
            });
            return _.extend({}, n, e, {
                turnForceAbilityConfs: t
            })
        });
        var o = s.helper,
            u = s.battlePhaseConfs,
            a = s.initMemberValues,
            f = s.initGlobalRegister,
            l = o.countupSnippet();
        return {
            startStateId: o.stateIdMap.STATE_INIT,
            globalRegister: _.extend({
                conf: s,
                currBattlePhaseIdx: o.bpIdx.BP1,
                totalBattlePhaseTurn: l.INIT_TURN,
                currBattlePhaseTurn: l.INIT_TURN,
                canTransit: !0,
                deadInterruptAbilityConfs: []
            }, f),
            notifyJudgedDeath: function() {
                var e = this.globalRegister;
                if (this.isCurrentState(o.stateIdMap.STATE_DEAD)) return !0;
                if (this.isCurrentState(o.stateIdMap.STATE_INT_DEAD)) return !1;
                var t = o.getInterruptAbilityConfsForDead(this);
                return 0 < t.length ? (e.deadInterruptAbilityConfs = t, this.changeState(o.stateIdMap.STATE_INT_DEAD), !1) : (this.changeState(o.stateIdMap.STATE_DEAD), !0)
            },
            states: [{
                id: o.stateIdMap.STATE_INIT,
                "class": "InitState",
                memberValues: _.extend({
                    nextStateId: o.stateIdMap.STATE_INT_HELLO,
                    paramSuffixNo: u[o.bpIdx.BP1].paramSuffixNo,
                    optionalCounterCheckType: e.Conf.ENEMY_OPTIONAL_COUNTER_CHECK_TYPE.SMART
                }, a)
            }, {
                id: o.stateIdMap.STATE_INT_HELLO,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = o.getInterruptAbilityConfsForHello(this),
                        r = 0,
                        i = {};
                    _.each(n, function(e) {
                        i[++r] = e
                    }), r === 0 && (i[++r] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), this._resetType = o.getResetTypeForHello(this, n), this._memberValues.abilityCount = r, this._memberValues.abilitySettingMap = i, t()
                }],
                outState: [function(e) {
                    o.resetByResetType(this, this._resetType), e()
                }],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_NORMAL,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_NORMAL,
                update: function() {
                    var t = this._executer,
                        n = this.parent.globalRegister;
                    if (t.isIncontrollable()) return;
                    o.updateEveryFrame(this), l.check(this) && o.multipleAttack(this);
                    if (o.getShouldWaitForInterruptAbilityToFinish(this) && e.ai.AiUtil.existsRegisteredInterruptAbility()) return;
                    if (!t.canDoAbility()) return;
                    if (o.shouldChangeBattlePhase(this)) {
                        this.setNextStateId(o.stateIdMap.STATE_INT_CHANGE_PARAM);
                        return
                    }
                    if (!t.isReadyToSelectAbility()) return;
                    o.registerAbility(this)
                },
                transitions: [{
                    "class": "NextStateIdTransition"
                }],
                conditionFlags: [l.getConditionFlagHash()]
            }, {
                id: o.stateIdMap.STATE_INT_CHANGE_PARAM,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = this._executer,
                        r = o.getNextBattlePhaseIndex(this),
                        i = u[r],
                        s = o.retrieveParamIdFromConf(this, i),
                        a = o.getInterruptAbilityConfsForChangeParam(this, r),
                        f = o.getResetTypeForChangeParam(this, a, r),
                        l = 0,
                        c = {};
                    _.each(a, function(e) {
                        c[++l] = e
                    }), l === 0 && (c[++l] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), _.each(c, function(e) {
                        e.options || (e.options = {
                            interruptBeforeCounter: !0
                        })
                    }), this._memberValues.abilityCount = l, this._memberValues.abilitySettingMap = c, this._resetType = f, o.changeBattlePhase(this, r), !s || n.changeBaseParam(s), t()
                }],
                outState: [function(e) {
                    o.resetByResetType(this, this._resetType), e()
                }],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_NORMAL,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_INT_DEAD,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = this.parent.globalRegister,
                        r = n.deadInterruptAbilityConfs,
                        i = 0,
                        s = {};
                    _.each(r, function(e) {
                        s[++i] = e
                    }), i === 0 && (s[++i] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), _.each(s, function(e) {
                        e.options || (e.options = {
                            interruptBeforeCounter: !0
                        })
                    }), this._memberValues.abilityCount = i, this._memberValues.abilitySettingMap = s, t()
                }, "CANCEL_INTERRUPT_ABILITY", "SET_SA"],
                memberValues: {
                    sa: [e.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE],
                    nextStateId: o.stateIdMap.STATE_DEAD,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_DEAD
            }]
        }
    }
}), define("scenes/battle/ai/stateSnippet/Wave", [], function() {
    var e = FF.ns.battle;
    e.ai.stateSnippet.Wave = {}, e.ai.stateSnippet.Wave.helper = {
        stateIdMap: {
            STATE_INIT: 10,
            STATE_INT_HELLO: 11,
            STATE_INT_WAVE_ENTER: 12,
            STATE_WAVE_BATTLE: 13,
            STATE_WAVE_EXIT: 14,
            STATE_INT_DEAD: 98,
            STATE_DEAD: 99
        },
        getChildNos: function(e, t) {
            var n = e.conf.battleWaveConfs,
                r = n[t];
            return _.isUndefined(r) ? [] : [].concat(r.childNos)
        },
        notifyJudgedDeath: function(e, t) {
            var n = e._executer,
                r = e.globalRegister,
                i = r.conf.helper;
            if (e.isCurrentState(i.stateIdMap.STATE_WAVE_EXIT)) return !0;
            var s = i.getChildNos(r, r.waveIdx),
                o = _.any(s, function(e) {
                    var t = n.getChild(e);
                    return t.isAlive() && !t.judgeDeath()
                });
            return o ? !0 : (e.changeState(i.stateIdMap.STATE_WAVE_EXIT), !1)
        },
        notifyJudgedDeathForFinal: function(e, t) {
            var n = e._executer,
                r = e.globalRegister,
                i = r.conf.helper;
            if (e.isCurrentState(i.stateIdMap.STATE_DEAD)) return !0;
            if (e.isCurrentState(i.stateIdMap.STATE_INT_DEAD)) return !1;
            var s = i.getChildNos(r, r.waveIdx),
                o = _.any(s, function(e) {
                    var t = n.getChild(e);
                    return t.isAlive() && !t.judgeDeath()
                });
            if (o) return !0;
            var u = i.getInterruptAbilityConfsForDead(e);
            return 0 < u.length ? (r.deadInterruptAbilityConfs = u, e.changeState(i.stateIdMap.STATE_INT_DEAD), !1) : (e.changeState(i.stateIdMap.STATE_DEAD), !0)
        },
        getInterruptAbilityConfsForHello: function(e) {
            var t = e.parent.globalRegister,
                n = t.conf;
            return n.helloInterruptAbilityConfs
        },
        getInterruptAbilityConfsForDead: function(e) {
            var t = e.globalRegister,
                n = t.conf;
            return n.deadInterruptAbilityConfs
        },
        getBattleWaveConfs: function(e) {
            var t = e.parent.globalRegister,
                n = t.waveIdx,
                r = t.conf.battleWaveConfs,
                i = r[n];
            return i
        },
        getInDeformTag: function(e) {
            var t = this.getBattleWaveConfs(e);
            return t.inDeformTag
        },
        getPreInAbilityConfs: function(e) {
            var t = this.getBattleWaveConfs(e);
            return t.preInAbilityConfs
        },
        getPostInAbilityConfs: function(e) {
            var t = this.getBattleWaveConfs(e);
            return t.postInAbilityConfs
        },
        getShouldShuffleAtbConfs: function(e) {
            var t = this.getBattleWaveConfs(e);
            return t.shouldShuffleAtb
        },
        getShouldWaitForInterruptAbilityToFinishConfs: function(e) {
            var t = this.getBattleWaveConfs(e);
            return t.shouldWaitForInterruptAbilityToFinish
        }
    };
    var t = {
            battleWaveConfs: void 0,
            helper: {},
            initMemberValues: {},
            initGlobalRegister: {},
            helloInterruptAbilityConfs: [],
            deadInterruptAbilityConfs: []
        },
        n = {
            childNos: [],
            inDeformTag: void 0,
            preInAbilityConfs: [],
            postInAbilityConfs: [],
            shouldShuffleAtb: !1,
            shouldWaitForInterruptAbilityToFinish: !1
        };
    e.ai.stateSnippet.Wave.makeJson = function(r) {
        var i = e.ai.StateSnippet.CustomInterruptMultipleAbility,
            s = _.extend({}, t, r);
        s.helper = _.extend({}, this.helper, r.helper), s.battleWaveConfs = _.map(r.battleWaveConfs, function(e) {
            return _.extend({}, n, e)
        });
        var o = s.helper,
            u = s.battleWaveConfs,
            a = s.initMemberValues,
            f = s.initGlobalRegister,
            l = s.abilityDeformMapTag;
        return {
            startStateId: o.stateIdMap.STATE_INIT,
            globalRegister: _.extend({
                conf: s,
                waveIdx: 0,
                isFinalWave: !1,
                deadInterruptAbilityConfs: []
            }, f),
            notifyJudgedDeath: function(e) {
                var t = this.globalRegister;
                return t.isFinalWave ? o.notifyJudgedDeathForFinal(this, e) : o.notifyJudgedDeath(this, e)
            },
            states: [{
                id: o.stateIdMap.STATE_INIT,
                "class": "InitState",
                memberValues: _.extend({
                    nextStateId: o.stateIdMap.STATE_INT_HELLO,
                    abilityDeformMapTag: l,
                    visible: {
                        visibleNo: void 0
                    }
                }, a),
                inState: [function(e) {
                    var t = this.parent.globalRegister,
                        n = o.getChildNos(t, t.waveIdx);
                    this._memberValues.visible.visibleNo = n, e()
                }]
            }, {
                id: o.stateIdMap.STATE_INT_HELLO,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = o.getInterruptAbilityConfsForHello(this),
                        r = 0,
                        i = {};
                    _.each(n, function(e) {
                        i[++r] = e
                    }), r === 0 && (i[++r] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), this._memberValues.abilityCount = r, this._memberValues.abilitySettingMap = i, t()
                }],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_WAVE_BATTLE,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_WAVE_BATTLE
            }, {
                id: o.stateIdMap.STATE_WAVE_EXIT,
                inState: [function(t) {
                    var n = this._executer,
                        r = this.parent.globalRegister,
                        i = r.waveIdx + 1,
                        s = o.getChildNos(r, i);
                    _.each(s, function(t) {
                        var r = n.getChild(t);
                        r.setEnable(!0), r.setStatusAilments(e.Conf.STATUS_AILMENTS_TYPE.INVISIBLE)
                    }), t()
                }],
                outState: [function(e) {
                    var t = this.parent.globalRegister;
                    t.waveIdx += 1;
                    var n = t.conf.battleWaveConfs;
                    _.isUndefined(n[t.waveIdx + 1]) && (t.isFinalWave = !0), e()
                }],
                update: function() {
                    var t = this._executer,
                        n = this.parent.globalRegister,
                        r = n.waveIdx;
                    if (o.getShouldWaitForInterruptAbilityToFinishConfs(this) && e.ai.AiUtil.existsRegisteredInterruptAbility()) return;
                    var i = o.getChildNos(n, r),
                        s = _.all(i, function(e) {
                            var n = t.getChild(e);
                            return n.isDead()
                        });
                    s && this.setNextStateId(o.stateIdMap.STATE_INT_WAVE_ENTER)
                },
                transitions: [{
                    "class": "NextStateIdTransition"
                }]
            }, {
                id: o.stateIdMap.STATE_INT_WAVE_ENTER,
                "class": "InterruptMultipleAbility",
                inState: [i.makeInState(function() {
                    var t = this._executer,
                        n = this.parent.globalRegister;
                    _.each(o.getPreInAbilityConfs(this), function(e) {
                        i.addAbility(this, e)
                    }, this);
                    var r = o.getChildNos(n, n.waveIdx),
                        s = [
                            [{
                                deformTag: o.getInDeformTag(this),
                                skipEnemyName: !0
                            }],
                            [{
                                builtin: "UNSET_SA",
                                sa: [e.Conf.STATUS_AILMENTS_TYPE.INVISIBLE],
                                saChildNos: r
                            }],
                            [{
                                builtin: "RESET",
                                resetChildNos: r
                            }]
                        ];
                    o.getShouldShuffleAtbConfs(this) && (s = s.concat([
                        [{
                            builtin: "SHUFFLE_ATB",
                            shuffleChildNos: r
                        }]
                    ])), i.addDeformMulti(this, s), _.each(o.getPostInAbilityConfs(this), function(e) {
                        i.addAbility(this, e)
                    }, this), i.setInterruptBeforeCounter(this)
                })],
                memberValues: i.makeMemberValues({
                    nextStateId: o.stateIdMap.STATE_WAVE_BATTLE
                })
            }, {
                id: o.stateIdMap.STATE_INT_DEAD,
                "class": "InterruptMultipleAbility",
                inState: [function(t) {
                    var n = this._executer,
                        r = this.parent.globalRegister,
                        i = r.deadInterruptAbilityConfs,
                        s = 0,
                        u = {};
                    _.each(i, function(e) {
                        u[++s] = e
                    }), s === 0 && (u[++s] = {
                        abilityId: e.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY
                    }), _.each(u, function(e) {
                        e.options || (e.options = {
                            interruptBeforeCounter: !0
                        })
                    }), this._memberValues.abilityCount = s, this._memberValues.abilitySettingMap = u;
                    var a = o.getChildNos(r, r.waveIdx);
                    _.each(a, function(t) {
                        var r = n.getChild(t);
                        r.setStatusAilments(e.Conf.STATUS_AILMENTS_TYPE.INVINCIBLE)
                    }), t()
                }, "CANCEL_INTERRUPT_ABILITY"],
                memberValues: {
                    nextStateId: o.stateIdMap.STATE_DEAD,
                    abilityCount: void 0,
                    abilitySettingMap: void 0
                }
            }, {
                id: o.stateIdMap.STATE_DEAD
            }]
        }
    }
}), define("scenes/battle/fsm/State", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.State = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this.transitions = [], this._stateId = t.id, this._memberValues = t.memberValues || {}
        },
        getMemberValues: function() {
            return this._memberValues
        },
        getStateId: function() {
            return this._stateId
        },
        inState: function() {},
        outState: function() {},
        update: function(e) {},
        updateTransition: function() {
            var e = null,
                t = this;
            _.any(this.transitions, function(n) {
                return n.update(), n.canTransition(t) ? (e = n, !0) : !1
            });
            if (e) return _.each(this.transitions, function(e) {
                e.reset()
            }), this.triggerTx = e, e.getNextStateId()
        },
        preUpdate: function(e) {},
        postUpdate: function(e) {},
        isInCurrentState: function() {
            return this.parent.isCurrentState(this.getStateId())
        }
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.State
}), define("scenes/battle/ai/State", ["util", "../fsm/State"], function(e, t) {
    var n = FF.ns.battle,
        r = function(e, t, r) {
            _.isArray(r) || (r = [r]), e.parent.globalRegister.lastVisibleNo = _.last(r);
            var i = {};
            _.each(r, function(e) {
                i[e] = !0
            }), _.each(t.getNos(), function(e) {
                var r = t.getChild(e),
                    s = n.Conf.STATUS_AILMENTS_TYPE.DISABLE,
                    o = r.statusAilments.has(n.Conf.STATUS_AILMENTS_TYPE.DISABLE);
                if (i[e]) o && r.statusAilments.unset(s);
                else if (!o) {
                    var u = n.util.DamageCalculator.makeDamageObject(r, r, void 0, {
                        statusAilments: [s]
                    });
                    r.applyDamageObject(u)
                }
            })
        },
        i = {
            OVERRIDE_ACTOR_PARAM: function(e) {
                _.each(this._memberValues.overrideActorParam, function(e, t) {
                    this._executer.set(t, e)
                }, this), e()
            },
            RECOVER: function(t) {
                var n = e.option({
                        recoverNo: void 0,
                        rate: void 0
                    }, this._memberValues.recover),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.recoverNo, function(e) {
                    var t = r.getChild(e),
                        i = t.get("maxHp");
                    n.rate > 0 && (i = Math.ceil(i * (n.rate / 100))), t.set("hp", i), t.rise()
                }), t()
            },
            RECOVER_ENABLE: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.visibleNo, function(e) {
                    var t = r.getChild(e);
                    t.set("hp", t.get("maxHp")), t.rise()
                }), t()
            },
            SET_SA: function(e) {
                var t = [];
                this._executer.container ? t.push(this._executer) : _.each(this._memberValues.saChildNos, function(e) {
                    t.push(this._executer.getChild(e))
                }, this);
                var n = this._memberValues.sa,
                    r = this._memberValues.saOptions;
                _.each(t, function(e) {
                    e.setStatusAilments(n, r)
                }), e()
            },
            UNSET_SA: function(e) {
                var t = [];
                this._executer.container ? t.push(this._executer) : _.each(this._memberValues.saChildNos, function(e) {
                    t.push(this._executer.getChild(e))
                }, this);
                var n = this._memberValues.sa;
                n = _.isArray(n) ? n : [n], _.each(t, function(e) {
                    _.each(n, function(t) {
                        e.statusAilments.unset(t)
                    })
                }), e()
            },
            UNSET_ALL_SA: function(e) {
                var t = [];
                if (this._executer.isContainer()) _.each(this._memberValues.saChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this);
                else {
                    var n = this._executer;
                    t.push(n)
                }
                t = _.filter(t, function(e) {
                    return e.isAlive()
                }), _.each(t, function(e) {
                    var t = e.statusAilments.cloneIds();
                    _.each(t, function(t) {
                        e.statusAilments.unset(t)
                    })
                }), e()
            },
            RESET: function(e) {
                var t = [];
                this._executer.container ? t = [this._executer] : _.isUndefined(this._memberValues.resetChildNos) ? t = this._executer.getChildren() : _.each(this._memberValues.resetChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this), _.each(t, function(e) {
                    e.isAlive() && e.reset()
                }), e()
            },
            SHUFFLE_ATB: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    r = this._executer.isContainer() ? this._executer : this._executer.container;
                _.each(n.visibleNo, function(t) {
                    var n = r.getChild(t),
                        i = e.randomInt(n.getAtbTime() - 1);
                    n.set("elapsedAtbTime", i)
                }), t()
            },
            CLEAR_TARGET: function(e) {
                var t = [],
                    r = this._executer,
                    i = n.ActorMgr.getActiveTarget();
                if (!i) {
                    e();
                    return
                }
                r.isContainer() ? _.each(this._memberValues.ctChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this) : t = [r], _.any(t, function(e) {
                    if (i.equals(e)) return n.ActorMgr.clearActiveTarget(), !0
                }), e()
            },
            RESET_CAST_ABILITY: function(e) {
                var t = [];
                this._executer.isContainer() ? _.isUndefined(this._memberValues.resetCAChildNos) ? t = this._executer.getChildren() : _.each(this._memberValues.resetCAChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this) : t = [this._executer], _.each(t, function(e) {
                    e.isAlive() && e.resetCastAbility()
                }), e()
            },
            ENABLE: function(t) {
                var n = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    i = this._executer;
                r(this, i, n.visibleNo), t()
            },
            ENABLE_AND_UPDATE_POS_ARRAY: function(t) {
                var i = e.option({
                        visibleNo: void 0
                    }, this._memberValues.visible),
                    s = this._executer;
                r(this, s, i.visibleNo), n.BattleViewController.getInstance().updateEnemyContainerPosArray(s.get("posId")), t()
            },
            CHANGE_PARAM: function(t) {
                var n = this._executer;
                this._memberValues.id && (n = n.getChild(this._memberValues.id));
                var r = this._memberValues.paramId,
                    i = this._memberValues.paramSuffixNo;
                !i || (r = n.getParamIdBySuffixNo(i));
                var s = this._memberValues.lotParam;
                if (s && r === void 0) {
                    var o = n.get("paramId"),
                        u;
                    s.allowCurrentParam ? u = s.paramIds : u = _.filter(s.paramIds, function(e) {
                        return e !== o
                    }), r = e.lot(u, function() {
                        return 1
                    })
                }
                n.changeBaseParam(r), t()
            },
            CHANGE_PARAM_MULTI: function(e) {
                var t = this._executer;
                if (this._memberValues.childParams === void 0) throw new Error("childParams is required");
                if (!t.isContainer()) throw new Error("exclusive use for god-ai");
                _.each(this._memberValues.childParams, function(e) {
                    var n = t.getChild(e.id),
                        r = e.paramId;
                    !e.paramSuffixNo || (r = n.getParamIdBySuffixNo(e.paramSuffixNo)), n.changeBaseParam(r)
                }), e()
            },
            CHANGE_ABILITY_DEFORM_MAP: function(e) {
                var t = this._executer,
                    n = t.isContainer() ? t : t.container,
                    r = this._memberValues.abilityDeformMap,
                    i = n.get("abilityDeformMap") || {};
                i = _.extend(i, r), n.set("abilityDeformMap", i), e()
            },
            CHANGE_ABILITY_DEFORM_MAP_TAG: function(e) {
                var t = this._executer,
                    n = t.isContainer() ? t : t.container,
                    r = {};
                _.each(this._memberValues.abilityDeformMapTag, function(e, t) {
                    var i = n.getChild(t);
                    r[t] = {}, _.each(e, function(e, n) {
                        var s = i.getAbilityIdByTag(n);
                        r[t][s] = e
                    })
                });
                var i = n.get("abilityDeformMapTag") || {};
                i = _.extend(i, r), n.set("abilityDeformMapTag", i), e()
            },
            SET_DEAD_ANIMATE_TYPE: function(e) {
                var t = this._executer,
                    n = this._memberValues.deadAnimateType;
                if (_.isNumber(n)) {
                    if (t.isContainer()) throw new Error("in enemy container, argument type must be object.");
                    t.setDeadAnimateType(n)
                } else {
                    if (!_.isObject(n)) throw new Error("argument type must be number or object.");
                    var r = t.isContainer() ? t : t.container;
                    _.each(n, function(e, t) {
                        var n = r.getChild(t);
                        if (!n) throw new Error("undefined actorNo. NO:" + t);
                        n.setDeadAnimateType(e)
                    })
                }
                e()
            },
            CANCEL_INTERRUPT_ABILITY: function(e) {
                var t = [];
                this._executer.container ? t = [this._executer] : _.isUndefined(this._memberValues.cancelIAChildNos) ? t = this._executer.getChildren() : _.each(this._memberValues.cancelIAChildNos, function(e) {
                    var n = this._executer.getChild(e);
                    t.push(n)
                }, this), _.each(t, function(e) {
                    e.cancelInterruptAbility()
                }), e()
            },
            DIFF_ENABLE: function(e) {
                n.ai.AiUtil.builtinDiffEnable(this._executer, this._memberValues), e()
            },
            SET_OPTIONAL_COUNTER_CHECK_TYPE: function(e) {
                n.ai.AiUtil.builtinSetOtionalCounterCheckType(this._executer, this._memberValues), e()
            }
        };
    return FF.ns.battle.ai.State = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.apply(this, arguments), this._executer = n, this._internalNextStateId = void 0, this.conditionFlags = {}, this.resultObjectTmps = {}
        },
        preUpdate: function(e) {
            t.prototype.preUpdate.apply(this, arguments), this._internalNextStateId = void 0, _.each(this.conditionFlags, function(t) {
                t.preUpdate(e)
            })
        },
        postUpdate: function(e) {
            t.prototype.postUpdate.apply(this, arguments), _.each(this.resultObjectTmps, function(t) {
                t.postUpdate(e)
            })
        },
        setNextStateId: function(e) {
            this._internalNextStateId = e
        },
        getNextStateId: function() {
            return this._internalNextStateId
        },
        getConditionFlagInCurrTransition: function(e) {
            var t = this.conditionFlags[e];
            return t.getFlagInCurrTransition()
        },
        getConditionFlagInFrame: function(e) {
            var t = this.conditionFlags[e];
            return t.getFlagInFrame()
        },
        getResultObjectsInFrame: function(e) {
            var t = this.resultObjectTmps[e];
            return t.getResultObjects()
        }
    }, {
        getBuiltinFunction: function(e) {
            return i[e]
        }
    }), FF.ns.battle.ai.State
}), define("scenes/battle/fsm/StateMap", ["util", "lib/EventBase"], function(e, t) {
    return FF.ns.battle.fsm.StateMap = t.extend({
        initialize: function(n) {
            t.prototype.initialize.apply(this, arguments), this.globalRegister = e.cloneDeep(n.globalRegister || {}), this.states = {}, this._params = n, this._currentState = null
        },
        update: function(e) {
            var t = this._currentState;
            if (!t) {
                t = this._currentState = this.states[this._params.startStateId];
                if (!t || !_.isFunction(t.inState)) throw new Error("inState Error Debug: " + JSON.stringify({
                    startStateId: this._params.startStateId,
                    existsCurrState: !!t,
                    statesKeys: _.keys(this.states)
                }));
                t.inState()
            }
            t.preUpdate(e), t.update(e), t.postUpdate(e);
            var n = t.updateTransition();
            n && this.changeState(n)
        },
        changeState: function(e) {
            var t = this._currentState,
                n = this.states[e],
                r = t.getStateId();
            t.outState(), t.triggerTx && (t.triggerTx.transit(t, n), t.triggerTx = null), FF.logger.debug("IN_STATE", e), n.inState(), this._currentState = n, this.trigger("StateMap::changeState", e, r)
        },
        findState: function(e) {
            return this.states[e]
        },
        isCurrentState: function(e) {
            return this._currentState && e === this._currentState.getStateId()
        }
    }), FF.ns.battle.fsm.StateMap
}), define("scenes/battle/ai/StateMap", ["../fsm/StateMap"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.StateMap = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n;
            var r = this._params.notifyJudgedDeath;
            _.isFunction(r) && (this.notifyJudgedDeath = r), _.isFunction(this._params.notifyCommunication) && (this.notifyCommunication = this._params.notifyCommunication);
            var i = this._executer.isContainer() ? this._executer : this._executer.container;
            if (this._executer.isContainer()) {
                var s = [].concat(this._params.initialInvisibleNos || []);
                _.each(s, function(e) {
                    var t = i.getChild(e);
                    t.setInvisible()
                })
            } else this._params.initialInvisible && this._executer.setInvisible();
            if (this._executer.isContainer()) {
                var o = [].concat(this._params.initialStatusAilments || []);
                _.each(o, function(e) {
                    var t = i.getChild(e.no);
                    t.setStatusAilments(e.saIds)
                })
            } else _.isEmpty(this._params.initialStatusAilmentsIds) || this._executer.setStatusAilments(this._params.initialStatusAilmentsIds);
            i && this._params.shouldDeformAllNodesInAppearing && i.setEnabledShouldDeformAllNodesInAppearing()
        },
        getExecuter: function() {
            return this._executer
        },
        notifyJudgedDeath: function() {
            return !0
        },
        notifyCommunication: function(e) {
            throw new Error("should override notifyCommunication if you want to use.")
        }
    }), FF.ns.battle.ai.StateMap
}), define("scenes/battle/ai/StateMapBuilder", ["util"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.StateMapBuilder = {
        createById: function(e, n) {
            var r = t.ai.conf[e];
            if (!r) throw new Error("state map not found." + e);
            return this.createByJson(r, n)
        },
        createByJson: function(e, n) {
            var r = new t.ai.StateMap(e, n);
            return e.states && _.each(e.states, function(e) {
                var t = this._buildState(e, n, r);
                t.parent = r, r.states[e.id] = t
            }, this), r
        },
        _buildState: function(n, r, i) {
            var s = n.class ? t.ai.state[n.class] : t.ai.State;
            if (!s) throw new Error("state class not found." + n.class);
            var o = new s(n, r);
            return _.each(["inState", "outState", "update", "updateTransition"], function(t) {
                var r = this._getBuiltinFuncs(s, n[t]);
                r.push(o[t]), o[t] = e.makeInterceptor(o, r)
            }, this), _.each(n.transitions, function(e) {
                var t = this._buildTransition(e, r);
                t.parent = o, o.transitions.push(t)
            }, this), _.each(n.conditionFlags, function(e) {
                var t = this._buildConditionFlag(e, r, i);
                t.parent = o, o.conditionFlags[t.conditionFlagTag] = t
            }, this), _.each(n.resultObjectTmps, function(e) {
                var t = this._buildResultObjectTmp(e, r, i);
                t.parent = o, o.resultObjectTmps[t.resultObjectTmpTag] = t
            }, this), o
        },
        _buildTransition: function(n, r) {
            if (!n.class && !n.nextStateId && !n.nextStateLot) throw new Error("transition nextState[Id|Lot] not defined.");
            var i = n.class ? t.ai.transition[n.class] : t.ai.Transition;
            if (!i) throw new Error("transition class not found." + n.class);
            var s = new i(n, r);
            return s.nextStateId = n.nextStateId, s.args = e.cloneDeep(n.args || {}), s.condition = this._buildTransitConditions(n.condition, r), _.each(s.condition, function(e) {
                e.parent = s
            }), _.each(["canTransition", "transit"], function(e) {
                var t = this._getBuiltinFunc(i, n[e]);
                t && (s[e] = t)
            }, this), s
        },
        _buildTransitConditions: function(e, n) {
            e = e || [], _.isArray(e) || (e = [e]);
            var r = [];
            return _.each(e, function(e) {
                var i = e.class ? t.ai.transitCondition[e.class] : t.ai.TransitCondition;
                if (!i) throw new Error("transitCondition class not found." + e.class);
                var s = new i(e, n);
                _.each(["canTransition"], function(t) {
                    var n = this._getBuiltinFunc(i, e[t]);
                    n && (s[t] = n)
                }, this), r.push(s)
            }, this), r
        },
        _buildConditionFlag: function(n, r, i) {
            if (!n.conditionFlagTag) throw new Error("conditionFlag conditionFlagTag not defined.");
            var s = n.class ? t.ai.conditionFlag[n.class] : t.ai.ConditionFlag;
            if (!s) throw new Error("conditionFlag class not found." + n.class);
            var o = new s(n, r, i);
            return o.conditionFlagTag = n.conditionFlagTag, o.args = e.cloneDeep(n.args || {}), o.condition = this._buildTransitConditions(n.condition, r), _.each(o.condition, function(e) {
                e.parent = o
            }), _.each([], function(e) {
                var t = this._getBuiltinFunc(s, n[e]);
                t && (o[e] = t)
            }, this), o
        },
        _buildResultObjectTmp: function(e, n, r) {
            if (!e.resultObjectTmpTag) throw new Error("resultObjectTmp resultObjectTmpTag not defined.");
            var i = t.ai.resultObjectTmp[e.class];
            if (!i) throw new Error("resultObjectTmp class not found." + e.class);
            var s = new i(e, n, r);
            return s.resultObjectTmpTag = e.resultObjectTmpTag, s
        },
        _getBuiltinFunc: function(e, t) {
            var n = t;
            if (!n) return;
            if (!_.isFunction(n)) {
                n = e.getBuiltinFunction(n);
                if (!n) throw new Error("invalid builtin func." + t)
            }
            return n
        },
        _getBuiltinFuncs: function(e, t) {
            var n = [];
            if (!t) return n;
            _.isArray(t) || (t = [t]);
            for (var r = 0, i = t.length; r < i; r++) n.push(this._getBuiltinFunc(e, t[r]));
            return n
        }
    }
}), define("scenes/battle/fsm/TransitCondition", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.TransitCondition = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments)
        },
        canTransition: function(e, t) {
            return !1
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        update: function() {}
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.TransitCondition
}), define("scenes/battle/ai/TransitCondition", ["../fsm/TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = {
            INTERRUPT_DONE: function() {
                var e = this.parent.parent,
                    t = e._ability;
                if (t) return t.isDone()
            },
            ABILITY_DONE: function() {
                var e = this._executer,
                    t = this._args;
                t && t.id && (e = e.getChild(t.id));
                var n = e.getAbility(),
                    r = !1;
                n && (this._ability = n);
                if (this._ability) {
                    var i = t ? t.abilityId : void 0;
                    t && t.abilityTag && (i = e.getAbilityIdByTag(t.abilityTag)), i ? r = this._ability.isDone() && this._ability.getAttributes().abilityId === i : r = this._ability.isDone(), r && (this._ability = void 0)
                }
                return r
            },
            DEAD: function() {
                var e = this._executer,
                    t = this._args;
                return t && t.id && (e = e.getChild(t.id)), e.isDead()
            },
            JUDGE_DEATH: function() {
                var e = this._executer,
                    t = this._args;
                return t && t.id && (e = e.getChild(t.id)), e.judgeDeath()
            },
            HP: function() {
                var e = this._executer,
                    t = this._args;
                t.id && (e = e.getChild(t.id));
                if (!!t.canNotDoAbility && !e.canDoAbility()) return !1;
                if (!!t.skipWhenExistsRegisteredInterruptAbility && n.ai.AiUtil.existsRegisteredInterruptAbility()) return !1;
                var r = e.getRemainingHpRate();
                if (this._retrieveUnder()) return r < this._retrieveUnder();
                if (this._retrieveUnderOrEqual()) return r <= this._retrieveUnderOrEqual();
                if (this._retrieveOver()) return r > this._retrieveOver();
                if (this._retrieveOverOrEqual()) return r >= this._retrieveOverOrEqual();
                throw new Error("invalid args")
            },
            HP_DIFF: function() {
                var e = this._executer,
                    t = this._args;
                t.id && (e = e.getChild(t.id));
                var n = e.getRemainingHpRate();
                if (!_.isNumber(this._targetRate)) {
                    var r = this._retrieveUnder() || this._retrieveUnderOrEqual() || this._retrieveOver() || this._retrieveOverOrEqual() || 0;
                    if (r === 0) throw new Error("invalid arguments");
                    var i = n + r;
                    if (i < 0 || i > 100) return !1;
                    this._targetRate = i
                }
                var s = !1;
                return this._retrieveUnder() ? s = n < this._targetRate : this._retrieveUnderOrEqual() ? s = n <= this._targetRate : this._retrieveOver() ? s = n > this._targetRate : this._retrieveOverOrEqual() && (s = n >= this._targetRate), s && (this._targetRate = void 0), s
            },
            SA: function() {
                var e = this._executer,
                    t = this._args,
                    r = [];
                t.saIds && (r = r.concat(t.saIds)), t.bundleId && (r = r.concat(n.StatusAilmentsConfig.getBundle(t.bundleId)));
                var i = _.intersection(e.statusAilments.getRefs(), r),
                    s = i.length > 0;
                return t.isNone ? !s : s
            },
            RANDOM: function() {
                var e = this._args,
                    n = e.rate || 50;
                return t.lotByFraction(n)
            }
        };
    return FF.ns.battle.ai.TransitCondition = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n, this._params = t, this._args = t.args || {}
        },
        dispose: function() {
            this.stopListening()
        },
        reset: function() {},
        _retrieveUnder: function() {
            return this._retrieveArg("under")
        },
        _retrieveUnderOrEqual: function() {
            return this._retrieveArg("underOrEqual")
        },
        _retrieveOver: function() {
            return this._retrieveArg("over")
        },
        _retrieveOverOrEqual: function() {
            return this._retrieveArg("overOrEqual")
        },
        _retrieveArg: function(e) {
            var t = this._args,
                n = this._executer,
                r = n.isContainer() ? n : n.container,
                i = e + "AiArg";
            return t[e] ? t[e] : t[i] ? r.aiArg.getNumber(t[i]) : void 0
        }
    }, {
        getBuiltinFunction: function(e) {
            return r[e]
        }
    }), FF.ns.battle.ai.TransitCondition
}), define("scenes/battle/fsm/Transition", ["lib/EventBase"], function(e) {
    var t = {};
    return FF.ns.battle.fsm.Transition = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments), this.condition = null, this._params = t
        },
        getNextStateId: function() {
            return this._params.nextStateId
        },
        canTransition: function(e) {
            return _.all(this.condition, function(t) {
                return t.canTransition(e)
            })
        },
        update: function() {
            _.each(this.condition, function(e) {
                e.update()
            })
        },
        transit: function() {},
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        }
    }, {
        registerBuiltinFunction: function(e, n) {
            t[e] = n
        },
        getBuiltinFunction: function(e) {
            return t[e]
        }
    }), FF.ns.battle.fsm.Transition
}), define("scenes/battle/ai/Transition", ["../fsm/Transition"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.Transition = e.extend({
        initialize: function(t, n) {
            e.prototype.initialize.apply(this, arguments), this._executer = n
        },
        getNextStateId: function() {
            var e = this._params.nextStateLot,
                n, r;
            return e ? (n = this.parent.parent.globalRegister.stateIds, r = new t.LotteryBox(n, e), r.lot()) : this._params.nextStateId
        },
        reset: function() {
            _.each(this.condition, function(e) {
                e.reset()
            })
        }
    }), FF.ns.battle.ai.Transition
}), define("scenes/battle/ai/ConditionFlag", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.ConditionFlag = e.extend({
        initialize: function(t, n, r) {
            e.prototype.initialize.apply(this, arguments), this.condition = null, this._params = t, this._flagInCurrTransition = !1, this._flagInFrame = !1, this.listenTo(r, "StateMap::changeState", this._onChangeState)
        },
        _onChangeState: function(e, t) {
            this.parent.getStateId() === e && (this._flagInCurrTransition = !1, this._flagInFrame = !1, _.each(this.condition, function(e) {
                e.reset()
            }))
        },
        preUpdate: function() {
            var e = this.parent;
            _.each(this.condition, function(e) {
                e.update()
            });
            var t = _.all(this.condition, function(t) {
                return t.canTransition(e)
            });
            t ? (this._flagInCurrTransition = !0, this._flagInFrame = !0, _.each(this.condition, function(e) {
                e.reset()
            })) : this._flagInFrame = !1
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        getFlagInCurrTransition: function() {
            return this._flagInCurrTransition
        },
        getFlagInFrame: function() {
            return this._flagInFrame
        }
    }), FF.ns.battle.ai.ConditionFlag
}), define("scenes/battle/ai/ResultObjectTmp", ["lib/EventBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.ResultObjectTmp = e.extend({
        initialize: function(t, n, r) {
            e.prototype.initialize.apply(this, arguments), this._executer = n, this._params = t, this._args = t.args || {}, this._resultObjects = [], this.listenTo(r, "StateMap::changeState", this._onChangeState)
        },
        _onChangeState: function(e, t) {
            this.parent.getStateId() === e && (this._resultObjects = [])
        },
        postUpdate: function() {
            this._resultObjects = []
        },
        isInCurrentState: function() {
            return this.parent.isInCurrentState()
        },
        getResultObjects: function() {
            return this._resultObjects
        }
    }), FF.ns.battle.ai.ResultObjectTmp
}), define("scenes/battle/ai/resultObjectTmp/BoostResultObjectTmp", ["../ResultObjectTmp"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.resultObjectTmp.BoostResultObjectTmp = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = t.ai.AiUtil.getActor(this._executer, this._args.id),
                r = t.ai.AiUtil.getEventNameOfBoost();
            this.listenTo(n, r, this._conditionHook)
        },
        _conditionHook: function(e, t, n, r) {
            var i = {
                key: t,
                boostValue: n,
                options: r
            };
            this._resultObjects.push(i)
        }
    })
}), define("scenes/battle/ai/resultObjectTmp/DamageResultObjectTmp", ["../ResultObjectTmp"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.resultObjectTmp.DamageResultObjectTmp = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = t.ai.AiUtil.getActor(this._executer, this._args.id),
                r = t.ai.AiUtil.getEventNameOfApplyDamageObject(this._args.scope);
            this.listenTo(n, r, this._damageConditionHook)
        },
        _damageConditionHook: function(e, n) {
            var r = t.ai.AiUtil.checkConditionForDamageObject(this._args, e, n);
            r && this._resultObjects.push(n)
        }
    })
}), define("scenes/battle/ai/resultObjectTmp/BuddyDamageResultObjectTmp", ["../ResultObjectTmp"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.resultObjectTmp.BuddyDamageResultObjectTmp = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = t.ai.AiUtil.getEventNameOfApplyDamageObject(this._args.scope),
                r = this;
            _.each(t.ActorMgr.getAllBuddies(), function(e) {
                r.listenTo(e, n, r._damageConditionHook)
            })
        },
        _damageConditionHook: function(e, n) {
            var r = t.ai.AiUtil.checkConditionForDamageObject(this._args, e, n);
            r && this._resultObjects.push(n)
        }
    })
}), define("scenes/battle/ai/state/DoNothingState", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.DoNothingState = e.extend({
        update: function() {
            var e = this._executer,
                n = this._executer.isContainer() ? this._executer : this._executer.container,
                r = this._memberValues;
            r && r.id && (e = n.getChild(r.id)), e.isReadyToSelectAbility() && t.Commander.getInstance().register(t.Conf.ABILITY_ID_OF.DO_NOTHING, e)
        }
    })
}), define("scenes/battle/ai/state/DoNothingStrictlyState", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.DoNothingStrictlyState = e.extend({
        update: function() {
            var e = this._executer,
                n = this._executer.isContainer() ? this._executer : this._executer.container,
                r = this._memberValues;
            r && r.id && (e = n.getChild(r.id)), e.isReadyToSelectAbility() && t.Commander.getInstance().register(t.Conf.ABILITY_ID_OF.DO_NOTHING_STRICTLY, e)
        }
    })
}), define("scenes/battle/ai/state/InitState", ["util", "../State"], function(e, t) {
    FF.ns.battle.ai.state.InitState = t.extend({
        inState: function() {
            var n = [];
            this._memberValues.visible && n.push(t.getBuiltinFunction("ENABLE")), this._memberValues.overrideActorParam && n.push(t.getBuiltinFunction("OVERRIDE_ACTOR_PARAM")), (this._memberValues.paramId || this._memberValues.paramSuffixNo) && n.push(t.getBuiltinFunction("CHANGE_PARAM")), this._memberValues.childParams && n.push(t.getBuiltinFunction("CHANGE_PARAM_MULTI")), this._memberValues.sa && n.push(t.getBuiltinFunction("SET_SA"));
            var r = this._executer,
                i = r.isContainer() ? r : r.container;
            this._memberValues.id && (r = r.getChild(this._memberValues.id)), this._memberValues.deadAnimateType && n.push(t.getBuiltinFunction("SET_DEAD_ANIMATE_TYPE")), this._memberValues.optionalCounterCheckType && n.push(t.getBuiltinFunction("SET_OPTIONAL_COUNTER_CHECK_TYPE")), this._memberValues.abilityDeformMap && n.push(t.getBuiltinFunction("CHANGE_ABILITY_DEFORM_MAP")), this._memberValues.abilityDeformMapTag && n.push(t.getBuiltinFunction("CHANGE_ABILITY_DEFORM_MAP_TAG")), n.push(function() {});
            var s = e.makeInterceptor(this, n);
            s()
        },
        updateTransition: function() {
            return this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/InterruptAbility", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.InterruptAbility = e.extend({
        inState: function() {
            var e = this._memberValues.abilityId,
                n = this._memberValues.abilityTag,
                r = _.extend({}, this._memberValues.abilityOptions),
                i = this._memberValues.options,
                s = this._executer,
                o = s.isContainer() ? s : s.container;
            r.id && (s = o.getChild(r.id)), r.activeTargetId && (r.activeTarget = o.getChild(r.activeTargetId)), n ? e = s.getAbilityIdByTag(n) : e || (e = s.lotAbility()), this._memberValues.shouldRegisterAbilityFromActor ? this._ability = s.registerInterruptAbility(e, r, i) : (i || (i = {
                interruptBoss: !0
            }), this._ability = t.Commander.getInstance().register(e, s, r, i))
        },
        outState: function() {
            this._ability = void 0
        },
        updateTransition: function() {
            if (this._ability && this._ability.isDone()) return this._ability = void 0, this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/InterruptMultipleAbility", ["../State"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.state.InterruptMultipleAbility = e.extend({
        initialize: function(t) {
            e.prototype.initialize.apply(this, arguments);
            if (_.isUndefined(this._memberValues.nextStateId)) throw new Error("InterruptMultipleAbility: memberValues.nextStateId must be specified")
        },
        inState: function() {
            this._isDone = !1, this._abilityNum = 1, this.registerCurrentAbility()
        },
        shiftNextAbility: function() {
            return this._abilityNum++, this._abilityNum <= this._memberValues.abilityCount
        },
        registerCurrentAbility: function() {
            var e = this._memberValues.abilitySettingMap ? this._memberValues.abilitySettingMap[this._abilityNum] : {},
                n = e.abilityId,
                r = e.abilityTag,
                i = _.extend({}, e.abilityOptions),
                s = e.options,
                o = this._executer,
                u = this._executer.isContainer() ? this._executer : this._executer.container;
            i.id && (o = o.getChild(i.id)), i.activeTargetId && (i.activeTarget = u.getChild(i.activeTargetId));
            if (r) n = o.getAbilityIdByTag(r);
            else if (!n)
                if (e.useFuncOfLotAbilityWithout) {
                    var a = o.getWithoutAbilityList({});
                    n = o.lotAbilityWithout(a)
                } else n = o.lotAbility();
            this._memberValues.shouldRegisterAbilityFromActor || i.shouldRegisterAbilityFromActor ? this._ability = o.registerInterruptAbility(n, i, s) : (s || (s = {
                interruptBoss: !0
            }), this._ability = t.Commander.getInstance().register(n, o, i, s))
        },
        update: function() {
            this._ability && this._ability.isDone() && (this.shiftNextAbility() ? this.registerCurrentAbility() : this._isDone = !0)
        },
        updateTransition: function() {
            if (this._isDone) return this._ability = void 0, this._memberValues.nextStateId
        }
    })
}), define("scenes/battle/ai/state/SimpleState", ["../State"], function(e) {
    FF.ns.battle.ai.state.SimpleState = e.extend({
        update: function() {
            var e = this._executer;
            e.isReadyToSelectAbility() && e.lotAndRegisterAbility()
        }
    })
}), define("scenes/battle/ai/state/SimpleWithoutState", ["../State"], function(e) {
    FF.ns.battle.ai.state.SimpleWithoutState = e.extend({
        update: function() {
            var e = this._executer;
            if (e.isReadyToSelectAbility()) {
                var t = {};
                this._memberValues && this._memberValues.withoutOptions && _.extend(t, this._memberValues.withoutOptions), e.withoutAndLotAndRegisterAbility(t)
            }
        }
    })
}), define("scenes/battle/ai/transition/NextStateIdTransition", ["../Transition"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.ai.transition.NextStateIdTransition = e.extend({
        getNextStateId: function() {
            return this.parent.getNextStateId()
        },
        canTransition: function(e, t) {
            return !!this.parent.getNextStateId()
        }
    }), FF.ns.battle.ai.transition.NextStateIdTransition
}), define("scenes/battle/ai/transitCondition/AbilityCountTransitCondition", ["../TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.AbilityCountTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._executer,
                n = this._args;
            if (!n.count) throw new Error("count is required");
            if (!(n.anyAbilities || n.abilityId || n.abilityTag || n.mainAbilityTag)) throw new Error("abilityId, abilityTag, mainAbilityTag, or anyAbilities is required");
            n.id && (t = t.getChild(n.id));
            var r = "ActorBase::entryInAction";
            !n.whenDone || (r = "ActorBase::exitInAction"), this.listenTo(t, r, this._onAction), this.reset()
        },
        reset: function() {
            this._can = !1, this._count = 0
        },
        canTransition: function(e) {
            return this._can
        },
        _onAction: function(e) {
            if (!this.isInCurrentState()) return;
            this._args.anyAbilities ? this._count++ : this._countCondAbility(e), this._count >= this._args.count && (this._can = !0, this._args && this._args.rate && (this._can = t.lotByFraction(this._args.rate), this._can || (this._count = 0)))
        },
        _countCondAbility: function(e) {
            var t = this._retrieveAbility(e),
                r = t.get("abilityId"),
                i = this._args.abilityId;
            if (this._args.abilityTag) {
                var s = _.isArray(this._args.abilityTag) ? this._args.abilityTag : [this._args.abilityTag];
                i = _.map(s, function(t) {
                    return e.getAbilityIdByTag(t)
                }, this)
            }
            if (this._args.mainAbilityTag) {
                var o = _.isArray(this._args.mainAbilityTag) ? this._args.mainAbilityTag : [this._args.mainAbilityTag];
                i = _.map(o, function(t) {
                    return e.getAbilityIdByTag(t)
                }, this), r = n.ai.AiUtil.retrieveMainAbilityId(t)
            }
            if (i) {
                var u = _.isArray(i) ? i : [i];
                _.any(u, function(e) {
                    return r === e
                }) && this._count++
            }
        },
        _retrieveAbility: function(e) {
            var t = e.getAbility();
            return !this._args.whenDone || (t = e.getLastAbility()), t
        }
    })
}), define("scenes/battle/ai/transitCondition/DamageTransitCondition", ["../TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.ai.transitCondition.DamageTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._executer,
                n = this._args;
            n.id && (t = t.getChild(n.id));
            var r = void 0;
            switch (n.scope) {
                case "SET_SA":
                    r = "ActorBase::addStatusAilments";
                    break;
                case "UNSET_SA":
                    r = "ActorBase::unsetStatusAilments";
                    break;
                case "ANY":
                    r = "ActorBase::applyDamageObject";
                    break;
                default:
                    r = "ActorBase::addDamage"
            }
            this.listenTo(t, r, this._damageConditionHook), this.reset()
        },
        reset: function() {
            this._can = !1
        },
        canTransition: function(e) {
            return this._can
        },
        _damageConditionHook: function(e, t) {
            if (!this.isInCurrentState()) return;
            if (this._can) return;
            this._onDamage(e, t)
        },
        _onDamage: function(e, r) {
            var i = r.ability,
                s = this._args,
                o = this._executer;
            s.id && (o = o.getChild(s.id));
            if (s.counter && !n.util.DamageCalculator.isEnableCounter(r)) return;
            var u = !1;
            s.all && (u = !0), s.canHit && r.canHit && (u = !0), s.element && n.Conf.ELEMENT_TYPE[s.element] === r.element && (u = !0), s.elements && _.any(s.elements, function(e) {
                return e === r.element
            }) && (u = !0);
            if (s.elementsOrPossibleElements) {
                var a = [r.element].concat(r.possibleElements),
                    f = _.intersection(s.elementsOrPossibleElements, a);
                _.isEmpty(f) || (u = !0)
            }
            s.exercise && !!i && n.Conf.EXERCISE_TYPE[s.exercise] === i.exerciseType() && (u = !0), s.exercises && _.any(s.exercises, function(e) {
                return !!i && e === i.get("exerciseType")
            }) && (u = !0), s.abilityCategoryIds && !!i && !!i.get("categoryId") && _.any(s.abilityCategoryIds, function(e) {
                return e === i.get("categoryId")
            }) && (u = !0), s.targetRange && !!i && s.targetRange === i.get("targetRange") && (u = !0), s.abilityIds && _.any(s.abilityIds, function(e) {
                return !!i && e === i.get("abilityId")
            }) && (u = !0), s.abilityTags && r.executer.isEnemy() && _.any(s.abilityTags, function(e) {
                return o.getAbilityIdByTag(e) === i.get("abilityId")
            }) && (u = !0), s.evaluateFlgName && r[s.evaluateFlgName] && (u = !0);
            if (s.setSaIds) {
                var l = [].concat(s.setSaIds),
                    c = r.statusAilments || [];
                c = _.map(c, function(e) {
                    return Number(e)
                }), _.intersection(l, c).length > 0 && (u = !0)
            }
            if (s.unsetSaIds) {
                var h = [].concat(s.unsetSaIds),
                    p = r.unsetStatusAilments || [];
                p = _.map(p, function(e) {
                    return Number(e)
                }), _.intersection(h, p).length > 0 && (u = !0)
            }
            s.buddyId && r.executer.getId() !== s.buddyId && (u = !1), n.util.DamageCalculator.isCalcTypeRadiantShield(r.type) && (u = !1);
            if (s.damagedOnly)
                if (s.ignorePoison === !0 && n.util.DamageCalculator.isCalcTypePoison(r.type)) u = !1;
                else if (_.isNumber(r.damage)) {
                var d = s.damagedOnlyOptions || {},
                    v = !1;
                _.isNumber(d.under) ? v = r.damage < d.under : _.isNumber(d.underOrEqual) ? v = r.damage <= d.underOrEqual : _.isNumber(d.over) ? v = r.damage > d.over : _.isNumber(d.overOrEqual) ? v = r.damage >= d.overOrEqual : v = r.damage > 0, v || (u = !1)
            } else u = !1;
            s.canDoAbility && (o.canDoAbility() || (u = !1)), s.ignoreCounterAbilities && !!i && i.get("isCounter") && (u = !1), u && (s.rate ? this._can = t.lotByFraction(s.rate) : this._can = !0)
        }
    }), FF.ns.battle.ai.transitCondition.DamageTransitCondition
}), define("scenes/battle/ai/transitCondition/EachDamageTransitCondition", ["./DamageTransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.EachDamageTransitCondition = e.extend({
        _damageConditionHook: function(e, t) {
            this.reset();
            if (!this.isInCurrentState()) return;
            this._onDamage(e, t)
        }
    })
}), define("scenes/battle/ai/transitCondition/DamageTransitConditionV2", ["../TransitCondition", "util"], function(e, t) {
    var n = FF.ns.battle;
    return FF.ns.battle.ai.transitCondition.DamageTransitConditionV2 = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._executer,
                r = this._args;
            r.id && (t = t.getChild(r.id));
            var i = n.ai.AiUtil.getEventNameOfApplyDamageObject(this._args.scope);
            this.listenTo(t, i, this._damageConditionHook), this.reset()
        },
        reset: function() {
            this._can = !1
        },
        canTransition: function(e) {
            return this._can
        },
        _damageConditionHook: function(e, t) {
            if (!this.isInCurrentState()) return;
            if (this._can) return;
            this._onDamage(e, t)
        },
        _onDamage: function(e, t) {
            this._can = n.ai.AiUtil.checkConditionForDamageObject(this._args, e, t)
        }
    }), FF.ns.battle.ai.transitCondition.DamageTransitConditionV2
}), define("scenes/battle/ai/transitCondition/TimeTransitCondition", ["../TransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.TimeTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.reset()
        },
        update: function() {
            this._elapsedTime += FF.scene.elapsedBattleTime
        },
        reset: function() {
            this._elapsedTime = 0
        },
        canTransition: function(e, t) {
            var n = this._args.sec;
            if (this._args.secAiArg) {
                var r = this._executer,
                    i = r.isContainer() ? r : r.container;
                n = i.aiArg.getNumber(this._args.secAiArg)
            }
            return this._elapsedTime >= n * 1e3
        }
    })
}), define("scenes/battle/ai/transitCondition/TurnTransitCondition", ["../TransitCondition"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.ai.transitCondition.TurnTransitCondition = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var t = this._args,
                n = this._executer;
            t.id && (n = n.getChild(t.id)), this.listenTo(n, "ActorBase::changeState", this._onChangeState), this.reset()
        },
        reset: function() {
            this._can = !1, this._box = void 0, this._elapsedTurn = 0;
            var e = this._args;
            e.lot && (this._box = new t.LotteryBox([!0, !1], e.lot))
        },
        canTransition: function(e, t) {
            return this._can
        },
        _onChangeState: function(e, t, n) {
            if (!this.isInCurrentState()) return;
            if (n !== "IN_ACTION") return;
            this._elapsedTurn++;
            var r = this._args;
            this._box && (this._can = this._box.lot()), r.turn > 0 && r.turn <= this._elapsedTurn && (this._can = !0);
            if (r.turnAiArg) {
                var i = this._executer,
                    s = i.isContainer() ? i : i.container,
                    o = s.aiArg.getNumber(r.turnAiArg);
                o <= this._elapsedTurn && (this._can = !0)
            }
        }
    })
}), define("scenes/battle/materia/MateriaHelper", ["util", "lib/EventBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.MateriaHelper = t.extend({
        initialize: function(e) {
            t.prototype.initialize.apply(this, arguments), this._materia = e
        },
        inflictSa: function(e, t) {
            this.inflictSaMulti([e], t)
        },
        inflictSaMulti: function(e, t) {
            t = t || {};
            var r = this._materia,
                i = r.executer,
                s = n.util.DamageCalculator.makeDamageObject(i, i, void 0, {
                    statusAilments: e,
                    statusAilmentsOptions: t
                });
            i.applyDamageObject(s)
        },
        inflictParam: function(t) {
            var r = this._materia,
                i = r.executer,
                s = n.Config.getInstance().get("MateriaParamConfig"),
                o = s[t];
            if (!o) throw new Error("param config not found.id=".configId);
            var u = [];
            for (var a = 0, f = o.length; a < f; a++) {
                var l = e.cloneDeep(o[a]),
                    c = void 0,
                    h = void 0,
                    p = l.paramName,
                    d = i.get(p);
                if (!_.has(l, "rate")) throw new Error("invalid ParamMateria boostObj");
                l.rate = l.rate;
                var v = i.setBoost(p, l.rate);
                u.push(v), FF.logger.debug("PARAM_MATERIA", d, c)
            }
            return u
        },
        resetParam: function(e) {
            var t = this._materia,
                n = t.executer;
            _.each(e, function(e) {
                n.resetParam(e)
            })
        },
        matchesForDamageHook: function(e, t) {
            var r = this._materia,
                i = e.ability,
                s = r.get("conditionType"),
                o = r.get("conditionValue");
            switch (s) {
                case n.Conf.MATERIA_CONDTION_TYPE.ABILITY_ID:
                    if (o === i.get("abilityId")) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.ELEMENT:
                    if (o === t.element) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.EXERCISE:
                    if (o === i.exerciseType()) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.ALL:
                    return !0;
                case n.Conf.MATERIA_CONDTION_TYPE.FLIGHT:
                    if (t.isFlightAttack) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.ABILITY_CATEGORY_ID:
                    if (o === i.get("categoryId")) return !0;
                    break;
                case n.Conf.MATERIA_CONDTION_TYPE.REMAINING_HP_RATE:
                    if (r.executer.getRemainingHpRate() <= o) return !0;
                    break;
                default:
                    throw new Error("invalid materia condition type=" + s)
            }
            return !1
        },
        matchesForCalcTypeCond: function(e, t) {
            var r = n.Config.getInstance().get("MateriaCalcTypeCond", t);
            return _.contains(r, e)
        },
        isAllowableTypesWithParams: function(t) {
            t = e.option({
                exerciseType: void 0,
                calcType: void 0
            }, t);
            var r = this._materia.get("allowableTypesId");
            if (!r) return !1;
            var i = n.Config.getInstance().get("MateriaAllowableTypesConfig", r);
            if (_.isUndefined(i) || !_.isObject(i)) throw new Error("undefined materia allowable types. ID:" + r);
            return _.all(i, function(e, n) {
                switch (n) {
                    case "exerciseTypes":
                        return _.contains(e, t.exerciseType);
                    case "calcTypes":
                        return _.contains(e, t.calcType);
                    default:
                        return !1
                }
            })
        },
        calcResultDamageByFactor: function(e, t, r) {
            var i = {};
            return r && (i = {
                maxDamageThresholdType: r.get("maxDamageThresholdType"),
                minDamageThresholdType: r.get("minDamageThresholdType")
            }), n.util.DamageCalculator.getAllowableDamage(Math.floor(e * t / 100), i)
        },
        lotAndSwapPanelAttackAbility: function(t, r) {
            r = e.option({
                abilityId: void 0
            }, r);
            var i = this._materia,
                s = i.executer,
                o = i.get("abilityId");
            r.abilityId && (o = r.abilityId);
            var u = i.get("swapAbilitySsPoint"),
                a = t.abilityPanel,
                f = a.get("receptorId"),
                l = t.result;
            if (f !== n.Conf.RECEPTOR.PANEL_ATTACK) return;
            if (l.abilityId) return;
            if (s.isIncontrollable()) return;
            if (!e.lotByFraction(i.get("rate"))) return;
            if (!i.get("ignoresSmartTargeting")) {
                var c = n.util.Targeting.searchByAbilityInfo(n.AbilityInfoMgr.getInstance().getById(o), s),
                    h = _.any(c, function(e) {
                        var t = e.receiver;
                        return n.util.EnemyTargeting.isEnableTargetForBuddy(s, o, t)
                    });
                if (!h) return
            }
            l.abilityId = o, l.swapAbilitySsPoint = u
        }
    })
}), define("scenes/battle/materia/MateriaBase", ["lib/NameConventionFsm"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.materia.MateriaBase = e.extend({
        initialize: function(n, r) {
            e.prototype.initialize.apply(this, arguments), this.executer = n, this._attributes = _.extend({}, r), this.helper = new t.materia.MateriaHelper(this), this._resumeData = {}
        },
        update: function() {},
        getSlot: function() {
            return this.get("slot")
        },
        notify: function(e, t) {},
        getDamageFactorByElement: function(e) {
            return t.Config.getInstance().get("MateriaBaseDamageFactor")
        },
        toPlainObject: function() {
            return this._resumeData
        },
        applyPlainObject: function(e) {
            _.extend(this._resumeData, e)
        }
    }), FF.ns.battle.materia.MateriaBase
}), define("scenes/battle/materia/FirstAttackMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.FirstAttackMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("prob", this.get("arg1"))
        },
        notify: function(t) {
            var r = this.executer;
            if (t !== n.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND) return;
            FF.logger.debug("FirstAttackMateria"), e.lotByFraction(this.get("prob")) && r.set("elapsedAtbTime", r.getAtbTime() - 1)
        }
    })
}), define("scenes/battle/materia/PanelNumMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("exerciseType", this.get("arg2")), this.set("recoverRate", this.get("arg3"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!e.equalsExerciseType(this.get("exerciseType"))) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateria")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelNumMateriaByCategory", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateriaByCategory = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("categoryId", this.get("arg2")), this.set("recoverRate", this.get("arg3"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!e.equalsCategoryId(this.get("categoryId"))) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateriaByCategory")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelNumMateriaByMultiCategory", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelNumMateriaByMultiCategory = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("num", this.get("arg1")), this.set("recoverRate", this.get("arg2"));
            var e = [];
            _.times(3, function(t) {
                var n = this.get("arg" + (t + 3));
                n && e.push(n)
            }, this), this.set("categoryIds", e)
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND ? !1 : this._resumeData.isDone ? !1 : !0
        },
        notify: function(t, n) {
            if (!this._should(t)) return;
            var r = this.executer,
                i = e.lotByFraction(this.get("recoverRate"));
            _.each(r.getAbilityPanels(), function(e) {
                if (!e.isCommandPanel()) return;
                if (!_.include(this.get("categoryIds"), e.get("abilityInfo").categoryId)) return;
                if (!i) return;
                var t = _.min([e.get("remainNum") + this.get("num"), e.get("maxNum")]);
                e.set("remainNum", t), FF.logger.debug("PanelNumMateriaByCategory")
            }, this), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/PanelSwapMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelSwapMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("abilityId", this.get("arg2")), this.set("swapAbilitySsPoint", this.get("arg3")), this.set("ignoresSmartTargeting", !0)
        },
        notify: function(e, t) {
            if (e !== r.ABILITY_PANEL) return;
            this.helper.lotAndSwapPanelAttackAbility(t)
        }
    })
}), define("scenes/battle/materia/PanelSwapAbilityInfoMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelSwapAbilityInfoMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("abilityId", this.get("arg2")), this.set("swapAbilitySsPoint", this.get("arg3"))
        },
        notify: function(e, t) {
            if (e !== r.ABILITY_PANEL) return;
            this.helper.lotAndSwapPanelAttackAbility(t)
        }
    })
}), define("scenes/battle/materia/PanelRandomSwapMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelRandomSwapMateria = t.extend({
        initialize: function() {
            var e = this;
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("swapAbilitySsPoint", this.get("arg2"));
            var n = [],
                r = [],
                i = ["arg3", "arg4", "arg5"];
            _.each(i, function(t) {
                e.get(t) !== 0 && (n.push(e.get(t)), r.push(1))
            }), this.set("abilityIds", n), this.set("abilityLot", r), this.set("ignoresSmartTargeting", !0)
        },
        notify: function(e, t) {
            if (e !== r.ABILITY_PANEL) return;
            var i = new n.LotteryBox(this.get("abilityIds"), this.get("abilityLot"));
            this.helper.lotAndSwapPanelAttackAbility(t, {
                abilityId: i.lot()
            })
        }
    })
}), define("scenes/battle/materia/PanelSwapAndInflictSaMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.PanelSwapAndInflictSaMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("abilityId", this.get("arg2")), this.set("swapAbilitySsPoint", this.get("arg3")), this.set("statusAilmentsId", this.get("arg4"))
        },
        notify: function(e, t) {
            this.notifyPanelSwap(e, t), this.notifyInflictSa(e, t)
        },
        notifyPanelSwap: function(e, t) {
            if (e !== r.ABILITY_PANEL) return;
            this.helper.lotAndSwapPanelAttackAbility(t)
        },
        notifyInflictSa: function(e, t) {
            if (!this._shouldInflictSa(e)) return;
            this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDoneInflictSa = !0
        },
        _shouldInflictSa: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDoneInflictSa ? !1 : !0
        }
    })
}), define("scenes/battle/materia/ParamMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should.apply(this, arguments)) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/ParamAndInflictSaMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamAndInflictSaMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("statusAilmentsId", this.get("arg2"))
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should(e)) return;
            this.helper.inflictParam(this.get("configId")), this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/InflictSaMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.InflictSaMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments);
            var e = [];
            this.get("arg3") > 0 && (e = n.StatusAilmentsConfig.getBundle(this.get("arg3")));
            var r = _.compact(_.flatten([this.get("arg1"), e]));
            this.set("saIds", r), this.get("arg2") > 0 && this.set("statusAilmentsOptions", {
                infoMap: {
                    duration: this.get("arg2")
                }
            })
        },
        _should: function(e) {
            return e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE ? !1 : e === r.SETUP_ROUND && this._resumeData.isDone ? !1 : !0
        },
        notify: function(e) {
            if (!this._should(e)) return;
            var t = this.get("statusAilmentsOptions") || {};
            this.helper.inflictSaMulti(this.get("saIds"), t), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/InflictSaWhenHpFallsMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.InflictSaWhenHpFallsMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("hpRate", this.get("arg1")), this.set("statusAilmentsId", this.get("arg2"))
        },
        update: function() {
            if (this._resumeData.isDone) return;
            var e = this.executer,
                t = e.get("hp"),
                n = e.get("maxHp");
            Math.ceil(t / n * 100) <= this.get("hpRate") && (this.helper.inflictSa(this.get("statusAilmentsId")), this._resumeData.isDone = !0)
        }
    })
}), define("scenes/battle/materia/DamageBoostWhenWeaknessMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostWhenWeaknessMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.result,
                o = t.data.ability,
                u = s.damage || 0;
            if (!s.canHit || u <= 0) return;
            var a = this.getDamageFactorByElement({
                    isWeakness: s.isWeakness
                }),
                f = n.Config.getInstance().get("MateriaBaseDamageFactor");
            if (a === f) return;
            s.damage = this.helper.calcResultDamageByFactor(u, a, o), FF.logger.debug("DamageBoostWhenWeaknessMateria", "dmg", s.damage, "dmg_old", u, "factor", a)
        },
        getDamageFactorByElement: function(e) {
            var t = n.Config.getInstance().get("MateriaBaseDamageFactor");
            return e.isWeakness ? this.get("factor") || t : t
        }
    })
}), define("scenes/battle/materia/DamageBoostElementMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostElementMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("element", this.get("arg2"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.result,
                o = t.data.ability,
                u = s.damage || 0;
            if (!s.canHit || u <= 0) return;
            var a = this.getDamageFactorByElement({
                    element: s.element
                }),
                f = n.Config.getInstance().get("MateriaBaseDamageFactor");
            if (a === f) return;
            s.damage = this.helper.calcResultDamageByFactor(u, a, o), FF.logger.debug("DamageBoostElementMateria", "dmg", s.damage, "dmg_old", u, "factor", a)
        },
        getDamageFactorByElement: function(e) {
            var t = n.Config.getInstance().get("MateriaBaseDamageFactor");
            return e.element !== this.get("element") ? t : this.get("factor") || t
        }
    })
}), define("scenes/battle/materia/DamageBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.result,
                o = t.data.ability,
                u = s.damage || 0,
                a = this.get("factor") || 100,
                f = s.type;
            if (!s.canHit || u <= 0) return;
            var l = i.get("weapon");
            if (l.categoryId !== this.get("weaponCategoryId")) return;
            if (f !== n.Conf.CALC_TYPE.ATTACK) return;
            var c = t.data.ability.get("exerciseType");
            if (c !== n.Conf.EXERCISE_TYPE.PHYSICAL) return;
            s.damage = this.helper.calcResultDamageByFactor(u, a, o), FF.logger.debug("DamageBoostByWeaponMateria", "dmg", s.damage, "dmg_old", u, "factor", a)
        }
    })
}), define("scenes/battle/materia/BlackMagicDamageBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.BlackMagicDamageBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.data.ability,
                o = t.result,
                u = o.damage || 0,
                a = this.get("factor") || 100,
                f = o.type;
            if (!o.canHit || u <= 0) return;
            var l = i.get("weapon");
            if (l.categoryId !== this.get("weaponCategoryId")) return;
            if (f !== n.Conf.CALC_TYPE.MAGIC) return;
            var c = s.get("exerciseType");
            if (c !== n.Conf.EXERCISE_TYPE.BLACK_MAGIC) return;
            o.damage = this.helper.calcResultDamageByFactor(u, a, s), FF.logger.debug("BlackMagicDamageBoostByWeaponMateria", "dmg", o.damage, "dmg_old", u, "factor", a)
        }
    })
}), define("scenes/battle/materia/DamageBoostByEquipmentAndExerciseTypeMateria", ["underscore", "util", "./MateriaBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = r.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostByEquipmentAndExerciseTypeMateria = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("equipmentCategoryId", this.get("arg2")), this.set("exerciseType", this.get("arg3"))
        },
        notify: function(t, n) {
            var r = this.executer;
            if (t !== i.DAMAGE_HOOK) return;
            var s = n.result,
                o = s.damage || 0,
                u = this.get("factor") || 100,
                a = s.type;
            if (!s.canHit || o <= 0) return;
            var f = +r.get("weapon").categoryId,
                l = +r.get("armor").categoryId;
            if (!e.contains([f, l], +this.get("equipmentCategoryId"))) return;
            var c = n.data.ability.get("exerciseType");
            if (c !== this.get("exerciseType")) return;
            s.damage = this.helper.calcResultDamageByFactor(o, u), FF.logger.debug("DamageBoostByEquipmentAndExerciseTypeMateria", "dmg", s.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/DamageBoostAbilityMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostAbilityMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("conditionType", this.get("arg2")), this.set("conditionValue", this.get("arg3"))
        },
        notify: function(e, t) {
            var i = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var s = t.data,
                o = s.ability,
                u = t.result,
                a = u.damage || 0;
            if (!u.canHit || a <= 0) return;
            var f = this.getDamageFactorByElement({
                    matchesData: s,
                    matchesDamageObject: u
                }),
                l = n.Config.getInstance().get("MateriaBaseDamageFactor");
            if (f === l) return;
            u.damage = this.helper.calcResultDamageByFactor(a, f, o), FF.logger.debug("DamageBoostAbilityMateria", "dmg", u.damage, "dmg_old", a, "factor", f)
        },
        getDamageFactorByElement: function(e) {
            var t = n.Config.getInstance().get("MateriaBaseDamageFactor");
            return this.helper.matchesForDamageHook(e.matchesData, e.matchesDamageObject) ? this.get("factor") || t : t
        }
    })
}), define("scenes/battle/materia/DamageBoostByWeaponWithAllowableTypesMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageBoostByWeaponWithAllowableTypesMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2")), this.set("allowableTypesId", this.get("arg3"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.result,
                s = t.data.ability,
                o = i.damage || 0,
                u = this.get("factor") || 100,
                a = i.type;
            if (!i.canHit || o <= 0) return;
            var f = n.get("weapon");
            if (f.categoryId !== this.get("weaponCategoryId")) return;
            var l = {
                exerciseType: t.data.ability.get("exerciseType"),
                calcType: a
            };
            if (!this.helper.isAllowableTypesWithParams(l)) return;
            i.damage = this.helper.calcResultDamageByFactor(o, u, s), FF.logger.debug("DamageBoostByWeaponWithAllowableTypesMateria", "dmg", i.damage, "dmg_old", o, "factor", u)
        }
    })
}), define("scenes/battle/materia/HealBoostMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.HealBoostMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("factor", this.get("arg1")), this.set("conditionType", this.get("arg2")), this.set("conditionValue", this.get("arg3"))
        },
        notify: function(e, t) {
            var n = this.executer;
            if (e !== r.DAMAGE_HOOK) return;
            var i = t.data,
                s = t.result,
                o = s.damage || 0,
                u = i.ability,
                a = this.get("factor") || 100;
            if (!s.canHit || o >= 0 || s.isAbilityPanel) return;
            if (!this.helper.matchesForDamageHook(i, s)) return;
            s.damage = this.helper.calcResultDamageByFactor(o, a, u), FF.logger.debug("HealBoostMateria", "dmg", s.damage, "dmg_old", o, "factor", a)
        }
    })
}), define("scenes/battle/materia/CounterMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.CounterMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("prob", this.get("arg1")), this.set("condType", this.get("arg2")), this.set("condValue", this.get("arg3")), this.set("factor", this.get("arg4")), this.set("abilityId", this.get("arg5"))
        },
        notify: function(e, t) {
            if (e === r.SETUP_ROUND) return this._notifySetupRound(t);
            if (e === r.DAMAGE_HOOK) return this._notifyDamageHook(t)
        },
        _notifyDamageHook: function(e) {
            var t = this.executer,
                n = e.result,
                r = n.damage || 0,
                i = this.get("factor") || 100,
                s = e.data.ability;
            if (!n.canHit || r <= 0) return;
            if (!s.get("isCounter")) return;
            if (s.get("abilityId") !== this._getAbilityId()) return;
            n.damage = this.helper.calcResultDamageByFactor(r, i, s), FF.logger.debug("CounterMateria", "dmg", n.damage, "dmg_old", r, "factor", i)
        },
        _notifySetupRound: function(e) {
            var t = this.executer;
            if (this._resumeData.isDone) return;
            if (!t.isBuddy()) return;
            var r = t.getReceptorById(n.Conf.RECEPTOR.PANEL_ATTACK),
                i = this._getAbilityId(),
                s = this.get("condType"),
                o = this.get("condValue"),
                u = this.get("prob"),
                a = {};
            a.priority = n.Config.getInstance().get("CounterPriority", "RECORD_MATERIA"), t.counters.add(i, s, o, u, a), FF.logger.debug("CounterMateria", "abilityId", i, "condType", s, "condValue", o, "prob", u, "priority", a.priority), this._resumeData.isDone = !0
        },
        _getAbilityId: function() {
            if (this.get("abilityId")) return this.get("abilityId");
            var e = this.executer.getReceptorById(n.Conf.RECEPTOR.PANEL_ATTACK);
            return e.get("abilityId")
        }
    })
}), define("scenes/battle/materia/ParamBoostInBuddyDeadMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostInBuddyDeadMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this._resumeData.attachParams = []
        },
        update: function() {
            var e = n.BuddyPartyMgr.getInstance().getMaxPartyNum() - n.ActorMgr.getAllBuddies().length,
                t = e + n.ActorMgr.getDeadBuddies().length - this._resumeData.attachParams.length;
            t !== 0 && (t > 0 ? this._inflictParams(t) : this._resetParams(Math.abs(t)))
        },
        _inflictParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this.helper.inflictParam(this.get("configId"));
                this._resumeData.attachParams.push(n)
            }
        },
        _resetParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this._resumeData.attachParams.shift();
                this.helper.resetParam(n)
            }
        },
        notify: function(e) {
            e === r.RESET_FOR_CONTINUE && (this._resumeData.attachParams = [])
        }
    })
}), define("scenes/battle/materia/ParamBoostInHpDecreaseMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE,
        i = 10;
    FF.ns.battle.materia.ParamBoostInHpDecreaseMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this._resumeData.attachParams = []
        },
        update: function() {
            var e = i - Math.ceil(this.executer.getRemainingHpRate() / i),
                t = e - this._resumeData.attachParams.length;
            t !== 0 && (t > 0 ? this._inflictParams(t) : this._resetParams(Math.abs(t)))
        },
        _inflictParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this.helper.inflictParam(this.get("configId"));
                this._resumeData.attachParams.push(n)
            }
        },
        _resetParams: function(e) {
            for (var t = 0; t < e; t++) {
                var n = this._resumeData.attachParams.shift();
                this.helper.resetParam(n)
            }
        },
        notify: function(e) {
            e === r.RESET_FOR_CONTINUE && (this._resumeData.attachParams = [])
        }
    })
}), define("scenes/battle/materia/ParamBoostByArmorMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostByArmorMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("armorCategoryId", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE) return !1;
            if (e === r.SETUP_ROUND && this._resumeData.isDone) return !1;
            var n = t.get("armor");
            if (+n.categoryId !== this.get("armorCategoryId")) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/ParamBoostByWeaponMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.ParamBoostByWeaponMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("configId", this.get("arg1")), this.set("weaponCategoryId", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== r.SETUP_ROUND && e !== r.RESET_FOR_CONTINUE) return !1;
            if (e === r.SETUP_ROUND && this._resumeData.isDone) return !1;
            var n = t.get("weapon");
            if (+n.categoryId !== this.get("weaponCategoryId")) return;
            this.helper.inflictParam(this.get("configId")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/SoulStrikePointFactorBoostMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.materia.SoulStrikePointFactorBoostMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("atkSsPointFactorByMateria", this.get("arg1")), this.set("defSsPointFactorByMateria", this.get("arg2"))
        },
        notify: function(e) {
            var t = this.executer;
            if (e !== n.Conf.MATERIA_NOTIFY_TYPE.SETUP_ROUND) return;
            if (this._resumeData.isDone) return;
            t.set("atkSsPointFactorByMateria", this.get("atkSsPointFactorByMateria")), t.set("defSsPointFactorByMateria", this.get("defSsPointFactorByMateria")), this._resumeData.isDone = !0
        }
    })
}), define("scenes/battle/materia/SeqActionByCategoryMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.SeqActionByCategoryMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("rate", this.get("arg1")), this.set("categoryId", this.get("arg2")), this.set("conditionType", this.get("arg3")), this.set("conditionValue", this.get("arg4"))
        },
        notify: function(t, i) {
            if (t !== r.ACTION_EXIT) return;
            var s = i.ability,
                o = s.get("abilityId"),
                u = n.AbilityInfoMgr.getInstance().getById(o).categoryId;
            if (u !== this.get("categoryId") || s.get("isSoulStrike") || s.get("isSupporterSoulStrike")) return;
            if (!!this.get("conditionType") && !this.helper.matchesForDamageHook(i, i.result)) return;
            e.lotByFraction(this.get("rate")) && n.Commander.getInstance().register(o, this.executer, {}, {
                interruptCounter: !0
            })
        }
    })
}), define("scenes/battle/materia/DamageReduceMateria", ["util", "./MateriaBase"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.MATERIA_NOTIFY_TYPE;
    FF.ns.battle.materia.DamageReduceMateria = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.set("reduceFactor", this.get("arg1")), this.set("prob", this.get("arg2")), this.set("conditionType", this.get("arg3")), this.set("conditionValue", this.get("arg4"))
        },
        notify: function(t, n) {
            if (t !== r.RECIEVE_DAMAGE_HOOK) return;
            if (!e.lotByFraction(this.get("prob"))) return;
            var i = n.result,
                s = n.data,
                o = s.ability;
            if (!this.helper.matchesForDamageHook(s, i)) return;
            var u = n.data.type,
                a = this.helper.matchesForCalcTypeCond(u, "damageReduceMateria");
            if (!a) return;
            var f = i.damage || 0;
            if (!i.canHit || f <= 0) return;
            var l = this.get("reduceFactor") || 100;
            i.damage = this.helper.calcResultDamageByFactor(f, l, o);
            var c = _.isObject(i.absorbHp) ? i.absorbHp.damage : 0;
            c && (i.absorbHp.damage = this.helper.calcResultDamageByFactor(c, l, o)), FF.logger.debug("DamageReduceMateria", "dmg", i.damage, "dmg_old", f, "reduceFactor", l)
        }
    })
}), define("scenes/battle/recept/ReceptBase", ["underscore", "lib/ProtectParamsBase"], function(e, t) {
    return FF.ns.battle.recept.ReceptBase = t.extend({
        initialize: function(e) {
            t.prototype.initialize.call(this), this._actor = e, this.set("visible", !0)
        },
        load: function() {
            throw new Error("override plz.")
        },
        canRecept: function() {
            throw new Error("override plz.")
        },
        makeCommandFunc: function() {
            throw new Error("override plz.")
        },
        decreaseResources: function() {
            throw new Error("override plz.")
        }
    }), FF.ns.battle.recept.ReceptBase
}), define("scenes/battle/recept/AbilityPanel", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = ["remainNum"];
    FF.ns.battle.recept.AbilityPanel = e.extend({
        load: function(e) {
            var r = e.maxNum ? e.maxNum : null,
                i = t.Config.getInstance().get("DefaultAbilityPanels"),
                s = !!e.isSpare,
                o = e.receptorId ? e.receptorId : i[e.panelNo];
            if (!o) throw new Error("not detect receptorId");
            var u = null;
            if (!s) {
                u = e.panelNo ? e.panelNo : _.invert(i)[o];
                if (!u) throw new Error("not detect panelNo")
            }
            _.extend(this._attributes, {
                receptorId: o,
                panelNo: u,
                isInfinity: r === null,
                maxNum: r,
                defaultMaxNum: r,
                abilityId: e.abilityId,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId),
                abilitySsPoint: e.abilitySsPoint || 0,
                panelType: e.panelType || n.PANEL_TYPE.COMMAND
            }), this.set("remainNum", e.num), this.set("name", this._detectName(e)), s ? (this.set("visible", !1), this._actor.sparePanelReceptors[o] = this) : (this.set("visible", !0), this._actor.receptors[o] = this)
        },
        getProtectParams: function() {
            var t = e.prototype.getProtectParams.call(this);
            return _.union(t, r)
        },
        _detectName: function(e) {
            return e.name ? e.name : this.isDefensePanel() ? t.TextMaster.getInstance().get("B10040") : ""
        },
        isLocated: function() {
            return !!this.get("panelNo") && !!this.get("visible")
        },
        locate: function(e) {
            this.set("panelNo", e), this.set("visible", !0)
        },
        dislocate: function() {
            this.set("panelNo", null), this.set("visible", !1)
        },
        isInfinity: function() {
            return this.get("isInfinity")
        },
        isCommandPanel: function() {
            return this.get("panelType") === n.PANEL_TYPE.COMMAND
        },
        isDefensePanel: function() {
            return this.get("panelType") === n.PANEL_TYPE.DEFENSE
        },
        decreaseResources: function() {
            if (this.isInfinity()) return;
            var e = this.get("remainNum");
            this.set("remainNum", _.max([0, e - 1]))
        },
        equalsExerciseType: function(e) {
            return this.get("abilityInfo").exerciseType === e
        },
        equalsCategoryId: function(e) {
            return this.get("abilityInfo").categoryId === e
        },
        canRecept: function() {
            if (!this._actor.canUseAllMagic()) {
                var e = t.Config.getInstance().get("MagicExerciseTypes");
                if (_.contains(e, this.get("abilityInfo").exerciseType)) return !1
            }
            return this.isInfinity() ? !0 : this.get("remainNum") > 0
        },
        resetForContinue: function() {
            if (this.isInfinity()) return;
            var e = this.get("defaultMaxNum");
            this.set("maxNum", e), this.set("remainNum", e)
        },
        addConsumableNum: function(e) {
            if (this.isInfinity()) return;
            var t = this.get("maxNum") + e,
                n = this.get("remainNum") + e;
            this.set("maxNum", t), this.set("remainNum", n)
        },
        makeCommandFunc: function() {
            var e = this,
                r = e._actor,
                i = e.get("abilityId"),
                s = e.get("abilityInfo"),
                o = t.ActorMgr.getActiveTarget(),
                u = n.ABILITY_ID_OF.ATTACK === i,
                a = n.PANEL_TYPE.DEFENSE === this.get("panelType");
            FF.logger.debug("[] " + s.options.name + "");
            var f = {
                receptorId: this.get("receptorId")
            };
            a || (f.isAbilityPanel = !0, f.activeTarget = o);
            var l = {};
            r.materiaHolder.notify(t.Conf.MATERIA_NOTIFY_TYPE.ABILITY_PANEL, {
                abilityPanel: this,
                result: l
            });
            var c = r.getSwapAbilityByAttachedElement();
            return u && c ? i = c : l.abilityId && (i = l.abilityId), !l.swapAbilitySsPoint || (f.swapAbilitySsPoint = l.swapAbilitySsPoint),
                function() {
                    t.ActorMgr.clearActiveTarget(), FF.ns.battle.Commander.getInstance().register(i, r, f)
                }
        }
    })
}), define("scenes/battle/recept/Skip", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.recept.Skip = e.extend({
        load: function(e) {
            _.extend(this._attributes, e), this._actor.receptors[n.RECEPTOR.SKIP] = this
        },
        decreaseResources: function() {},
        canRecept: function() {
            var e = this,
                n = _.filter(t.ActorMgr.getReadyToSelectAbilityBuddies(), function(t) {
                    return e._actor.getUid() !== t.getUid()
                });
            return n.length > 0
        },
        makeCommandFunc: function() {
            var e = this._actor;
            return function() {
                t.ActorMgr.notifySkipAbility(e)
            }
        }
    })
}), define("scenes/battle/recept/SoulStrike", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle;
    return FF.ns.battle.recept.SoulStrike = e.extend({
        load: function(e) {
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                dispName: e.options.dispName,
                consumeSoulStrikePoint: e.options.consumeSoulStrikePoint,
                point: e.point,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId)
            }), this._actor.receptors[t.Conf.RECEPTOR.SOUL_STRIKE] = this
        },
        addPointAsExecuter: function(e) {
            var t = e.get("actionResult");
            if (!t) return;
            var n = _.flatten(t.damageObjects),
                r = _.any(n, function(e) {
                    return e.canHit
                }, this);
            if (!r) return;
            var i = _.any(n, function(e) {
                    return e.isWeakness
                }, this),
                s = this._calculateAbilitySsPoint(e, i);
            s > 0 && this.addPoint(s)
        },
        addPointAsReceiver: function(e) {
            if (e.isRecovery) return;
            var t = e.executer,
                n = e.receiver;
            if (!t || !n) return;
            if (!t.isEnemy() || !n.isBuddy()) return;
            var r = this._calculateDamagedSsPoint();
            r > 0 && this.addPoint(r)
        },
        addPoint: function(e) {
            var n = this.get("point"),
                r = n + e,
                i = t.Config.getInstance().get("SoulStrike", "maxSsPoint");
            r > i && (r = i), r < 0 && (r = 0), this.set("point", r)
        },
        makeCommandFunc: function() {
            var e = this,
                n = e._actor,
                r = e.get("abilityId"),
                i = t.ActorMgr.getActiveTarget();
            return function() {
                var e = {
                    isSoulStrike: !0,
                    activeTarget: i
                };
                t.ActorMgr.clearActiveTarget(), t.Commander.getInstance().register(r, n, e)
            }
        },
        canRecept: function() {
            var e = this.get("consumeSoulStrikePoint"),
                n = this._actor.getSoulStrike().get("point");
            if (n < e) return !1;
            if (!this._actor.canUseAllMagic()) {
                var r = t.Config.getInstance().get("MagicExerciseTypes");
                if (_.contains(r, this.get("abilityInfo").exerciseType)) return !1
            }
            return !0
        },
        decreaseResources: function() {
            var e = this.get("point"),
                t = this.get("consumeSoulStrikePoint");
            this.set("point", e - t)
        },
        _calculateAbilitySsPoint: function(e, n) {
            var r = t.Config.getInstance(),
                i = void 0,
                s = this._actor.getAtkSsPointFactor(),
                o = _.max([s + 100, 0]),
                u = n ? r.get("SoulStrike", "c") : 100,
                a = e.get("receptorId"),
                f = this._actor.getReceptorById(a);
            return i = f.get("abilitySsPoint"), e.get("swapAbilitySsPoint") >= 1 && (i = e.get("swapAbilitySsPoint")), Math.floor(i * (o / 100) * (u / 100))
        },
        _calculateDamagedSsPoint: function() {
            var e = t.Config.getInstance().get("SoulStrike", "damagedSsPoint"),
                n = this._actor.getDefSsPointFactor(),
                r = _.max([n + 100, 0]);
            return Math.floor(e * (r / 100))
        },
        replaceBaseInfo: function(e) {
            this.set("abilityId", e.get("abilityId")), this.set("name", e.get("name")), this.set("consumeSoulStrikePoint", e.get("consumeSoulStrikePoint")), this.set("abilityInfo", e.get("abilityInfo"))
        }
    }), FF.ns.battle.recept.SoulStrike
}), define("scenes/battle/recept/SoulStrikePanel", ["./SoulStrike"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.recept.SoulStrikePanel = e.extend({
        load: function(e) {
            var n = t.Config.getInstance().get("SoulStrikePanels"),
                r = n[e.slot];
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                dispName: e.options.dispName,
                consumeSoulStrikePoint: e.options.consumeSoulStrikePoint,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId),
                receptorId: r,
                slot: e.slot
            }), this._actor.receptors[r] = this
        },
        makeCommandFunc: function() {
            var e = this,
                t = this._actor.getSoulStrike();
            return function() {
                t.replaceBaseInfo(e), t.makeCommandFunc()()
            }
        },
        get: function(t) {
            if (t === "point") throw new Error("invalid access: SoulStrike point.");
            return e.prototype.get.call(this, t)
        }
    })
}), define("scenes/battle/recept/SupporterSoulStrike", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = ["restCount"];
    FF.ns.battle.recept.SupporterSoulStrike = e.extend({
        load: function(e) {
            _.extend(this._attributes, {
                abilityId: e.abilityId,
                name: e.options.name,
                abilityInfo: t.AbilityInfoMgr.getInstance().getById(e.abilityId)
            }), this.set("restCount", e.restCount), this._actor.receptors[t.Conf.RECEPTOR.SUPPORTER_SOUL_STRIKE] = this
        },
        getProtectParams: function() {
            var t = e.prototype.getProtectParams.call(this);
            return _.union(t, n)
        },
        makeCommandFunc: function(e) {
            var n = this,
                r = n.get("abilityId"),
                i = t.ActorMgr.getActiveTarget();
            return function() {
                var n = {
                    isSupporterSoulStrike: !0,
                    activeTarget: i
                };
                t.ActorMgr.clearActiveTarget(), t.Commander.getInstance().register(r, e, n)
            }
        },
        canRecept: function(e) {
            var t = this.get("restCount");
            return t < 1 ? !1 : !0
        },
        decreaseResources: function() {
            var e = this.get("restCount");
            this.set("restCount", e - 1)
        }
    })
}), define("scenes/battle/recept/PositiveIncontrollable", ["./ReceptBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf;
    FF.ns.battle.recept.PositiveIncontrollable = e.extend({
        load: function(e) {
            _.extend(this._attributes, e, {
                abilitySsPoint: 0
            }), this._actor.receptors[n.RECEPTOR.POSITIVE_INCONTROLLABLE] = this
        },
        decreaseResources: function() {},
        canRecept: function() {
            return !0
        },
        makeCommandFunc: function() {
            var e = this._actor,
                t = e.getAbilityInfoByPositiveIncontrollable(),
                r = t.abilityId,
                i = FF.ns.battle.AbilityInfoMgr.getInstance(),
                s = i.getById(r),
                o = _.extend({
                    receptorId: n.RECEPTOR.POSITIVE_INCONTROLLABLE,
                    isPositiveIncontrollable: !0,
                    shouldAddSsPoint: !0,
                    swapAbilitySsPoint: s.options.ssPoint
                }, t.abilityOptions);
            return function() {
                FF.ns.battle.Commander.getInstance().register(r, e, o)
            }
        }
    })
}), define("scenes/battle/util/DamageCalculator", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.CALC_TYPE.ATTACK] = "_calculateDamageByAttack", r[n.CALC_TYPE.MAGIC] = "_calculateDamageByMagic", r[n.CALC_TYPE.FRACTION] = "_calculateDamageByFraction", r[n.CALC_TYPE.SELF_DESTRUCTION] = "_calculateDamageBySelfDestruction", r[n.CALC_TYPE.FIXED_DAMAGE] = "_calculateFixedDamage", r[n.CALC_TYPE.DAMAGED_HP] = "_calculateDamageByDamagedHp", r[n.CALC_TYPE.HEAL] = "_calculateHealValue", r[n.CALC_TYPE.HEAL_SA] = "_calculateHealSa", r[n.CALC_TYPE.HEAL_DEATH] = "_calculateHealDeath", r[n.CALC_TYPE.POISON] = "_calculatePoison", r[n.CALC_TYPE.REGEN] = "_calculateRegen", r[n.CALC_TYPE.HP_BARTER] = "_calculateHpBarter", r[n.CALC_TYPE.STATUS_AILMENTS] = "_calculateStatusAilments", r[n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS] = "_calculatePhysicalStatusAilments", r[n.CALC_TYPE.DEALING_SS_POINT] = "_calculateDealingSsPoint", r[n.CALC_TYPE.ABILITY_PANEL] = "_calculateAbilityPanel", r[n.CALC_TYPE.ABILITY_PANEL_FIXED_DAMAGE] = "_calculateAbilityPanelFixedDamage", r[n.CALC_TYPE.FRACTION_HEAL] = "_calculateHealByFractionValue", r[n.CALC_TYPE.HEAL_HP_BY_DAMAGE_SUM] = "_calculateHealHpValueByDamageSum", r[n.CALC_TYPE.FIXED_HEAL_HP] = "_calculateFixedHealValue", r[n.CALC_TYPE.RADIANT_SHIELD] = "_calculateRadiantShield";
    var i = {};
    i[n.SITUATIONAL_RECALCULATE_DAMAGE_HOOK_TYPE.EXECUTER_REMAINING_HP_RATE] = function(e, n) {
        var r = n.executer,
            i = t.Config.getInstance().get("DamageCalculator", "SITUATIONAL_RECALCULATE_DAMAGE"),
            s = n.damage,
            o, u = r.getRemainingHpRate(),
            a = [{
                condition: function(e) {
                    return e >= 70 ? !0 : !1
                },
                recalcFunc: function(e) {
                    return .9 + (100 - e) / 100 * 1 / 3
                }
            }, {
                condition: function(e) {
                    return e >= 40 ? !0 : !1
                },
                recalcFunc: function(e) {
                    return 1 + (70 - e) / 100 * 1 / 3
                }
            }, {
                condition: function(e) {
                    return e >= 20 ? !0 : !1
                },
                recalcFunc: function(e) {
                    return 1.1 + (40 - e) / 100 * 1 / 2
                }
            }, {
                condition: function(e) {
                    return !0
                },
                recalcFunc: function(e) {
                    return 1.2 + (20 - e) / 100 * 2 / 1.5
                }
            }],
            f = _.find(a, function(e) {
                return e.condition(u)
            }),
            l = f.recalcFunc(u);
        o = Math.floor(s * l);
        var c = i.SCALE_LIMIT.EXECUTER_REMAINING_HP_RATE;
        return o = _.min([o, Math.floor(s * c)]), o
    }, FF.ns.battle.util.DamageCalculator = {
        postCalculate: function(e) {
            return e
        },
        makeDamageObject: function(e, t, n, r) {
            return _.extend({
                damage: void 0,
                executer: e,
                receiver: t,
                ability: n
            }, r)
        },
        isEnableCounter: function(t, n) {
            n = e.option({
                counterInfo: void 0
            }, n);
            var r = _.isObject(n.counterInfo) ? n.counterInfo.isPossibleMultiCounter : !1;
            if (!t.ability) return !1;
            var i = t.ability.get("isCounter");
            if (i) return !1;
            var s = t.executer,
                o = t.receiver;
            if (!s || !o) return !1;
            if (s.equals(o)) return !1;
            if (t.reflector) return !1;
            if (r) {
                if (!t.counterEnable && !t.deactivatedCounterEnable) return !1
            } else if (!t.counterEnable) return !1;
            return o.canDoAbility() ? o.isIncontrollable() ? !1 : !0 : !1
        },
        calculateHp: function(e, t) {
            var n = e.get("hp") || 0,
                r = e.get("maxHp") || 0,
                i = this._calculateHp(t, n, r);
            return {
                maxHp: r,
                prevHp: n,
                currHp: i,
                actualDamage: n - i
            }
        },
        recalculateHp: function(e) {
            var t = {},
                n = {},
                r = function(e) {
                    if (_.isArray(e)) {
                        _.each(e, r, this);
                        return
                    }
                    var i = e.receiver;
                    if (!i) return;
                    if (!_.isNumber(e.damage) || !_.isNumber(e.prevHp) || !_.isNumber(e.currHp) || !_.isNumber(e.maxHp)) return;
                    this._recalculateCounterEnableFlag(e, n);
                    var s = i.getUid(),
                        o = _.isNumber(t[s]) ? t[s] : e.prevHp;
                    e.prevHp = o, e.currHp = this._calculateHp(e.damage, o, e.maxHp), e.actualDamage = o - e.currHp, t[s] = e.currHp
                };
            _.each(e, r, this)
        },
        recalculateCounterEnableFlag: function(e) {
            var t = {},
                n = function(e) {
                    if (_.isArray(e)) {
                        _.each(e, n, this);
                        return
                    }
                    this._recalculateCounterEnableFlag(e, t)
                };
            _.each(e, n, this)
        },
        _recalculateCounterEnableFlag: function(e, t) {
            var n = e.receiver.getUid();
            if (!e.counterEnable) return;
            e.canHit || !_.has(t, n) ? (e.counterEnable = t[n] ? !1 : !0, t[n] = !0) : e.counterEnable = !1, e.counterEnable || (e.deactivatedCounterEnable = !0)
        },
        _calculateHp: function(e, t, n) {
            var r = _.max([t - e, 0]);
            return r = _.min([r, n]), r
        },
        calculateAbilityPanelNum: function(e, t) {
            var n = t.get("maxNum"),
                r = t.isInfinity(),
                i = t.get("remainNum"),
                s = this._calculateAbilityPanelNum(e, i, n, r);
            return {
                maxNum: n,
                prevNum: i,
                currNum: s,
                actualDamage: i - s
            }
        },
        recalculateAbilityPanelNum: function(e) {
            var t = {},
                n = function(e) {
                    if (_.isArray(e)) {
                        _.each(e, n, this);
                        return
                    }
                    if (!e.isAbilityPanel) return;
                    var r = e.receiver;
                    if (!r) return;
                    if (!_.isNumber(e.damage) || !_.isNumber(e.prevNum) || !_.isNumber(e.currNum) || !_.isNumber(e.maxNum)) return;
                    var i = r.getUid(),
                        s = e.abilityPanel.get("receptorId"),
                        o = e.abilityPanel.isInfinity();
                    t[i] || (t[i] = {});
                    var u = _.isNumber(t[i][s]) ? t[i][s] : e.prevNum;
                    e.prevNum = u, e.currNum = this._calculateAbilityPanelNum(e.damage, u, e.maxNum, o), e.actualDamage = u - e.currNum, t[i][s] = e.currNum
                };
            _.each(e, n, this)
        },
        _calculateAbilityPanelNum: function(e, t, n, r) {
            var i = 0;
            return r || (i = _.max([t - e, 0]), i = _.min([i, n])), i
        },
        calculate: function(e) {
            var n = e.type,
                i = r[n];
            if (!this[i]) throw new Error("invalid type.t=" + n);
            var s = this[i](e);
            return s.type = n, s.typeHistory = s.typeHistory || [], s.typeHistory.push(n), s = t.DamageCalculateHook.postCalculate(e, s), this.postCalculate(s)
        },
        recalculateSituationalDamage: function(e, n, r) {
            var s = i[r];
            if (!s) throw new Error("invalid situationalRecalculateDamageHookType: ", r);
            var o = e.ability,
                u = s(e, n);
            return t.util.DamageCalculator.getAllowableDamage(u, {
                maxDamageThresholdType: o.get("maxDamageThresholdType"),
                minDamageThresholdType: o.get("minDamageThresholdType")
            })
        },
        _calculateDamageByAttack: function(r) {
            var i = r.type;
            r = e.option({
                executer: {},
                target: {},
                ability: {},
                targetNum: 1,
                forceHit: !1,
                forceCritical: !1,
                forceMiss: !1,
                defIgnored: !1,
                atkExponentialFactor: void 0,
                defBoostIgnored: !1,
                atkElement: void 0,
                possibleElements: []
            }, r);
            var s = r.ability,
                o = r.atkElement || s.get("atkElement"),
                u = r.executer,
                a = r.target.receiver,
                f = u.equals(a) ? 0 : s.get("absorbHpFactor"),
                l = !!f,
                c = u.getAttachElementAddOnFactor(o, s),
                h = s.get("atkType") === n.ATK_TYPE.INDIRECT || u.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT,
                p = void 0,
                d = [],
                v = s.get("damageCalculateParamAdjustConf");
            v && v[n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT] && (p = v[n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT].adjustType, d = v[n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.ATK_CONVERT].adjustConds);
            var m = u.statusAilments.adjustCriticalCoefficient(_.isNumber(s.get("criticalCoefficient")) && s.get("criticalCoefficient") > 0 ? s.get("criticalCoefficient") : t.Config.getInstance().get("DamageCalculator", "DAMAGE", "criticalCoefficient")),
                g = u.get("hp") / u.get("maxHp"),
                y = u.getBaseParam(),
                b = a.getBaseParam();
            FF.logger.info("ATTACK", u.get("dispName"), u.get("hp"), "->", a.get("dispName"), a.get("hp"));
            var w = this.__calculateDamageByAttack({
                atk: u.get("atk"),
                def: a.get("def"),
                acc: u.get("acc"),
                eva: a.get("eva"),
                executerDef: u.get("def"),
                executerBaseDef: y.get("def"),
                critical: _.isNumber(s.get("critical")) ? s.get("critical") : u.get("critical"),
                criticalCoefficient: m,
                baseDef: b.get("def"),
                executerRow: u.get("row"),
                receiverRow: a.get("row"),
                targetRange: s.get("targetRange"),
                targetNum: r.targetNum,
                abilityDamageFactor: this.__getAbilityDamageFactor(s, a, u),
                abilityAbsorbHpFactor: f,
                isAbsorbable: l,
                element: o,
                possibleElements: r.possibleElements,
                matkElementMap: u.get("matkElementMap"),
                defAttributeMap: a.get("defAttributeMap"),
                atkType: h,
                forceHit: r.forceHit,
                forceCritical: r.forceCritical,
                forceMiss: r.forceMiss,
                defIgnored: r.defIgnored,
                defBoostIgnored: r.defBoostIgnored,
                isDead: a.isDead(),
                isInDefense: a.isInDefense(),
                isHittable: a.isHittable(s.get("exerciseType"), i),
                isBlinded: u.isBlinded(),
                receiverType: a.isBuddy() ? "buddy" : "enemy",
                attachElementCoefficient: c,
                atkConvertType: p,
                atkAdjustConds: d,
                currHpRate: g,
                atkExponentialFactor: r.atkExponentialFactor,
                maxDamageThresholdType: s.get("maxDamageThresholdType"),
                minDamageThresholdType: s.get("minDamageThresholdType")
            });
            return w.ability = s, w.executer = u, w.receiver = a, l && w.absorbHpDamage ? (w.absorber = u, w.absorbHp = _.extend({
                damage: w.absorbHpDamage,
                canHit: !0
            }, this.calculateHp(w.absorber, w.absorbHpDamage))) : w.absorber = void 0, _.extend(w, this.calculateHp(a, w.damage)), w
        },
        __calculateDamageByAttack: function(n) {
            n = e.option({
                atk: 0,
                def: 0,
                acc: 0,
                eva: 0,
                critical: 0,
                criticalCoefficient: t.Config.getInstance().get("DamageCalculator", "DAMAGE", "criticalCoefficient"),
                executerDef: 0,
                executerBaseDef: 0,
                baseDef: 0,
                executerRow: void 0,
                receiverRow: void 0,
                targetRange: t.Conf.TARGET_RANGE.SINGLE,
                targetNum: 1,
                abilityDamageFactor: 100,
                abilityAbsorbHpFactor: 0,
                element: "",
                possibleElements: [],
                matkElementMap: {},
                defAttributeMap: {},
                forceHit: !1,
                forceCritical: !1,
                forceMiss: !1,
                defIgnored: !1,
                defBoostIgnored: !1,
                atkType: void 0,
                isDead: !1,
                isInDefense: !1,
                isHittable: !0,
                isBlinded: !1,
                isAbsorbable: !1,
                receiverType: void 0,
                attachElementCoefficient: 100,
                atkConvertType: void 0,
                atkAdjustConds: [],
                currHpRate: 1,
                atkExponentialFactor: void 0,
                maxDamageThresholdType: 0,
                minDamageThresholdType: 0
            }, n);
            var r = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                isWeakness: !1,
                advantage: void 0,
                atkType: n.atkType
            };
            if (!this._lotCanAttackHit(n)) return r;
            var i = n.atkExponentialFactor ? Math.pow(n.atk, n.atkExponentialFactor / 100) : n.atk,
                s = n.defIgnored ? 1 : n.defBoostIgnored ? n.baseDef : n.def,
                o = n.abilityDamageFactor,
                u = n.executerDef,
                a = n.executerBaseDef,
                f = t.Config.getInstance().get("DamageCalculator", "DAMAGE"),
                l = this._lotIsAttackCritical(n),
                c = f.minDamage,
                h = f.basePower,
                p = f.ratioDefence,
                d = f.maxBasic,
                v = f.maxBasicForPhysicalAndReceiverEnemy,
                m = f.ratioPower,
                g = f.ratioPowerDefence,
                y = f.ratioCoefficient,
                b = f.maxRatio,
                w = f.randCoeffiecient,
                E = f.defBufAtkConvertPower,
                S = f.maxDefBufRatio,
                x = this._calculateCoefficientByElement(n),
                T = x.coefficient,
                N = this._calculateCoefficientByRow(n),
                C = this._calculateCoefficientByNumber(n),
                k = l ? n.criticalCoefficient : 10,
                L = this._calculateCoefficientByDefense(n),
                A = n.matkElementMap[n.element] || 100,
                O = n.attachElementCoefficient,
                M = n.receiverType,
                D = n.atkConvertType,
                P = n.atkAdjustConds,
                H = i,
                B = n.currHpRate;
            if (M === "enemy" && D) {
                var j = t.util.DamageCalculateParamAdjuster.calculate({
                    adjustType: D,
                    adjustConds: P,
                    atk: i,
                    executerBaseDef: a,
                    executerDef: u,
                    defBufAtkConvertPower: E,
                    maxDefBufRatio: S,
                    currHpRate: B
                });
                j.atk && (H = j.atk)
            }
            var F = M === "buddy" ? Math.floor(c + _.min([Math.pow(H, h), d]) * _.min([Math.pow(H / Math.pow(s, p), g) * y, b]) * o / 100) : Math.floor(c + _.min([Math.pow(H, h), v]) * _.min([Math.pow(H / s, m) * y, b]) * o / 100),
                I = this.getAllowableDamage(Math.floor(F * (T / 10) * (C / 100) * (k / 10) * (N / 10) * (L / 10) * ((100 + (A - 100) + (O - 100)) / 100) * (1 + w * Math.pow(e.randomInt(100, 0), 2) / 1e6)), {
                    maxDamageThresholdType: n.maxDamageThresholdType,
                    minDamageThresholdType: n.minDamageThresholdType
                }),
                q = 0;
            return n.isAbsorbable && (q = this.___calculateAbsorbHpDagame(I, n.abilityAbsorbHpFactor, {
                maxDamageThresholdType: n.maxDamageThresholdType,
                minDamageThresholdType: n.minDamageThresholdType
            })), FF.logger.info("dmg", I, "atk", i, "def", s, "basicPhysicalDamage", F, "damageFactor", o, "minDamage", c, "basePower", h, "ratioDefence", p, "receiverType", M, "maxBasic", d, "maxBasicForPhysicalAndReceiverEnemy", v, "ratioPower", m, "ratioPowerDefence", g, "ratioCoefficient", y, "maxRatio", b, "elementCoefficient", T, "backCoefficient", N, "multipleTargetCoefficient", C, "criticalCoefficient", k, "defenseCoefficient", L, "randCoeffiecient", w, "absorbHpDamage", q, "matkElementCoefficient", A, "atkExponentialFactor", n.atkExponentialFactor), r.damage = I, r.absorbHpDamage = q, r.canHit = !0, r.isCritical = l, r.isRecovery = I < 0, r.isDamage = !0, r.isWeakness = x.isWeakness, r.advantage = x.advantage, r.element = n.element, r.possibleElements = n.possibleElements, r
        },
        _calculateDamageByMagic: function(t) {
            var n = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                targetNum: 1,
                defIgnored: !1,
                defBoostIgnored: !1,
                matkExponentialFactor: void 0,
                matkElement: void 0,
                possibleElements: []
            }, t);
            var r = t.executer,
                i = t.target.receiver,
                s = t.ability,
                o = t.matkElement || s.get("matkElement"),
                u = i.getBaseParam();
            FF.logger.info("MAGIC", r.get("dispName"), r.get("hp"), "->", i.get("dispName"), i.get("hp"), "id", s.get("abilityId"), "el", o);
            var a = !1;
            r.equals(i) && s.get("absorbHpFactor") && (a = !0);
            var f = !!s.get("absorbHpFactor"),
                l = r.getAttachElementAddOnFactor(o, s),
                c = this.__calculateDamageByMagic({
                    matk: r.get("matk"),
                    mnd: r.get("mnd"),
                    mdef: i.get("mdef"),
                    baseMdef: u.get("mdef"),
                    exerciseType: s.get("exerciseType"),
                    targetRange: s.get("targetRange"),
                    targetNum: t.targetNum,
                    element: o,
                    possibleElements: t.possibleElements,
                    matkElementMap: r.get("matkElementMap"),
                    defAttributeMap: i.get("defAttributeMap"),
                    abilityDamageFactor: this.__getAbilityDamageFactor(s, i, r),
                    abilityMinDamageFactor: s.get("minDamageFactor"),
                    abilityAbsorbHpFactor: s.get("absorbHpFactor"),
                    isAbsorbable: f,
                    isInDefense: i.isInDefense(),
                    isHittable: i.isHittable(s.get("exerciseType"), n),
                    forceMiss: a,
                    defIgnored: t.defIgnored,
                    defBoostIgnored: t.defBoostIgnored,
                    receiverType: i.isBuddy() ? "buddy" : "enemy",
                    matkExponentialFactor: t.matkExponentialFactor,
                    attachElementCoefficient: l,
                    maxDamageThresholdType: s.get("maxDamageThresholdType"),
                    minDamageThresholdType: s.get("minDamageThresholdType")
                });
            return c.ability = t.ability, c.executer = r, c.receiver = i, f && c.absorbHpDamage ? (c.absorber = r, c.absorbHp = _.extend({
                damage: c.absorbHpDamage,
                canHit: !0
            }, this.calculateHp(c.absorber, c.absorbHpDamage))) : c.absorber = void 0, _.extend(c, this.calculateHp(i, c.damage)), c
        },
        __calculateDamageByMagic: function(n) {
            n = e.option({
                matk: 0,
                mnd: 0,
                mdef: 0,
                baseMdef: 0,
                exerciseType: 0,
                element: "",
                possibleElements: [],
                matkElementMap: {},
                defAttributeMap: {},
                targetNum: 1,
                targetRange: t.Conf.TARGET_RANGE.SINGLE,
                abilityDamageFactor: 100,
                abilityMinDamageFactor: 0,
                abilityAbsorbHpFactor: 0,
                isInDefense: !1,
                isHittable: !0,
                forceMiss: !1,
                defIgnored: !1,
                defBoostIgnored: !1,
                isAbsorbable: !1,
                receiverType: void 0,
                matkExponentialFactor: void 0,
                attachElementCoefficient: 100,
                maxDamageThresholdType: 0,
                minDamageThresholdType: 0
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "DAMAGE"),
                i = {
                    damage: 0,
                    canHit: !1
                };
            if (!this._lotCanMagicHit(n)) return i;
            var s = n.matkExponentialFactor ? Math.pow(n.matk, n.matkExponentialFactor / 100) : n.matk,
                o = n.defIgnored ? 1 : n.defBoostIgnored ? n.baseMdef : n.mdef,
                u = n.mnd,
                a = n.abilityDamageFactor,
                f = n.abilityMinDamageFactor,
                l = r.minDamage,
                c = r.magicBasePower,
                h = r.ratioMagicDefence,
                p = r.maxBasic,
                d = r.maxBasicForMagicAndReceiverEnemy,
                v = r.maxBasicForNinja,
                m = r.ratioPower,
                g = r.ratioPowerDefence,
                y = r.ratioCoefficient,
                b = r.maxRatio,
                w = r.randCoeffiecient,
                E = this._calculateCoefficientByElement(n),
                S = E.coefficient,
                x = this._calculateCoefficientByNumber(n),
                T = this._calculateCoefficientByDefense(n),
                N = n.matkElementMap[n.element] || 100,
                C = n.attachElementCoefficient,
                k = n.receiverType,
                L = 0;
            switch (n.exerciseType) {
                case t.Conf.EXERCISE_TYPE.BLACK_MAGIC:
                case t.Conf.EXERCISE_TYPE.BLUE_MAGIC:
                case t.Conf.EXERCISE_TYPE.INBORN:
                    L = k === "buddy" ? Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / Math.pow(o, h), g) * y, b]) * a / 100) : Math.floor(l + _.min([Math.pow(s, c), d]) * _.min([Math.pow(s / o, m) * y, b]) * a / 100);
                    break;
                case t.Conf.EXERCISE_TYPE.NINJA:
                    L = k === "buddy" ? Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / Math.pow(o, h), g) * y, b]) * a / 100) : Math.floor(l + _.min([Math.pow(s, c), v]) * _.min([Math.pow(s / o, m) * y, b]) * a / 100);
                    break;
                case t.Conf.EXERCISE_TYPE.WHITE_MAGIC:
                    L = k === "buddy" ? Math.floor(l + _.min([Math.pow(u, c), p]) * _.min([Math.pow(u / Math.pow(o, h), g) * y, b]) * a / 100) : Math.floor(l + _.min([Math.pow(u, c), d]) * _.min([Math.pow(u / o, m) * y, b]) * a / 100);
                    break;
                case t.Conf.EXERCISE_TYPE.SUMMON:
                    L = k === "buddy" ? Math.floor(l + _.min([Math.pow(s, c), p]) * _.min([Math.pow(s / o, m) * y, b]) * a / 100) : Math.floor(l + _.min([Math.pow(s, c), d]) * _.min([Math.pow(s / o, m) * y, b]) * a / 100), m = r.summonRatioPower, y = r.summonRatioCoefficient, L = _.max([L, Math.floor(l + _.min([Math.pow(1 / o, m) * y, b]) * f)]);
                    break;
                default:
                    throw new Error("invalid exercisetype.t=" + n.exerciseType)
            }
            var A = this.getAllowableDamage(Math.floor(L * (S / 10) * (x / 100) * (T / 10) * ((100 + (N - 100) + (C - 100)) / 100) * (1 + w * Math.pow(e.randomInt(100, 0), 2) / 1e6)), {
                    maxDamageThresholdType: n.maxDamageThresholdType,
                    minDamageThresholdType: n.minDamageThresholdType
                }),
                O = 0;
            return n.isAbsorbable && (O = this.___calculateAbsorbHpDagame(A, n.abilityAbsorbHpFactor, {
                maxDamageThresholdType: n.maxDamageThresholdType,
                minDamageThresholdType: n.minDamageThresholdType
            })), FF.logger.info("dmg", A, "matk", s, "mdef", o, "basicMagicalDamage", L, "damageFactor", a, "minDamage", l, "basePower", c, "ratioMagicDefence", h, "receiverType", k, "maxBasic", p, "ratioPower", m, "ratioPowerDefence", g, "ratioCoefficient", y, "maxRatio", b, "elementCoefficient", S, "multipleTargetCoefficient", x, "defenseCoefficient", T, "randCoeffiecient", w, "minDamageFactor", f, "matkElementCoefficient", N, "absorbHpDamage", O), i.damage = A, i.absorbHpDamage = O, i.canHit = !0, i.isRecovery = A < 0, i.isDamage = !0, i.isWeakness = E.isWeakness, i.advantage = E.advantage, i.element = n.element, i.possibleElements = n.possibleElements, i
        },
        _calculateHealValue: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability;
            FF.logger.info("HEAL", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var s = this.__calculateHealValue({
                mnd: n.get("mnd"),
                abilityFactor: i.get("factor"),
                isDead: r.isDead(),
                maxDamageThresholdType: i.get("maxDamageThresholdType"),
                minDamageThresholdType: i.get("minDamageThresholdType")
            });
            return s.ability = i, s.executer = n, s.receiver = r, _.extend(s, this.calculateHp(r, s.damage)), s
        },
        __calculateHealValue: function(n) {
            n = e.option({
                mnd: 0,
                abilityFactor: 1,
                isDead: !1,
                maxDamageThresholdType: 0,
                minDamageThresholdType: 0
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "HEAL"),
                i = r.a,
                s = r.b,
                o = n.mnd,
                u = n.abilityFactor;
            if (n.isDead) throw new Error("can not heal dead actor");
            var a = this.getAllowableDamage(-1 * Math.round(u * (i + Math.pow(o, .75) / 256 * s)), {
                maxDamageThresholdType: n.maxDamageThresholdType,
                minDamageThresholdType: n.minDamageThresholdType
            });
            FF.logger.info("heal", a, "mnd", o, "factor", u, "a", i, "b", s);
            var f = {
                canHit: !0,
                isRecovery: !0,
                damage: a
            };
            return f
        },
        _calculateFixedHealValue: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {},
                fixedHealValue: 0
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability,
                s = this.getAllowableDamage(-1 * t.fixedHealValue, {
                    maxDamageThresholdType: i.get("maxDamageThresholdType"),
                    minDamageThresholdType: i.get("minDamageThresholdType")
                }),
                o = {
                    ability: t.ability,
                    executer: n,
                    receiver: r,
                    damage: s,
                    canHit: s < 0,
                    isRecovery: s < 0
                };
            return _.extend(o, this.calculateHp(r, o.damage)), o
        },
        _calculateHealHpValueByDamageSum: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                damageSum: 1,
                forceMiss: !1
            }, t);
            var n = t.ability,
                r = n.get("healHpFactor"),
                i = t.damageSum,
                s = this.___calculateAbsorbHpDagame(i, r, {
                    maxDamageThresholdType: n.get("maxDamageThresholdType"),
                    minDamageThresholdType: n.get("minDamageThresholdType")
                }),
                o = {};
            return o.ability = n, o.executer = t.executer, o.receiver = t.target.receiver, o.canHit = t.forceMiss ? !1 : !0, o.isRecovery = !0, o.damage = s, _.extend(o, this.calculateHp(o.receiver, o.damage)), o
        },
        _calculateHealDeath: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                hitRate: 0,
                hpFactor: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.hitRate,
                o = t.hpFactor,
                u = r.get("maxHp");
            FF.logger.info("HEAL_DEATH", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var a = {
                executer: n,
                receiver: r,
                ability: i,
                canHit: !1,
                isRecovery: !0,
                damage: 0,
                healDeath: !0
            };
            if (r.isEnemy()) return a;
            if (!r.canHealDeath()) return a;
            if (!e.lotByFraction(s)) return a;
            var f = this.getAllowableDamage(-1 * Math.floor(u * o / 100), {
                maxDamageThresholdType: i.get("maxDamageThresholdType"),
                minDamageThresholdType: i.get("minDamageThresholdType")
            });
            return a.canHit = !0, a.damage = f, _.extend(a, this.calculateHp(r, a.damage)), FF.logger.info("heal", f, "hpfactor", o, "can", a.canHit, "rate", s), a
        },
        _calculateDamageByFraction: function(t) {
            var n = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsId: 0,
                statusAilmentsFactor: 0,
                numerator: 0,
                forceHitWithoutSa: !1
            }, t);
            var r = t.executer,
                i = t.target.receiver,
                s = t.ability,
                o = s.get("damageRate") || 0,
                u = i.get("defAttributeMap") || {},
                a = t.statusAilmentsId,
                f = t.statusAilmentsFactor,
                l = t.numerator,
                c = t.forceHitWithoutSa,
                h = i.isHittable(s.get("exerciseType"), n);
            FF.logger.info("FRACTION", r.get("dispName"), r.get("hp"), "->", i.get("dispName"), i.get("hp"), "id", s.get("abilityId"));
            var p = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: s,
                executer: r,
                receiver: i,
                isDamage: !0
            };
            if (!h) return p;
            if (!c) {
                var d = {};
                d[a] = f;
                var v = this._calculateStatusAilments({
                    executer: r,
                    target: t.target,
                    atkStatusAilments: d,
                    ability: s,
                    ignoresAtkSaCoef: !0
                });
                if (!v.canHit) return p.isNoeffect = v.isNoeffect, p
            }
            var m = this.getAllowableDamage(Math.floor(l * o / 100), {
                maxDamageThresholdType: s.get("maxDamageThresholdType"),
                minDamageThresholdType: s.get("minDamageThresholdType")
            });
            return FF.logger.info("dmg", m, "numerator", l, "dmgrate", o, "said", a, "safactor", f), p.damage = m, p.canHit = !0, _.extend(p, this.calculateHp(i, p.damage)), p
        },
        _calculateDamageBySelfDestruction: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsId: 0,
                statusAilmentsFactor: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = n.get("hp"),
                o = i.get("damageFactor") || 0,
                u = r.get("defAttributeMap") || {};
            FF.logger.info("SELF_DESTRUCTION", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"), "id", i.get("abilityId"));
            var a = {
                    damage: 0,
                    canHit: !0,
                    isCritical: !1,
                    ability: i,
                    executer: n,
                    receiver: r,
                    isDamage: !0
                },
                f = this.getAllowableDamage(Math.floor(s * o / 100), {
                    maxDamageThresholdType: i.get("maxDamageThresholdType"),
                    minDamageThresholdType: i.get("minDamageThresholdType")
                });
            return FF.logger.info("dmg", f, "executerHp", s, "damageFactor", o), a.damage = f, _.extend(a, this.calculateHp(r, a.damage)), a
        },
        _calculateFixedDamage: function(t) {
            var r = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                fixedDamage: 0,
                targetCount: 1,
                ignoreTargetCountDivision: !1
            }, t);
            var i = t.executer,
                s = t.target.receiver,
                o = t.ability,
                u = t.fixedDamage,
                a = t.targetCount,
                f = t.ignoreTargetCountDivision,
                l = s.isHittable(o.get("exerciseType"), r),
                c = o.get("atkType") === n.ATK_TYPE.INDIRECT || i.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT;
            FF.logger.info("FIXED_DAMAGE", i.get("dispName"), i.get("hp"), "->", s.get("dispName"), s.get("hp"), "id", o.get("abilityId"));
            var h = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: o,
                executer: i,
                receiver: s,
                isDamage: !0,
                atkType: c
            };
            if (!l) return h;
            var p = u;
            f || (p = Math.floor(u / a));
            var d = this.getAllowableDamage(p, {
                maxDamageThresholdType: o.get("maxDamageThresholdType"),
                minDamageThresholdType: o.get("minDamageThresholdType")
            });
            return FF.logger.info("dmg", d, "fixedDamage", u, "targetCount", a), h.damage = d, h.canHit = !0, _.extend(h, this.calculateHp(s, h.damage)), h
        },
        _calculateDamageByDamagedHp: function(t) {
            var r = t.type;
            t = e.option({
                executer: {},
                target: {},
                ability: {}
            }, t);
            var i = t.executer,
                s = t.target.receiver,
                o = t.ability,
                u = o.get("damageFactor") || 0,
                a = i.get("maxHp"),
                f = i.get("hp"),
                l = s.isHittable(o.get("exerciseType"), r),
                c = o.get("atkType") === n.ATK_TYPE.INDIRECT || i.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT;
            FF.logger.info("DAMAGED_HP", i.get("dispName"), i.get("hp"), "->", s.get("dispName"), s.get("hp"), "id", o.get("abilityId"));
            var h = {
                damage: 0,
                canHit: !1,
                isCritical: !1,
                ability: o,
                executer: i,
                receiver: s,
                isDamage: !0,
                atkType: c
            };
            if (!l) return h;
            var p = this.getAllowableDamage(Math.floor((a - f) * u / 100), {
                maxDamageThresholdType: o.get("maxDamageThresholdType"),
                minDamageThresholdType: o.get("minDamageThresholdType")
            });
            return FF.logger.info("dmg", p, "maxHP", a, "currHP", f, "dmgFactor", u), h.damage = p, h.canHit = !0, _.extend(h, this.calculateHp(s, h.damage)), h
        },
        _lotCanMagicHit: function(e) {
            return e.forceMiss ? (FF.logger.info("HIT_RATE", "FORCE_MISS"), !1) : e.isHittable ? !0 : (FF.logger.info("HIT_RATE", "HITTABLE"), !1)
        },
        _lotCanAttackHit: function(n) {
            var r = t.Config.getInstance().get("DamageCalculator", "ACC");
            n = e.option({
                acc: 0,
                eva: 0,
                isDead: !1,
                isHittable: !0,
                forceHit: !1,
                forceMiss: !1,
                isBlinded: !1
            }, n);
            if (n.isDead) throw new Error("can not attack to dead actor");
            if (!n.isHittable) return FF.logger.info("HIT_RATE", "HITTABLE"), !1;
            if (n.forceMiss) return FF.logger.info("HIT_RATE", "FORCE_MISS"), !1;
            if (n.forceHit) return FF.logger.info("HIT_RATE", "FORCE_HIT"), !0;
            var i = n.acc,
                s = n.eva,
                o = r.a,
                u = r.b,
                a = r.c,
                f = r.d,
                l = n.isBlinded ? r.blinded : r.e,
                c = r.f,
                h = Math.floor(_.max([_.min([(o * i - u * s) / a + f, 100]) * (l / 100), c])),
                p = e.lotByFraction(h);
            return FF.logger.info("HIT_RATE", h, "canHit", p, "acc", i, "eva", s, "a", o, "b", u, "c", a, "d", f, "e", l, "f", c), p
        },
        _lotIsAttackCritical: function(t) {
            if (t.forceCritical) return FF.logger.info("FORCE_CRITICAL"), !0;
            var n = t.critical || 0;
            return e.lotByFraction(n)
        },
        _calculateCoefficientByNumber: function(e) {
            return e.targetRange === t.Conf.TARGET_RANGE.ALL ? 100 : _.max([100 - 10 * (e.targetNum - 1), 1])
        },
        _calculateCoefficientByElement: function(r) {
            r = e.option({
                element: "",
                defAttributeMap: {}
            }, r);
            var i = t.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE"),
                s = t.Config.getInstance().get("DamageCalculator", "ELEMENT_ADVANTAGE_DEFAULT"),
                o = r.defAttributeMap,
                u = o[r.element],
                a = i[u] || s,
                f = a[0],
                l = a[1],
                c = {
                    advantage: f,
                    coefficient: l,
                    isWeakness: f === n.ADVANTAGE.WEAK,
                    isVoid: f === n.ADVANTAGE.VOID,
                    isHalf: f === n.ADVANTAGE.HALF,
                    isAbsorption: f === n.ADVANTAGE.ABSORPTION
                };
            return FF.logger.info("element", "atk", r.element, "def", o, "ret", c), c
        },
        _calculateCoefficientByRow: function(r) {
            r = e.option({
                executerRow: n.ROW_TYPE.FRONT,
                receiverRow: n.ROW_TYPE.FRONT,
                atkType: n.ATK_TYPE.DIRECT
            }, r);
            var i = t.Config.getInstance().get("DamageCalculator", "ROW");
            return r.atkType === n.ATK_TYPE.INDIRECT ? i.DEFAULT : i[r.executerRow][r.receiverRow]
        },
        _calculateCoefficientByDefense: function(n) {
            n = e.option({
                isInDefense: !1
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "DAMAGE", "defenseCoefficient");
            return r[n.isInDefense ? "defense" : "default"]
        },
        calculatePotion: function(t) {
            t = e.option({
                item: void 0,
                receiver: void 0
            }, t), FF.logger.info("POTION", t.item);
            var n = this._calculatePotion({
                type: t.item.type,
                maxHp: t.receiver.get("maxHp")
            });
            return n.receiver = t.receiver, _.extend(n, this.calculateHp(t.receiver, n.damage)), n
        },
        _calculatePotion: function(n) {
            n = e.option({
                type: void 0,
                maxHp: 0
            }, n);
            var r = n.type,
                i = n.maxHp,
                s = t.Config.getInstance().get("DamageCalculator", "DROP_ITEM"),
                o = s[r] || 0,
                u = this.getAllowableDamage(-1 * Math.round(i * o / 100));
            return FF.logger.info("heal", u, "type", r, "maxHp", i), {
                canHit: !0,
                isRecovery: !0,
                damage: u
            }
        },
        _calculateAbilityPanel: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                abilityPanel: {},
                damageFactor: 0,
                isDecrease: !0,
                hitRate: 0,
                isRemainingBase: !1
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.abilityPanel,
                o = t.damageFactor,
                u = t.isDecrease,
                a = t.hitRate,
                f = t.isRemainingBase,
                l = {
                    damage: 0,
                    canHit: !1,
                    ability: i,
                    executer: n,
                    receiver: r,
                    abilityPanel: s
                };
            return e.lotByFraction(a) ? (_.extend(l, this.__calculateAbilityPanel({
                remainNum: t.abilityPanel.get("remainNum"),
                maxNum: t.abilityPanel.get("maxNum"),
                damageFactor: o,
                isDecrease: u,
                isInfinity: t.abilityPanel.isInfinity(),
                isRemainingBase: f
            })), _.extend(l, this.calculateAbilityPanelNum(l.damage, t.abilityPanel)), l) : l
        },
        _calculateAbilityPanelFixedDamage: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                abilityPanel: {},
                fixedDamage: 0,
                isDecrease: !0,
                hitRate: 0,
                isRemainingBase: !1
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.abilityPanel,
                o = t.fixedDamage,
                u = t.isDecrease,
                a = t.hitRate,
                f = t.isRemainingBase,
                l = {
                    damage: 0,
                    canHit: !1,
                    ability: i,
                    executer: n,
                    receiver: r,
                    abilityPanel: s
                };
            return e.lotByFraction(a) ? (_.extend(l, this.__calculateAbilityPanelFixedDamage({
                remainNum: t.abilityPanel.get("remainNum"),
                maxNum: t.abilityPanel.get("maxNum"),
                fixedDamage: o,
                isDecrease: u,
                isInfinity: t.abilityPanel.isInfinity(),
                isRemainingBase: f
            })), _.extend(l, this.calculateAbilityPanelNum(l.damage, t.abilityPanel)), l) : l
        },
        calculateEther: function(n) {
            n = e.option({
                item: void 0,
                receiver: void 0,
                abilityPanel: void 0
            }, n);
            var r = n.receiver;
            FF.logger.info("ETHER", n.item, n.abilityPanel.get("abilityId"));
            var i = t.Config.getInstance().get("DamageCalculator", "DROP_ITEM"),
                s = i[n.item.type] || 0,
                o = this.__calculateAbilityPanel({
                    remainNum: n.abilityPanel.get("remainNum"),
                    maxNum: n.abilityPanel.get("maxNum"),
                    damageFactor: s,
                    isDecrease: !1,
                    isInfinity: n.abilityPanel.isInfinity(),
                    isRemainingBase: !1
                });
            return o.abilityPanel = n.abilityPanel, o.receiver = r, _.extend(o, this.calculateAbilityPanelNum(o.damage, n.abilityPanel)), o
        },
        __calculateAbilityPanel: function(t) {
            t = e.option({
                remainNum: 0,
                maxNum: 0,
                damageFactor: 0,
                isDecrease: !1,
                isInfinity: !1,
                isRemainingBase: !1
            }, t);
            var n = {
                canHit: !0,
                isAbilityPanel: !0,
                isDecrease: t.isDecrease,
                damage: 0,
                prev: t.remainNum,
                curr: t.remainNum,
                max: t.maxNum
            };
            if (t.isInfinity) return n;
            var r = t.remainNum,
                i = t.maxNum,
                s = t.damageFactor,
                o = t.isDecrease,
                u = o ? 1 : -1,
                a = t.isRemainingBase,
                f = a ? r : i,
                l = u * Math.ceil(f * s / 100);
            return n.damage = l, FF.logger.info("abilityPanel", l, "maxNum", i, "remainNum", r, "damageFactor", s, "isDecrease", o, "isRemainingBase", a, n), n
        },
        __calculateAbilityPanelFixedDamage: function(t) {
            t = e.option({
                remainNum: 0,
                maxNum: 0,
                fixedDamage: 0,
                isDecrease: !1,
                isInfinity: !1,
                isRemainingBase: !1
            }, t);
            var n = {
                canHit: !0,
                isAbilityPanel: !0,
                isDecrease: t.isDecrease,
                damage: 0,
                prev: t.remainNum,
                curr: t.remainNum,
                max: t.maxNum
            };
            if (t.isInfinity) return n;
            var r = t.remainNum,
                i = t.maxNum,
                s = t.fixedDamage,
                o = t.isDecrease,
                u = o ? 1 : -1,
                a = t.isRemainingBase,
                f = u * s;
            return n.damage = f, FF.logger.info("abilityPanel", f, "maxNum", i, "remainNum", r, "fixedDamage", s, "isDecrease", o, "isRemainingBase", a, n), n
        },
        _calculateDealingSsPoint: function(r) {
            r = e.option({
                executer: {},
                target: {},
                ability: {},
                ssPoint: 0,
                dealType: n.DEAL_SS_POINT_TYPE.NORMAL
            }, r);
            var i = r.executer,
                s = r.target.receiver,
                o = {
                    isSsPoint: !0,
                    ability: r.ability,
                    executer: i,
                    receiver: s
                };
            if (i.isEnemy() || s.isEnemy()) throw new Error("can not deal soul strike point of enemy");
            var u = t.Config.getInstance().get("SoulStrike", "maxSsPoint"),
                a = r.ssPoint,
                f = s.getSoulStrike().get("point"),
                l = i.getSoulStrike().get("point"),
                c = 0,
                h = 0;
            switch (r.dealType) {
                case n.DEAL_SS_POINT_TYPE.NORMAL:
                    c = a > 0 ? _.min([a, u - f]) : _.max([a, -f]);
                    break;
                case n.DEAL_SS_POINT_TYPE.ENTRUST:
                    var p = 0;
                    l + f < u ? p = l : p = u - f, c = p, h = -p;
                    break;
                default:
                    throw new Error("invalid dealType:" + r.dealType)
            }
            return o.canHit = c !== 0, o.receiverSsPointDiff = c, o.executorSsPointDiff = h, o
        },
        _calculatePoison: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability.get("damageFactor") || 0,
                s = this.getAllowableDamage(Math.round(n.get("maxHp") * i / 256));
            FF.logger.info("POISON/SAP", n.get("dispName"), n.get("hp"), "factor", i, "dmb", s);
            var o = {
                canHit: !0,
                damage: s,
                ability: t.ability,
                executer: n,
                receiver: r
            };
            return _.extend(o, this.calculateHp(r, o.damage)), o
        },
        _calculateRadiantShield: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {},
                fixedDamage: 0
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability,
                s = t.fixedDamage,
                o = this.getAllowableDamage(s, {
                    maxDamageThresholdType: i.get("maxDamageThresholdType"),
                    minDamageThresholdType: i.get("minDamageThresholdType")
                });
            FF.logger.info("RADIANT_SHIELD", n.get("dispName"), n.get("hp"), "factor", s, "dmb", o);
            var u = {
                canHit: !0,
                damage: o,
                ability: i,
                executer: n,
                receiver: r
            };
            return _.extend(u, this.calculateHp(r, u.damage)), u
        },
        _calculateRegen: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {}
            }, t);
            var n = t.executer,
                r = t.receiver,
                i = t.ability.get("damageFactor") || 0,
                s = this.getAllowableDamage(-1 * Math.round(n.get("maxHp") * i / 100));
            FF.logger.info("REGEN", n.get("dispName"), n.get("hp"), "dmg", s);
            var o = {
                canHit: !0,
                damage: s,
                ability: t.ability,
                executer: n,
                receiver: r
            };
            return _.extend(o, this.calculateHp(r, o.damage)), o
        },
        _calculatePhysicalStatusAilments: function(e) {
            var t = this._calculateStatusAilments(e),
                r = e.executer,
                i = e.ability;
            return t.atkType = i.get("atkType") === n.ATK_TYPE.INDIRECT || r.get("atkType") === n.ATK_TYPE.INDIRECT ? n.ATK_TYPE.INDIRECT : n.ATK_TYPE.DIRECT, t
        },
        _calculateStatusAilments: function(n) {
            var r = n.type;
            n = e.option({
                executer: {},
                target: {},
                atkStatusAilments: {},
                statusAilmentsOptions: {},
                ability: {},
                forceHit: !1,
                forceMiss: !1,
                damageObject: void 0,
                ignoresAtkSaCoef: !1
            }, n);
            var i = n.executer,
                s = n.target.receiver,
                o = n.ability;
            FF.logger.info("LOT_STATUS_AILMENTS", i.get("dispName"), "->", s.get("dispName"), "sa", n.atkStatusAilments);
            var u = this._lotCanAddStatusAilments({
                    atkStatusAilments: n.atkStatusAilments,
                    defAttributeMap: s.get("defAttributeMap"),
                    extraDefStatusAilments: this._makeExtraDefStatusAilments(s, n.atkStatusAilments),
                    receiverType: s.isBuddy() ? "buddy" : "enemy",
                    forceHit: n.forceHit,
                    forceMiss: n.forceMiss,
                    isHittable: s.isHittable(o.get("exerciseType"), r),
                    atkSaCoef: i.get("atkSaCoef"),
                    ignoresAtkSaCoef: n.ignoresAtkSaCoef
                }),
                a = n.damageObject || t.util.DamageCalculator.makeDamageObject(i, s, o);
            return n.damageObject ? (a.statusAilments = u.statusAilments, a.appendedStatusAilments = u) : _.extend(a, u), a.statusAilmentsOptions = _.extend({}, n.statusAilmentsOptions), a
        },
        _lotCanAddStatusAilments: function(n) {
            n = e.option({
                atkStatusAilments: {},
                defAttributeMap: {},
                receiverType: void 0,
                forceHit: !1,
                forceMiss: !1,
                isHittable: !0,
                extraDefStatusAilments: {},
                atkSaCoef: 100,
                ignoresAtkSaCoef: !1
            }, n);
            var r = t.Config.getInstance().get("DamageCalculator", "STATUS_AILMENTS"),
                i = r.a,
                s = r.b,
                o = n.atkSaCoef,
                u = n.ignoresAtkSaCoef,
                a = {
                    hasAtkStatusAilments: _.size(n.atkStatusAilments) > 0,
                    canHit: !1,
                    isNoeffect: !1,
                    statusAilments: []
                };
            if (!!n.isHittable && !n.forceMiss)
                if (n.forceHit && n.receiverType === "enemy") _.each(n.atkStatusAilments, function(e, t) {
                    var r = n.defAttributeMap[t];
                    r ? a.isNoeffect = !0 : this.__judgeForbiddenByReceiverType(t, n.receiverType) || (FF.logger.info("STATUS_AILMENTS", "forceHit enemy"), a.statusAilments.push(t))
                }, this);
                else if (n.forceHit && n.receiverType === "buddy") _.each(n.atkStatusAilments, function(e, t) {
                if (this.__judgeForbiddenByReceiverType(t, n.receiverType)) return;
                FF.logger.info("STATUS_AILMENTS", "forceHit buddy"), a.statusAilments.push(t)
            }, this);
            else if (n.receiverType === "enemy") _.each(n.atkStatusAilments, function(e, t) {
                var r = !1,
                    i = n.defAttributeMap[t],
                    s = void 0,
                    f = void 0;
                i ? a.isNoeffect = !0 : this.__judgeForbiddenByReceiverType(t, n.receiverType) || (s = e, f = n.extraDefStatusAilments[t], f && (s = _.max([s + f, 0])), r = this.__judgeCanAddStatusAilment(e, o, u, s)), FF.logger.info("STATUS_AILMENTS", "can", r, "rate", s, "atkSaCoef", o, "ignoresAtkSaCoef", u, "atkVal", e, "def", i, "extraDefVal", f), r && a.statusAilments.push(t)
            }, this);
            else {
                if (n.receiverType !== "buddy") throw new Error("INVALID receiverType.t=" + n.receiverType);
                _.each(n.atkStatusAilments, function(e, t) {
                    if (this.__judgeForbiddenByReceiverType(t, n.receiverType)) return;
                    var r = n.defAttributeMap[t] || 1,
                        f = i + e / r * s,
                        l = this.__judgeCanAddStatusAilment(e, o, u, f);
                    FF.logger.info("STATUS_AILMENTS", "can", l, "rate", f, "atkSaCoef", o, "ignoresAtkSaCoef", u, "a", i, "b", s, "atk", e, "def", r), l && a.statusAilments.push(t)
                }, this)
            }
            return a.statusAilments = _.uniq(a.statusAilments), a.statusAilments.length && (a.canHit = !0, a.isNoeffect = !1), a
        },
        __judgeCanAddStatusAilment: function(n, r, i, s) {
            var o = t.Config.getInstance().get("DamageCalculator", "FORCE_HITTABLE_STATUS_AILMENTS_FACTOR");
            return n >= o ? !0 : (s = _.min([s, 100]), i || (s = s * r / 100), e.lotByFraction(s))
        },
        __judgeForbiddenByReceiverType: function(e, n) {
            var r = void 0;
            if (n === "buddy") r = t.StatusAilmentsConfig.getCanNotSetToBuddyIdMap();
            else {
                if (n !== "enemy") throw new Error("invalid receiverType: " + n);
                r = t.StatusAilmentsConfig.getCanNotSetToEnemyIdMap()
            }
            return !!r[e]
        },
        _makeExtraDefStatusAilments: function(e, t) {
            if (e.isBuddy()) return {};
            var n = e.retrieveExtraDefStatusAilmentConfig();
            if (_.isEmpty(n)) return {};
            var r = {};
            return _.each(t, function(e, t) {
                var i = n[t] || {};
                if (_.isNumber(i.addingAtkFactor)) r[t] = i.addingAtkFactor;
                else if (_.isNumber(i.addingAtkFactorRate)) {
                    var s = i.addingAtkFactorRate;
                    r[t] = Math.floor(e * s / 100)
                }
            }), r
        },
        _calculateHpBarter: function(t) {
            t = e.option({
                executer: {},
                receiver: {},
                ability: {},
                isMultiplicandMaxHp: !0
            }, t);
            var n = t.executer,
                r = t.ability,
                i = t.ability.get("barterRate"),
                s = n.get("maxHp"),
                o = n.get("hp"),
                u = t.isMultiplicandMaxHp ? Math.floor(s * i / 1e3) : Math.floor(o * i / 1e3),
                a = this.getAllowableDamage(u < o ? u : o - 1, {
                    maxDamageThresholdType: r.get("maxDamageThresholdType"),
                    minDamageThresholdType: r.get("minDamageThresholdType")
                });
            return FF.logger.info("BARTER", "dmg", a, "rate", i), {
                canHit: !0,
                damage: a,
                ability: t.ability,
                executer: t.executer,
                receiver: t.receiver
            }
        },
        _calculateHealSa: function(n) {
            n = e.option({
                executer: {},
                target: {},
                ability: {},
                statusAilmentsIds: [],
                hitRate: 0
            }, n);
            var r = n.target,
                i = n.statusAilmentsIds,
                s = _.intersection(i, r.receiver.statusAilments.getRefs()),
                o = e.lotByFraction(n.hitRate),
                u = t.util.DamageCalculator.makeDamageObject(n.executer, r.receiver, n.ability, {
                    unsetStatusAilments: o ? i : void 0,
                    intersectionUnsetSaIds: s,
                    canHit: o
                });
            return FF.logger.info("HEAL_SA", "can", o, "ids", i, "rate", n.hitRate), u
        },
        _calculateHealByFractionValue: function(t) {
            t = e.option({
                executer: {},
                target: {},
                ability: {},
                numerator: 0
            }, t);
            var n = t.executer,
                r = t.target.receiver,
                i = t.ability,
                s = t.numerator;
            FF.logger.info("FRACTION_HEAL", n.get("dispName"), n.get("hp"), "->", r.get("dispName"), r.get("hp"));
            var o = {
                canHit: !0,
                isRecovery: !0,
                damage: this.getAllowableDamage(-1 * Math.floor(s * i.get("factor") / 100), {
                    maxDamageThresholdType: i.get("maxDamageThresholdType"),
                    minDamageThresholdType: i.get("minDamageThresholdType")
                })
            };
            return o.ability = i, o.executer = n, o.receiver = r, _.extend(o, this.calculateHp(r, o.damage)), o
        },
        getAllowableDamage: function(e, r) {
            r = r || {};
            if (_.isNaN(e) || !_.isFinite(e) || !_.isNumber(e)) return 0;
            var i = t.Config.getInstance().get("DamageCalculator", "DAMAGE", "damageThresholdTypeMap"),
                s = i[n.DAMAGE_THRESHOLD_TYPE.DEFAULT];
            r.maxDamageThresholdType && i[r.maxDamageThresholdType] && (s = i[r.maxDamageThresholdType]), r.maxDamageThresholdType && r.maxDamageThresholdType === n.DAMAGE_THRESHOLD_TYPE.INFINITY && (s = e);
            var o = -i[n.DAMAGE_THRESHOLD_TYPE.DEFAULT];
            return r.minDamageThresholdType && i[r.minDamageThresholdType] && (o = -i[r.minDamageThresholdType]), r.minDamageThresholdType && r.minDamageThresholdType === n.DAMAGE_THRESHOLD_TYPE.INFINITY && (o = e), Math.max(Math.min(e, s), o)
        },
        __getAbilityDamageFactor: function(e, r, i) {
            var s = e.get("damageCalculateParamAdjustConf");
            if (s && s[n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR]) {
                var o = t.util.DamageCalculateParamAdjuster.calculate(_.extend({
                    executer: i,
                    receiver: r,
                    ability: e,
                    defaultDamageFactor: e.get("damageFactor")
                }, s[n.DAMAGE_CALCULATE_PARAM_ADJUST_TYPE.DAMAGE_FACTOR]));
                if (o.damageFactor) return o.damageFactor
            }
            return e.get("damageFactor")
        },
        ___calculateAbsorbHpDagame: function(e, t, n) {
            return this.getAllowableDamage(Math.min(-1 * Math.floor(e * t / 100), -1), n)
        },
        calculateAbsorbHpDamageByAbility: function(e, t) {
            return this.___calculateAbsorbHpDagame(e, t.get("absorbHpFactor"), {
                maxDamageThresholdType: t.get("maxDamageThresholdType"),
                minDamageThresholdType: t.get("minDamageThresholdType")
            })
        },
        detectElementByTarget: function(e, n) {
            var r = e.get("elementConfs");
            if (!r || r.length === 0) return null;
            var i = n.receiver.get("defAttributeMap"),
                s = e.executer,
                o = s.get("matkElementMap"),
                u = t.Config.getInstance().get("MateriaBaseDamageFactor"),
                a = void 0,
                f = [],
                l = void 0,
                c = _.sortBy(r, function(e) {
                    return e.priority
                });
            return _.each(c, function(t) {
                f.push(t.element);
                var n = this._calculateCoefficientByElement({
                        element: t.element,
                        defAttributeMap: i
                    }),
                    r = n.coefficient,
                    c = o[t.element] || 100,
                    h = s.getAttachElementAddOnFactor(t.element, e),
                    p = {
                        isWeakness: n.isWeakness,
                        element: t.element,
                        matchesData: {
                            ability: e
                        },
                        matchesDamageObject: {
                            element: t.element,
                            isFlightAttack: e.get("isFlightAttack")
                        }
                    },
                    d = s.materiaHolder.getDamageFactorByElement(p),
                    v = r / 10 * ((100 + (c - 100) + (h - 100)) / 100) * (d / u);
                if (_.isUndefined(l) || v > l) a = t.element, l = v
            }, this), FF.logger.info("detect_element", "elementConfs", r, "def", i, "ret", a, "possibleElements", f), {
                targetElement: a,
                possibleElements: f
            }
        },
        isCalcTypePoison: function(e) {
            var t = [n.CALC_TYPE.POISON];
            return _.contains(t, e)
        },
        isCalcTypeRadiantShield: function(e) {
            var t = [n.CALC_TYPE.RADIANT_SHIELD];
            return _.contains(t, e)
        },
        isCalcTypeAttackEffectOfStatusAilements: function(e) {
            return this.isCalcTypePoison(e) ? !0 : this.isCalcTypeRadiantShield(e) ? !0 : !1
        }
    }
}), define("scenes/battle/util/DamageCalculateHook", ["lib/ClassBase"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = e.extend({
            shouldHook: function(e, t) {
                return !1
            },
            postCalculate: function(e, t) {
                throw new Error("override plz")
            }
        }),
        i = {};
    i[n.CALC_HOOK.REFRECTOR] = r.extend({
        shouldHook: function(e, t) {
            return !0
        },
        postCalculate: function(e, t) {
            var n = e && e.target && e.target.reflector;
            return t.reflector = n ? e.target.reflector : void 0, t
        }
    }), i[n.CALC_HOOK.COUNTER_ENABLE] = r.extend({
        shouldHook: function(e, t) {
            return !0
        },
        postCalculate: function(e, t) {
            var n = _.isFunction(e.ability.get) && !!e.ability.get("counterEnable");
            return t.counterEnable = n, t
        }
    }), i[n.CALC_HOOK.MATERIA] = r.extend({
        shouldHook: function(e, t) {
            return t.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : !0
        },
        postCalculate: function(e, n) {
            var r = n.executer,
                i = n.receiver;
            return r && r.materiaHolder.notify(t.Conf.MATERIA_NOTIFY_TYPE.DAMAGE_HOOK, {
                data: e,
                result: n
            }), i && i.materiaHolder.notify(t.Conf.MATERIA_NOTIFY_TYPE.RECIEVE_DAMAGE_HOOK, {
                data: e,
                result: n
            }), n
        }
    }), i[n.CALC_HOOK.RECEIVER_SA] = r.extend({
        shouldHook: function() {
            return !0
        },
        postCalculate: function(e, t) {
            return t.receiver.statusAilments.processForDamageCalculateHook(t), t
        }
    }), i[n.CALC_HOOK.BRK_DEF] = r.extend({
        shouldHook: function(e, t) {
            return t.type !== n.CALC_TYPE.STATUS_AILMENTS && t.type !== n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS ? !1 : t.statusAilments ? t.statusAilments.length < 1 ? !1 : !0 : !1
        },
        postCalculate: function(e, t) {
            var n = this.detectBreakableParamsFromResult(t),
                r = void 0,
                i = {};
            if (n.length > 0) {
                var s = this.makeReceiverBrkDefInfos(t.receiver);
                _.each(n, function(e) {
                    var t = s[e];
                    t && (r = t[0], i[e] = t[1])
                })
            }
            r && (t.advantage = r);
            var o = t.statusAilmentsOptions || {};
            return o.brkDefRates = i, t.statusAilmentsOptions = o, t
        },
        makeReceiverBrkDefInfos: function(e) {
            var n = e.get("defAttributeMap"),
                r = t.Config.getInstance().get("BrkDefConfig"),
                i = {};
            return _.each(n, function(e, t) {
                var n = r.PARAM_NAME[t];
                if (!n) return;
                var s = r.ADVANTAGE[e];
                if (!s) throw new Error("Invalid brkDefId: " + e);
                i[n] = s
            }), i
        },
        detectBreakableParamsFromResult: function(e) {
            var n = this,
                r = e.statusAilments || [],
                i = e.statusAilmentsOptions || {},
                s = [];
            return _.each(r, function(e) {
                var r = t.StatusAilmentsConfig.getParam(e),
                    o = n.detectBreakableParams(r, i);
                s = s.concat(o)
            }), _.uniq(s)
        },
        detectBreakableParams: function(e, t) {
            if (!e.boosts) return [];
            var n = [];
            return _.each(e.boosts, function(e) {
                if (_.isUndefined(e.rate)) return;
                if (e.rate < 0) n.push(e.paramName);
                else if (e.rate === 0) {
                    var r = t.boost && t.boost.rate ? t.boost.rate : 0;
                    r < 0 && n.push(e.paramName)
                }
            }), n
        }
    }), i[n.CALC_HOOK.HP_STOCK] = r.extend({
        shouldHook: function(e, r) {
            if (!r.canHit) return !1;
            if (r.type !== n.CALC_TYPE.STATUS_AILMENTS) return !1;
            var i = _.any(r.statusAilments, function(e) {
                return t.StatusAilmentsConfig.getParam(e).isHpStock
            });
            return i ? !0 : !1
        },
        postCalculate: function(e, n) {
            var r = n.statusAilmentsOptions,
                i = r && r.infoMap && r.infoMap.maxConsumableHpStock;
            if (!i) {
                var s = _.find(n.statusAilments, function(e) {
                        return t.StatusAilmentsConfig.getParam(e).isHpStock
                    }),
                    o = t.StatusAilmentsConfig.getParam(s);
                i = o.maxConsumableHpStock
            }
            if (!i || i <= 0) throw new Error("invalid maxConsumableHpStock. " + i);
            return _.extend(n, {
                isHpStock: !0,
                hpStockDamage: -1 * i
            })
        }
    }), i[n.CALC_HOOK.DAMAGE_BARRIER] = r.extend({
        shouldHook: function(e, n) {
            var r = n.receiver;
            if (!r.statusAilments.hasDamageBarrier()) return !1;
            if (!n.canHit) return !1;
            if (!n.isDamage) return !1;
            if ((n.damage || 0) <= 0) return !1;
            var i = e.ability,
                s = i.get("exerciseType"),
                o = e.type,
                u = "DAMAGE_BARRIER";
            return t.StatusAilments.judgeHittabilityByReason(s, o, u) ? !0 : !1
        },
        postCalculate: function(e, n) {
            var r = n.receiver.statusAilments,
                i = r.havingDamageBarrierId(),
                s = n.damage,
                o = r.getDamageBarrierRemainHp(i),
                u = _.min([s, o]),
                a = s - u;
            r.consumeDamageBarrier(i, u);
            var f = a === 0 ? 0 : void 0,
                l = e.ability;
            if (!_.isEmpty(l) && !_.isUndefined(n.absorber)) {
                var c = t.util.DamageCalculator.calculateAbsorbHpDamageByAbility(a, l);
                n.absorbHp = _.extend(n.absorbHp, {
                    damage: c
                }, t.util.DamageCalculator.calculateHp(n.absorber, c))
            }
            return _.extend(n, {
                damage: a,
                fakeDamage: f
            }, t.util.DamageCalculator.calculateHp(n.receiver, a))
        }
    }), i[n.CALC_HOOK.FLIGHT_ATTACK] = r.extend({
        shouldHook: function(e, t) {
            var n = e.ability;
            return n.get("isFlightAttack") ? !0 : !1
        },
        postCalculate: function(e, t) {
            return _.extend(t, {
                isFlightAttack: !0
            }), t
        }
    }), i[n.CALC_HOOK.UNDEAD_CURE] = r.extend({
        shouldHook: function(e, r) {
            if (n.CALC_TYPE.HEAL !== e.type && n.CALC_TYPE.FRACTION_HEAL !== e.type) return !1;
            var i = e.target.receiver;
            if (!i.isUndeadBreed()) return !1;
            var s = e.ability;
            return s.get("exerciseType") !== t.Conf.EXERCISE_TYPE.WHITE_MAGIC ? !1 : !0
        },
        postCalculate: function(e, r) {
            var i = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.MAGIC
            }));
            return i.counterEnable = !0, i
        }
    }), i[n.CALC_HOOK.SA_DAMAGE_REVERSE] = r.extend({
        shouldHook: function(e, t) {
            var n = t.receiver,
                r = n.getDamageReverseSaIds();
            if (!(r && r.length > 0)) return !1;
            var i = e.ability;
            return _.contains(r, i.get("reasonStatusAilmentId")) ? t.canHit ? !0 : !1 : !1
        },
        postCalculate: function(e, n) {
            var r = n.receiver,
                i = -1 * n.damage;
            return _.extend(n, {
                damage: i
            }, t.util.DamageCalculator.calculateHp(r, i)), n
        }
    }), i[n.CALC_HOOK.ADJUST_DAMAGE] = r.extend({
        shouldHook: function(e, t) {
            if (!t.canHit) return !1;
            var n = t.receiver,
                r = {
                    calcType: e.type,
                    exerciseType: e.ability && e.ability.get("exerciseType"),
                    damage: t.damage
                };
            return n.hasAdjustDamageConf(r) ? !0 : !1
        },
        postCalculate: function(e, n) {
            var r = n.receiver,
                i = e.ability,
                s = {
                    calcType: e.type,
                    exerciseType: i && i.get("exerciseType"),
                    damage: n.damage
                },
                o = r.detectAdjustDamageConfig(s),
                u = o.factor,
                a = t.util.DamageCalculator.getAllowableDamage(Math.floor(n.damage * u / 100), {
                    maxDamageThresholdType: i.get("maxDamageThresholdType"),
                    minDamageThresholdType: i.get("minDamageThresholdType")
                });
            _.extend(n, {
                damage: a
            }, t.util.DamageCalculator.calculateHp(r, a));
            if (!_.isUndefined(i) && !_.isUndefined(i.get("absorbHpFactor")) && !_.isUndefined(n.absorber)) {
                var f = t.util.DamageCalculator.calculateAbsorbHpDamageByAbility(a, i);
                n.absorbHp = _.extend(n.absorbHp, {
                    damage: f
                }, t.util.DamageCalculator.calculateHp(n.absorber, f))
            }
            return n
        }
    }), i[n.CALC_HOOK.UNDEAD_RAISE] = r.extend({
        shouldHook: function(e, r) {
            if (n.CALC_TYPE.HEAL_DEATH !== e.type) return !1;
            var i = e.target.receiver;
            if (!i.isUndeadBreed()) return !1;
            var s = e.ability;
            return s.get("exerciseType") !== t.Conf.EXERCISE_TYPE.WHITE_MAGIC ? !1 : !0
        },
        postCalculate: function(e, r) {
            var i = {};
            i[t.Conf.STATUS_AILMENTS_TYPE.INSTANT_DEATH] = 1;
            var s = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.STATUS_AILMENTS,
                atkStatusAilments: i,
                forceHit: !0
            }));
            return s.counterEnable = !0, s
        }
    }), i[n.CALC_HOOK.SEALING] = r.extend({
        targetStatusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.RUNIC, t.Conf.STATUS_AILMENTS_TYPE.GRAND_CROSS],
        shouldHook: function(e, t) {
            if (t.type === n.CALC_TYPE.ABILITY_PANEL) return !1;
            if (t.executer.isBuddy()) return !1;
            var r = e.ability.get("exerciseType");
            return t.reflector && this._shouldHook(r, t.reflector) ? !0 : this._shouldHook(r, t.receiver) ? !0 : !1
        },
        _shouldHook: function(e, t) {
            return t.isBuddy() ? _.some(this.targetStatusAilmentsIds, function(n) {
                if (!t.statusAilments.has(n)) return !1;
                var r = t.statusAilments.getSubstitutesById(n);
                return r && _.contains(r, e) ? !0 : !1
            }) : !1
        },
        postCalculate: function(e, r) {
            var i = void 0,
                s = void 0,
                o = e.ability.get("exerciseType");
            e.target.reflector && this._shouldHook(o, e.target.reflector) ? i = e.target.reflector : (i = e.target.receiver, s = e.target.reflector);
            var u = void 0;
            u = t.util.PanelTargeting.search(i, {
                receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                usedNum: t.Conf.PANEL_TARGET_USED_NUM.USED,
                defaultReceptorId: t.Conf.RECEPTOR.PANEL_ATTACK
            });
            var a = t.util.DamageCalculator.calculate(_.extend({}, e, {
                type: n.CALC_TYPE.ABILITY_PANEL,
                target: {
                    receiver: i,
                    reflector: s
                },
                abilityPanel: u,
                damageFactor: 1,
                isDecrease: !1,
                hitRate: 100
            }));
            return _.extend(a, {
                hasReplacedCalcType: !0
            })
        }
    }), i[n.CALC_HOOK.PYRAMID] = r.extend({
        shouldHook: function(e, r) {
            var i = r.receiver;
            return i.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.PYRAMID) ? !r.canHit && r.damage >= 0 ? !1 : r.type === n.CALC_TYPE.HEAL_SA ? !1 : r.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : !0 : !1
        },
        postCalculate: function(e, r) {
            var i = r.type,
                s = e.ability.get("exerciseType");
            if (i === n.CALC_TYPE.ATTACK && s === t.Conf.EXERCISE_TYPE.PHYSICAL) {
                var o = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.PYRAMID]
                }));
                return _.extend(o, {
                    damage: 0,
                    fakeDamage: r.damage,
                    maxHp: r.maxHp,
                    currHp: r.prevHp,
                    prevHp: r.prevHp,
                    isCritical: r.isCritical
                }), o
            }
            return _.extend(r, {
                damage: 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.FARAWAY] = r.extend({
        shouldHook: function(e, r) {
            var i = [n.CALC_TYPE.ATTACK, n.CALC_TYPE.DAMAGED_HP, n.CALC_TYPE.FIXED_DAMAGE, n.CALC_TYPE.PHYSICAL_STATUS_AILMENTS];
            if (!_.contains(i, r.type)) return !1;
            if (e.ability.get("exerciseType") !== t.Conf.EXERCISE_TYPE.PHYSICAL) return !1;
            var s = r.receiver;
            return s.isFaraway() && r.atkType === n.ATK_TYPE.DIRECT || s.isAntiFaraway() && r.atkType === n.ATK_TYPE.INDIRECT ? !0 : !1
        },
        postCalculate: function(e, t) {
            var n = {},
                r = t.receiver;
            if (r.isFaraway()) n.isFaraway = !0;
            else {
                if (!r.isAntiFaraway()) throw new Error("receiver statusAilments invalid at CALC_HOOK.FARAWAY");
                n.isAntiFaraway = !0
            }
            return _.extend(t, e, {
                damage: 0,
                canHit: !1,
                statusAilments: [],
                unsetStatusAilments: []
            }, n), t
        }
    }), i[n.CALC_HOOK.WATER_BALL] = r.extend({
        shouldHook: function(e, r) {
            var i = r.receiver;
            return i.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.WATER_BALL) ? i.isOpponent(e.executer) ? !1 : !r.canHit && r.damage >= 0 ? !1 : r.type === n.CALC_TYPE.HEAL_SA ? !1 : r.type === n.CALC_TYPE.STATUS_AILMENTS ? !1 : t.util.DamageCalculator.isCalcTypeAttackEffectOfStatusAilements(r.type) ? !1 : !0 : !1
        },
        postCalculate: function(e, r) {
            var i = r.type,
                s = e.ability.get("exerciseType"),
                o = e.ability.get("matkElement"),
                u = [t.Conf.EXERCISE_TYPE.WHITE_MAGIC, t.Conf.EXERCISE_TYPE.BLACK_MAGIC, t.Conf.EXERCISE_TYPE.BLUE_MAGIC];
            if (r.damage > 0 && _.contains(u, s) && i === n.CALC_TYPE.MAGIC && o !== n.ELEMENT_TYPE.POISON) {
                var a = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.WATER_BALL]
                }));
                return _.extend(a, {
                    damage: 0,
                    fakeDamage: r.damage,
                    maxHp: r.maxHp,
                    currHp: r.prevHp,
                    prevHp: r.prevHp,
                    isCritical: r.isCritical
                }), a
            }
            return _.extend(r, {
                damage: 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.NON_DAMAGE] = r.extend({
        targetStatusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.NON_DAMAGE, t.Conf.STATUS_AILMENTS_TYPE.INDOMITABLENESS, t.Conf.STATUS_AILMENTS_TYPE.ARM_CATCH],
        shouldHook: function(e, t) {
            var n = this._isExistShouldHookReceiver(t),
                r = this._isExistShouldHookAbsorber(t);
            return !n && !r ? !1 : !t.canHit && t.damage >= 0 ? !1 : !0
        },
        postCalculate: function(e, t) {
            return this._isExistShouldHookReceiver(t) && (t = this._postCalculateForReceiver(t)), this._isExistShouldHookAbsorber(t) && (t.absorbHp = this._postCalculateForAbsorber(t)), t
        },
        _postCalculateForReceiver: function(e) {
            var t = {
                damage: void 0,
                absorbHp: void 0,
                statusAilments: void 0,
                unsetStatusAilments: void 0,
                canHit: !1
            };
            return e.isAbilityPanel && _.extend(t, {
                currNum: e.prevNum,
                actualDamage: void 0
            }), _.extend(e, t)
        },
        _postCalculateForAbsorber: function(e) {
            var t = {
                damage: void 0,
                actualDamage: void 0,
                currHp: e.absorbHp.prevHp,
                canHit: !1
            };
            return _.extend(e.absorbHp, t)
        },
        _isExistShouldHookReceiver: function(e) {
            return _.some(this.targetStatusAilmentsIds, function(t) {
                return e.receiver.statusAilments.has(t)
            })
        },
        _isExistShouldHookAbsorber: function(e) {
            if (!e.absorbHp) return !1;
            var t = e.absorber;
            return t ? _.some(this.targetStatusAilmentsIds, function(e) {
                return t.statusAilments.has(e)
            }) : !1
        }
    }), i[n.CALC_HOOK.INVINCIBLE] = r.extend({
        shouldHook: function(e, t) {
            var n = t.receiver;
            return n.isInvincible() && t.canHit ? !0 : !1
        },
        postCalculate: function(e, t) {
            var n = t.type;
            return _.extend(t, {
                damage: void 0,
                absorbHp: void 0,
                statusAilments: void 0,
                unsetStatusAilments: void 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.SWALLOWED] = r.extend({
        shouldHook: function(e, n) {
            var r = n.receiver,
                i = n.executer;
            return r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.SWALLOWED) && (i.isBuddy() || i.isEnemy() && n.canHit && n.isDamage) ? !0 : !1
        },
        postCalculate: function(e, t) {
            return _.extend(t, {
                damage: void 0,
                statusAilments: void 0,
                unsetStatusAilments: void 0,
                canHit: !1
            })
        }
    }), i[n.CALC_HOOK.FURY] = r.extend({
        _allowExerciseTypes: [t.Conf.EXERCISE_TYPE.PHYSICAL, t.Conf.EXERCISE_TYPE.WHITE_MAGIC, t.Conf.EXERCISE_TYPE.BLACK_MAGIC, t.Conf.EXERCISE_TYPE.NINJA],
        _ignoreCalcTypes: [t.Conf.CALC_TYPE.HEAL_SA, t.Conf.CALC_TYPE.POISON, t.Conf.CALC_TYPE.RADIANT_SHIELD, t.Conf.CALC_TYPE.STATUS_AILMENTS],
        shouldHook: function(e, n) {
            var r = n.receiver,
                i = e.ability;
            return r.statusAilments.has(t.Conf.STATUS_AILMENTS_TYPE.FURY) ? r.isOpponent(e.executer) ? !1 : !n.canHit || !n.isDamage || (n.damage || 0) <= 0 ? !1 : _.contains(this._allowExerciseTypes, i.get("exerciseType")) ? _.contains(this._ignoreCalcTypes, e.type) ? !1 : !0 : !1 : !1
        },
        postCalculate: function(e, r) {
            var i = t.util.DamageCalculator.calculate(_.extend({}, e, {
                    type: n.CALC_TYPE.HEAL_SA,
                    hitRate: 100,
                    statusAilmentsIds: [t.Conf.STATUS_AILMENTS_TYPE.FURY]
                })),
                s = [].concat(r.unsetStatusAilments || [], i.unsetStatusAilments);
            return r.unsetStatusAilments = _.uniq(s), r
        }
    }), i[n.CALC_HOOK.IGNORE_GENERAL_DAMAGED_RATE_SCORE] = r.extend({
        shouldHook: function(e, t) {
            var n = e.ability;
            return t.executer.isEnemy() ? n.get("ignoreCalcDamagedRateScore") ? !0 : !1 : !1
        },
        postCalculate: function(e, t) {
            return t.ignoreCalcDamagedRateScore = !0, t
        }
    }), i[n.CALC_HOOK.SITUATIONAL_RECALCULATE_DAMAGE] = r.extend({
        targetCalcTypes: [n.CALC_TYPE.ATTACK, n.CALC_TYPE.MAGIC],
        shouldHook: function(e, t) {
            var n = e.ability && e.ability.get("situationalRecalculateDamageHookType");
            return n ? _.contains(this.targetCalcTypes, t.type) ? !t.canHit || !t.isDamage || (t.damage || 0) <= 0 ? !1 : !0 : !1 : !1
        },
        postCalculate: function(e, n) {
            var r = n.executer,
                i = n.receiver;
            if (!_.contains(this.targetCalcTypes, n.type)) throw new Error("invalid result.type for CALC_HOOK.SITUATIONAL_RECALCULATE_DAMAGE: ", n.type);
            var s = n.damage,
                o = void 0,
                u = e.ability && e.ability.get("situationalRecalculateDamageHookType");
            return o = t.util.DamageCalculator.recalculateSituationalDamage(e, n, u), FF.logger.debug("CALC_HOOK.SITUATIONAL_RECALCULATE_DAMAGE. newDamage:", o, " oldDamage:", s), _.extend(n, {
                damage: o
            }, t.util.DamageCalculator.calculateHp(i, o)), n
        }
    });
    var s = void 0,
        o = void 0,
        u = [n.CALC_HOOK.FLIGHT_ATTACK, n.CALC_HOOK.REFRECTOR, n.CALC_HOOK.COUNTER_ENABLE, n.CALC_HOOK.MATERIA, n.CALC_HOOK.RECEIVER_SA, n.CALC_HOOK.BRK_DEF, n.CALC_HOOK.HP_STOCK, n.CALC_HOOK.SA_DAMAGE_REVERSE, n.CALC_HOOK.SITUATIONAL_RECALCULATE_DAMAGE, n.CALC_HOOK.ADJUST_DAMAGE],
        a = [n.CALC_HOOK.UNDEAD_CURE, n.CALC_HOOK.UNDEAD_RAISE, n.CALC_HOOK.SEALING, n.CALC_HOOK.PYRAMID, n.CALC_HOOK.FARAWAY, n.CALC_HOOK.WATER_BALL, n.CALC_HOOK.NON_DAMAGE, n.CALC_HOOK.SWALLOWED, n.CALC_HOOK.FURY, n.CALC_HOOK.IGNORE_GENERAL_DAMAGED_RATE_SCORE, n.CALC_HOOK.INVINCIBLE, n.CALC_HOOK.DAMAGE_BARRIER];
    FF.ns.battle.DamageCalculateHook = {
        postCalculate: function(e, t) {
            return (!s || !o) && this._init(), _.each(u, function(n) {
                var r = s[n];
                if (!r.shouldHook(e, t)) return;
                t = r.postCalculate(e, t)
            }, this), _.any(a, function(n) {
                var r = o[n];
                return r.shouldHook(e, t) ? (t = r.postCalculate(e, t), !0) : !1
            }, this), t
        },
        _init: function() {
            s = {}, o = {}, _.each(u, function(e) {
                var t = i[e];
                if (!t) throw new Error("unknown type. " + e);
                s[e] = new t
            }), _.each(a, function(e) {
                var t = i[e];
                if (!t) throw new Error("unknown type. " + e);
                o[e] = new t
            })
        }
    }
}), define("scenes/battle/util/DamageCalculateParamAdjuster", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.DAMAGE_CALCULATE_PARAM_ADJUST.SPD_CONVERT_ATK] = "_noAdjust", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.DEF_CONVERT_ATK] = "_calculateAtkByDefConvertAtk", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.VALIANT_ATTACK] = "_calculateAtkValiantAttack", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.CURRENT_HP_CONVERT_ATK] = "_calculateAtkByCurrentHp", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA] = "_calculateDamageFactorByReceiverSa", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_SA] = "_calculateDamageFactorByExecuterSa", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA_BUNDLE] = "_calculateDamageFactorByReceiverSaBundle", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_SA_BUNDLE] = "_calculateDamageFactorByExecuterSaBundle", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.ALL_ALIVE_BUDDIES] = "_calculateDamageFactorByAllAliveBuddies", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.BUDDIES_IN_FLIGHT] = "_calculateDamageFactorByBuddiesInFlight", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.RECEIVER_SA_NUM] = "_calculateDamageFactorByReceiverSaNum", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_ATK_TYPE] = "_calculateDamageFactorByExecuterAtkType", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.STATUS_DOWN_OF_ATK_DEF_MATK_MDEF_MND] = "_calculateDamageFactorByStatusDownOfAtkDefMatkMdefMnd", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.ENEMY_NUM] = "_calculateDamageFactorByEnemyNum", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.SS_POINT] = "_calculateDamageFactorBySsPoint", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.EXECUTER_EQUIPMENT_CATEGORY] = "_calculateDamageFactorByExecuterEquipmentCategory", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.BUDDIES_SEX] = "_calculateDamageFactorByBuddiesSex", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.ATK] = "_calculateDamageFactorByAtk", r[n.DAMAGE_CALCULATE_PARAM_ADJUST.DAMAGE_RECEIVE_COUNT] = "_calculateDamageFactorByDamageReceiveCount", FF.ns.battle.util.DamageCalculateParamAdjuster = {
        calculate: function(e) {
            var t = e.adjustType,
                n = r[t];
            if (!this[n]) throw new Error("invalid DAMAGE_CALCULATE_PARAM_ADJUST_TYPE: " + t);
            var i = {
                    atk: void 0,
                    damageFactor: void 0
                },
                s = this[n](e);
            return _.extend(i, s)
        },
        _noAdjust: function() {
            return {}
        },
        _calculateAtkByDefConvertAtk: function(e) {
            var t = e.atk * .3 + e.executerBaseDef * _.min([Math.pow(e.executerDef / e.executerBaseDef, e.defBufAtkConvertPower), e.maxDefBufRatio]) * .7;
            return {
                atk: t
            }
        },
        _calculateAtkValiantAttack: function(e) {
            var t = e.currHpRate,
                n = e.atk,
                r;
            return .3 < t ? r = n / .9 + (n / .9 * 1.07 - n / .9) * ((1 - t) / .7) : .2 < t && t <= .3 ? r = n / .9 * 1.07 + (n / .9 * 1.13 - n / .9 * 1.07) * ((1 - t - .7) / .1) : 0 < t && t <= .2 ? r = n / .9 * 1.13 + (n / .9 * 1.5 - n / .9 * 1.13) * Math.pow((1 - t - .8) / .2, 1.5) : r = n, {
                atk: _.min([r, n * 1.4])
            }
        },
        _calculateAtkByCurrentHp: function(e) {
            var t = e.currHpRate,
                n = e.atk,
                r = e.adjustConds[0],
                i = e.adjustConds[1],
                s = (1 - (2 / (1 + Math.exp(-1 * t * r)) - 1)) * i + n;
            return {
                atk: s
            }
        },
        _calculateDamageFactorByReceiverSa: function(e) {
            var t = e.receiver,
                n = e.adjustConds[0],
                r = e.adjustConds.slice(1),
                i = _.some(r, function(e) {
                    return t.statusAilments.has(e)
                });
            return i ? {
                damageFactor: n
            } : {}
        },
        _calculateDamageFactorByExecuterSa: function(e) {
            var t = e.executer,
                n = e.adjustConds[0],
                r = e.adjustConds.slice(1),
                i = _.some(r, function(e) {
                    return t.statusAilments.has(e)
                });
            return i ? {
                damageFactor: n
            } : {}
        },
        _calculateDamageFactorByReceiverSaBundle: function(e) {
            var n = e.adjustConds[0],
                r = e.adjustConds.slice(1),
                i = _.flatten(_.map(r, function(e) {
                    return t.StatusAilmentsConfig.getBundle(e, {
                        noThrow: !0
                    }) || []
                })),
                s = _.clone(e);
            return s.adjustConds = [].concat(n, i), this._calculateDamageFactorByReceiverSa(s)
        },
        _calculateDamageFactorByExecuterSaBundle: function(e) {
            var n = e.adjustConds[0],
                r = e.adjustConds.slice(1),
                i = _.flatten(_.map(r, function(e) {
                    return t.StatusAilmentsConfig.getBundle(e, {
                        noThrow: !0
                    }) || []
                })),
                s = _.clone(e);
            return s.adjustConds = [].concat(n, i), this._calculateDamageFactorByExecuterSa(s)
        },
        _calculateDamageFactorByAllAliveBuddies: function(e) {
            var n = e.adjustConds[0],
                r = t.ActorMgr.getAllBuddies(),
                i = _.all(r, function(e) {
                    return e.isAlive()
                });
            return i && r.length > 1 ? {
                damageFactor: n
            } : {}
        },
        _calculateDamageFactorByBuddiesInFlight: function(e) {
            var n = e.executer,
                r = e.adjustConds.slice(0, 5),
                i = _.filter(t.ActorMgr.getBuddiesInFlight(), function(e) {
                    return !e.equals(n)
                });
            if (i.length <= 0) return {};
            var s = _.min([i.length - 1, r.length - 1]),
                o = r[s];
            if (!o) throw new Error("invalid index: " + s);
            return {
                damageFactor: o
            }
        },
        _calculateDamageFactorByBuddiesSex: function(e) {
            var n = e.adjustConds[0],
                r = e.adjustConds[1],
                i = e.adjustConds[2],
                s = _.filter(t.ActorMgr.getAllBuddies(), function(e) {
                    return e.get("sex") === n && !e.isForceEscaped()
                });
            return s.length < r ? {} : {
                damageFactor: i
            }
        },
        _calculateDamageFactorByDamageReceiveCount: function(e) {
            var n = e.adjustConds[0],
                r = e.adjustConds[1],
                i = e.adjustConds[2],
                s = e.adjustConds[3] * .001,
                o = e.executer.actorStats.getStats(t.Conf.ACTOR_STATS_TYPE.DAMAGE_RECEIVE_COUNT),
                u = o.get(n),
                a = this.__calculateDamageFactorByDamageReceiveCount(r, i, s, u);
            return {
                damageFactor: a
            }
        },
        __calculateDamageFactorByDamageReceiveCount: function(e, t, n, r) {
            return (e - t) * (1 - Math.pow(Math.E, -1 * n * r)) + t
        },
        _calculateDamageFactorByReceiverSaNum: function(e) {
            var n = e.receiver,
                r = e.adjustConds[0],
                i = e.adjustConds.slice(1, 4),
                s = t.StatusAilmentsConfig.getBundle(r),
                o = _.filter(s, function(e) {
                    return n.statusAilments.has(e)
                });
            if (o.length <= 0) return {};
            var u = _.min([o.length - 1, i.length - 1]),
                a = i[u];
            if (!a) throw new Error("invalid index:" + u);
            return {
                damageFactor: a
            }
        },
        _calculateDamageFactorByExecuterAtkType: function(e) {
            var t = e.adjustConds[0],
                n = e.adjustConds[1],
                r = e.executer;
            return r.isBuddy() ? r.get("atkType") !== n ? {} : {
                damageFactor: t
            } : {}
        },
        _calculateDamageFactorByStatusDownOfAtkDefMatkMdefMnd: function(e) {
            var r = e.adjustConds.slice(0, 5),
                i = e.receiver,
                s = t.Config.getInstance().get("ParamName"),
                o = _.map([n.PARAM_ID_OF.ATK, n.PARAM_ID_OF.DEF, n.PARAM_ID_OF.MATK, n.PARAM_ID_OF.MDEF, n.PARAM_ID_OF.MND], function(e) {
                    return s[e]
                }),
                u = {};
            _.each(i.statusAilments.getAllBoosts(), function(e) {
                _.contains(o, e.paramName) && e.rate < 0 && (u[e.paramName] = !0)
            });
            var a = _.size(u);
            if (a === 0) return {};
            var f = _.min([a - 1, o.length - 1]);
            return {
                damageFactor: r[f]
            }
        },
        _calculateDamageFactorByEnemyNum: function(e) {
            var n = e.adjustConds.slice(0, 4),
                r = _.filter(t.ActorMgr.getAliveEnemies(), function(e) {
                    return e.isPossibleToTarget()
                }),
                i = _.min([r.length - 1, n.length - 1]);
            i = _.max([i, 0]);
            var s = n[i];
            if (!s) throw new Error("invalid index: " + i);
            return {
                damageFactor: s
            }
        },
        _calculateDamageFactorBySsPoint: function(e) {
            var t = e.ability,
                n = e.executer,
                r = n.getSoulStrike().get("point"),
                i = e.adjustConds[0] * .001,
                s = e.adjustConds[1],
                o = e.adjustConds[2];
            n.isPossessedBySupporter() || (r += t.get("consumeSoulStrikePoint"));
            var u = _.max([i * r + s, o]);
            return {
                damageFactor: u
            }
        },
        _calculateDamageFactorByExecuterEquipmentCategory: function(e) {
            var t = e.adjustConds[0],
                n = e.adjustConds[1],
                r = e.executer;
            if (!r.isBuddy()) return {};
            var i = r.get("weapon").categoryId,
                s = r.get("armor").categoryId;
            return _.contains([i, s], n) ? {
                damageFactor: t
            } : {}
        },
        _calculateDamageFactorByAtk: function(e) {
            var t = e.executer.get("atk"),
                n = e.defaultDamageFactor,
                r = e.adjustConds[0] / 100,
                i = e.adjustConds[1] / 100,
                s = e.adjustConds[2] / 100,
                o = Math.floor((1 + _.min([(1 / (1 + Math.exp(-t / 1e3 * r)) * 2 - 1) * i, s])) * n);
            return {
                damageFactor: o
            }
        }
    }
}), define("scenes/battle/util/DelayCallback", [], function() {
    var e = {},
        t = 1;
    return FF.ns.battle.util.DelayCallback = {
        update: function(t, n) {
            n = n || t;
            var r = [];
            _.each(e, function(e, i) {
                e.forBattle ? e.elapsedTime += n : e.elapsedTime += t, e.elapsedTime >= e.waitTime && (e.callback(), r.push(i))
            }), _.each(r, function(t) {
                delete e[t]
            })
        },
        register: function(n, r) {
            return e[t] = {
                waitTime: n,
                callback: r,
                elapsedTime: 0
            }, t++
        },
        registerForBattle: function(n, r) {
            return e[t] = {
                waitTime: n,
                callback: r,
                elapsedTime: 0,
                forBattle: !0
            }, t++
        },
        registerDeferred: function(e) {
            var t = $.Deferred();
            return this.register(e, function() {
                t.resolve()
            }), t
        },
        clear: function(t) {
            delete e[t]
        }
    }, FF.ns.battle.util.DelayCallback
}), define("scenes/battle/util/DropItem", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.DROP_ITEM_TYPE.GIL] = "_giveGil", r[n.DROP_ITEM_TYPE.POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.HI_POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.X_POTION] = "_givePotion", r[n.DROP_ITEM_TYPE.ETHER] = "_giveEther", r[n.DROP_ITEM_TYPE.TURBO_ETHER] = "_giveEther", r[n.DROP_ITEM_TYPE.TREASURE] = "_giveTreasure", r[n.DROP_ITEM_TYPE.ORB] = "_giveOrb", r[n.DROP_ITEM_TYPE.EVENT_ITEM] = "_giveEventItem";
    var i = {};
    i[n.DROP_ITEM_TYPE.GIL] = "_applyGil", i[n.DROP_ITEM_TYPE.POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.HI_POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.X_POTION] = "_applyPotion", i[n.DROP_ITEM_TYPE.ETHER] = "_applyEther", i[n.DROP_ITEM_TYPE.TURBO_ETHER] = "_applyEther", i[n.DROP_ITEM_TYPE.TREASURE] = "_applyTreasure", i[n.DROP_ITEM_TYPE.ORB] = "_applyOrb", i[n.DROP_ITEM_TYPE.EVENT_ITEM] = "_applyEventItem";
    var s = void 0;
    FF.ns.battle.util.DropItem = {
        _resetTmpNumMap: function() {
            var e = t.BuddyPartyMgr.getInstance();
            s = {
                gil: e.get("gil"),
                orb: e.get("orb"),
                treasure: e.get("treasure"),
                eventItem: e.get("eventItem")
            }
        },
        give: function(e, n) {
            this._resetTmpNumMap();
            var r = {},
                i = {};
            _.each(e, function(e) {
                var t = e.container.containerUid;
                r[t] = r[t] || [], r[t].push(e), i[t] = e.container
            });
            var s = [];
            return _.each(i, function(e, t) {
                if (!e.isAllDead()) return;
                var n = r[t],
                    i = e.getDropItemList();
                for (var o = 0, u = i.length; o < u; o++) s.push({
                    executer: n[o % n.length],
                    dropItem: i[o]
                })
            }), n === t.Conf.JUDGE.VICTORY && _.each(t.BattleInfo.getInstance().getDropItemList(), function(t, n) {
                s.push({
                    executer: e[n % e.length],
                    dropItem: t
                })
            }), _.map(s, function(e) {
                return this._give(e)
            }, this)
        },
        applyResult: function(e) {
            _.each(e, function(e) {
                var t = e.item;
                FF.logger.debug("drop item apply. type: ", t.type);
                var n = this._getApplyFuncName(t.type);
                this[n](e)
            }, this)
        },
        _give: function(e) {
            var t = e.dropItem;
            FF.logger.debug("drop item. type: ", t.type);
            var n = this._getGiveFuncName(t.type);
            return {
                executer: e.executer,
                item: e.dropItem,
                dropItemObjects: this[n](e)
            }
        },
        _givePotion: function(e) {
            var n = e.dropItem,
                r = [],
                i = t.ActorMgr.getAliveBuddies();
            return _.map(i, function(r) {
                var i = r.get("hp"),
                    s = t.util.DamageCalculator.calculatePotion({
                        item: n,
                        receiver: r
                    });
                return s.executer = e.executer, s.item = e.dropItem, s
            }, this)
        },
        _applyPotion: function(e) {
            _.each(e.dropItemObjects, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        _giveEther: function(e) {
            var n = e.dropItem,
                r = t.ActorMgr.getAliveBuddies();
            return _.map(r, function(r) {
                var i = this._lotAbilityPanelForEther(r),
                    s = t.util.DamageCalculator.calculateEther({
                        item: n,
                        receiver: r,
                        abilityPanel: i
                    });
                return s.executer = e.executer, s.item = e.dropItem, s
            }, this)
        },
        _applyEther: function(e) {
            _.each(e.dropItemObjects, function(e) {
                e.receiver.applyDamageObject(e)
            })
        },
        _lotAbilityPanelForEther: function(e) {
            return t.util.PanelTargeting.search(e, {
                receptable: t.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: t.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                defaultReceptorId: t.Conf.RECEPTOR.PANEL_ATTACK
            })
        },
        _giveGil: function(e) {
            var t = e.dropItem,
                n = t.amount;
            if (!n || n < 0) n = 0;
            var r = s.gil,
                i = r + n;
            return s.gil = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyGil: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveGil(e.num)
            })
        },
        _giveTreasure: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.treasure,
                i = r + n;
            return s.treasure = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyTreasure: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveTreasure(e.num)
            })
        },
        _giveOrb: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.orb,
                i = r + n;
            return s.orb = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyOrb: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveOrb(e.num)
            })
        },
        _giveEventItem: function(e) {
            var t = e.dropItem,
                n = t.num || 0,
                r = s.eventItem,
                i = r + n;
            return s.eventItem = i, [{
                executer: e.executer,
                item: e.dropItem,
                num: n,
                prevNum: r,
                currNum: i
            }]
        },
        _applyEventItem: function(e) {
            _.each(e.dropItemObjects, function(e) {
                t.BuddyPartyMgr.getInstance().giveEventItem(e.num)
            })
        },
        _getGiveFuncName: function(e) {
            var t = r[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        _getApplyFuncName: function(e) {
            var t = i[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        }
    }
}), define("scenes/battle/util/Targeting", ["underscore", "util"], function(e, t) {
    function s(e, t, r, s, o) {
        if (e.length === 0) return void 0;
        var u = void 0,
            a = {};
        switch (t) {
            case n.Conf.TARGET_METHOD.HP_RATIO_DESC:
                u = i.hpRatio, a.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.HP_RATIO_ASC:
                u = i.hpRatio, a.sign = 1;
                break;
            case n.Conf.TARGET_METHOD.HP_DESC:
                u = i.hp, a.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.HP_ASC:
                u = i.hp, a.sign = 1;
                break;
            case n.Conf.TARGET_METHOD.SA_RANDOM:
                u = i.sa, a.statusAilmentsId = r, a.has = !0;
                break;
            case n.Conf.TARGET_METHOD.DIS_SA_RANDOM:
                u = i.sa, a.statusAilmentsId = r, a.has = !1;
                break;
            case n.Conf.TARGET_METHOD.ESNA:
                u = i.saBundle, a.bundleId = n.Conf.STATUS_AILMENTS_BUNDLE.ESNA, a.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.RANDOM:
                break;
            case n.Conf.TARGET_METHOD.NOTHING:
                break;
            case n.Conf.TARGET_METHOD.DISPEL:
                u = i.saBundle, a.bundleId = n.Conf.STATUS_AILMENTS_BUNDLE.DISPEL, a.sign = -1;
                break;
            case n.Conf.TARGET_METHOD.MP_RANDOM:
                u = i.mp, a.has = !0;
                break;
            case n.Conf.TARGET_METHOD.MARAISE:
                u = i.maraise;
                break;
            case n.Conf.TARGET_METHOD.LOT_BY_HP_RATE:
                u = i.lotByHpRatio, a.minWeight = 10, a.maxWeight = 20, a.minHpRatio = 30, a.maxHpRatio = 70;
                break;
            case n.Conf.TARGET_METHOD.BUDDY_SMART:
                u = i.buddySmart, a.executer = s, a.abilityId = o;
                break;
            case n.Conf.TARGET_METHOD.AI_SMART:
                u = i.aiSmart, a.executer = s, a.abilityId = o, a.forceIgnoresReflection = !1;
                break;
            case n.Conf.TARGET_METHOD.AI_SMART_IGNORE_REFRECTION:
                u = i.aiSmart, a.executer = s, a.abilityId = o, a.forceIgnoresReflection = !0;
                break;
            default:
                throw new Error("unknown targetMethod. [" + t + "]")
        }
        return u ? u(e, a) : e[0]
    }

    function o(t, r) {
        switch (t) {
            case n.Conf.TARGET_DEATH.EXCLUDE_PURE_DEATH:
                return e.filter(r, function(e) {
                    return e.isAlive({
                        pureDeath: !0
                    })
                });
            case n.Conf.TARGET_DEATH.EXCLUDE:
                return e.filter(r, function(e) {
                    return e.isAlive()
                });
            case n.Conf.TARGET_DEATH.INCLUDE:
                return r;
            default:
                throw new Error("unknown targetDeath.[" + t + "]")
        }
    }

    function u(t, r, i) {
        switch (r) {
            case n.Conf.TARGET_SEGMENT.OPPONENT:
                return e.filter(i, function(e) {
                    return t.isOpponent(e)
                });
            case n.Conf.TARGET_SEGMENT.COLLEAGUE:
                return e.filter(i, function(e) {
                    return t.isColleague(e)
                });
            case n.Conf.TARGET_SEGMENT.BOTH:
                return i;
            case n.Conf.TARGET_SEGMENT.BOTH_EXCEPT_MYSELF:
                return e.filter(i, function(e) {
                    return !t.equals(e)
                });
            case n.Conf.TARGET_SEGMENT.COLLEAGUE_EXCEPT_MYSELF:
                return e.filter(i, function(e) {
                    return !t.equals(e) && t.isColleague(e)
                });
            case n.Conf.TARGET_SEGMENT.MYSELF_AND_OPPONENT:
                return e.filter(i, function(e) {
                    return t.equals(e) || t.isOpponent(e)
                });
            case n.Conf.TARGET_SEGMENT.AI_NO_1:
                return e.filter(i, function(e) {
                    return t.isColleague(e) && e.get("no") === 1
                });
            default:
                throw new Error("unknown segment. [" + r + "]")
        }
    }

    function a(t) {
        return e.filter(t, function(e) {
            return e.isPossibleToTarget()
        })
    }

    function f(e, t, r) {
        var i = n.ActorMgr.getSubstituteTarget(e, t);
        return i && i.isColleague(r) && i.isPossibleToTarget() ? i : void 0
    }

    function l(e) {
        var t = e.forceTargets;
        return t = a(t), o(e.death, t)
    }

    function c(e) {
        var t = e.executer,
            r = e.at,
            i = e.atMethod;
        if (!r) return void 0;
        if (!r.isPossibleToTarget()) return void 0;
        t.isEnemy() && (i = n.Conf.ACTIVE_TARGET_METHOD.BOTH_ENABLE);
        var s = !1;
        switch (i) {
            case n.Conf.ACTIVE_TARGET_METHOD.BOTH_DISABLE:
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.OPPONENT_DISABLE:
                t.isColleague(r) && (s = !0);
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.COLLEGUE_DISABLE:
                t.isOpponent(r) && (s = !0);
                break;
            case n.Conf.ACTIVE_TARGET_METHOD.BOTH_ENABLE:
                s = !0;
                break;
            default:
                throw new Error("unknown activeTargetMethod. [" + i + "]")
        }
        if (!s) return;
        var u = o(e.death, [r])[0];
        if (!u) return;
        var a = f(t, e.exerType, u);
        return a ? a : u
    }

    function h(t) {
        if (t.executer.isInConfusion() && !t.executer.shouldIgnoreIncontrollable()) return m(t);
        if (t.executer.isInBerserker() && !t.executer.shouldIgnoreIncontrollable()) return g(t);
        if (!e.isUndefined(t.forceTargets)) return l(t);
        var n = c(t);
        return n ? [n] : p(t)
    }

    function p(e) {
        switch (e.range) {
            case n.Conf.TARGET_RANGE.SINGLE:
                return v(e);
            case n.Conf.TARGET_RANGE.ALL:
                return d(e);
            case n.Conf.TARGET_RANGE.SELF:
                return [e.executer];
            default:
                throw new Error("unknown target_range. [" + e.range + "]")
        }
    }

    function d(e) {
        var t = u(e.executer, e.segment, e.actors);
        return t = a(t), o(e.death, t)
    }

    function v(e) {
        var t = u(e.executer, e.segment, e.actors);
        t = a(t), t = o(e.death, t);
        var n = s(t, e.method, e.saId, e.executer, e.abilityId);
        if (n) {
            var r = f(e.executer, e.exerType, n);
            return r ? [r] : [n]
        }
        return []
    }

    function m(t) {
        var r = [n.Conf.TARGET_SEGMENT.OPPONENT, n.Conf.TARGET_SEGMENT.COLLEAGUE];
        return e.extend(t, {
            method: n.Conf.TARGET_METHOD.RANDOM,
            segment: e.first(e.shuffle(r))
        }), p(t)
    }

    function g(t) {
        return e.extend(t, {
            method: n.Conf.TARGET_METHOD.RANDOM
        }), p(t)
    }

    function y(t) {
        return e.map(t, function(e) {
            return {
                receiver: e,
                reflector: void 0
            }
        })
    }

    function b(e) {
        if (e.range === n.Conf.TARGET_RANGE.ALL) return !0;
        var t = n.Config.getInstance().get("ReflectionExerciseTypes");
        return t.indexOf(e.exerType) < 0 ? !0 : e.ignoresReflection ? !0 : !1
    }

    function w(t, r) {
        if (b(r)) return;
        var i = e.some(t, function(e) {
            var t = r.executer,
                i = e.receiver;
            if (!i.isReflected()) return !1;
            var s = t.isOpponent(i) ? n.Conf.TARGET_SEGMENT.COLLEAGUE : n.Conf.TARGET_SEGMENT.OPPONENT,
                o = p({
                    executer: r.executer,
                    range: n.Conf.TARGET_RANGE.SINGLE,
                    segment: s,
                    method: n.Conf.TARGET_METHOD.SA_RANDOM,
                    forceTargets: void 0,
                    at: void 0,
                    atMethod: n.Conf.ACTIVE_TARGET_METHOD.BOTH_DISABLE,
                    death: r.death,
                    exerType: r.exerType,
                    actors: r.actors
                });
            return o.length <= 0 ? !0 : (e.reflector = i, e.receiver = o[0], !1)
        });
        i && t.splice(0, t.length)
    }

    function E(r, i, s) {
        s = t.option({
            actors: void 0,
            ignoresReflection: !0,
            forceTargets: void 0,
            activeTarget: void 0
        }, s);
        var o = s.actors ? s.actors : n.ActorMgr.getAll();
        o = e.shuffle(o);
        var u = {
            executer: i,
            range: r.options.targetRange,
            segment: r.options.targetSegment,
            method: r.options.targetMethod,
            forceTargets: s.forceTargets,
            at: s.activeTarget,
            atMethod: r.options.activeTargetMethod,
            saId: r.options.statusAilmentsId,
            exerType: r.exerciseType,
            death: r.options.targetDeath,
            ignoresReflection: s.ignoresReflection,
            actors: o,
            abilityId: r.abilityId
        };
        return u
    }
    var n = FF.ns.battle,
        r = function(e, t) {
            e.sort(function(e, n) {
                var r, i;
                for (var s = 0, o = t.length; s < o; s++) {
                    r = t[s], i = r(e) - r(n);
                    if (i) return i
                }
                return 0
            })
        },
        i = {
            hpRatio: function(e, n) {
                var i = t.option({
                    sign: 1
                }, n);
                return r(e, [function(e) {
                    return i.sign * Math.floor(e.get("hp") / e.get("maxHp") * 100)
                }]), e[0]
            },
            hp: function(e, n) {
                var i = t.option({
                    sign: 1
                }, n);
                return r(e, [function(e) {
                    return i.sign * e.get("hp")
                }]), e[0]
            },
            sa: function(e, n) {
                var i = t.option({
                    statusAilmentsId: 0,
                    has: !0
                }, n);
                return r(e, [function(e) {
                    return i.has ? e.statusAilments.has(i.statusAilmentsId) ? 0 : 1 : e.statusAilments.has(i.statusAilmentsId) ? 1 : 0
                }]), e[0]
            },
            saBundle: function(i, s) {
                var o = t.option({
                        bundleId: 0,
                        sign: 1
                    }, s),
                    u = n.StatusAilmentsConfig.getBundle(o.bundleId),
                    a = {};
                return e.each(i, function(t) {
                    a[t.getUid()] = e.intersection(u, t.statusAilments.getRefs()).length
                }), r(i, [function(e) {
                    return o.sign * a[e.getUid()]
                }]), i[0]
            },
            mp: function(e, i) {
                var s = t.option({
                    has: !0
                }, i);
                return r(e, [function(e) {
                    if (!e.isBuddy()) return 1;
                    var t = n.util.PanelTargeting.search(e, {
                        receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                        remainNum: n.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS,
                        usedNum: n.Conf.PANEL_TARGET_USED_NUM.ANY
                    });
                    return s.has ? t ? 0 : 1 : t ? 1 : 0
                }]), e[0]
            },
            maraise: function(t, n) {
                var r = e.find(t, function(e) {
                    return e.isDead({
                        pureDeath: !0
                    })
                });
                if (r) return r;
                var s = e.filter(t, function(e) {
                    return e.isAlive()
                });
                return i.hpRatio(s, {
                    sign: 1
                })
            },
            lotByHpRatio: function(n, r) {
                var i = t.option({
                        minWeight: 30,
                        maxWeight: 70,
                        minHpRatio: 30,
                        maxHpRatio: 70
                    }, r),
                    s = (i.maxWeight - i.minWeight) / (i.maxHpRatio - i.minHpRatio);
                return t.lot(n, function(t) {
                    var n = t.getRemainingHpRate(),
                        r = s * (n - i.minHpRatio) + i.minWeight;
                    return e.min([e.max([i.maxWeight, r]), i.minWeight])
                })
            },
            buddySmart: function(e, t) {
                var i = t.executer,
                    s = t.abilityId;
                return r(e, [function(e) {
                    return n.util.EnemyTargeting.getPriorityForBuddy(i, s, e)
                }]), e[0]
            },
            aiSmart: function(e, i) {
                var s = t.option({
                        forceIgnoresReflection: !0
                    }, i),
                    o = i.executer,
                    u = i.abilityId;
                return r(e, [function(e) {
                    return n.util.EnemyTargeting.getPriorityForEnemy(o, u, e, s)
                }]), e[0]
            }
        };
    FF.ns.battle.util.Targeting = {
        search: function(r, i) {
            i = t.option({
                actors: void 0
            }, i);
            var s = i.actors ? i.actors : n.ActorMgr.getAll();
            s = e.shuffle(s);
            var o = {
                executer: r.executer,
                range: r.get("targetRange"),
                segment: r.get("targetSegment"),
                method: r.get("targetMethod"),
                forceTargets: r.get("forceTargets"),
                at: r.get("activeTarget"),
                atMethod: r.get("activeTargetMethod"),
                saId: r.get("statusAilmentsId"),
                exerType: r.get("exerciseType"),
                death: r.get("targetDeath"),
                ignoresReflection: !!r.get("ignoresReflection"),
                actors: s,
                abilityId: r.get("abilityId")
            };
            FF.logger.info("TARGET", o);
            var u = h(o),
                a = y(u);
            return w(a, o), a
        },
        makeResult: function(e) {
            var t = [];
            return e && (t = t.concat(e)), y(t)
        },
        searchByAbilityInfo: function(e, t, n) {
            var r = E(e, t, n);
            FF.logger.info("TARGET", r);
            var i = h(r),
                s = y(i);
            return w(s, r), s
        },
        getIgnoresReflectionByAbilityInfo: function(e, t, n) {
            var r = E(e, t, n);
            return b(r)
        }
    }
}), define("scenes/battle/util/EnemyTargeting", ["underscore", "util"], function(e, t) {
    var n = FF.ns.battle,
        r = n.Conf.ENEMY_TARGETING,
        i = {
            healHpRate: 80,
            forceIgnoresReflection: !0,
            forceTargets: void 0,
            activeTarget: void 0
        },
        s = {
            healHpRate: 99,
            forceIgnoresReflection: !1,
            forceTargets: void 0,
            activeTarget: void 0
        },
        o = function(e, t) {
            if (t) return !1;
            var n = e.isInReflection();
            return n
        },
        u = function(t, n, r) {
            if (o(t, n)) return !1;
            var i = e.all(r, function(e) {
                return t.statusAilments.has(e)
            });
            return !i
        },
        a = function(t, n, r) {
            if (o(t, n)) return !1;
            var i = e.some(r, function(e) {
                return t.statusAilments.has(e)
            });
            return i
        },
        f = function(e, t, n) {
            if (o(e, t)) return !1;
            var r = e.getRemainingHpRate(),
                i = r <= n;
            return i
        },
        l = function(e, t, n, i, s, o) {
            var l = !0,
                c = !1;
            return !c && 0 <= e.indexOf(r.SET_SA) && (l = !1, c = u(t, n, i)), !c && 0 <= e.indexOf(r.UNSET_SA) && (l = !1, c = a(t, n, s)), !c && 0 <= e.indexOf(r.HEAL_HP) && (l = !1, c = f(t, n, o)), l || c
        },
        c = function(r, s, o) {
            var u = n.AbilityInfoMgr.getInstance(),
                a = u.getById(s),
                f = t.option(i, o);
            if (o) {
                var c = o[s];
                f = t.option(f, c)
            }
            var h = u.getEnemyTargeting(s);
            if (h.length === 0) return {
                isThereEnable: !0,
                targetInfoList: void 0
            };
            var p = u.getSaIdsForSetById(s),
                d = u.getSaIdsForUnsetById(s),
                v = f.healHpRate,
                m = f.forceIgnoresReflection;
            m || (m = n.util.Targeting.getIgnoresReflectionByAbilityInfo(a, r, {
                ignoresReflection: u.getIgnoresReflection(s)
            }));
            if (r.isIncontrollable()) throw new Error("cannot use in uncontrollable");
            var g = n.util.Targeting.searchByAbilityInfo(a, r, {
                    forceTargets: f.forceTargets,
                    activeTarget: f.activeTarget
                }),
                y = e.map(g, function(e) {
                    var t = e.receiver,
                        n = l(h, t, m, p, d, v);
                    return {
                        isEnable: n,
                        targeting: e
                    }
                }),
                b = e.some(y, function(e) {
                    return e.isEnable
                }),
                w = {
                    isThereEnable: b,
                    targetInfoList: y
                };
            return w
        },
        h = function(e, t, n) {
            var r = c(e, t, n);
            return r
        },
        p = function(r, s, u) {
            var a = t.option(i, u),
                f = n.AbilityInfoMgr.getInstance(),
                l = f.getById(s),
                c = f.getEnemyTargeting(s),
                h = a.forceIgnoresReflection;
            h || (h = n.util.Targeting.getIgnoresReflectionByAbilityInfo(l, r, {
                ignoresReflection: f.getIgnoresReflection(s)
            }));
            if (c.length === 0) return {
                isThereEnable: !0,
                targetInfoList: void 0
            };
            var p = n.util.Targeting.searchByAbilityInfo(l, r, {
                    forceTargets: a.forceTargets,
                    activeTarget: a.activeTarget
                }),
                d = e.map(p, function(e) {
                    var t = e.receiver,
                        n = !o(t, h);
                    return {
                        isEnable: n,
                        targeting: e
                    }
                }),
                v = e.some(d, function(e) {
                    return e.isEnable
                }),
                m = {
                    isThereEnable: v,
                    targetInfoList: d
                };
            return m
        },
        d = function(e, r, s, o) {
            var u = t.option(i, o),
                a = n.AbilityInfoMgr.getInstance(),
                f = a.getById(r),
                c = a.getEnemyTargeting(r),
                h = a.getSaIdsForSetById(r),
                p = a.getSaIdsForUnsetById(r),
                d = u.healHpRate,
                v = u.forceIgnoresReflection;
            v || (v = n.util.Targeting.getIgnoresReflectionByAbilityInfo(f, e, {
                ignoresReflection: a.getIgnoresReflection(r)
            }));
            var m = l(c, s, v, h, p, d);
            return {
                abilityInfoMgr: a,
                abilityInfo: f,
                checkList: c,
                saIdsForSet: h,
                saIdsForUnset: p,
                healHpRate: d,
                ignoresReflection: v,
                isEnable: m
            }
        },
        v = {
            HIGH: 0,
            NOT_FULL_HP: 1e3,
            NOT_REFLECTION: 2e3,
            LOW: 9999
        },
        m = {
            HIGH: 0,
            SA_HIGH: 1e3,
            NOT_SA_HIGH: 2e3,
            LOW: 9999
        },
        g = 60;
    FF.ns.battle.util.EnemyTargeting = {
        getWithoutAbilityList: function(t, n, r) {
            var i = e.filter(n, function(e) {
                var n = this.isThereEnableAbilityTarget(t, e, r);
                return !n
            }, this);
            return i
        },
        isThereEnableAbilityTarget: function(e, t, n) {
            var r = this.getEnableAbilityTargetInfo(e, t, n);
            return r.isThereEnable
        },
        getEnableAbilityTargetInfo: function(e, t, r) {
            var i = n.AbilityInfoMgr.getInstance().getById(t),
                s;
            return i.options.targetRange === n.Conf.TARGET_RANGE.ALL ? s = h(e, t, r) : s = c(e, t, r), s
        },
        isThereEnableAbilityTargetWithCondReflection: function(e, t, n) {
            var r = p(e, t, n);
            return r.isThereEnable
        },
        isEnableTargetForEnemy: function(e, t, n, r) {
            var i = d(e, t, n, r);
            return i.isEnable
        },
        isEnableTargetForBuddy: function(e, n, r, i) {
            var o = t.option(s, i),
                u = d(e, n, r, o);
            return u.isEnable
        },
        getPriorityForEnemy: function(e, t, n, i) {
            var s = d(e, t, n, i);
            return s.isEnable ? v.HIGH : o(n, s.ignoresReflection) ? v.LOW : 0 <= s.checkList.indexOf(r.HEAL_HP) && n.getRemainingHpRate() < 100 ? v.NOT_FULL_HP : v.NOT_REFLECTION
        },
        getPriorityForBuddy: function(e, n, i, s) {
            var u = t.option({
                    healHpRate: -1,
                    forceIgnoresReflection: !1
                }, s),
                a = d(e, n, i, u);
            if (o(i, a.ignoresReflection)) return m.LOW;
            if (a.checkList.length === 0) return m.HIGH + i.getRemainingHpRate();
            var f = 100;
            return 0 <= a.checkList.indexOf(r.HEAL_HP) && (f = i.getRemainingHpRate()), f <= g ? m.HIGH + f : a.isEnable ? m.SA_HIGH + f : m.NOT_SA_HIGH + f
        }
    }
}), define("scenes/battle/util/PanelTargeting", ["underscore", "util"], function(e, t) {
    function r(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_RECEPTABLE.ENBALE:
                r = e.canRecept();
                break;
            case n.Conf.PANEL_TARGET_RECEPTABLE.DISABLE:
                r = !e.canRecept();
                break;
            case n.Conf.PANEL_TARGET_RECEPTABLE.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown receptable type. " + t)
        }
        return r
    }

    function i(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_REMAIN_NUM.EXISTS:
                r = e.get("remainNum") > 0;
                break;
            case n.Conf.PANEL_TARGET_REMAIN_NUM.EMPTY:
                r = e.get("remainNum") <= 0;
                break;
            case n.Conf.PANEL_TARGET_REMAIN_NUM.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown remainNum type. " + t)
        }
        return r
    }

    function s(e, t) {
        var r = !1;
        switch (t) {
            case n.Conf.PANEL_TARGET_USED_NUM.USED:
                r = e.get("remainNum") < e.get("maxNum");
                break;
            case n.Conf.PANEL_TARGET_USED_NUM.NOT_USED:
                r = e.get("remainNum") === e.get("maxNum");
                break;
            case n.Conf.PANEL_TARGET_USED_NUM.ANY:
                r = !0;
                break;
            default:
                throw new Error("unknown usedNum type. " + t)
        }
        return r
    }

    function o(o, u) {
        var a = [].concat(n.Config.getInstance().get("FlexibleAbilities"));
        u.includesAttack && a.push(n.Conf.RECEPTOR.PANEL_ATTACK), u.includesDefense && a.push(n.Conf.RECEPTOR.PANEL_DEFENSE), a = e.filter(a, function(e) {
            var t = o.getReceptorById(e);
            return t ? r(t, u.receptable) ? i(t, u.remainNum) ? s(t, u.usedNum) ? !0 : !1 : !1 : !1 : !1
        });
        if (a.length <= 0) {
            if (!u.defaultReceptorId) return void 0;
            a.push(u.defaultReceptorId)
        }
        var f;
        switch (u.priorityType) {
            case n.Conf.PANEL_TARGET_PRIORITY_TYPE.RANDOM:
                f = t.lot(a, function() {
                    return 1
                });
                break;
            case n.Conf.PANEL_TARGET_PRIORITY_TYPE.LEAST_REMAIN_NUM:
                var l = e.map(a, function(e) {
                        return o.getReceptorById(e)
                    }),
                    c = e.shuffle(l).sort(function(e, t) {
                        return t.isInfinity() ? -1 : e.isInfinity() ? 1 : e.get("remainNum") - t.get("remainNum")
                    });
                f = c[0].get("receptorId");
                break;
            default:
                throw new Error("Invalid PanelTargeting search condition `priorityType`: " + u.priorityType)
        }
        return o.getReceptorById(f)
    }
    var n = FF.ns.battle;
    FF.ns.battle.util.PanelTargeting = {
        search: function(e, r) {
            return r = t.option({
                receptable: n.Conf.PANEL_TARGET_RECEPTABLE.ANY,
                remainNum: n.Conf.PANEL_TARGET_REMAIN_NUM.ANY,
                usedNum: n.Conf.PANEL_TARGET_USED_NUM.ANY,
                priorityType: n.Conf.PANEL_TARGET_PRIORITY_TYPE.RANDOM,
                includesAttack: !1,
                includesDefense: !1,
                defaultReceptorId: void 0
            }, r), o(e, r)
        }
    }
}), define("scenes/battle/util/ParamCalculator", ["util"], function(e) {
    var t = FF.ns.battle,
        n = t.Conf,
        r = {};
    r[n.ATTENUATION_CURVE.LN] = "_calculateAttenuationLn", r[n.ATTENUATION_CURVE.LOG] = "_calculateAttenuationLog", FF.ns.battle.util.ParamCalculator = {
        _adjustByAttenuation: function(e, n, r) {
            var i = n,
                s = t.Config.getInstance().get("BoostRateAttenuationConfig");
            s = s[r] && s[r][e];
            if (!!s) {
                var o = void 0;
                if (!!s.upper && s.upper.threshold < n) o = s.upper;
                else if (!!s.lower && 0 < n && n < s.lower.threshold) o = s.lower;
                else if (n <= 0) throw new Error("Unexpected boostRate:" + n);
                !o || (i = this._calculateAttenuation(o, n))
            }
            return i
        },
        _calculateAttenuation: function(e, t) {
            var n = r[e.attenuationCurve];
            if (!this[n]) throw new Error("invalid attenuationCurve=" + attenuationCurve);
            return this[n](e, t)
        },
        _calculateAttenuationLn: function(e, t) {
            var n = e.threshold,
                r = e.a,
                i = e.b;
            return n + r * Math.log(t - n + i)
        },
        _calculateAttenuationLog: function(e, t) {
            var n = e.threshold,
                r = e.a,
                i = e.b;
            return n - r * Math.log(n - t + i) / Math.LN10
        },
        _adjustByLimit: function(e, n, r) {
            var i = n,
                s = void 0,
                o = t.Config.getInstance().get("BoostRateLimitConfig", r);
            return o && (s = o[e] || o.limitDefault), s && (i = _.min([_.max([s.minVal, n]), s.maxVal])), i
        },
        calulateBoostRate: function(e, n) {
            var r = {};
            _.each(n, function(e) {
                if (!!e.isAbsolute) return;
                var n = e.boostType || t.Conf.BOOST_TYPE.STATUS,
                    i = r[n] || 1;
                r[n] = i * (100 + e.boostValue) / 100
            });
            var i = 1;
            return _.each(r, function(t, n) {
                var r = this._adjustByAttenuation(e, t, n),
                    s = this._adjustByLimit(e, r, n);
                i *= s, FF.logger.debug("calulateBoostRate", "paramName", e, "BoostType", n, "InitRate", t, "modifiedByAttenuation", r, "modifiedByLimit", s)
            }, this), i
        }
    }
}), define("scenes/battle/view/AbilityPanelView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    FF.ns.battle.view.AbilityPanelView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.posId = e.posId;
            var t = e.topNode,
                n = s.BattleInfo.getInstance().isMo(),
                i = this.battleViewController.battleLayer;
            this._numText = "", this._name = void 0, this._enabled = void 0, this._iconAssetId = void 0, this._visible = !0, this.touchEnabled = !0, this._highlighted = !1, this.ab = {}, this.ab.panelNode = new r({
                name: sprintf("ability_panel_%s", this.posId),
                layer: n ? FF.ns.battle.mo.BattleLayerNames.ASSETS : i.layerName,
                duplicateFrom: "command_base_nul",
                duplicateFromOptions: {
                    visualParentLayer: n ? FF.ns.battle.mo.BattleLayerNames.FOOTER : i.layerName,
                    visualParentNode: "command_pos_nul_" + this.posId
                }
            }), this.ab.touchNode = t.createChildNode(sprintf("command_visible_touch_%s", this.posId)), this.ab.animNode = t.createChildNode(sprintf("command_anm_nul_%s", this.posId)), this.ab.panelColorNode = this.ab.panelNode.createChildNode("command_color_nul"), this.ab.panelParticleBurst = this.ab.panelNode.createChildNode("particle_burst"), this.flush()
        },
        setPanelInfo: function(e) {
            e.iconAssetId && this.setPanelImage(e.iconAssetId), this.setVisible(e.visible), this.setPanelEnabled(e.enabled), this.setPanelText(e.num), this.setPanelName(e.name), this.setHighlight(e.highlighted), this.flush()
        },
        setTouchEnded: function(e) {
            var n = this,
                r = s.DataConstructor.convPosIdToPanelNo(n.posId);
            this.ab.touchNode.addCallback("action_touch_ended", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || n.touchEnabled === !1) return;
                if (n._visible === !1) return;
                n.touchEnabled = !1, n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_end"), n.ab.animNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    n.battleViewController.setCanStartPause(!0), e(r)
                })
            }), this.ab.touchNode.addCallback("action_touch_began", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                if (n._visible === !1) return;
                n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_start").process(), n.ab.animNode.play("command_tap_start").process()
            }), this.ab.touchNode.addCallback("action_touch_enterd", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                if (n._visible === !1) return;
                n.battleViewController.setCanStartPause(!1), n.ab.panelNode.play("command_tap_start").process(), n.ab.animNode.play("command_tap_start").process()
            }), this.ab.touchNode.addCallback("action_touch_exited", function() {
                if (!s.DataConstructor.canOperateBattle()) return;
                if (n._enabled === !1 || !n.touchEnabled) return;
                t.when(n.ab.panelNode.play("command_tap_cancel").processDeferred("action_stop"), n.ab.animNode.play("command_tap_cancel").processDeferred("action_stop")).then(function() {
                    n.battleViewController.setCanStartPause(!0)
                })
            })
        },
        setPanelImage: function(e) {
            if (e === this._iconAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.panelNode.loadBundle(t.bundle).setImage("command_icon_img", t.assetPath), this._iconAssetId = e
        },
        setPanelEnabled: function(e) {
            if (e === this._enabled) return;
            var t = e ? "enabled" : "disabled";
            this.ab.panelColorNode.play(t), this._enabled = e
        },
        setPanelText: function(e) {
            if (this._numText === e) return;
            this.ab.panelNode.setText("command_num_txt", e), this._numText = e
        },
        setPanelName: function(e) {
            if (this._name === e) return;
            this.ab.panelNode.setText("command_name_txt", e), this._name = e
        },
        setVisible: function(e) {
            if (e === this._visible) return;
            this.ab.panelNode.setVisible(e).process(), this._visible = e
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e).process()
        },
        isVisible: function() {
            return this._visible
        },
        commandInParticleBurstDeferred: function() {
            return this.ab.panelParticleBurst.play("command_change_in").processDeferred("action_stop")
        },
        commandOutParticleBurstDeferred: function() {
            return this.ab.panelParticleBurst.play("command_change_out").processDeferred("action_stop")
        },
        setHighlight: function(e) {
            if (this._highlighted === e) return;
            var t = e ? !0 : !1;
            this.ab.panelParticleBurst.setVisible(t).process(), this._highlighted = e
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.panelNode.deleteNode().process()
        }
    })
}), define("scenes/battle/view/BackgroundView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle,
        o = "bg01_idle",
        u = "bg02_idle",
        a = "bg01",
        f = "bg02",
        l = "scene_change";
    return FF.ns.battle.view.BackgroundView = i.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController;
            var n = e.backgroundInfo || {},
                i = n.animationInfo.id,
                s = this.battleViewController.battleLayer,
                a = this.battleViewController.assetsManager.getAssetInfo(i);
            this.layerName = a.layerName, this.bgEffLayerNames = [], this.bgIdleTag = void 0, this.ab = {}, this.ab.bgNode = (new r({
                name: "bg_nul",
                layer: this.layerName,
                visualParentTo: "bg_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: s.layerName
                }
            })).setVisible(!0), this.ab.bg01Node = this.ab.bgNode.createChildNode("bg01_nul"), this.ab.bg01ScrollNode = this.ab.bgNode.createChildNode("bg01_scroll_nul"), this.ab.bg01IdleNode = this.ab.bg01ScrollNode.createChildNode("bg01_idle_nul"), this.ab.bg01EffPosNode = this.ab.bgNode.createChildNode("bg01_eff_pos_nul_02"), this.ab.bg02Node = this.ab.bgNode.createChildNode("bg02_nul"), this.ab.bg02ScrollNode = this.ab.bgNode.createChildNode("bg02_scroll_nul"), this.ab.bg02IdleNode = this.ab.bg02ScrollNode.createChildNode("bg02_idle_nul"), this.ab.bg02EffPosNode = this.ab.bgNode.createChildNode("bg02_eff_pos_nul_02"), this.ab.bg01IdleNode.play(o, {
                loop: !0
            }), this.ab.bg02IdleNode.play(u, {
                loop: !0
            }), this.ab.wipeNode = this.ab.bgNode.createChildNode("wipe"), this.ab.bgBlackNode = (new r({
                name: "bg_black_win",
                layer: s.layerName
            })).play("black_in");
            var f = n.animationInfo.bgEffectIds;
            this._setupBGEffect(f, s, this.layerName), this.flush()
        },
        _playDeferred: function(e, n, r) {
            r = r || {};
            var i = t.Deferred();
            return e.addCallbackOnce("action_stop", function() {
                i.resolve()
            }).play(n, r), i.promise()
        },
        _playTransitionDeferred: function(e) {
            var n = t.Deferred(),
                r = [];
            switch (e) {
                case a:
                    r.push(this.ab.bg01Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg01ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                case f:
                    r.push(this.ab.bg02Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg02ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                case l:
                    r.push(this.ab.wipeNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg01ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg01EffPosNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02Node.play(e).processDeferred("action_stop")), r.push(this.ab.bg02ScrollNode.play(e).processDeferred("action_stop")), r.push(this.ab.bg02EffPosNode.play(e).processDeferred("action_stop"));
                    break;
                default:
                    throw new Error("unknown tag: " + e)
            }
            return this.flush(), this.bgIdleTag = void 0, t.when.apply(t, r)
        },
        _setupBGEffect: function(t, n, i) {
            var s = this;
            e.each(t, function(e) {
                var t = e.split("-"),
                    o = i + "-" + e;
                s.bgEffLayerNames.push(o);
                var u = (new r({
                    name: "bg_effect_nul",
                    layer: o,
                    visualParentTo: "bg" + t[0] + "_eff_pos_nul_" + t[1],
                    visualParentToOptions: {
                        visualParentLayer: t[1] >= 10 ? n.layerName : i
                    }
                })).play("play").process()
            })
        },
        playBackgroundIdle: function(e) {
            var t = e ? u : o;
            if (t === this.bgIdleTag) return;
            this._playIdleTag(t), this.bgIdleTag = t
        },
        _playIdleTag: function(e) {
            switch (e) {
                case o:
                    this.ab.bg01Node.setVisible(!0), this.ab.bg01ScrollNode.setVisible(!0), this.ab.bg02Node.setVisible(!1), this.ab.bg02ScrollNode.setVisible(!1);
                    break;
                case u:
                    this.ab.bg01Node.setVisible(!1), this.ab.bg01ScrollNode.setVisible(!1), this.ab.bg02Node.setVisible(!0).play(e), this.ab.bg02ScrollNode.setVisible(!0).play(e);
                    break;
                default:
                    throw new Error("unknown idle tag: " + e)
            }
            this.flush()
        },
        playScrollTransitionDeferred: function() {
            this.ab.bgBlackNode.play("black_out");
            var e = this.bgIdleTag === u ? f : a;
            return this._playTransitionDeferred(e)
        },
        suspendTransition: function() {
            this.ab.bgBlackNode.play("black_in"), this.flush()
        },
        playChangeTransitionDeferred: function() {
            return this._playTransitionDeferred(l)
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.BackgroundView
}), define("scenes/battle/view/BuddyView", ["underscore", "jquery", "backbone", "sprintf", "util", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.BuddyView = o.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.nodePrefix = "player", this.spritePrefix = "character", this.commonAssetId = this.battleViewController.buddyCommonAssetId, this.buddyInfo = e.buddyInfo, this.posId = this.buddyInfo.posId, this.baseSpriteId = "buddy-" + this.buddyInfo.buddyAnimationInfo.path, this.baseAssetInfo = this.battleViewController.assetsManager.getAssetInfo(this.commonAssetId), this._isDead = !1, this._isTargeted = !1, this._isFingerPointed = !1, this._isCursorPointed = !1, this._isSpecialReady = !1, this._isSupporterReady = !1, this._playTag = void 0, this._spriteAssetId = void 0, this._currHp = void 0, this._uid = void 0, this._atbRate = void 0, this._castRate = void 0, this._isAtbFull = !1, this._row = void 0, this._isInAnimation = !1, this._isInAnimationList = [], this._nonresidentSaNodeNames = [];
            var t = this.battleViewController.battleLayer,
                n = t.layerName,
                i = this.battleViewController.assetsManager.getAssetInfo("status_eff"),
                o = this.battleViewController.assetsManager.getAssetInfo("elemental_aura"),
                a = this.battleViewController.assetsManager.getAssetInfo("txt_eff"),
                f = this.battleViewController.assetsManager.getAssetInfo("back_eff");
            this.ab = {}, this.ab.playerNode = new s({
                name: r("player_nul_%s", this.posId),
                layer: n
            }), this.ab.playerEffNode = new s({
                name: r("player_eff_nul_%s", this.posId),
                layer: n
            }), this.ab.playerGaugeNode = new s({
                name: r("player_gauge_nul_%s", this.posId),
                layer: n
            }), this.ab.playerCursorNode = new s({
                name: r("player_cursor_pos_nul_%s", this.posId),
                layer: n
            }), this.ab.playerInfoNode = new s({
                name: r("player_info_nul_%s", this.posId),
                layer: n
            }), this.ab.playerSightNode = new s({
                name: r("player_sight_nul_%s", this.posId),
                layer: n
            }), this.ab.cursorNode = new s({
                name: r("%s_cursor_%s", this.nodePrefix, this.posId),
                layer: n,
                topNodeName: "cursor_center_nul",
                duplicateFrom: "cursor_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_cursor_nul_%s", this.nodePrefix, this.posId)
                }
            });
            var l = r("%s_visible_touch_nul_%s", this.nodePrefix, this.posId);
            this.ab.characterNode = new s({
                name: r("%s_character_%s", this.nodePrefix, this.posId),
                layer: this.baseAssetInfo.layerName,
                touchNodeName: l,
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: n,
                    visualParentNode: r("%s_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this._addCustomActionCallbacks(this.ab.characterNode), this.ab.touchNode = t.createNode(l).setVisible(!0), this.ab.targetNode = new s({
                name: r("%s_target_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "target_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.hpDamageNode = new s({
                name: r("%s_hp_damage_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_damage_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.hpDamageOverflowNode = new s({
                name: r("%s_hp_damage_overflow_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_damage_overflow_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.hpRecoveryNode = new s({
                name: r("%s_hp_recovery_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_recovery_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.maxHpStockNode = new s({
                name: r("%s_hp_recovery_special_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "hp_recovery_special_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.mpDamageNode = new s({
                name: r("%s_mp_damage_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "mp_damage_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.mpRecoveryNode = new s({
                name: r("%s_mp_recovery_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "mp_recovery_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.gaugeNode = new s({
                name: r("%s_gauge_%s", this.nodePrefix, this.posId),
                layer: n,
                parentNodeName: r("%s_gauge_nul_%s", this.nodePrefix, this.posId),
                duplicateFrom: "gauge_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_gauge_nul_%s", this.nodePrefix, this.posId)
                }
            });
            var c = this.ab.gaugeNode;
            this.ab.hpGaugeNode = c.createChildNode("hp_gauge_bar_img"), this.ab.hpGaugeRedNode = c.createChildNode("hp_gauge_bar_red_img"), this.ab.atbGaugeNode = c.createChildNode("atb_gauge_bar_img"), this.ab.castGaugeNode = c.createChildNode("atb2_gauge_bar_img"), this.ab.atbFullNode = c.createChildNode("atb_full_bar_img").setVisible(!1), this.ab.statusAilmentsBalloon = new s({
                name: r("%s_status_icon_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "status_icon_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.statusAilmentsDoom = new s({
                name: r("%s_death_num_%s", this.nodePrefix, this.posId),
                layer: n,
                duplicateFrom: "death_num_nul",
                duplicateFromOptions: {
                    parentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this.ab.statusAilmentsAura = new s({
                name: r("%s_character_eff_front_nul_%s", this.nodePrefix, this.posId),
                layer: i.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsOverlayAura = new s({
                name: r("%s_character_eff_overlay_nul_%s", this.nodePrefix, this.posId),
                layer: i.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsElementalAura = new s({
                name: r("%s_character_elemental_aura_%s", this.nodePrefix, this.posId),
                layer: o.layerName,
                duplicateFrom: "character_elemental_aura",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_back_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsMirage = this.ab.characterNode.createChildNode("cloning_nul"), this.ab.statusAilmentsBackAura = new s({
                name: r("%s_character_eff_back_nul_%s", this.nodePrefix, this.posId),
                layer: f.layerName,
                duplicateFrom: "character_eff_back_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_back_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.statusAilmentsView = new u.view.StatusAilmentsView(this), this.ab.colorChangeLoopNode = this.ab.characterNode.createChildNode("character_color_change_loop_nul"), this.ab.colorChangeNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul"), this.ab.colorChangeAddNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul_add"), this.ab.colorChangeSinglePosNode = this.ab.characterNode.createChildNode("character_color_change_single_pos_nul"), this.ab.colorChangeLoopSingleNode = new s({
                name: r("%s_character_color_change_loop_nul_%s", this.nodePrefix, this.posId),
                layer: this.ab.characterNode.layer,
                duplicateFrom: "character_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.colorChangeSinglePosNode.name,
                    parentTopNode: this.ab.characterNode.name
                }
            }), this.ab.characterNode.setParam({
                color_change_parent: this.ab.colorChangeLoopSingleNode.name
            }), this.ab.colorChangeSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul"), this.ab.colorChangeSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul_add"), this.ab.leftArmColorChangeLoopNode = this.ab.characterNode.createChildNode("left_arm_color_change_loop_nul"), this.ab.leftArmColorChangeNode = this.ab.leftArmColorChangeLoopNode.createChildNode("left_arm_color_change_nul"), this.ab.leftArmColorChangeAddNode = this.ab.leftArmColorChangeLoopNode.createChildNode("left_arm_color_change_nul_add"), this.ab.leftArmColorChangeSinglePosNode = this.ab.characterNode.createChildNode("left_arm_color_change_single_pos_nul"), this.ab.leftArmColorChangeLoopSingleNode = new s({
                name: r("%s_left_arm_color_change_loop_nul_%s", this.nodePrefix, this.posId),
                layer: this.ab.characterNode.layer,
                duplicateFrom: "left_arm_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.leftArmColorChangeSinglePosNode.name,
                    parentTopNode: this.ab.characterNode.name
                }
            }), this.ab.characterNode.setParam({
                color_change_arm_parent: this.ab.leftArmColorChangeLoopSingleNode.name
            }), this.ab.leftArmColorChangeSingleNode = this.ab.leftArmColorChangeLoopSingleNode.createChildNode("left_arm_color_change_nul"), this.ab.leftArmColorChangeSingleAddNode = this.ab.leftArmColorChangeLoopSingleNode.createChildNode("left_arm_color_change_nul_add"), this.ab.txtEffNode = new s({
                name: r("%s_txt_eff_%s", this.nodePrefix, this.posId),
                layer: a.layerName,
                duplicateFrom: "txt_eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: t.layerName,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId)
                }
            }), this._addCustomActionCallbacks(this.ab.txtEffNode), this.ab.specialReadyNode = (new s({
                name: r("special_ready_nul_%s", this.posId),
                layer: "layer_chara_aura",
                duplicateFrom: "special_ready_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            })).setVisible(!1), this.ab.supporterReadyNode = (new s({
                name: r("social_special_ready_nul_%s", this.posId),
                layer: "layer_social_aura",
                duplicateFrom: "special_ready_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            })).setVisible(!1), this.replaceBuddyInfo(this.buddyInfo), this.flush()
        },
        getTargetPositionDeferred: function() {
            var e = this.battleViewController;
            return e.getScreenPositionDeferred(this.ab.targetNode)
        },
        replaceBuddyInfo: function(e) {
            var t = e.buddyAnimationInfo,
                n = e.weaponAnimationInfo || {},
                r = e.handedness,
                i = "buddy-" + t.path,
                s = [t.left1OffsetX, t.left1OffsetY],
                o = [t.left2OffsetX, t.left2OffsetY],
                a = [t.right1OffsetX, t.right1OffsetY],
                f = [t.right2OffsetX, t.right2OffsetY];
            this.weaponEquipNodes = [], this.weaponEquipType = void 0, this.weaponAttackTag = void 0, this.canWeaponMove = n.canMove ? !0 : !1, n.equipType === u.Conf.WEAPON_EQUIP_TYPE.FREE ? r === "left" ? (this.weaponEquipType = u.Conf.WEAPON_EQUIP_TYPE.LEFT, this.weaponAttackTag = "attack_2") : (this.weaponEquipType = u.Conf.WEAPON_EQUIP_TYPE.RIGHT, this.weaponAttackTag = "attack") : (this.weaponEquipType = n.equipType, this.weaponAttackTag = n.attackTag);
            if (n.id) {
                var l = this.battleViewController.assetsManager.getAssetInfo("weapon-" + n.id);
                this._setupWeaponEquipNodes(l, this.baseAssetInfo)
            }
            this.ab.characterNode.setParam({
                weapon_right_1_offset_x: a[0],
                weapon_right_1_offset_y: a[1],
                weapon_right_2_offset_x: f[0],
                weapon_right_2_offset_y: f[1],
                weapon_left_1_offset_x: s[0],
                weapon_left_1_offset_y: s[1],
                weapon_left_2_offset_x: o[0],
                weapon_left_2_offset_y: o[1]
            }), this.setSprite(i), this.statusBonusFlgOf = e.statusBonusFlgOf, this.statusBonusTypeOf = e.statusBonusTypeOf, this._setupStatusBonusNodes(this.baseAssetInfo)
        },
        _createWeaponEquipNode: function(e, t, n) {
            return new s({
                name: r("weapon_%s_%s", e, this.posId),
                layer: t.layerName,
                duplicateFrom: "weapon_nul",
                duplicateFromOptions: {
                    visualParentLayer: n.layerName,
                    visualParentNode: r("weapon_%s_pos_nul", e),
                    visualParentTopNode: this.ab.characterNode.name
                }
            })
        },
        _setupWeaponEquipNodes: function(t, n) {
            var r = ["weaponRightNode", "weaponLeftNode"];
            e.each(r, function(e) {
                this.ab[e] && (this.ab[e].deleteNode().process(), delete this.ab[e])
            }, this), this.weaponEquipNodes = [];
            switch (this.weaponEquipType) {
                case u.Conf.WEAPON_EQUIP_TYPE.RIGHT:
                    this.ab.weaponRightNode = this._createWeaponEquipNode("right", t, n), this.weaponEquipNodes.push(this.ab.weaponRightNode);
                    break;
                case u.Conf.WEAPON_EQUIP_TYPE.LEFT:
                    this.ab.weaponLeftNode = this._createWeaponEquipNode("left", t, n), this.weaponEquipNodes.push(this.ab.weaponLeftNode);
                    break;
                case u.Conf.WEAPON_EQUIP_TYPE.BOTH:
                    this.ab.weaponRightNode = this._createWeaponEquipNode("right", t, n), this.ab.weaponLeftNode = this._createWeaponEquipNode("left", t, n), this.weaponEquipNodes.push(this.ab.weaponRightNode), this.weaponEquipNodes.push(this.ab.weaponLeftNode);
                    break;
                default:
            }
        },
        _setupStatusBonusNodeByType: function(e, t, n) {
            var i = void 0,
                o = void 0,
                a = void 0;
            switch (e) {
                case u.Conf.STATUS_BONUS_PARTS.BUDDY:
                    i = "statusBonusBuddyNode", o = "chara", a = "back";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.WEAPON:
                    i = "statusBonusWeaponNode", o = "attack", a = "back";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.ARMOR:
                    i = "statusBonusArmorNode", o = "defense", a = "front";
                    break;
                case u.Conf.STATUS_BONUS_PARTS.ACCESSORY:
                    return;
                default:
                    throw new Error("invalid type " + e)
            }
            var f = this.battleViewController.assetsManager.getAssetInfo(r("%s_eff_%s", n, o));
            this.ab[i] = new s({
                name: r("status_bonus_eff_%s_%s", o, this.posId),
                layer: f.layerName,
                duplicateFrom: r("status_bonus_eff_%s_nul", o),
                duplicateFromOptions: {
                    visualParentLayer: t.layerName,
                    visualParentNode: r("status_bonus_eff_%s_pos_nul", a),
                    visualParentTopNode: this.ab.characterNode.name
                }
            })
        },
        _setupStatusBonusNodes: function(t) {
            var n = ["statusBonusBuddyNode", "statusBonusWeaponNode", "statusBonusArmorNode"],
                r = this._getStatusBonusAssetName();
            e.each(n, function(e) {
                this.ab[e] && (this.ab[e].deleteNode().process(), delete this.ab[e])
            }, this), e.each(u.Conf.STATUS_BONUS_PARTS, function(e) {
                if (!this.statusBonusFlgOf[e]) return;
                this._setupStatusBonusNodeByType(e, t, r)
            }, this), this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.BUDDY] ? this.setStatusBonusBuddyVisible(!0) : this.setStatusBonusBuddyVisible(!1)
        },
        _getStatusBonusAssetName: function() {
            var e = {};
            return e[u.Conf.STATUS_BONUS_TYPE.SERIES] = "series", e[u.Conf.STATUS_BONUS_TYPE.ROLE] = "role", e[this.statusBonusTypeOf]
        },
        _addCustomActionCallbacks: function(e) {
            var t = this;
            e.setParam({
                layer_battle_field: this.battleViewController.battleLayer.layerName
            }), e.addCallback("action_shake_part", function() {
                t.battleViewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.battleViewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.battleViewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.battleViewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.battleViewController.stopShakeField()
            })
        },
        playTagWithPriority: function(t) {
            var n = u.Config.getInstance().get("BuddyTagPriority"),
                r = e.filter(t, function(e) {
                    return !n[e]
                });
            if (r.length !== 0) throw new Error("invalid tagList [" + t.join(",") + "]");
            var i = e.min(t, function(e) {
                return n[e]
            });
            this.playLoop(i)
        },
        setBuddyInfo: function(e) {
            this.setATBGauge(e.atbRate), this.setCastGauge(e.castRate);
            if (this.isInAnimation()) {
                this.flush();
                return
            }
            this.setRow(e.row || u.Conf.ROW_TYPE.FRONT), this.setLifeGauge(e.hp, e.maxHp), this.statusAilmentsView.update(e), this.playTagWithPriority(e.playTagList), this.setSpecialReady(e), this.setSupporterReady(e.isSupporterReady), e.isDead ? e.isForceEscaped ? this.forceEscapedMotion() : this.deadMotion() : this.aliveMotion(), this._uid = e.uid, this.flush()
        },
        setSprite: function(e) {
            if (e === this._spriteAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.colorChangeLoopNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this.ab.colorChangeLoopSingleNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath);
            var n = r("%s_left_arm", e),
                i = this.battleViewController.assetsManager.getAssetInfo(n, {
                    error: !1
                });
            i && (this.ab.leftArmColorChangeLoopNode.loadBundle(i.bundle).setSpriteAnimeByNode("sprite_left_arm_base", i.assetPath).setSpriteAnimeByNode("sprite_left_arm_add", i.assetPath), this.ab.leftArmColorChangeLoopSingleNode.loadBundle(i.bundle).setSpriteAnimeByNode("sprite_left_arm_base", i.assetPath).setSpriteAnimeByNode("sprite_left_arm_add", i.assetPath)), this.ab.statusAilmentsMirage.loadBundle(t.bundle).setSpriteAnimeByNode("sprite_character_cloning_01", t.assetPath).setSpriteAnimeByNode("sprite_character_cloning_02", t.assetPath).setSpriteAnimeByNode("sprite_character_cloning_03", t.assetPath), this._playTag && this.ab.characterNode.play(this._playTag), this._spriteAssetId = e
        },
        setRow: function(e) {
            if (e === this._row) return;
            e === u.Conf.ROW_TYPE.BACK ? (this.ab.playerNode.play("rearguard_pos"), this.ab.playerEffNode.play("rearguard_pos"), this.ab.playerGaugeNode.play("rearguard_pos"), this.ab.playerCursorNode.play("rearguard_pos"), this.ab.playerInfoNode.play("rearguard_pos"), this.ab.playerSightNode.play("rearguard_pos")) : (this.ab.playerNode.play("vanguard_pos"), this.ab.playerEffNode.play("vanguard_pos"), this.ab.playerGaugeNode.play("vanguard_pos"), this.ab.playerCursorNode.play("vanguard_pos"), this.ab.playerInfoNode.play("vanguard_pos"), this.ab.playerSightNode.play("vanguard_pos")), this._row = e
        },
        setSpecialReady: function(e) {
            var t = e.isSpecialReady;
            if (t === this._isSpecialReady) return;
            if (t) {
                var n = "play";
                e.specialAuraType === u.Conf.SPECIAL_AURA_TYPE.BREAK_MAX_DAMAGE_THRESHOLD ? n = "play_color_02" : e.specialAuraType === u.Conf.SPECIAL_AURA_TYPE.HAS_PARAM_BOOSTER && (n = "play_color_01"), this.ab.specialReadyNode.setVisible(!0).play(n)
            } else this.ab.specialReadyNode.setVisible(!1);
            this._isSpecialReady = t
        },
        setSupporterReady: function(e) {
            if (e === this._isSupporterReady) return;
            e ? this.ab.supporterReadyNode.setVisible(!0).play("play") : this.ab.supporterReadyNode.setVisible(!1), this._isSupporterReady = e
        },
        hideSpecialReady: function() {
            this._isSpecialReady && (this.setSpecialReady(!1), this.flush()), this._isSupporterReady && (this.setSupporterReady(!1), this.flush())
        },
        playWalkDeferred: function(e) {
            var n = this,
                i = e === "front",
                s = i ? "attack" : "back",
                o = i ? !1 : !0,
                u = new t.Deferred,
                a = this.battleViewController.battleLayer,
                f = this.ab.playerNode.createChildNode("player_action_nul_" + this.posId),
                l = this.ab.playerEffNode.createChildNode("player_eff_action_nul_" + this.posId);
            return this.ab.statusAilmentsMirage.setVisible(o), this.ab.characterNode.play("walk"), this.ab.playerEffNode.play(s, {
                node: r("player_eff_action_nul_%s", this.posId),
                isPlayChild: !1
            }), this.ab.playerInfoNode.play(s, {
                node: r("player_info_action_nul_%s", this.posId),
                isPlayChild: !1
            }), this.ab.playerSightNode.play(s, {
                node: r("player_sight_action_nul_%s", this.posId),
                isPlayChild: !1
            }), f.addCallbackOnce("action_stop", function() {
                n.playDeferred("idle"), u.resolve()
            }).play(s).process(), this.flush(), u.promise()
        },
        playInDeferred: function(e, n) {
            var r = t.Deferred();
            return this._isCursorPointed && this.ab.cursorNode.setVisible(!0).process(), this._setVisibleForCharaInOut(!0), this.playDeferred(e).then(function() {
                n && n(), r.resolve()
            }), r.promise()
        },
        playOutDeferred: function(e) {
            return this._isCursorPointed && this.ab.cursorNode.setVisible(!1).process(), this.hideSpecialReady(), this._setVisibleForCharaInOut(!1), this.playDeferred(e)
        },
        _setVisibleForCharaInOut: function(t) {
            if (this._isDead) return;
            if (this._isForceEscaped) return;
            this.ab.gaugeNode.setVisible(t), this.ab.statusAilmentsBalloon.setVisible(t), this.ab.statusAilmentsAura.setVisible(t), this.ab.statusAilmentsOverlayAura.setVisible(t), this.ab.statusAilmentsElementalAura.setVisible(t), this.ab.statusAilmentsBackAura.setVisible(t), this.ab.statusAilmentsDoom.setVisible(t), this.ab.statusAilmentsMirage.setVisible(t), this.ab.statusAilmentsTranceAura && this.ab.statusAilmentsTranceAura.setVisible(t), e.each(this._nonresidentSaNodeNames, function(e) {
                this.ab[e].setVisible(t)
            }, this), this.setStatusBonusBuddyVisible(t), this.flush()
        },
        setVisibleForReplacingSupporter: function(e) {
            this.ab.gaugeNode.setVisible(e), this.statusAilmentsView.reset()
        },
        playWalk: function() {
            this._isInAnimation = !0, this.hideSpecialReady(), this.ab.characterNode.play("walk").process()
        },
        playIdle: function() {
            this._isInAnimation = !1, this.hideSpecialReady(), this.ab.characterNode.play("idle").process()
        },
        setATBGauge: function(e) {
            if (e === this._atbRate) return;
            e === 100 ? (this.ab.atbFullNode.play("bar_light_loop", {
                loop: !0
            }).setVisible(!0).process(), this._isAtbFull = !0) : (this.ab.atbGaugeNode.playFrame("bar", e, e).process(), this._isAtbFull && (this.ab.atbFullNode.setVisible(!1).process(), this._isAtbFull = !1)), this._atbRate = e
        },
        setCastGauge: function(e) {
            if (e === this._castRate) return;
            this._isAtbFull && (this.ab.atbFullNode.setVisible(!1).process(), this._isAtbFull = !1), this.ab.castGaugeNode.playFrame("bar", e, e).process(), this._castRate = e
        },
        setCursorEnabled: function(e) {
            if (e === this._isCursorPointed) return;
            e ? this.ab.cursorNode.setVisible(!0).play("cursor_open") : this._isForceEscaped || this.ab.cursorNode.setVisible(!0).play("cursor_close"), this._isCursorPointed = e
        },
        setTargetEnabled: function(e) {
            if (e === this._isTargeted) return;
            e ? this.ab.targetNode.play("target_in") : this.ab.targetNode.play("target_out"), this._isTargeted = e
        },
        setTouchEnded: function(e) {
            this.setTouchEvent("action_touch_ended", e)
        },
        setTouchBegan: function(e) {
            this.setTouchEvent("action_touch_began", e)
        },
        setTouchEvent: function(e, t) {
            var n = this;
            this.ab.characterNode.addCallback(e, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                t(n._uid)
            }, {
                layer: this.ab.characterNode.visualParentLayer,
                node: this.ab.characterNode.touchNodeName
            })
        },
        removeAllCallback: function() {
            this.ab.characterNode.removeAllCallback()
        },
        getCurrHP: function() {
            return this._currHp
        },
        setLifeGauge: function(t, n) {
            if (!e.isNumber(t) || !e.isNumber(n)) throw new Error("invalid life gauge param");
            if (t === this._currHp) return;
            var r = Math.floor((n - t) / n * 100);
            r <= 100 && (this.ab.hpGaugeNode.playFrame("bar", r, r).process(), this.ab.hpGaugeRedNode.playFrame("bar", r, r).process()), this._currHp = t
        },
        setLifeGaugeMotionDeferred: function(t, n, r) {
            if (!e.isNumber(t) || !e.isNumber(n) || !e.isNumber(r)) throw new Error("invalid life gauge param");
            if (n === this._currHp) return;
            var i = this,
                s, o, u, a;
            return t > n ? (s = "bar", o = Math.floor((r - t) / r * 100), u = Math.floor((r - n) / r * 100)) : (s = "bar_reverse", o = Math.floor(t / r * 100), u = Math.floor(n / r * 100)), a = e.max([Math.abs(o - u) / 20, 1]), this._currHp = n, this.ab.hpGaugeNode.playFrame(s, o, u, {
                speed: a
            }).processDeferred("action_stop", {
                node: i.ab.hpGaugeNode.name,
                topNode: i.ab.gaugeNode.name
            }).then(function() {
                return i.ab.hpGaugeRedNode.playFrame(s, o, u, {
                    speed: a
                }).processDeferred("action_stop", {
                    node: i.ab.hpGaugeRedNode.name,
                    topNode: i.ab.gaugeNode.name
                })
            })
        },
        setDamageMotionDeferred: function(e, n, r, i, s, o, a, f) {
            var l = this;
            f = f || {};
            if (!e) return t.Deferred().resolve().promise();
            var c = void 0,
                h = void 0,
                p = this._playTag;
            if (s >= 0) {
                c = "" + s, h = o || "damage";
                var d = u.Config.getInstance().get("DamageCalculator", "DAMAGE", "damageThresholdTypeMap"),
                    v = this.playHpDamageDeferred,
                    m = this.playDeferred(h).then(function() {
                        return t.when(l.playDeferred(p), v.apply(l, [c, f]), l.setLifeGaugeMotionDeferred(n, r, i))
                    }),
                    g = this._playDamageOptionalDeferred();
                return t.when(m, g)
            }
            return c = "" + -1 * s, h = a || "eff_recover", this.playColorChangeDeferred(h).then(function() {
                return t.when(l.playHpRecoveryDeferred(c, f), l.setLifeGaugeMotionDeferred(n, r, i))
            })
        },
        setAbsorbDamageMotionDeferred: function(e, n, r, i, s, o, u, a, f) {
            return a ? this.setDamageMotionDeferred(e, n, r, i, s, o, u, f) : t.Deferred().resolve().promise()
        },
        playMpDamageMotionDeferred: function(e, n, r) {
            r = r || {};
            if (!e) return t.Deferred().resolve().promise();
            var i = void 0;
            return n >= 0 ? (i = "" + n, this.playMpDamageDeferred(i)) : (i = "" + -1 * n, this.playMpRecoveryDeferred(i))
        },
        playHpStockDamageMotionDeferred: function(e, n, r) {
            r = r || {};
            if (!e) return t.Deferred().resolve().promise();
            if (n < 0) {
                var i = "" + -1 * n;
                return this.playMaxHpStockDeferred(i)
            }
            throw new Error("invalid hp stock damage: " + n)
        },
        playDeferred: function(e, n) {
            var r = this;
            n = n || {};
            var i = t.Deferred();
            return this.ab.characterNode.addCallbackOnce("action_stop", function() {
                r._playTag = e, i.resolve()
            }).play(e, n).process(), i.promise()
        },
        playColorChangeDeferred: function(n, r) {
            var i = this;
            r = r || {};
            var s = t.Deferred(),
                o = t.Deferred(),
                u = e.extend({
                    isPlayChild: !1
                }, r);
            return this.ab.colorChangeSinglePosNode.play(n, u).addCallbackOnce("action_stop", function() {
                i.ab.colorChangeSinglePosNode.play("stop", u).setVisible(!1).process(), s.resolve()
            }), this.ab.colorChangeSingleNode.play(n, u), this.ab.colorChangeSingleAddNode.play(n, u), this.ab.leftArmColorChangeSinglePosNode.play(n, u).addCallbackOnce("action_stop", function() {
                i.ab.leftArmColorChangeSinglePosNode.play("stop", u).setVisible(!1).process(), o.resolve()
            }), this.ab.leftArmColorChangeSingleNode.play(n, u), this.ab.leftArmColorChangeSingleAddNode.play(n, u), this.flush(), t.when(s.promise(), o.promise())
        },
        playAttackDeferred: function(e, t) {
            var n = this;
            return t = t || {}, this._playPreAttackDeferred(t).then(function() {
                var r = e.atkMotion;
                return r ? n.playDeferred(r, t) : n.playWeaponAttackDeferred(t)
            })
        },
        _playPreAttackDeferred: function(e) {
            return this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.WEAPON] ? this.ab.statusBonusWeaponNode.play("play").processDeferred("action_next") : t.Deferred().resolve().promise()
        },
        playWeaponAttackDeferred: function(t) {
            var n = this;
            return this.canWeaponMove && e.each(this.weaponEquipNodes, function(e) {
                e.play(this.weaponAttackTag, t).process()
            }, this), this.ab.characterNode.play(this.weaponAttackTag, t).processDeferred("action_attack_next")
        },
        _playDamageOptionalDeferred: function() {
            return this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.ARMOR] ? this.ab.statusBonusArmorNode.play("play").processDeferred("action_stop") : t.Deferred().resolve().promise()
        },
        playLoop: function(e) {
            if (e === this._playTag) return;
            e === "dead" ? this.ab.characterNode.setParam({
                normal: "dead",
                white: "dead_white"
            }) : e === "fatal" ? this.ab.characterNode.setParam({
                normal: "fatal",
                white: "fatal_white"
            }) : this.ab.characterNode.setParam({
                normal: "idle",
                white: "idle_white"
            }), this.ab.characterNode.play(e), this._playTag = e
        },
        playHpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpDamageNode, "hp_damage", e, t)
        },
        playHpDamageOverflowDeferred: function(t, n) {
            return e.extend(n, {
                tagName: "hp_text_long"
            }), this.playDigitsDeferred(this.ab.hpDamageOverflowNode, "hp_damage_overflow", t, n)
        },
        playHpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpRecoveryNode, "hp_recovery", e, t)
        },
        playMpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.mpDamageNode, "mp_damage", e, t)
        },
        playMpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.mpRecoveryNode, "mp_recovery", e, t)
        },
        playMaxHpStockDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.maxHpStockNode, "hp_recovery_special", e, t)
        },
        playDigitsDeferred: function(n, i, s, o) {
            var u = t.Deferred();
            o = o || {};
            var a = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7],
                f = String(s).split("").reverse();
            e.each(a, function(e, t) {
                var s = f[t] || "";
                n.setText(r("%s_%d_txt", i, e), s)
            });
            var l = "hp_text";
            return o.tagName && (l = o.tagName, delete o.tagName), n.addCallbackOnce("action_stop", function() {
                u.resolve()
            }).play(l, o).process(), u.promise()
        },
        playCriticalDeferred: function() {
            return this.ab.txtEffNode.play("critical").processDeferred("action_stop")
        },
        playWeaknessDeferred: function() {
            return this.ab.txtEffNode.play("weakness").processDeferred("action_stop")
        },
        playDefenseDeferred: function() {
            return this.ab.txtEffNode.play("defense").processDeferred("action_stop")
        },
        playAbsorbDeferred: function() {
            return this.ab.txtEffNode.play("absorb").processDeferred("action_stop")
        },
        playResistDeferred: function() {
            return this.ab.txtEffNode.play("resist").processDeferred("action_stop")
        },
        playMissDeferred: function() {
            return this.ab.txtEffNode.play("miss").processDeferred("action_stop")
        },
        playNoeffectDeferred: function() {
            return this.ab.txtEffNode.play("noeffect").processDeferred("action_stop")
        },
        aliveMotion: function() {
            if (!this._isDead) return;
            this._isDead = !1, this.ab.gaugeNode.setVisible(!0), this.setStatusBonusBuddyVisible(!0)
        },
        deadMotion: function() {
            if (this._isDead) return;
            this._isDead = !0, this.ab.gaugeNode.setVisible(!1), this.ab.cursorNode.setVisible(!1), this.hideSpecialReady(), this.setStatusBonusBuddyVisible(!1), this.flush()
        },
        forceEscapedMotion: function() {
            if (this._isForceEscaped) return;
            this._isForceEscaped = !0, this.setVisible(!1), this.ab.gaugeNode.setVisible(!1), this.ab.cursorNode.setVisible(!1), this.ab.targetNode.setVisible(!1), this.ab.statusAilmentsDoom.setVisible(!1), this.hideSpecialReady(), this.flush()
        },
        handsUpMotion: function() {
            this._isInAnimation = !0, this.hideSpecialReady(), this.ab.statusAilmentsMirage.setVisible(!1), this.ab.characterNode.play("hands_up"), this.ab.gaugeNode.setVisible(!1), this.setCursorEnabled(!1), this.flush()
        },
        setVisible: function(e) {
            this.ab.characterNode.setVisible(e).process()
        },
        setStatusBonusBuddyVisible: function(e) {
            if (!this.statusBonusFlgOf[u.Conf.STATUS_BONUS_PARTS.BUDDY]) return;
            if (e === this._isShowingStatusBonusBuddy) return;
            e ? this.ab.statusBonusBuddyNode.play("play") : this.ab.statusBonusBuddyNode.play("stop"), this._isShowingStatusBonusBuddy = e
        },
        getAbilityNodeDuplicateOptions: function(e) {
            var t = {
                visualParentLayer: this.battleViewController.battleLayer.layerName,
                visualParentNode: r("%s_%s_pos_nul_%s", this.nodePrefix, e, this.posId)
            };
            return t
        },
        setAbilityShotAttractor: function(e) {
            e.setAttractor("shot_particle", r("%s_attractor_%s", this.nodePrefix, this.posId), {
                attractorLayer: this.battleViewController.battleLayer.layerName
            })
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e), this.flush()
        },
        getUid: function() {
            return this._uid
        },
        registerIsInAnimation: function() {
            this._isInAnimationList.push(!0)
        },
        unregisterIsInAnimation: function() {
            this._isInAnimationList.shift()
        },
        isInAnimation: function() {
            return this._isInAnimation || this._isInAnimationList.length > 0
        },
        getStatusAilmentsTranceAura: function(e) {
            e = e || {};
            if (!!e.shouldCreateIfNotExists && !this.ab.statusAilmentsTranceAura) {
                var t = this.battleViewController.assetsManager.getAssetInfo("back_eff");
                this.ab.statusAilmentsTranceAura = new s({
                    name: r("%s_character_eff_trance_nul_%s", this.nodePrefix, this.posId),
                    layer: t.layerName,
                    duplicateFrom: "character_eff_back_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_back_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                })
            }
            return this.ab.statusAilmentsTranceAura
        },
        getStatusAilmentsNonresidentBackAura: function(t, n) {
            n = n || {};
            var o = r("statusAilmentsNonresidentBackAura_%s", i.camelize(t));
            if (!!n.shouldCreateIfNotExists && !this.ab[o]) {
                var u = this.battleViewController.assetsManager.getAssetInfo(t);
                this.ab[o] = new s({
                    name: r("%s_character_eff_nonresident_back_nul_%s_%s", this.nodePrefix, this.posId, t),
                    layer: u.layerName,
                    duplicateFrom: "character_eff_back_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_back_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                }), this._nonresidentSaNodeNames.push(o), e.isNumber(n.zOrder) && this.ab[o].setZOrder(n.zOrder)
            }
            return this.ab[o]
        },
        getStatusAilmentsNonresidentFrontAura: function(t, n) {
            n = n || {};
            var o = r("statusAilmentsNonresidentFrontAura_%s", i.camelize(t));
            if (!!n.shouldCreateIfNotExists && !this.ab[o]) {
                var u = this.battleViewController.assetsManager.getAssetInfo(t);
                this.ab[o] = new s({
                    name: r("%s_character_eff_nonresident_front_nul_%s_%s", this.nodePrefix, this.posId, t),
                    layer: u.layerName,
                    duplicateFrom: "character_eff_front_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_front_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                }), this._nonresidentSaNodeNames.push(o), e.isNumber(n.zOrder) && this.ab[o].setZOrder(n.zOrder)
            }
            return this.ab[o]
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.weaponEquipNodes = null
        }
    }), FF.ns.battle.view.BuddyView
}), define("scenes/battle/view/CommandView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    return FF.ns.battle.view.CommandView = s.extend({
        initialize: function(t) {
            this.battleViewController = t.battleViewController;
            var n;
            o.BattleInfo.getInstance().isMo() ? n = this.battleViewController.battleFooterLayer : n = this.battleViewController.battleLayer, this.commandSet = {}, this.selector = void 0, this.isAnimating = !1, this.visible = !1, this.skipTouchEnabled = !0, this.canSkip = !1, this._isInAuto = !1, this._autoButtonEnabled = !0, this.ab = {}, this.ab.footerBaseNode = n.createNode("menu_footer_nul").setVisible(!0), this.ab.footerBgNode = this.ab.footerBaseNode.createChildNode("image_footer_bg").play("command_change_out").setVisible(!0), this.ab.skipButtonNode = this.ab.footerBaseNode.createChildNode("skip_nul").setVisible(!1), this.ab.skipVisibleTouchNode = this.ab.skipButtonNode.createChildNode("skip_visible_touch"), this.ab.commandNode = this.ab.footerBaseNode.createChildNode("command_nul").setVisible(!1), this.ab.criticalNode = this.ab.footerBaseNode.createChildNode("critical_nul").setVisible(!1), this.ab.criticalSelectNode = this.ab.footerBaseNode.createChildNode("critical_select").setVisible(!1), this.ab.charaNameNode = this.ab.footerBaseNode.createChildNode("chr_name_txt").setVisible(!1), this.ab.autoButtonNode = this.ab.footerBaseNode.createChildNode("auto_nul").setVisible(!0), this.ab.autoCancelButtonNode = this.ab.footerBaseNode.createChildNode("auto_cancel_nul").setVisible(!0), this.ab.autoTextNode = this.ab.footerBaseNode.createChildNode("auto_text_nul").setVisible(!0), this.ab.autoVisibleTouchNode = this.ab.autoButtonNode.createChildNode("auto_visible_touch"), this.ab.autoCancelVisibleTouchNode = this.ab.autoCancelButtonNode.createChildNode("auto_cancel_visible_touch"), this.ab.autoButtonNode.play("command_change_in").process();
            if (o.BattleInfo.getInstance().isMo()) {
                var r = kickmotor.nativefn.getLogicalScreenHeight();
                this.ab.footerBaseNode.setPosition([0, r])
            }
            var i = o.DataConstructor.getAllPanelPosIds();
            e.each(i, function(e) {
                this.commandSet[e] = new o.view.AbilityPanelView({
                    battleViewController: this.battleViewController,
                    posId: e,
                    topNode: this.ab.footerBaseNode
                })
            }, this), this.specialCommand = new o.view.SoulStrikeView({
                battleViewController: this.battleViewController,
                topNode: this.ab.footerBaseNode
            }), this.listenTo(this.specialCommand, o.view.SoulStrikeView.EVENTS.SOUL_STRIKE_SELECTOR_SHOWN, e.bind(this._handleSoulStrikeSelectorEvent, this)), this.listenTo(this.specialCommand, o.view.SoulStrikeView.EVENTS.SOUL_STRIKE_SELECTOR_HIDDEN, e.bind(this._handleSoulStrikeSelectorEvent, this)), this._skipButtonVisible = void 0, this._commandSetTouchEnabled = void 0, this.flush()
        },
        showCommands: function(t) {
            var n = t.panelInfoArray,
                r = t.specialInfo,
                i = [];
            e.each(n, function(e) {
                this.commandSet[e.posId].setPanelInfo(e), i.push(e.posId)
            }, this), e.each(this.commandSet, function(t, n) {
                e.contains(i, n) || t.setVisible(!1)
            }, this), this.showSkipButton(t.canSkip), this.specialCommand.setSoulStrikeInfo(r)
        },
        showAutoButton: function(e) {
            e ? this._isInAuto || (this.ab.autoButtonNode.play("command_change_out").process(), this.ab.autoCancelButtonNode.play("command_change_in").process(), this.ab.autoTextNode.play("command_change_in").process(), this._isInAuto = !0, this.battleViewController.setCanStartPause(!0)) : this._isInAuto && (this.ab.autoCancelButtonNode.play("command_change_out").process(), this.ab.autoButtonNode.play("command_change_in").process(), this.ab.autoTextNode.play("command_change_out").process(), this._isInAuto = !1, this.battleViewController.setCanStartPause(!0))
        },
        setAutoButtonEnabled: function(e) {
            e = !!e, this._autoButtonEnabled !== e && (this._autoButtonEnabled = e, this._updateAutoButtonEnabled())
        },
        _updateAutoButtonEnabled: function() {
            if (!o.BattleInfo.getInstance().isMo()) return;
            var e = this._autoButtonEnabled && !this.specialCommand.isSoulStrikeSelectorMenuShown();
            this.ab.autoCancelButtonNode.setVisible(e).process(), this.ab.autoButtonNode.setVisible(e).process(), this.ab.autoTextNode.setVisible(e).process()
        },
        showSkipButton: function(e) {
            if (e === this.canSkip) return;
            this.canSkip = e, this._updateSkipButtonVisible()
        },
        resetSpecialCommand: function() {
            this.specialCommand.resetTag()
        },
        setTouch: function(t) {
            var n = this;
            e.each(this.commandSet, function(e) {
                e.setTouchEnded(function(e) {
                    if (!n._isSpecialCommandUIBusy()) return;
                    var r = n.getCurrentSelectorUid();
                    t(r, e)
                })
            })
        },
        setSpecialTouch: function(e) {
            var t = this;
            this.specialCommand.setTouchEnded(function() {
                var n = t.getCurrentSelectorUid();
                e(n)
            })
        },
        setSpecialPanelTouch: function(e) {
            var t = this;
            this.specialCommand.setSpecialPanelTouch(function(n) {
                var r = t.getCurrentSelectorUid();
                e(r, n)
            })
        },
        setAutoTouch: function(e) {
            var t = this;
            this.ab.autoVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!t._isSpecialCommandUIBusy()) return;
                t._isInAuto || e()
            }), this.ab.autoCancelVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!t._isSpecialCommandUIBusy()) return;
                t._isInAuto && e()
            })
        },
        setSkipTouch: function(e) {
            function n() {
                return o.DataConstructor.canOperateBattle() ? t.skipTouchEnabled ? t._isSpecialCommandUIBusy() ? !0 : !1 : !1 : !1
            }
            var t = this;
            this.ab.skipVisibleTouchNode.addCallback("action_touch_ended", function() {
                if (!n()) return;
                t.skipTouchEnabled = !1, t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_end").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPause(!0);
                    var n = t.getCurrentSelectorUid();
                    e(n)
                })
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_began", function() {
                if (!n()) return;
                t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_start").process()
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_enterd", function() {
                if (!n()) return;
                t.battleViewController.setCanStartPause(!1), t.ab.skipButtonNode.play("command_tap_start").process()
            }), this.ab.skipVisibleTouchNode.addCallback("action_touch_exited", function() {
                if (!n()) return;
                t.ab.skipButtonNode.play("command_tap_cancel").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPause(!0)
                })
            }), this.flush()
        },
        setSoulStrikeSelectorVisibleChangeHandler: function(e) {
            this._soulStrikeSelectorVisibleChangeHandler = e
        },
        setSpecialGauge: function(e) {
            this.specialCommand.setSoulStrikeGauge(e)
        },
        commandInDeferred: function(n, r) {
            var i = this,
                s = t.Deferred();
            return this.selector && n.uid === this.selector.uid ? (this.showCommands(r), s.resolve().promise()) : this.isAnimating || this.visible ? s.resolve().promise() : (this.selector = n, this.showCommands(r), this.isAnimating = !0, this.battleViewController.toggleCursor(n.uid), this.ab.commandNode.setVisible(!0).process(), this.ab.criticalNode.play("command_change_in", {
                node: "critical_btn_anm_nul",
                isPlayChild: !1
            }), this.ab.criticalNode.play("command_change_in", {
                node: "critical_gauge_anm_nul",
                isPlayChild: !0
            }), this.ab.criticalNode.setVisible(!0).process(), this.ab.criticalSelectNode.play("command_change_in", {
                node: "critical_select_gauge_anm",
                isPlayChild: !0
            }), this.ab.criticalSelectNode.setVisible(!0).process(), this.specialCommand.showSoulStrikePanel(), this.specialCommand.updateGaugeCursorVisible(), this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this.ab.charaNameNode.setVisible(!0).play("command_change_in").process(), this.ab.footerBgNode.play("command_change_in").process(), this.ab.commandNode.play("command_change_in").processDeferred("action_stop").then(function() {
                i.isAnimating = !1, i.visible = !0, i.setTouchEnabled(!0)
            }), e.each(this.commandSet, function(e) {
                e.commandInParticleBurstDeferred()
            }, this), s.promise())
        },
        commandOutDeferred: function(n) {
            var r = this;
            n = n || {};
            var i = t.Deferred();
            return this.isAnimating || !this.visible ? i.resolve().promise() : (this.isAnimating = !0, r.setTouchEnabled(!1), this.ab.criticalNode.play("command_change_out", {
                node: "critical_btn_anm_nul",
                isPlayChild: !1
            }), this.ab.criticalNode.play("command_change_out", {
                node: "critical_gauge_anm_nul",
                isPlayChild: !0
            }), this.ab.criticalNode.process(), this.ab.criticalSelectNode.play("command_change_out", {
                node: "critical_select_gauge_anm",
                isPlayChild: !0
            }), this.ab.criticalSelectNode.setVisible(!0).process(), n.keepCurrentMenu || this.specialCommand.hideSoulStrikePanelMenu(), this.specialCommand.hideSoulStrikePanel(), this.ab.charaNameNode.play("command_change_out").process(), this.ab.footerBgNode.play("command_change_out").process(), this.showSkipButton(!1), this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this.ab.commandNode.play("command_change_out").processDeferred("action_stop").then(function() {
                r.isAnimating = !1, r.visible = !1, r.selector = void 0, r.specialCommand.reset()
            }), e.each(this.commandSet, function(e) {
                e.commandOutParticleBurstDeferred()
            }, this), i.promise())
        },
        cancelSoulStrikePanelTouch: function() {
            this.setTouchEnabled(!0)
        },
        setTouchEnabled: function(e) {
            this._commandSetTouchEnabled = e, this._updateCommandSetTouchEnabled(), this.skipTouchEnabled = e, this.specialCommand.setTouchEnabled(e)
        },
        _updateCommandSetTouchEnabled: function() {
            var t = this;
            e.each(this.commandSet, function(e) {
                e.touchEnabled = t._commandSetTouchEnabled && !t.specialCommand.isSoulStrikeSelectorMenuShown()
            })
        },
        setTouchVisible: function(t) {
            e.each(this.commandSet, function(e) {
                e.setTouchVisible(t)
            }), this.specialCommand.setTouchVisible(t), this.ab.skipVisibleTouchNode.setVisible(t), this.flush()
        },
        _updateSkipButtonVisible: function() {
            var e = this.canSkip && !this.specialCommand.isSoulStrikeSelectorMenuShown();
            if (this._skipButtonVisible === e) return;
            this._skipButtonVisible = e, this._skipButtonVisible ? this.ab.skipButtonNode.setVisible(!0).play("command_change_in").process() : this.ab.skipButtonNode.play("command_change_out").setVisible(!1).process()
        },
        _handleSoulStrikeSelectorEvent: function() {
            this._updateSkipButtonVisible(), this._updateAutoButtonEnabled(), this._updateCommandSetTouchEnabled(), this._soulStrikeSelectorVisibleChangeHandler && this._soulStrikeSelectorVisibleChangeHandler()
        },
        _isSpecialCommandUIBusy: function() {
            return this.specialCommand.resetMenuButtons(), !this.specialCommand.isSoulStrikeSelectorMenuShown() && !this.specialCommand.isMenuUILocked()
        },
        isSoulStrikeSelectorMenuShown: function() {
            return this.specialCommand && this.specialCommand.isSoulStrikeSelectorMenuShown()
        },
        isChangedSelector: function(e) {
            return this.selector && e.uid !== this.selector.uid
        },
        getCurrentSelectorUid: function() {
            return this.selector && this.selector.uid
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.stopListening()
        }
    }), FF.ns.battle.view.CommandView
}), define("scenes/battle/view/MateriaDropView", ["underscore", "jquery", "backbone", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    return FF.ns.battle.view.MateriaDropView = s.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController, this.ab = {};
            var n = this.battleViewController.battleLayer,
                r = this.battleViewController.assetsManager.getAssetInfo("materia_get");
            this.ab.node = new i({
                name: "cutin_nul",
                layer: r.layerName,
                visualParentTo: "cutin_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: n.layerName
                }
            });
            var s = this.ab.node.createChildNode("cutin_bt_nul_01");
            s.addCallback("action_touch_began", function() {
                if (!t._touchEnabled) return;
                s.play("tap_start").process()
            }), s.addCallback("action_touch_ended", function() {
                if (!t._touchEnabled) return;
                s.play("tap_end").process(), t._touchDeferred && t._touchDeferred.resolve()
            }), s.process(), this._touchDeferred = void 0, this._touchEnabled = !1
        },
        showDeferred: function(e) {
            var n = this,
                r = e.name,
                i = {
                    posId: e.buddyPos
                },
                s = sprintf("item-%d", e.itemId);
            this.battleViewController.setCanStartPause(!1);
            var o = this.ab.node;
            o.setText("cutin_body_txt", r);
            var u = this.battleViewController.assetsManager.getAssetInfo(s);
            o.loadBundle(u.bundle).setImage("materia_img", u.assetPath);
            var a = this.battleViewController.getActorView(i),
                f = this.battleViewController.assetsManager.getAssetInfo(a.baseSpriteId);
            o.loadBundle(f.bundle).setSpriteAnimeByNode("chara_sprite", f.assetPath);
            var l = this._enableTouchDeferred();
            return t.Deferred().resolve().then(function() {
                var e = o.createChildNode("cutin_bg_nul");
                return e.play("scale_window_1", {
                    autoRemove: !1
                }).processDeferred("action_stop")
            }).then(function() {
                return o.play("in").processDeferred("action_stop")
            }).then(function() {
                return n._waitAnyDeferred([o.play("loop").processDeferred("action_stop"), l])
            }).then(function() {
                return o.play("out").processDeferred("action_stop")
            }).then(function() {
                return n.battleViewController.setCanStartPause(!0), n._disableTouchDeferred()
            })
        },
        _enableTouchDeferred: function() {
            var e = t.Deferred();
            return this._touchDeferred = e, this._touchEnabled = !0, e.promise()
        },
        _disableTouchDeferred: function() {
            this._touchDeferred = void 0, this._touchEnabled = !1
        },
        _waitAnyDeferred: function(e) {
            var n = t.Deferred(),
                r = function() {
                    n.resolve()
                };
            for (var i = 0, s = e.length; i < s; i++) e[i].then(r);
            return n.promise()
        }
    }), FF.ns.battle.view.MateriaDropView
}), define("scenes/battle/view/DropItemView", ["underscore", "jquery", "backbone", "lib/ClassBase", "lib/ab/ABNode"], function(e, t, n, r, i) {
    var s = FF.ns.battle,
        o = s.Conf,
        u = {};
    u[o.DROP_ITEM_TYPE.POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.HI_POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.X_POTION] = "_setCureNode", u[o.DROP_ITEM_TYPE.ETHER] = "_setCureNode", u[o.DROP_ITEM_TYPE.TURBO_ETHER] = "_setCureNode", u[o.DROP_ITEM_TYPE.TREASURE] = "_setTreasureNode", u[o.DROP_ITEM_TYPE.ORB] = "_setOrbNode";
    var a = {
        DROP_GIL_SOUND: "se_battle_101026"
    };
    FF.ns.battle.view.DropItemView = r.extend({
        initialize: function(e) {
            this.posId = e.posId, this.childPosId = e.childPosId || "1", this.battleViewController = e.battleViewController;
            var t = this.battleViewController.getActorView({
                isEnemy: !0,
                posId: this.posId,
                childPosId: this.childPosId
            });
            this.hasCureItem = void 0;
            var n = this._getAssetsLayer().layerName;
            this.dropItemNode = new i({
                name: sprintf("enemy_drop_item_nul_%s_%s", this.posId, this.childPosId),
                layer: n,
                duplicateFrom: "drop_item_nul",
                duplicateFromOptions: {
                    visualParentLayer: t.ab.characterEffNode.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: t.ab.characterEffNode.name
                }
            })
        },
        dropItemDeferred: function(t) {
            var n = this,
                r = [],
                i = !1;
            e.each(t, function(e) {
                e.type === s.Conf.DROP_ITEM_TYPE.GIL ? i = !0 : r.push(e)
            }), i || this.dropItemNode.setVisible(!1, {
                node: "drop_item_gil_particle",
                topNode: this.dropItemNode.name
            }), s.BattleInfo.getInstance().isMo() && this.dropItemNode.setAttractor("drop_item_gil_particle", "gil_attractor", {
                attractorLayer: this._getHeaderLayer().layerName
            }), this.dropItemNode.setVisible(!1, {
                node: "drop_item_anm_nul_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.setVisible(!1, {
                node: "drop_item_anm_nul_02",
                topNode: this.dropItemNode.name
            });
            var o = "drop_item";
            return e.each(r, function(e) {
                var t = n.battleViewController.assetsManager.getAssetInfo(e.assetId),
                    r = n._getDropPos(e.type);
                e.rarity >= 6 && (o = "drop_item_long"), n.dropItemNode.setVisible(!0, {
                    node: sprintf("drop_item_anm_nul_%s", r),
                    topNode: n.dropItemNode.name
                }), n._adjustParticleByRarity(e), n.dropItemNode.loadBundle(t.bundle).setImage(sprintf("drop_item_img_%s", r), t.assetPath);
                var i = n._getFuncName(e.type);
                if (!n[i]) throw new Error("invalid drop item type.t=" + e.type);
                n[i](e)
            }), i && this._getHeaderLayer().createNode("gil_nul").addCallbackOnce("action_se_gil", function() {
                FF.SoundMgr.playEffect(a.DROP_GIL_SOUND)
            }).play("drop_item").process(), this.dropItemNode.play(o).processDeferred("action_stop")
        },
        _getAssetsLayer: function() {
            return s.BattleInfo.getInstance().isMo() ? this.battleViewController.battleAssetsLayer : this.battleViewController.battleLayer
        },
        _getHeaderLayer: function() {
            return s.BattleInfo.getInstance().isMo() ? this.battleViewController.battleHeaderLayer : this.battleViewController.battleLayer
        },
        _adjustParticleByRarity: function(e) {
            var t = this._getDropPos(e.type);
            e.rarity <= 2 && this.dropItemNode.setVisible(!1, {
                node: sprintf("drop_item_eff_particle_%s_02", t),
                topNode: this.dropItemNode.name
            }), e.rarity <= 1 && this.dropItemNode.setVisible(!1, {
                node: sprintf("drop_item_eff_particle_%s_01", t),
                topNode: this.dropItemNode.name
            }), e.type === s.Conf.DROP_ITEM_TYPE.ORB && this._adjustOrbParticleByRarity(e)
        },
        _adjustOrbParticleByRarity: function(e) {
            e.rarity >= 6 ? this.dropItemNode.setVisible(!0, {
                node: "drop_item_front_eff_particle_02",
                topNode: this.dropItemNode.name
            }) : e.rarity === 5 && this.dropItemNode.setVisible(!0, {
                node: "drop_item_front_eff_particle",
                topNode: this.dropItemNode.name
            })
        },
        _getDropPos: function(e) {
            return e === s.Conf.DROP_ITEM_TYPE.TREASURE || e === s.Conf.DROP_ITEM_TYPE.ORB ? "01" : "02"
        },
        _getFuncName: function(e) {
            var t = u[e];
            if (!t) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        _setCureNode: function(e) {
            this.hasCureItem = !0
        },
        _setTreasureNode: function(e) {
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
            this._itemName = "treasure", this.dropItemNode.setVisible(!0, {
                node: "drop_item_treasure_particle_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.loadBundle(t.bundle).setParticleTexture("drop_item_treasure_particle_01", t.assetPath, {
                descendant: !0
            }), s.BattleInfo.getInstance().isMo() && this.dropItemNode.setAttractor("drop_item_treasure_particle_01", "treasure_attractor", {
                attractorLayer: this._getHeaderLayer().layerName
            })
        },
        _setOrbNode: function(e) {
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId);
            this._itemName = "orb", this.dropItemNode.setVisible(!0, {
                node: "drop_item_orb_particle_01",
                topNode: this.dropItemNode.name
            }), this.dropItemNode.loadBundle(t.bundle).setParticleTexture("drop_item_orb_particle_01", t.assetPath, {
                descendant: !0
            }), s.BattleInfo.getInstance().isMo() && this.dropItemNode.setAttractor("drop_item_orb_particle_01", "orb_attractor", {
                attractorLayer: this._getHeaderLayer().layerName
            })
        },
        workDeferred: function() {
            var e = this,
                n = [];
            if (this._itemName) {
                var r = t.Deferred(),
                    i = t.Deferred(),
                    s = this._itemName,
                    o = this._getHeaderLayer().createNode(s + "_nul");
                this.dropItemNode.play("drop_item_close", {
                    node: "drop_item_anm_nul_01",
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_particle_disappear", function() {
                    i.resolve()
                }, {
                    node: sprintf("drop_item_%s_particle_01", s),
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_stop", function() {
                    r.resolve()
                }, {
                    tag: "drop_item_close",
                    node: "drop_item_anm_nul_01",
                    topNode: this.dropItemNode.name
                }), o.play("drop_item_close").process(), n.push(i.promise()), n.push(r.promise())
            }
            if (this.hasCureItem) {
                var u = t.Deferred();
                this.dropItemNode.play("drop_item_cure", {
                    node: "drop_item_anm_nul_02",
                    topNode: this.dropItemNode.name
                }).addCallbackOnce("action_stop", function() {
                    u.resolve()
                }, {
                    tag: "drop_item_cure",
                    node: "drop_item_anm_nul_02",
                    topNode: this.dropItemNode.name
                }), n.push(u.promise())
            }
            return this.dropItemNode.process(), t.when.apply(null, n)
        },
        dispose: function() {
            this.dropItemNode.deleteNode().process()
        }
    })
}), define("scenes/battle/view/EnemyContainer", ["underscore", "jquery", "backbone", "sprintf", "lib/ClassBase", "lib/ab/ABNode", "lib/ab/ABLayer"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.EnemyContainer = i.extend({
        initialize: function(e) {
            this.enemyViews = {}, this.posId = e.posId, this.usesFixPos = e.usesFixPos, this.viewController = e.battleViewController, this.mainAssetId = e.mainAssetId, this._isVisualized = void 0, this._posArray = [], this._posArrayDead = []
        },
        _updatePosArray: function(t) {
            var n = e.difference(this._posArray, this._posArrayDead),
                r = e.difference(t, n),
                i = e.difference(n, t);
            return this._posArray = t, this._posArrayDead = [], {
                posArrayIn: r,
                posArrayOut: i
            }
        },
        playDeformDeferred: function(n, r, i, s) {
            var o = [],
                u = this,
                a = this._updatePosArray(r),
                f = a.posArrayIn,
                l = a.posArrayOut,
                c = s.invisibleHpGaugePosArray ? s.invisibleHpGaugePosArray : [];
            this.hideHpGauge([].concat(l, c));
            var h = function(e) {
                if (!!s.skipMainNodeDeform) return;
                var t = {},
                    r = {};
                o.push(u.mainNode.play(n, t, e).processDeferred("action_stop", r, e)), i && o.push(u.mainEffNode.play(n, t, e).processDeferred("action_stop", r, e), u.mainSightNode.play(n, t, e).processDeferred("action_stop", r, e), u.mainInfoNode.play(n, t, e).processDeferred("action_stop", r, e))
            };
            return n === "in" && this.visualize(!0), s.filteringDeformPosArray || h(), i && o.push(this.viewController.closeTargetArrowOnDeformStartingDeferred()), e.each(this.enemyViews, function(t, i) {
                e.contains(r, i) && t.ab.characterPositionNode.setVisible(!0);
                if (!s.filteringDeformPosArray || e.include(s.filteringDeformPosArray, +i)) !s.filteringDeformPosArray || h(t.ab.characterNode.visualParentNodeName), o.push(t.ab.characterNode.play(n).processDeferred("action_stop")), t.setPlayTag("idle", s.isRandom);
                t.ab.colorChangeLoopNode.setVisible(!1), t.ab.colorChangeSinglePosNode.setVisible(!0), t.ab.touchNode.setVisible(!1), e.contains(l, i) && t.setVisibleSurrounding(!1), t.flush()
            }), t.when.apply(null, o).then(function() {
                i && u.viewController.openTargetArrowOnDeformFinishing(), e.each(r, function(t) {
                    var n = u.enemyViews[t];
                    n.ab.touchNode.setVisible(!0), e.contains(f, t) && n.setVisibleSurrounding(!0), n.ab.colorChangeLoopNode.setVisible(!0), n.ab.colorChangeSinglePosNode.setVisible(!1), n.flush()
                }), u.showHpGauge(f, s.invisibleHpGaugePosArray)
            })
        },
        updatePosArray: function(t) {
            var n = e.uniq([].concat(this._posArray, t)),
                r = e.difference(n, this._posArray),
                i = e.difference(n, t);
            this._posArray = t, e.each(this.enemyViews, function(t, n) {
                e.contains(i, n) ? (t.ab.touchNode.setVisible(!1), t.setVisibleSurrounding(!1)) : e.contains(r, n) && (t.ab.touchNode.setVisible(!0), t.setVisibleSurrounding(!0)), t.flush()
            }), this.showEnemyName(2e3), this.setHpGaugeEnabled(!0)
        },
        showEnemyName: function(t, n) {
            var r = this;
            e.each(this._posArray, function(i) {
                var s = e.contains(n, +i);
                s ? r.enemyViews[i].setNameEnabledForcibly(!0) : r.enemyViews[i].setNameEnabled(!0), u.util.DelayCallback.register(t, function() {
                    var e = r.enemyViews[i];
                    e && (s ? e.setNameEnabledForcibly(!1) : e.setNameEnabled(!1))
                })
            })
        },
        showEnemyNameDeferred: function(n) {
            var r = this,
                i = [];
            return e.each(this._posArray, function(e) {
                var s = t.Deferred();
                r.enemyViews[e].setNameEnabled(!0), i.push(s.promise()), u.util.DelayCallback.register(n, function() {
                    var t = r.enemyViews[e];
                    t ? t.setNameEnabledDeferred(!1).then(function() {
                        s.resolve()
                    }) : s.resolve()
                })
            }), t.when.apply(t, i)
        },
        setHpGaugeEnabled: function(t) {
            var n = this;
            e.each(this._posArray, function(e) {
                n.enemyViews[e].setHpGaugeEnabled(t)
            })
        },
        showHpGauge: function(t, n) {
            var r = this,
                i = e.difference(t, n);
            FF.logger.debug("showHpGauge", i), e.each(i, function(e) {
                r.enemyViews[e].setHpGaugeEnabled(!0)
            })
        },
        hideHpGauge: function(t) {
            var n = this;
            FF.logger.debug("hideHpGauge", t), e.each(t, function(e) {
                n.enemyViews[e].setHpGaugeEnabled(!1)
            })
        },
        cnt: 0,
        updateEnemyInfo: function(e) {
            this.cnt++;
            var t = this,
                n = e.childPosId || 1;
            if (e.mainAssetId && !this.mainNode) {
                this.visualize(!1);
                var i = this.usesFixPos ? this.posId + "_fix" : this.posId;
                this.mainNode = (new s({
                    name: "character_group_nul",
                    layer: "layer_" + e.mainAssetId,
                    visualParentTo: r("enemy_pos_nul_%s", i),
                    visualParentToOptions: {
                        visualParentLayer: this.viewController.battleLayer.layerName
                    }
                })).setParam({
                    layer_battle_field: this.viewController.battleLayer.layerName,
                    layer_bg: this.viewController.backgroundView.layerName
                }).process(), this.mainEffNode = (new s({
                    name: "character_eff_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_eff_pos_nul_%s", i)
                    }
                })).process(), this.mainSightNode = (new s({
                    name: "character_sight_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_sight_pos_nul_%s", i)
                    }
                })).process(), this.mainInfoNode = (new s({
                    name: "character_info_group_nul",
                    layer: this.mainNode.layer,
                    duplicateFrom: "character_group_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.mainNode.visualParentLayer,
                        visualParentNode: r("enemy_info_pos_nul_%s", i)
                    }
                })).process()
            }
            this.enemyViews[n] || (this.enemyViews[n] = new u.view.EnemyView({
                posId: this.posId,
                childPosId: n,
                battleViewController: this.viewController,
                mainAssetId: e.mainAssetId,
                subAssetId: e.subAssetId,
                offset: e.offset,
                scale: e.scale,
                hpGaugeSize: e.hpGaugeSize
            })), this.enemyViews[n].setEnemyInfo(e), e.isSpEnemy || (this.visualize(!0), this._posArray = [n]), this.enemyViews[n].flush()
        },
        addPosArrayDead: function(e) {
            this._posArrayDead.push("" + e)
        },
        setTouchBegan: function(t) {
            e.each(this.enemyViews, function(e) {
                e.setTouchBegan(t)
            })
        },
        setTouchEnded: function(t) {
            e.each(this.enemyViews, function(e) {
                e.setTouchEnded(t)
            })
        },
        visualize: function(e) {
            if (e === this._isVisualized) return;
            var t = this.usesFixPos ? new s({
                name: "enemy_fix_nul",
                layer: this.viewController.battleLayer.layerName,
                topNodeName: "chr_fix_nul"
            }) : new s({
                name: r("enemy_nul_%s", this.posId),
                layer: this.viewController.battleLayer.layerName,
                topNodeName: "enemy_nul"
            });
            t.setVisible(e).process(), this._isVisualized = e
        },
        dispose: function() {
            e.each(this.enemyViews, function(e, t) {
                e.dispose(), delete this.enemyViews[t]
            }, this), this.visualize(!1)
        }
    }), FF.ns.battle.view.EnemyContainer
}), define("scenes/battle/view/EnemyView", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase", "util"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle;
    return FF.ns.battle.view.EnemyView = s.extend({
        initialize: function(e) {
            var t = this;
            this.posId = e.posId, this.offset = e.offset, this.scale = e.scale, this.childPosId = e.childPosId, this.nodePrefix = "enemy", this.spritePrefix = "enemy", this.battleViewController = e.battleViewController, this.ab = {}, this._isTargeted = !1, this._spriteAssetId = void 0, this._currHp = void 0, this._playTag = void 0, this._uid = void 0, this._name = void 0, this._nameHistory = [], this._isInAnimationList = [], this._hpGaugeSize = e.hpGaugeSize, this._nonresidentSaNodeNames = [];
            var n = this.battleViewController.battleLayer,
                s = n.layerName;
            this._isSpEnemy = e.mainAssetId ? !0 : !1;
            var o = this._isSpEnemy ? e.mainAssetId : r("%s_common_%s", this.nodePrefix, this.posId.charAt(0)),
                a = this.battleViewController.assetsManager.getAssetInfo(o);
            if (!a) throw new Error(r("enemy main asset not found.id=%s", o));
            var f = this.battleViewController.assetsManager.getAssetInfo("status_eff"),
                l = this.battleViewController.assetsManager.getAssetInfo("txt_eff");
            if (this._isSpEnemy) {
                var c = e.subAssetId,
                    h = this.battleViewController.assetsManager.getAssetInfo(c);
                this.ab.characterNode = new i({
                    name: r("character_nul_%s", this.childPosId),
                    layer: h.layerName,
                    touchNodeName: "character_visible_touch",
                    duplicateFrom: "character_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_group_nul"
                    }
                }), this.ab.characterEffNode = new i({
                    name: r("eff_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "eff_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_eff_group_nul"
                    }
                }), this.ab.characterSightNode = new i({
                    name: r("sight_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "sight_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_sight_group_nul"
                    }
                }), this.ab.characterInfoNode = new i({
                    name: r("info_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "info_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_info_group_nul"
                    }
                }), this.ab.characterGaugeNode = new i({
                    name: r("gauge_nul_%s", this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "gauge_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_gauge_group_nul"
                    }
                }), this.ab.txtEffInfoNode = new i({
                    name: r("%s_txt_eff_info_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: h.layerName,
                    duplicateFrom: "character_eff",
                    duplicateFromOptions: {
                        visualParentLayer: a.layerName,
                        visualParentNode: r("character_group_pos_nul_%s", this.childPosId),
                        visualParentTopNode: "character_info_group_nul"
                    }
                }), this.ab.txtEffNode = new i({
                    name: r("%s_txt_eff_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: l.layerName,
                    duplicateFrom: "txt_eff_nul",
                    duplicateFromOptions: {
                        visualParentLayer: h.layerName,
                        visualParentNode: this.ab.txtEffInfoNode.name
                    }
                })
            } else this.ab.characterNode = (new i({
                name: r("character_nul_%s", this.posId),
                layer: a.layerName,
                touchNodeName: "character_visible_touch",
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_pos_nul_%s", this.nodePrefix, this.posId)
                }
            })).play("idle"), this.ab.characterEffNode = new i({
                name: r("eff_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_eff_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "eff_center_nul"
                }
            }), this.ab.characterSightNode = new i({
                name: r("sight_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "sight_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "sight_center_nul"
                }
            }), this.ab.characterInfoNode = new i({
                name: r("info_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "info_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "info_center_nul"
                }
            }), this.ab.characterGaugeNode = new i({
                name: r("gauge_nul_%s", this.posId),
                layer: a.layerName,
                duplicateFrom: "gauge_nul",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_sight_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "sight_center_nul"
                }
            }), this.ab.txtEffInfoNode = new i({
                name: r("%s_txt_eff_info_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: a.layerName,
                duplicateFrom: "character_eff",
                duplicateFromOptions: {
                    visualParentLayer: s,
                    visualParentNode: r("%s_info_pos_nul_%s", this.nodePrefix, this.posId),
                    visualParentTopNode: "info_center_nul"
                }
            }), this.ab.txtEffNode = new i({
                name: r("%s_txt_eff_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: l.layerName,
                duplicateFrom: "txt_eff_nul",
                duplicateFromOptions: {
                    visualParentLayer: a.layerName,
                    visualParentNode: this.ab.txtEffInfoNode.name
                }
            });
            this._addCustomActionCallbacks(this.ab.characterNode);
            var p = this.ab.characterNode,
                d = this.ab.characterEffNode,
                v = this.ab.characterInfoNode,
                m = this.ab.characterSightNode,
                g = this.ab.characterGaugeNode;
            this.ab.characterPositionNode = p.createChildNode("character_position_nul"), this.ab.characterActionNode = p.createChildNode("character_action_nul"), this.ab.colorChangeLoopNode = p.createChildNode("character_color_change_loop_nul"), this.ab.colorChangeNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul"), this.ab.colorChangeAddNode = this.ab.colorChangeLoopNode.createChildNode("character_color_change_nul_add"), this.ab.colorChangeSinglePosNode = p.createChildNode("character_color_change_single_pos_nul"), this.ab.colorChangeLoopSingleNode = new i({
                name: r("%s_character_color_change_loop_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: p.layer,
                duplicateFrom: "character_color_change_loop_nul",
                duplicateFromOptions: {
                    parentNode: this.ab.colorChangeSinglePosNode.name,
                    parentTopNode: p.name
                }
            }), this.ab.colorChangeSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul"), this.ab.colorChangeSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_color_change_nul_add"), this.ab.characterNode.setParam({
                color_change_parent: this.ab.colorChangeLoopSingleNode.name,
                character_nul: p.name
            }), this.ab.effFrontPosNode = this.ab.characterNode.createChildNode("character_eff_front_pos_nul"), this.ab.effBackPosNode = this.ab.characterNode.createChildNode("character_eff_back_pos_nul"), this._isSpEnemy ? (this.ab.motionNode = p.createChildNode("character_motion_nul"), this.ab.motionAddNode = p.createChildNode("character_motion_nul_add"), this.ab.motionSingleNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_motion_nul"), this.ab.motionSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("character_motion_nul_add")) : this.initPositionScale(), this.ab.nameNode = new i({
                name: r("%s_name_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "enemy_name_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            }), this.ab.touchNode = p.createChildNode("character_visible_touch"), this.ab.targetNode = new i({
                name: r("%s_target_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "target_enemy_nul",
                duplicateFromOptions: {
                    visualParentLayer: m.layer,
                    visualParentNode: "character_sight",
                    visualParentTopNode: m.name
                }
            }), this.ab.hpDamageNode = new i({
                name: r("%s_hp_damage_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "hp_damage_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            }), this.ab.hpDamageOverflowNode = new i({
                name: r("%s_hp_damage_overflow_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "hp_damage_overflow_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            }), this.ab.hpRecoveryNode = new i({
                name: r("%s_hp_recovery_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "hp_recovery_nul",
                duplicateFromOptions: {
                    visualParentLayer: v.layer,
                    visualParentNode: "character_info",
                    visualParentTopNode: v.name
                }
            });
            if (this.isHpGaugeVisible()) {
                this.ab.gaugeNode = (new i({
                    name: r("%s_gauge_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                    layer: "layer_enemy_gauge",
                    duplicateFrom: r("enemy_gauge_nul_%02d", this._hpGaugeSize),
                    duplicateFromOptions: {
                        visualParentLayer: g.layer,
                        visualParentNode: "character_gauge",
                        visualParentTopNode: g.name
                    }
                })).setVisible(!1);
                var y = this.ab.gaugeNode;
                this.ab.hpGaugeNode = y.createChildNode(r("hp_gauge_bar_img_%02d", this._hpGaugeSize)), this.ab.hpGaugeRedNode = y.createChildNode(r("hp_gauge_bar_red_img_%02d", this._hpGaugeSize))
            }
            this.ab.statusAilmentsBalloon = new i({
                name: r("%s_status_icon_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "status_icon_nul",
                duplicateFromOptions: {
                    visualParentLayer: d.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: d.name
                }
            }), this.ab.statusAilmentsDoom = new i({
                name: r("%s_death_num_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: s,
                duplicateFrom: "death_num_nul",
                duplicateFromOptions: {
                    visualParentLayer: d.layer,
                    visualParentNode: "character_eff",
                    visualParentTopNode: d.name
                }
            }), this.ab.statusAilmentsAura = new i({
                name: r("%s_character_eff_front_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: f.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsAura.setScale([-1, 1]), this.ab.statusAilmentsOverlayAura = new i({
                name: r("%s_character_eff_overlay_nul_%s_%s", this.nodePrefix, this.posId, this.childPosId),
                layer: f.layerName,
                duplicateFrom: "character_eff_front_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.ab.characterNode.layer,
                    visualParentNode: "character_eff_front_pos_nul",
                    visualParentTopNode: this.ab.characterNode.name
                }
            }), this.ab.statusAilmentsOverlayAura.setScale([-1, 1]), this.statusAilmentsView = new u.view.StatusAilmentsView(this), this._addCustomActionCallbacks(this.ab.txtEffNode), this._isHpGaugeVisualized = !1, this._previousIsInvisible = !1, this.flush()
        },
        _addCustomActionCallbacks: function(e) {
            var t = this;
            e.setParam({
                layer_battle_field: this.battleViewController.battleLayer.layerName,
                layer_bg: this.battleViewController.backgroundView.layerName
            }), e.addCallback("action_shake_part", function() {
                t.battleViewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.battleViewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.battleViewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.battleViewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.battleViewController.stopShakeField()
            })
        },
        initPositionScale: function() {
            this.ab.spriteBaseNode = this.ab.characterNode.createChildNode("sprite_enemy_base"), this.ab.spriteAddNode = this.ab.characterNode.createChildNode("sprite_enemy_add"), this.ab.spriteSingleBaseNode = this.ab.colorChangeLoopSingleNode.createChildNode("sprite_enemy_base"), this.ab.spriteSingleAddNode = this.ab.colorChangeLoopSingleNode.createChildNode("sprite_enemy_add"), this.ab.spriteBaseNode.setPosition(this.offset), this.ab.spriteAddNode.setPosition(this.offset), this.ab.spriteSingleBaseNode.setPosition(this.offset), this.ab.spriteSingleAddNode.setPosition(this.offset), this.ab.shadowScaleNode = this.ab.characterNode.createChildNode("shadow_scale_nul"), this.ab.effFrontPosNode.setScale([this.scale, this.scale]), this.ab.shadowScaleNode.setScale([this.scale, this.scale])
        },
        getTargetPositionDeferred: function() {
            var e = this.battleViewController;
            return e.getScreenPositionDeferred(this.ab.targetNode)
        },
        setEnemyInfo: function(e) {
            if (this.isInAnimation()) return;
            e.spriteAssetId && this.setSprite(e.spriteAssetId), this.setDispName(e.dispName), this.statusAilmentsView.update(e), this._setEffNode(), this._setHpGaugeInfo(e), this._uid = e.uid, this.flush()
        },
        _setEffNode: function() {
            this.ab.effFrontPosNode.setVisible(!0), this.ab.effBackPosNode.setVisible(!0)
        },
        _setHpGaugeInfo: function(e) {
            if (!this.isHpGaugeVisible()) return;
            !e.isInvisible && this._previousIsInvisible && this.showNameAndShowHpGauge(), e.isInvisible && this.setHpGaugeEnabled(!1), this._previousIsInvisible = e.isInvisible, this.setLifeGauge(e.hp, e.maxHp)
        },
        setDispName: function(e) {
            if (e === this._name) return;
            this.ab.nameNode.setText("enemy_name_txt", e), this._name = e
        },
        setNameEnabled: function(t) {
            if (e.contains(this._nameHistory, this._name)) return;
            t ? this.ab.nameNode.setVisible(!0).play("text_in") : (this._nameHistory.push(this._name), this.ab.nameNode.play("text_out")), this.flush()
        },
        setNameEnabledForcibly: function(e) {
            e ? this.ab.nameNode.setVisible(!0).play("text_in") : (this._nameHistory.push(this._name), this.ab.nameNode.play("text_out")), this.flush()
        },
        setNameEnabledDeferred: function(n) {
            return e.contains(this._nameHistory, this._name) ? t.Deferred().resolve().promise() : n ? this.ab.nameNode.setVisible(!0).play("text_in").processDeferred("action_stop") : (this._nameHistory.push(this._name), this.ab.nameNode.play("text_out").processDeferred("action_stop"))
        },
        setHpGaugeEnabled: function(e) {
            if (!this.isHpGaugeVisible()) return;
            e ? (this._isHpGaugeVisualized || this.ab.gaugeNode.setVisible(!0).play("bar_open"), this._isHpGaugeVisualized = !0) : (this._isHpGaugeVisualized && this.ab.gaugeNode.setVisible(!1), this._isHpGaugeVisualized = !1), this.flush()
        },
        showNameAndShowHpGauge: function() {
            var t = this;
            e.contains(this._nameHistory, this._name) ? this.setHpGaugeEnabled(!0) : (this.setNameEnabled(!0), this.setHpGaugeEnabled(!0), u.util.DelayCallback.register(2e3, function() {
                t.setNameEnabled(!1)
            }))
        },
        setSprite: function(e) {
            if (e === this._spriteAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e);
            this.ab.colorChangeLoopNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this.ab.colorChangeLoopSingleNode.loadBundle(t.bundle).setSpriteAnimeByNode(r("sprite_%s_base", this.spritePrefix), t.assetPath).setSpriteAnimeByNode(r("sprite_%s_add", this.spritePrefix), t.assetPath), this._spriteAssetId = e
        },
        setPlayTag: function(e, t) {
            if (!this._isSpEnemy) return;
            if (e === this._playTag) return;
            var n = 0;
            t && (n = o.random()), this.ab.motionNode.play(e, {
                startRatio: n
            }), this.ab.motionAddNode.play(e, {
                startRatio: n
            }), this.ab.motionSingleNode.play(e, {
                startRatio: n
            }), this.ab.motionSingleAddNode.play(e, {
                startRatio: n
            }), this._playTag = e
        },
        setTargetEnabled: function(e) {
            if (e === this._isTargeted) return;
            e ? this.ab.targetNode.play("target_in_enemy") : this.ab.targetNode.play("target_out_enemy"), this.flush(), this._isTargeted = e
        },
        setTouchBegan: function(e) {
            this.setTouchEvent("action_touch_began", e)
        },
        setTouchEnded: function(e) {
            this.setTouchEvent("action_touch_ended", e)
        },
        setTouchEvent: function(e, t) {
            var n = this;
            this.ab.characterNode.addCallback(e, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                t(n._uid)
            }, {
                layer: this.ab.characterNode.layer,
                topNode: this.ab.characterNode.name,
                node: this.ab.characterNode.touchNodeName
            })
        },
        removeAllCallback: function() {
            this.ab.characterNode.removeAllCallback()
        },
        getCurrHP: function() {
            return this._currHp
        },
        setLifeGauge: function(t, n) {
            if (!this.isHpGaugeVisible()) return;
            if (!e.isNumber(t) || !e.isNumber(n)) throw new Error("invalid life gauge param");
            if (t === this._currHp) return;
            var r = Math.floor((n - t) / n * 100);
            r <= 100 && (this.ab.hpGaugeNode.playFrame("bar", r, r).process(), this.ab.hpGaugeRedNode.playFrame("bar", r, r).process()), this._currHp = t
        },
        setDamageMotionDeferred: function(e, n, r, i, s, o, a, f) {
            f = f || {};
            if (!e) return t.Deferred().resolve().promise();
            var l = void 0,
                c = void 0;
            if (s >= 0) {
                l = "" + s, c = o || "damage_red";
                var h = u.Config.getInstance().get("DamageCalculator", "DAMAGE", "damageThresholdTypeMap"),
                    p = this.playHpDamageDeferred;
                return s > h[u.Conf.DAMAGE_THRESHOLD_TYPE.DEFAULT] && (p = this.playHpDamageOverflowDeferred), t.when(this.playDeferred(c), p.apply(this, [l, f]), this.setLifeGaugeMotionDeferred(n, r, i))
            }
            return l = "" + -1 * s, c = a || "eff_recover", t.when(this.playDeferred(c), this.playHpRecoveryDeferred(l, f), this.setLifeGaugeMotionDeferred(n, r, i))
        },
        setAbsorbDamageMotionDeferred: function(e, n, r, i, s, o, u, a, f) {
            return a ? this.setDamageMotionDeferred(e, n, r, i, s, o, u, f) : t.Deferred().resolve().promise()
        },
        playDeferred: function(n, r) {
            var i = this;
            r = r || {};
            var s = t.Deferred(),
                o = e.extend({
                    isPlayChild: !1
                }, r);
            return this.ab.colorChangeLoopNode.setVisible(!1), this.ab.colorChangeSinglePosNode.setVisible(!0).play(n, o).addCallbackOnce("action_stop", function() {
                i.ab.colorChangeLoopNode.setVisible(!0), i.ab.colorChangeSinglePosNode.setVisible(!1), i.flush(), s.resolve()
            }), this.ab.colorChangeSingleNode.play(n, o), this.ab.colorChangeSingleAddNode.play(n, o), this.flush(), s.promise()
        },
        playHpDamageDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpDamageNode, "hp_damage", e, t)
        },
        playHpDamageOverflowDeferred: function(t, n) {
            return e.extend(n, {
                tagName: "hp_text_long"
            }), this.playDigitsDeferred(this.ab.hpDamageOverflowNode, "hp_damage_overflow", t, n)
        },
        playHpRecoveryDeferred: function(e, t) {
            return this.playDigitsDeferred(this.ab.hpRecoveryNode, "hp_recovery", e, t)
        },
        playDigitsDeferred: function(n, i, s, o) {
            var u = t.Deferred();
            o = o || {};
            var a = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7],
                f = String(s).split("").reverse();
            e.each(a, function(e, t) {
                var s = f[t] || "";
                n.setText(r("%s_%d_txt", i, e), s)
            });
            var l = "hp_text";
            return o.tagName && (l = o.tagName, delete o.tagName), n.addCallbackOnce("action_stop", function() {
                u.resolve()
            }).play(l, o).process(), u.promise()
        },
        playCriticalDeferred: function() {
            return this.ab.txtEffNode.play("critical").processDeferred("action_stop")
        },
        playWeaknessDeferred: function() {
            return this.ab.txtEffNode.play("weakness").processDeferred("action_stop")
        },
        playDefenseDeferred: function() {
            return this.ab.txtEffNode.play("defense").processDeferred("action_stop")
        },
        playAbsorbDeferred: function() {
            return this.ab.txtEffNode.play("absorb").processDeferred("action_stop")
        },
        playResistDeferred: function() {
            return this.ab.txtEffNode.play("resist").processDeferred("action_stop")
        },
        playMissDeferred: function() {
            return this.ab.txtEffNode.play("miss").processDeferred("action_stop")
        },
        playNoeffectDeferred: function() {
            return this.ab.txtEffNode.play("noeffect").processDeferred("action_stop")
        },
        setLifeGaugeMotionDeferred: function(n, r, i) {
            if (!this.isHpGaugeVisible()) return t.Deferred().resolve().promise();
            if (!e.isNumber(n) || !e.isNumber(r) || !e.isNumber(i)) return t.Deferred().resolve().promise();
            if (r === this._currHp) return;
            var s = this,
                o, u, a, f;
            return n > r ? (o = "bar", u = Math.floor((i - n) / i * 100), a = Math.floor((i - r) / i * 100)) : (o = "bar_reverse", u = Math.floor(n / i * 100), a = Math.floor(r / i * 100)), f = e.max([Math.abs(u - a) / 20, 1]), this._currHp = r, this.ab.hpGaugeNode.playFrame(o, u, a, {
                speed: f
            }).processDeferred("action_stop", {
                node: s.ab.hpGaugeNode.name,
                topNode: s.ab.gaugeNode.name
            }).then(function() {
                return s.ab.hpGaugeRedNode.playFrame(o, u, a, {
                    speed: f
                }).processDeferred("action_stop", {
                    node: s.ab.hpGaugeRedNode.name,
                    topNode: s.ab.gaugeNode.name
                })
            })
        },
        setDeadInfo: function(e) {
            e = o.option({
                isApparentDead: !1
            }, e), e.isApparentDead ? this.hideVisibleSurrounding() : this.hide();
            var t = this.battleViewController.enemyContainers[this.posId];
            t.addPosArrayDead(this.childPosId)
        },
        hide: function() {
            this.ab.characterPositionNode.setVisible(!1), this.ab.touchNode.setVisible(!1), this.ab.statusAilmentsAura.setVisible(!1), this.ab.statusAilmentsBalloon.setVisible(!1), this.ab.statusAilmentsDoom.setVisible(!1), this.flush()
        },
        hideVisibleSurrounding: function() {
            this.setVisibleSurrounding(!1), this.flush()
        },
        getAbilityNodeDuplicateOptions: function(e) {
            var t = {
                visualParentLayer: this.ab.characterEffNode.layer,
                visualParentNode: r("character_%s", e),
                visualParentTopNode: this.ab.characterEffNode.name
            };
            return t
        },
        setAbilityShotAttractor: function(e) {
            e.setAttractor("shot_particle", "character_attractor", {
                attractorLayer: this.ab.characterEffNode.layer,
                attractorTopNode: this.ab.characterEffNode.name
            })
        },
        playInDeferred: function(e) {
            return this.setVisibleSurrounding(!0), this.flush(), this.ab.characterNode.play(e).processDeferred("action_stop")
        },
        playOutDeferred: function(e) {
            return this.setVisibleSurrounding(!1), this.flush(), this.ab.characterNode.play(e).processDeferred("action_stop")
        },
        setVisibleSurrounding: function(e) {
            this.ab.targetNode.setVisible(e), this.ab.statusAilmentsAura.setVisible(e), this.ab.statusAilmentsBalloon.setVisible(e), this.ab.statusAilmentsDoom.setVisible(e)
        },
        setTouchVisible: function(e) {
            this.ab.touchNode.setVisible(e), this.flush()
        },
        getUid: function() {
            return this._uid
        },
        registerIsInAnimation: function() {
            this._isInAnimationList.push(!0)
        },
        unregisterIsInAnimation: function() {
            this._isInAnimationList.shift()
        },
        isInAnimation: function() {
            return this._isInAnimationList.length > 0
        },
        isHpGaugeVisible: function() {
            return this._hpGaugeSize > 0
        },
        getStatusAilmentsNonresidentBackAura: function(t, n) {
            n = n || {};
            var s = r("statusAilmentsNonresidentBackAura_%s", o.camelize(t));
            if (!!n.shouldCreateIfNotExists && !this.ab[s]) {
                var u = this.battleViewController.assetsManager.getAssetInfo(t);
                this.ab[s] = new i({
                    name: r("%s_character_eff_nonresident_back_nul_%s_%s", this.nodePrefix, this.posId, t),
                    layer: u.layerName,
                    duplicateFrom: "character_eff_back_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_back_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                }), this._nonresidentSaNodeNames.push(s), e.isNumber(n.zOrder) && this.ab[s].setZOrder(n.zOrder), this.ab[s].setScale([-1, 1])
            }
            return this.ab[s]
        },
        getStatusAilmentsNonresidentFrontAura: function(t, n) {
            n = n || {};
            var s = r("statusAilmentsNonresidentFrontAura_%s", o.camelize(t));
            if (!!n.shouldCreateIfNotExists && !this.ab[s]) {
                var u = this.battleViewController.assetsManager.getAssetInfo(t);
                this.ab[s] = new i({
                    name: r("%s_character_eff_nonresident_front_nul_%s_%s", this.nodePrefix, this.posId, t),
                    layer: u.layerName,
                    duplicateFrom: "character_eff_front_nul",
                    duplicateFromOptions: {
                        visualParentLayer: this.ab.characterNode.layer,
                        visualParentNode: "character_eff_front_pos_nul",
                        visualParentTopNode: this.ab.characterNode.name
                    }
                }), this._nonresidentSaNodeNames.push(s), e.isNumber(n.zOrder) && this.ab[s].setZOrder(n.zOrder), this.ab[s].setScale([-1, 1])
            }
            return this.ab[s]
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush()
        }
    }), FF.ns.battle.view.EnemyView
}), define("scenes/battle/view/MenuWindowView", ["underscore", "jquery", "backbone", "sprintf", "lib/BattleConfig", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            CLOSE: "close",
            PAUSE: "pause",
            RETIRE: "retire",
            ESCAPE: "escape",
            GAMEOVER: "gameover",
            GAMEOVER_MO_FREE: "gameover_mo_free",
            GAMEOVER_MO_MITHRIL_ONLY: "gameover_mo_mithril",
            POWER_UP: "power_up",
            POWER_SELECT: "power_select",
            CONTINUE: "continue",
            FREE_CONFIRM: "system_1",
            FREE_ALERT: "system_2",
            BALANCE_ERROR: "buy_check",
            VC_LIST: "buy_select",
            GEM_AND_MITHRIL_HELP: "gem_and_mithril_help"
        },
        f = {
            PAUSE: "MenuWindowView::pause",
            BACK: "MenuWindowView::back",
            ESCAPE: "MenuWindowView::escape",
            RETIRE: "MenuWindowView::retire",
            CONTINUED: "MenuWindowView::continued",
            CONTINUE_BY_SOUL_PIECE: "MenuWindowView::continueBySoulPiece",
            CONTINUE_BY_COIN: "MenuWindowView::continueByCoin",
            FREE_LEFT: "MenuWindowView::freeLeft",
            FREE_RIGHT: "MenuWindowView::freeRight",
            BALANCE_ERROR_CANCEL: "MenuWindowView::balanceErrorCancel",
            TO_VC_LIST: "MenuWindowView::toVCList",
            BUY_VC: "MenuWindowView::buyVC",
            BUY_VC_CLOSE: "MenuWindowView::buyVCClose",
            GEM_AND_MITHRIL_HELP: "MenuWindowView::gemAndMithrilHelp"
        };
    return FF.ns.battle.view.MenuWindowView = o.extend({
        initialize: function(t) {
            this.battleViewController = t.battleViewController, this.ab = {}, this._listeningEvents = [];
            var n = this.battleViewController.battleLayer,
                r = n.layerName,
                i = this.battleViewController.assetsManager.getAssetInfo("menu_window");
            this.layerName = i.layerName, this.ab.windowMainNode = new s({
                name: "window_main_nul",
                layer: this.layerName,
                visualParentTo: "sys_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r
                }
            }), FF.env.isTutorial() || (this.ab.frameWaitNode = this._createNode("frame_wait_nul"), this.ab.frameWaitNode.setVisible(!0).process()), this.touchBeganDeferred = void 0, this.btnEnableInfo = {}, this._isOpeningWindow = !1, this._isJustOpeningWindow = !1, this._isJustClosingWindow = !1, this._tappingBtnName = void 0, this._prepareBtnEvent(), this._registerFixedEvent(), this.battleViewController.addIngoreSupendLayers(this.ab.windowMainNode.layer), FF.env.isTutorial() ? this.WINDOW_TAG = e.extend({}, a, {
                PAUSE: "pause_tutorial"
            }) : this.WINDOW_TAG = a
        },
        _prepareBtnEvent: function() {
            var t = this;
            this.ab.pauseToBackNode = this._createBtnNode("pause_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.BACK)
                })
            }), this.ab.pauseToEscapeNode = this._createBtnNode("pause_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    u.DataConstructor.judgePauseOrEscapeAvailable() ? (t._showWindowDeferred(a.ESCAPE), t.flush()) : t._showEscapeAlertWindow()
                })
            }), this._pauseToBattleSpeedNodes = {}, FF.env.isTutorial() || e.each(i.getBattleSpeedCandidates(), function(e, n) {
                var i = this._createNode(r("wait_toggle_nul_0%d", +n));
                i.addCallback("action_touch_ended", function() {
                    FF.SoundMgr.playChooseEffect(), t._showBattleSpeed(n)
                }), this._pauseToBattleSpeedNodes[n] = i, this.ab[r("pauseToBattleSpeedNode%d", +n)] = i
            }, this), this.ab.escapeYesNode = this._createBtnNode("escape_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    u.DataConstructor.judgePauseOrEscapeAvailable() ? t.trigger(f.ESCAPE) : t._showEscapeAlertWindow()
                })
            }), this.ab.escapeNoNode = this._createBtnNode("escape_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.BACK)
                })
            }), this.ab.gameoverItemNode = this._createBtnNode("gameover_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.CONFIRM_CONTINUE, function() {
                        t.trigger(f.CONTINUE_BY_SOUL_PIECE)
                    }, function() {
                        t._playBtnEnable(t.ab.gameoverItemNode), t._showWindowDeferred(t._gameOverWindowTag)
                    })
                })
            }), this.ab.mithrilNumNode = this._createNode("gameover_bt_1_sub_nul"), this.ab.gameoverCoinNode = this._createBtnNode("gameover_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.trigger(f.CONTINUE_BY_COIN)
                })
            }), this.ab.coinNumNode = this._createNode("gameover_bt_2_sub_nul"), this.ab.gameorverRetireNode = this._createBtnNode("gameover_bt_3_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t._showWindowDeferred(t.WINDOW_TAG.RETIRE), t.flush()
                })
            }), this.ab.gameorverTokushouNode = this._createBtnNode("gameover_bt_4_nul", function() {
                kickmotor.platform.resetMobageDashboardListener(), kickmotor.platform.setMobageDashboardListener(function() {}, function() {
                    t._unlockBtnTap(), kickmotor.platform.resetMobageDashboardListener()
                }, function(e) {}), kickmotor.platform.mobageLegal()
            }), this.ab.retireNoNode = this._createBtnNode("retire_bt_2_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t._playBtnEnable(t.ab.gameoverItemNode), t._showWindowDeferred(t._gameOverWindowTag)
                })
            }), this.ab.retireYesNode = this._createBtnNode("retire_bt_1_nul", function() {
                t.closeWindowDeferred().then(function() {
                    t.trigger(f.RETIRE)
                })
            }), this.ab.continueBackNode = this._createBtnNode("continue_bt_1_nul", function() {
                var e = t.getContinueBonusView();
                e.setBaseCharaVisible(!1), t.closeWindowDeferred().then(function() {
                    e.deleteNodes(), t.clearContinueBonusView(), t.setInvisible(), t.trigger(f.CONTINUED)
                })
            }), this.ab.freeRightNode = this._createBtnNode("system_bt_nul_01", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.FREE_RIGHT)
                })
            }), this.ab.freeLeftNode = this._createBtnNode("system_bt_nul_02", function() {
                t.closeWindowDeferred().then(function() {
                    t.setInvisible(), t.trigger(f.FREE_LEFT)
                })
            }), FF.env.isWWRegion() && this._prepareBtnEventWW()
        },
        _prepareBtnEventWW: function() {
            var e = this;
            this.ab.toVCListNode = this._createBtnNode("buy_check_bt_1_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.TO_VC_LIST)
                })
            }), this.ab.balanceErrorCancelNode = this._createBtnNode("buy_check_bt_2_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.BALANCE_ERROR_CANCEL)
                })
            }), this.ab.buyVCCloseNode = this._createBtnNode("buy_select_close_nul", function() {
                if (e._vcListView.isSelected) {
                    e.ab.buyVCCloseNode.play("reset").process(), e.touchBeganDeferred = void 0, e._unlockBtnTap();
                    return
                }
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.BUY_VC_CLOSE)
                })
            }), this.ab.gemAndMithrilHelpNode = this._createBtnNode("buy_select_link_nul", function() {
                e.ab.gemAndMithrilHelpCloseNode.setVisible(!0);
                if (e._vcListView.isSelected) {
                    e.ab.gemAndMithrilHelpNode.play("reset").process(), e.touchBeganDeferred = void 0, e._unlockBtnTap();
                    return
                }
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.GEM_AND_MITHRIL_HELP)
                })
            }), this.ab.gemAndMithrilHelpCloseNode = this._createBtnNode("help_select_close_nul", function() {
                e.closeWindowDeferred().then(function() {
                    e.setInvisible(), e.trigger(f.TO_VC_LIST)
                })
            })
        },
        showFreeWindow: function(t) {
            t = e.extend({
                title: "",
                description: "",
                buttons: [{
                    title: "",
                    callback: function() {}
                }]
            }, t), this._setText("system_title_txt", t.title), this._setText("system_txt", t.description);
            var n = void 0;
            e.each(t.buttons, function(e, t) {
                if (t === 0) this._setText("system_bt_txt_01", e.title), this.addCallback(f.FREE_RIGHT, e.callback), n = this.WINDOW_TAG.FREE_ALERT;
                else {
                    if (t !== 1) throw new Error("lots of button info");
                    this._setText("system_bt_txt_02", e.title), this.addCallback(f.FREE_LEFT, e.callback), n = this.WINDOW_TAG.FREE_CONFIRM
                }
            }, this);
            if (!n) throw new Error("button info empty");
            this.flush(), this._showWindowDeferred(n)
        },
        getContinueBonusView: function() {
            if (!this._continueBonusView) {
                var e = this.battleViewController.assetsManager.getAssetInfo("menu_window"),
                    t = new u.view.ContinueBonusView({
                        battleViewController: this.battleViewController,
                        menuLayerInfo: e,
                        windowNode: this.ab.windowMainNode
                    });
                t.setup(), this._continueBonusView = t
            }
            return this._continueBonusView
        },
        clearContinueBonusView: function() {
            this._continueBonusView = void 0
        },
        _registerFixedEvent: function() {
            this.addCallback(f.PAUSE, function() {
                FF.scene.suspend()
            }), this.addCallback(f.BACK, function() {
                FF.scene.resume()
            }), this.addCallback(f.ESCAPE, function() {
                FF.scene.escape()
            }), FF.env.isWWRegion() && this._registerFixedEventWW()
        },
        _registerFixedEventWW: function() {
            var e = this;
            this.addCallback(f.BALANCE_ERROR_CANCEL, function() {
                e._clearBalanceErrorButtons(), e._rejectBalanceErrorWindow()
            }), this.addCallback(f.BUY_VC_CLOSE, function() {
                e._clearVCListView(), e._rejectBalanceErrorWindow(), e.ab.gemAndMithrilHelpNode && e.ab.gemAndMithrilHelpNode.setVisible(!1)
            }), this.addCallback(f.TO_VC_LIST, function() {
                e._clearBalanceErrorButtons(), e.ab.gemAndMithrilHelpCloseNode && e.ab.gemAndMithrilHelpCloseNode.setVisible(!1), e.ab.gemAndMithrilHelpNode && e.ab.gemAndMithrilHelpNode.setVisible(!0), e.setInvisible(), e._showVCListWindowDeferred()
            }), this.addCallback(f.GEM_AND_MITHRIL_HELP, function() {
                e.ab.buyVCCloseNode && e.ab.buyVCCloseNode.setVisible(!1), e.flush(), e._showWindowDeferred(e.WINDOW_TAG.GEM_AND_MITHRIL_HELP)
            })
        },
        _setText: function(e, t) {
            this.ab.windowMainNode.setText(e, t).process()
        },
        _createNode: function(e) {
            var t = this.ab.windowMainNode.createChildNode(e);
            return t
        },
        _createBtnNode: function(e, t) {
            var n = this,
                r = this._createNode(e);
            return this._setBtnEnable(r, !0), r.addCallback("action_touch_began", function() {
                if (!n._isBtnEnable(r)) return;
                if (!n._lockBtnTap(r)) return;
                n.touchBeganDeferred = r.play("tap").processDeferred("action_stop")
            }), r.addCallback("action_touch_ended", function() {
                if (!n._isLockedBtnTap(r) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    FF.SoundMgr.playChooseEffect(), n.touchBeganDeferred = void 0, t()
                })
            }), r.addCallback("action_touch_exited", function() {
                if (!n._isLockedBtnTap(r) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    r.play("reset").process(), n.touchBeganDeferred = void 0, n._unlockBtnTap()
                })
            }), r
        },
        _setBtnEnable: function(e, t) {
            this.btnEnableInfo[e.name] = t
        },
        _isBtnEnable: function(e) {
            return this.btnEnableInfo[e.name] ? !0 : !1
        },
        _playBtnEnable: function(e) {
            this._isBtnEnable(e) ? e.play("reset", {
                autoRemove: !1
            }) : e.play("bt_disable", {
                autoRemove: !1
            }), this.flush()
        },
        _lockBtnTap: function(e) {
            return this._tappingBtnName ? !1 : (this._tappingBtnName = e.name, !0)
        },
        _isLockedBtnTap: function(e) {
            return !!this._tappingBtnName && this._tappingBtnName === e.name
        },
        _unlockBtnTap: function() {
            this._tappingBtnName = void 0
        },
        addCallback: function(t, n) {
            e.contains(this._listeningEvents, t) && this.stopListening(this, t), this.listenTo(this, t, n), this._listeningEvents.push(t), this._listeningEvents = e.uniq(this._listeningEvents)
        },
        startPause: function() {
            var e = this;
            this._showBattleSpeed(), this._showWindowDeferred(this.WINDOW_TAG.PAUSE).then(function() {
                e.flush(), e.trigger(f.PAUSE)
            })
        },
        showGameOverWindow: function(e, t, n, r) {
            e._showMithrilNum = !0, e._showCoin = !0, e.noticeText = this._getExpireNoticetext(e), this._setGameOverInfo(e), this.addCallback(f.CONTINUE_BY_SOUL_PIECE, t), this.addCallback(f.CONTINUE_BY_COIN, n), this.addCallback(f.RETIRE, r), this._gameOverWindowTag = this.WINDOW_TAG.GAMEOVER, this._showWindowDeferred(this._gameOverWindowTag)
        },
        showGameOverWindowFreeContinue: function(e, t, n) {
            e._showMithrilNum = !1, e._showCoin = !1, e.noticeText = this._getExpireNoticetext(e, !0), this._setGameOverInfo(e), this.addCallback(f.CONTINUE_BY_SOUL_PIECE, t), this.addCallback(f.RETIRE, n), this._gameOverWindowTag = this.WINDOW_TAG.GAMEOVER_MO_FREE, this._showWindowDeferred(this._gameOverWindowTag)
        },
        showGameOverWindowMithrilContinueOnly: function(e, t, n) {
            e._showMithrilNum = !0, e._showCoin = !1, e.noticeText = this._getExpireNoticetext(e), this._setGameOverInfo(e), this.addCallback(f.CONTINUE_BY_SOUL_PIECE, t), this.addCallback(f.RETIRE, n), this._gameOverWindowTag = this.WINDOW_TAG.GAMEOVER_MO_MITHRIL_ONLY, this._showWindowDeferred(this._gameOverWindowTag)
        },
        _getExpireNoticetext: function(e, t) {
            var n = u.TextMaster.getInstance(),
                i = Math.floor(e.untilExpire / 3600),
                s = Math.floor(e.untilExpire % 3600 / 60);
            return r(n.get(t ? "B15381" : "B10210"), i, s)
        },
        _setGameOverInfo: function(e) {
            var t = u.TextMaster.getInstance(),
                n = u.Conf.CONTINUE_TYPE;
            this._setText("notice_txt", e.noticeText);
            var i = t.get("mithril");
            this.ab.mithrilNumNode.setVisible(e._showMithrilNum).process(), e._showMithrilNum && (this._setText("gameover_bt_1_sub_key_txt", r(t.get("B10180"), i)), this._setText("gameover_bt_1_sub_value_txt", e[n.SOUL_PIECE].balance)), this._setText("gameover_bt_1_txt", r(t.get("B10190"), i)), this._setText("gameover_bt_1_num_txt", r(t.get("B10200"), e[n.SOUL_PIECE].payCost)), this._setBtnEnable(this.ab.gameoverItemNode, !!e[n.SOUL_PIECE].canConsume), this._playBtnEnable(this.ab.gameoverItemNode), this.ab.gameoverCoinNode.setVisible(e._showCoin).process(), this.ab.coinNumNode.setVisible(e._showCoin).process();
            if (e._showCoin) {
                this._setText("gameover_bt_2_sub_key_txt", r(t.get("B10180"), this._detectCurrencyUnit())), this._setText("gameover_bt_2_sub_value_txt", e[n.COIN].balance), this._setText("gameover_bt_2_txt", r(t.get("B10190"), this._detectCurrencyUnit()));
                var s = FF.env.isWWRegion() ? " " : "";
                this._setText("gameover_bt_2_num_txt", e[n.COIN].payCost + s + this._detectCurrencyUnit())
            }
            this.ab.gameorverTokushouNode.setVisible(e._showCoin).process()
        },
        showPowerUpWindow: function(e, t) {
            var n = this,
                r = this.getContinueBonusView();
            this.ab.windowMainNode.addCallbackOnce("action_next", function() {
                r.showPreRaise()
            }), this.ab.windowMainNode.addCallbackOnce("action_raise", function() {
                r.showPostRaise()
            }), this._showWindowDeferred(this.WINDOW_TAG.POWER_SELECT).then(function() {
                r.registerCardTouch(e, t)
            })
        },
        showContinueDoneWindow: function(t, n) {
            var i = this,
                s = n.lastBonusId,
                o = n.bonusAmount,
                a = u.TextMaster.getInstance(),
                l = u.Config.getInstance().get("ContinueBonus", s);
            this.ab.stUpColorNode || (this.ab.stUpColorNode = this.ab.windowMainNode.createChildNode("status_up_color_win")), this.ab.stUpColorNode.play(l.colorTag, {
                autoRemove: !1
            }), this._setText("status_up_txt", r(a.get(l.descTextId), "+" + l.boostFactor));
            var c = [];
            e.each(u.Config.getInstance().get("ContinueBonusIds"), function(e) {
                var t = o[e];
                if (!t) return;
                var n = u.Config.getInstance().get("ContinueBonus", e),
                    i = n.boostFactor * t;
                c.push(r(a.get(n.descTextId), i))
            }, this), this._setText("continue_sub_txt", c.join("{n}")), this.addCallback(f.CONTINUED, t), this.flush();
            var h = this.getContinueBonusView();
            h.setBaseCharaVisible(!1), i.closeWindowDeferred().then(function() {
                return h.showPostRaise(), i._showWindowDeferred(i.WINDOW_TAG.CONTINUE)
            })
        },
        _showEscapeAlertWindow: function() {
            var e = this;
            this.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.ALERT_ESCAPE, function() {
                e.setInvisible(), e.trigger(f.BACK)
            })
        },
        closeWindowDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this._isJustClosingWindow = !0, this.ab.windowMainNode.play(this.WINDOW_TAG.CLOSE).processDeferred("action_stop").then(function() {
                e._isJustClosingWindow = !1, n.resolve()
            }), n.promise()
        },
        _showWindowDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            return this._unlockBtnTap(), this.setOpeningWindow(!0), this._isJustOpeningWindow = !0, this.ab.windowMainNode.setVisible(!0).play(e).processDeferred("action_stop").then(function() {
                n._isJustOpeningWindow = !1, r.resolve()
            }), r.promise()
        },
        _showBattleSpeed: function(e) {
            if (FF.env.isTutorial()) return;
            e || (e = u.DataConstructor.getBattleSpeedIndex()), this._currBattleSpeedIdx && this._pauseToBattleSpeedNodes[this._currBattleSpeedIdx].play("disable").process(), this._pauseToBattleSpeedNodes[e].play("enable").process();
            var t = u.TextMaster.getInstance().get("B15240");
            this.ab.windowMainNode.setText("wait_title_txt", r(t, +e)).process(), this._currBattleSpeedIdx = e, this._callBattleSpeedTouch(e)
        },
        setBattleSpeedTouch: function(t) {
            if (!e.isFunction(t)) throw new TypeError("Argument 1 must be type of Function");
            this._battleSpeedTouch = t
        },
        setInvisible: function() {
            this.setOpeningWindow(!1), this.ab.windowMainNode.setVisible(!1), this.flush()
        },
        _callBattleSpeedTouch: function(e) {
            if (!this._battleSpeedTouch) {
                FF.logger.warn("Undefined property _battleSpeedTouch");
                return
            }
            this._battleSpeedTouch(e)
        },
        _detectCurrencyUnit: function() {
            return u.TextMaster.getInstance().getMobacoinUnit()
        },
        prepareForTutorial: function() {
            var e = this.ab.pauseToEscapeNode;
            this._setBtnEnable(e, !1), this._playBtnEnable(e), this.ab.tutorialText || (this.ab.tutorialText = this.ab.windowMainNode.createChildNode("tutorial_txt")), this.ab.tutorialText.setVisible(!0), this.flush()
        },
        setOpeningWindow: function(e) {
            this._isOpeningWindow = e
        },
        isOpeningWindow: function() {
            return this._isOpeningWindow
        },
        isJustAnimatingWindow: function() {
            return this._isJustOpeningWindow || this._isJustClosingWindow
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this._battleSpeedTouch = void 0
        },
        _rejectBalanceErrorWindow: function() {
            if (this._balanceErrorD) {
                var e = this._balanceErrorD;
                this._balanceErrorD = void 0, e.reject()
            }
        },
        _clearBalanceErrorButtons: function() {
            this.ab.balanceErrorCancelNode && this.ab.balanceErrorCancelNode.setVisible(!1), this.ab.toVCListNode && this.ab.toVCListNode.setVisible(!1)
        },
        _showBalanceErrorButtons: function() {
            this.ab.balanceErrorCancelNode && this.ab.balanceErrorCancelNode.setVisible(!0), this.ab.toVCListNode && this.ab.toVCListNode.setVisible(!0), this.flush()
        },
        _clearVCListView: function() {
            this.ab.buyVCCloseNode && this.ab.buyVCCloseNode.setVisible(!1), this._vcListView && (this._vcListView.setButtonVisibility(!1), this._vcListView.deleteNodes()), this._vcListView = void 0
        },
        showBalanceErrorWindowDeferred: function(e, n) {
            var i = this;
            this._balanceErrorD = t.Deferred();
            var s = u.TextMaster.getInstance(),
                o = r(s.get("B30000"), n - e);
            return this._showBalanceErrorButtons(), this._setText("buy_check_owned_num", e), this._setText("buy_check_needed_num", n), this._setText("buy_check_word_needed", o), this._showWindowDeferred(this.WINDOW_TAG.BALANCE_ERROR).then(function() {
                i.flush()
            }), this._balanceErrorD.promise()
        },
        confirmWithUserDeferred: function(e, n) {
            var i = t.Deferred(),
                s = u.TextMaster.getInstance(),
                o = r(s.get("BWW15161"), n, e),
                a = {
                    title: s.get("BWW15151"),
                    description: o,
                    buttons: [{
                        title: s.get("yes"),
                        callback: function() {
                            i.resolve()
                        }
                    }, {
                        title: s.get("no"),
                        callback: function() {
                            i.reject()
                        }
                    }]
                };
            return this.showFreeWindow(a), i.promise()
        },
        _showVCListWindowDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.ab.buyVCCloseNode && this.ab.buyVCCloseNode.setVisible(!0), this.flush(), this._setupVCListViewDeferred().then(function() {
                return e._showWindowDeferred(e.WINDOW_TAG.VC_LIST)
            }).then(function() {
                e.flush(), n.resolve()
            }), n.promise()
        },
        _setupVCListViewDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (this._vcListView) return setTimeout(function() {
                n.resolve()
            }, 0), n.promise();
            var r = this.battleViewController.battleLayer,
                i = r.layerName,
                s = this.battleViewController.assetsManager.getAssetInfo("menu_window"),
                o = new u.view.VCListView({
                    windowMainNode: this.ab.windowMainNode,
                    menuLayerInfo: s,
                    battleLayerName: i
                });
            return o.setupDeferred().done(function() {
                n.resolve(), e._vcListView = o
            }).fail(function() {
                n.reject(), e.battleViewController.showSystemWindow(u.Conf.SYSTEM_WINDOW.NETWORK)
            }), n.promise()
        },
        endPause: function() {
            var e = this;
            e.closeWindowDeferred().then(function() {
                e.setInvisible(), e.trigger(f.BACK)
            })
        }
    }), FF.ns.battle.view.MenuWindowView
}), define("scenes/battle/view/LoadingView", ["underscore", "jquery", "sprintf", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    return FF.ns.battle.view.LoadingView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.ab = {};
            var t = this.battleViewController.battleLayer,
                n = this.battleViewController.assetsManager.getAssetInfo("loading");
            this.ab.loadingNode = new r({
                name: "loading_nul",
                layer: n.layerName,
                visualParentTo: "loading_bottom_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: t.layerName
                }
            }), this.ab.loadingNode.setVisible(!1).process(), this._isOpening = !1, this.battleViewController.addIngoreSupendLayers(this.ab.loadingNode.layer)
        },
        open: function() {
            this.ab.loadingNode.setVisible(!0).play("play"), this.flush(), this._isOpening = !0
        },
        close: function() {
            this.ab.loadingNode.setVisible(!1), this.flush(), this._isOpening = !1
        },
        isOpening: function() {
            return this._isOpening
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush()
        }
    }), FF.ns.battle.view.LoadingView
}), define("scenes/battle/view/MessageView", ["underscore", "jquery", "backbone", "util", "lib/ClassBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle,
        o = 1500,
        u = "{N}";
    return FF.ns.battle.view.MessageView = i.extend({
        initialize: function(e) {
            var t;
            s.BattleInfo.getInstance().isMo() ? t = e.battleViewController.battleHeaderLayer : t = e.battleViewController.battleLayer, this.headerTextNode = t.createNode("header_text_nul"), this._queue = [], this._showingMsgInfo = void 0
        },
        show: function(t) {
            t = r.option({
                message: "",
                duration: o,
                callback: void 0,
                showHook: void 0,
                id: 0
            }, t);
            if (t.message.indexOf(u) >= 0) {
                var n = t.message.split(u),
                    i = t.callback,
                    s = t.showHook;
                for (var a = 0, f = n.length; a < f; a++) {
                    var l = a === f - 1 ? i : void 0,
                        c = a === 0 ? s : void 0;
                    this.show(e.extend(t, {
                        message: n[a],
                        callback: l,
                        showHook: c
                    }))
                }
                return
            }
            t.showHook && t.showHook(), this._showingMsgInfo ? this._queue.push(t) : this._show(t)
        },
        _show: function(e) {
            var t = this;
            this.headerTextNode.setText("header_txt", e.message), this.headerTextNode.setVisible(!0).process(), this._showingMsgInfo = e, FF.logger.debug("MSG:" + e.message), s.util.DelayCallback.register(e.duration, function() {
                t.hide(), e.callback && e.callback(), t._showingMsgInfo = void 0, t._queue.length > 0 && t._show(t._queue.shift())
            })
        },
        hide: function() {
            this.headerTextNode.setText("header_txt", ""), this.headerTextNode.setVisible(!1).process()
        },
        showForever: function(e) {
            this.headerTextNode.setText("header_txt", e), this.headerTextNode.setVisible(!0).process()
        }
    }), FF.ns.battle.view.MessageView
}), define("scenes/battle/view/SoulStrikeView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            SOUL_STRIKE_SELECTOR_SHOWN: "ssSelectorShown",
            SOUL_STRIKE_SELECTOR_HIDDEN: "ssSelectorHidden"
        };
    return FF.ns.battle.view.SoulStrikeView = o.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.topNode = e.topNode, this._charaAssetId = void 0, this._enabled = void 0, this._touchEnabled = !0, this._soulStrikeCount = 1, this.touchEndedCallback = void 0, this.touchEndedCallbackWithSlot = void 0, this.ab = {}, this.ab.criticalNode = this.topNode.createChildNode("critical_nul"), this.ab.criticalSelectNode = this.topNode.createChildNode("critical_select"), this.normalSoulStrikeGauge = new FF.ns.battle.view.SoulStrikeGauge(this.ab.criticalNode, "normal"), this.selectorSoulStrikeGauge = new FF.ns.battle.view.SoulStrikeGauge(this.ab.criticalSelectNode, "selector"), this.ab.charaTextNode = this.topNode.createChildNode("chr_name_txt").setVisible(!0), this.ab.textNode = this.ab.criticalNode.createChildNode("critical_text_nul").setVisible(!0), this.ab.buttonNode = this.ab.criticalNode.createChildNode("critical_btn_nul"), this.ab.buttonTouchNode = this.ab.criticalNode.createChildNode("critical_btn_visible_touch"), this._initSoulStrikeSelectorView(), this._switchUI(), this.flush()
        },
        _initSoulStrikeSelectorView: function() {
            var e = this;
            this.ssSelectorView = new FF.ns.battle.view.SoulStrikeSelectorView(this.topNode, this.battleViewController);
            var t = this.ssSelectorView,
                n = FF.ns.battle.view.SoulStrikeSelectorView.EVENTS;
            t.setVisible(!0), t.on(n.OPEN_TOUCHED, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (!e._touchEnabled) return;
                t.showMenu(), e.trigger(a.SOUL_STRIKE_SELECTOR_SHOWN)
            }), t.on(n.CLOSE_TOUCHED, function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (!e._touchEnabled) return;
                t.hideMenu(), e.trigger(a.SOUL_STRIKE_SELECTOR_HIDDEN)
            }), t.on(n.SLOT_SELECTED, function(t, r) {
                FF.logger.debug(n.SLOT_SELECTED, "soulStrikeInfo:", t, r);
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e._touchEnabled = !1, e.battleViewController.setCanStartPauseBySoulStrikeSelector(!0), e._executeTouchEndCallback(r)
            }), t.on(n.SLOT_TOUCH_START, function(t, n) {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e.battleViewController.setCanStartPauseBySoulStrikeSelector(!1)
            }), t.on(n.SLOT_TOUCH_CANCEL, function(t, n) {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (e._enabled === !1 || !e._touchEnabled) return;
                e.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
            }), t.hideAll()
        },
        _isSoulStrikeSelectorMode: function() {
            return this._soulStrikeCount > 1
        },
        setSoulStrikeInfo: function(e) {
            this._soulStrikeCount = e.length || 1;
            var t = !1;
            if (!this._isSoulStrikeSelectorMode()) this._setSoulStrikeInfo(e[0]);
            else {
                var n;
                for (n = 0; n < 4; n++) this._setSoulStrikeInfoToSlot(n + 1, e[n - (4 - this._soulStrikeCount)]);
                for (n = 0; n < this._soulStrikeCount; n++) {
                    var r = e[n];
                    if (r && r.enabled) {
                        t = !0;
                        break
                    }
                }
            }
            this.setSoulStrikeGauge(e[0].point, e[0].consumePoint), this._setCharaName(e[0]), t ? this.ssSelectorView.showOpenBtnEffect() : this.ssSelectorView.hideOpenBtnEffect(), this.flush()
        },
        isSoulStrikeSelectorShown: function() {
            return this.ssSelectorView.isShown()
        },
        isSoulStrikeSelectorMenuShown: function() {
            return this.ssSelectorView.isMenuShown()
        },
        resetMenuButtons: function() {
            this.ssSelectorView.resetMenuButtons()
        },
        isMenuUILocked: function() {
            return this.ssSelectorView.isUILocked()
        },
        _switchUI: function() {
            this._isSoulStrikeSelectorMode() ? (this.ssSelectorView.setVisible(!0), this.ab.buttonNode.setVisible(!1)) : (this.ssSelectorView.setVisible(!1), this.ab.buttonNode.setVisible(!0))
        },
        _setSoulStrikeInfoToSlot: function(e, t) {
            if (t) {
                var n = this.battleViewController.assetsManager.getAssetInfo(t.assetId);
                this.ssSelectorView.setSoulStrikeInfo(e, t, n)
            } else this.ssSelectorView.resetSoulStrikeInfo(e)
        },
        _setSoulStrikeInfo: function(e) {
            this.setSoulStrikeEnabled(e.enabled);
            if (e.charaAssetId === this._charaAssetId) return;
            var t = this.battleViewController.assetsManager.getAssetInfo(e.assetId),
                n = e.soulStrikeDispName ? e.soulStrikeDispName : e.soulStrikeName;
            this.ab.buttonNode.loadBundle(t.bundle).setImage("critical_btn_pos_img", t.assetPath), this.ab.textNode.setText("critical_name_txt", n), this._charaAssetId = e.charaAssetId
        },
        _setCharaName: function(e) {
            this.ab.charaTextNode.setText("chr_name_txt", e.charaName)
        },
        setSoulStrikeEnabled: function(e) {
            if (e === this._enabled) return;
            var t = e ? "enabled_special" : "disabled_special";
            this.ab.buttonNode.play(t).process(), this._enabled = e
        },
        showSoulStrikePanel: function() {
            this.ssSelectorView.hideOpenBtnEffect(), this.ssSelectorView.showAll(), this._switchUI()
        },
        hideSoulStrikePanelMenu: function() {
            this.ssSelectorView.hideMenu(), this.trigger(a.SOUL_STRIKE_SELECTOR_HIDDEN), this.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
        },
        hideSoulStrikePanel: function() {
            this.ssSelectorView.hideAll(), this.battleViewController.setCanStartPauseBySoulStrikeSelector(!0)
        },
        resetTag: function() {
            var e = this._enabled ? "enabled_special" : "disabled";
            this.ab.buttonNode.play(e).process(), this.ssSelectorView.resetTag()
        },
        setTouchEnabled: function(e) {
            this._touchEnabled = e
        },
        setTouchEnded: function(e) {
            this.touchEndedCallback = e;
            var t = this;
            this.ab.buttonTouchNode.addCallback("action_touch_ended", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t._touchEnabled = !1, t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_end").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPauseBySoulStrikeView(!0), t._executeTouchEndCallback()
                })
            }), this.ab.buttonTouchNode.addCallback("action_touch_began", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_start").process()
            }), this.ab.buttonTouchNode.addCallback("action_touch_enterd", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.battleViewController.setCanStartPauseBySoulStrikeView(!1), t.ab.buttonNode.play("command_special_tap_start").process()
            }), this.ab.buttonTouchNode.addCallback("action_touch_exited", function() {
                if (!u.DataConstructor.canOperateBattle()) return;
                if (t._enabled === !1 || !t._touchEnabled) return;
                t.ab.buttonNode.play("command_special_tap_cancel").processDeferred("action_stop").then(function() {
                    t.battleViewController.setCanStartPauseBySoulStrikeView(!0)
                })
            }), this.flush()
        },
        setSpecialPanelTouch: function(e) {
            this.touchEndedCallbackWithSlot = e
        },
        _executeTouchEndCallback: function(e) {
            e ? this.touchEndedCallbackWithSlot && this.touchEndedCallbackWithSlot(e.slot) : this.touchEndedCallback && this.touchEndedCallback()
        },
        setSoulStrikeGauge: function(e, t) {
            this.normalSoulStrikeGauge.setSoulStrikeGauge(e, t), this.selectorSoulStrikeGauge.setSoulStrikeGauge(e, t)
        },
        setGaugeCursor: function(e, t) {
            this.normalSoulStrikeGauge.setGaugeCursor(e, t), this.selectorSoulStrikeGauge.setGaugeCursor(e, t)
        },
        updateGaugeCursorVisible: function() {
            this.normalSoulStrikeGauge.setGaugeCursorVisible(!this._isSoulStrikeSelectorMode()), this.selectorSoulStrikeGauge.setGaugeCursorVisible(!this._isSoulStrikeSelectorMode())
        },
        setTouchVisible: function(e) {
            this.ab.buttonTouchNode.setVisible(e).process()
        },
        updateSoulStrikeGauge: function(e, t, n) {
            this.normalSoulStrikeGauge.updateSoulStrikeGauge(e, t, n), this.selectorSoulStrikeGauge.updateSoulStrikeGauge(e, t, n)
        },
        reset: function() {
            this._charaAssetId = void 0, this._enabled = void 0
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t), this.ssSelectorView && this.ssSelectorView.flush(), this.normalSoulStrikeGauge && this.normalSoulStrikeGauge.flush(), this.selectorSoulStrikeGauge && this.selectorSoulStrikeGauge.flush()
        },
        dispose: function() {
            this.ssSelectorView && this.ssSelectorView.dispose(), this.normalSoulStrikeGauge && this.normalSoulStrikeGauge.dispose(), this.selectorSoulStrikeGauge && this.selectorSoulStrikeGauge.dispose()
        }
    }), FF.ns.battle.view.SoulStrikeView.EVENTS = a, FF.ns.battle.view.SoulStrikeView
}), define("scenes/battle/view/SoulStrikeSelectorView", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = "command_special_tap_start",
        f = "command_special_tap_end",
        l = "command_special_tap_cancel",
        c = "command_special_tap_end_2",
        h = "enabled_special",
        p = "disabled_special",
        d = "disabled",
        v = "enabled_special_select",
        m = "disabled_special_select",
        g = "enabled_special_select_eff",
        y = "btn_critical_name_txt",
        b = "btn_critical_img",
        w = "btn_critical_backlight_img",
        E = "btn_critical_enabled_particle",
        S = "btn_critical_tap_particle",
        x = "btn_critical_tap_particle",
        T = "SoulStrikeSelectors",
        N = o.extend({
            initialize: function(e, t, n, i) {
                this.btnReplaceNode = t, this.index = e, this.btnParentNode = n;
                var o, c = this.btnReplaceNode.name + "_inserted",
                    h = u.BattleInfo.getInstance().isMo();
                h ? o = FF.ns.battle.mo.BattleLayerNames.ASSETS : o = this.btnReplaceNode.layer, this.mainNode = new r({
                    name: c,
                    layer: o,
                    duplicateFrom: "btn_critical",
                    duplicateFromOptions: {
                        visualParentLayer: h ? FF.ns.battle.mo.BattleLayerNames.FOOTER : o,
                        visualParentNode: this.btnReplaceNode.name
                    }
                }), this.btn = (new s(this.btnParentNode, void 0, T)).setButtonStateTags(a, f, l).setCheckEnabledFunction(i), this.backLightNode = (new r({
                    name: w,
                    layer: o,
                    topNodeName: c
                })).setVisible(!1).process(), this.imageNode = (new r({
                    name: b,
                    layer: o,
                    topNodeName: c
                })).setVisible(!1).process(), this.effectParticleNode = (new r({
                    name: E,
                    layer: o,
                    topNodeName: c
                })).setVisible(!0).process(), this.effectTapParticleNode = (new r({
                    name: S,
                    layer: o,
                    topNodeName: c
                })).setVisible(!0).process(), this.tapParticleNode = (new r({
                    name: x,
                    layer: o,
                    topNodeName: c
                })).setVisible(!0).process(), this._lastAssetPath = void 0, this._soulStrikeInfo = void 0, this._viewEnabled = void 0, this._buttonEnabled = void 0, this._hasView = void 0, this._particleVisible = void 0, this._updateButtonEnabled()
            },
            setBasicTouchHandlers: function(e, t, n, r) {
                return this.setTouchHandler(e), this.setTouchStartHandler(t), this.setTouchEnterHandler(n), this.setTouchCancelHandler(r), this
            },
            setTouchHandler: function(e) {
                var t = this;
                return this.btn.setTouchHandler(function() {
                    s.lockByGroupName(T), t.tapParticleNode.play(c).setVisible(!0).processDeferred("action_stop", {
                        tag: c
                    }).then(function() {
                        s.unlockByGroupName(T), e(t.index, t._soulStrikeInfo)
                    })
                }), this
            },
            setTouchEnterHandler: function(e) {
                var t = this;
                return this.btn.setTouchEnterHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setTouchStartHandler: function(e) {
                var t = this;
                return this.btn.setTouchStartHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setTouchCancelHandler: function(e) {
                var t = this;
                return this.btn.setTouchCancelHandler(function() {
                    e(t.index, t._soulStrikeInfo)
                }), this
            },
            setParticleVisible: function(e) {
                if (this._particleVisible === e) return;
                this._particleVisible = e, this.effectParticleNode.setVisible(this._particleVisible).process(), this.effectTapParticleNode.setVisible(this._particleVisible).process()
            },
            updateSlotView: function(e, t) {
                if (this._soulStrikeInfo === t) return;
                this._soulStrikeInfo = t;
                var n = this._soulStrikeInfo ? this._soulStrikeInfo.soulStrikeDispName : "";
                this.mainNode.setText(y, n, {
                    topNode: this.mainNode.name
                }).process();
                if (e === void 0) {
                    this._hasView = !1, this._lastAssetPath = void 0, this.backLightNode.setVisible(!1).process(), this.imageNode.setVisible(!1).process(), this._setViewEnabled(!1), this._updateButtonEnabled();
                    return
                }
                this._hasView = !0, this._setViewEnabled(this._soulStrikeInfo.enabled), this._updateButtonEnabled();
                if (this._lastAssetPath === e.assetPath) return;
                this.backLightNode.setVisible(!0).process(), this.imageNode.setVisible(!0).process(), this.mainNode.loadBundle(e.bundle).setImage(b, e.assetPath, {
                    topNode: this.mainNode.name
                }).setVisible(!0).process(), this._lastAssetPath = e.assetPath
            },
            _setViewEnabled: function(e) {
                if (e === this._viewEnabled) return;
                this._viewEnabled = e;
                var t = this._viewEnabled ? h : p;
                this.mainNode.play(t).process(), this._viewEnabled ? this.effectParticleNode.resumeParticle({
                    descendant: !0,
                    topNode: this.mainNode.name
                }).process() : this.effectParticleNode.suspendParticle({
                    effectParticleNode: !0,
                    topNode: this.mainNode.name
                }).process()
            },
            setButtonEnabled: function(e) {
                if (this._buttonEnabled === e) return;
                this._buttonEnabled = e, this._updateButtonEnabled()
            },
            _updateButtonEnabled: function() {
                var e = this._viewEnabled && this._hasView && this._buttonEnabled;
                this.btn.setEnabled(e)
            },
            resetTag: function() {
                var e = this._viewEnabled ? h : d;
                this.mainNode.play(e).process(), this._updateButtonEnabled()
            },
            dispose: function() {
                this.mainNode && this.mainNode.deleteNode(), this.mainNode = void 0, this.btn && this.btn.dispose(), this.btn = void 0
            }
        }),
        C = o.extend({
            _TAGS: {
                OUT: "command_change_out",
                IN: "command_change_in"
            },
            initialize: function(t, n) {
                var r = this,
                    i = C.EVENTS,
                    o = function(e) {
                        return u.DataConstructor.canOperateBattle()
                    },
                    c = function(e) {
                        return u.DataConstructor.canOperateBattle() && n.canStartPause()
                    };
                this.baseNode = t, this._isShown = void 0, this._isMenuShown = void 0, this._buttonEffectShown = void 0, this._soulStrikes = [], this._slots = [], this._currentTags = {}, this.ab = {}, this.ab.btnContainer = this.baseNode.createChildNode("critical_select").setVisible(!0), this.ab.open = this.baseNode.createChildNode("btn_critical_select_open").setVisible(!0), this.ab.close = this.baseNode.createChildNode("btn_critical_select_close").setVisible(!0), this.ab.openBtnEffects1 = this.baseNode.createChildNode("btn_critical_select_open_switch"), this.ab.openBtnEffects2 = this.baseNode.createChildNode("btn_critical_select_open_eff"), this.btnOpen = (new s(this.ab.open, this.baseNode.topNodeName, T)).setTouchHandler(e.bind(this._touchHandler, this)).setButtonStateTags(a, f, l).setCheckEnabledFunction(c), this.btnOpen.setLabelWithDetail(u.TextMaster.getInstance().get("B15250"), !0, "critical_name_txt_sample_01"), this.btnClose = (new s(this.ab.close, this.baseNode.topNodeName, T)).setTouchHandler(e.bind(this._touchHandler, this)).setButtonStateTags(a, f, l).setCheckEnabledFunction(o);
                var h = function(e, t) {
                        r.trigger(i.SLOT_SELECTED, e, t)
                    },
                    p = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_START, e, t)
                    },
                    d = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_START, e, t)
                    },
                    v = function(e, t) {
                        r.trigger(i.SLOT_TOUCH_CANCEL, e, t)
                    },
                    m = (new N(1, this.baseNode.createChildNode("btn_critical_pos_01"), this.baseNode.createChildNode("btn_critical_01"), o)).setBasicTouchHandlers(h, p, d, v),
                    g = (new N(2, this.baseNode.createChildNode("btn_critical_pos_02"), this.baseNode.createChildNode("btn_critical_02"), o)).setBasicTouchHandlers(h, p, d, v),
                    y = (new N(3, this.baseNode.createChildNode("btn_critical_pos_03"), this.baseNode.createChildNode("btn_critical_03"), o)).setBasicTouchHandlers(h, p, d, v),
                    b = (new N(4, this.baseNode.createChildNode("btn_critical_pos_04"), this.baseNode.createChildNode("btn_critical_04"), o)).setBasicTouchHandlers(h, p, d, v);
                this._slots[0] = m, this._slots[1] = g, this._slots[2] = y, this._slots[3] = b, this.hideAll()
            },
            _touchHandler: function(e) {
                var t = C.EVENTS;
                switch (e) {
                    case this.btnOpen:
                        FF.SoundMgr.playChooseEffect(), this.trigger(t.OPEN_TOUCHED);
                        break;
                    case this.btnClose:
                        FF.SoundMgr.playChooseEffect(), this.trigger(t.CLOSE_TOUCHED)
                }
            },
            setSoulStrikeInfo: function(e, t, n) {
                if (!e) return;
                this._soulStrikes[e - 1] = t, this._slots[e - 1].updateSlotView(n, t), this._updateAllParticleVisible(), this._updateButtonsEnabled()
            },
            resetSoulStrikeInfo: function(e) {
                if (!e) return;
                this._soulStrikes[e - 1] = void 0, this._slots[e - 1].updateSlotView(void 0, void 0), this._updateButtonsEnabled()
            },
            showOpenBtnEffect: function() {
                if (this._buttonEffectShown === !0) return;
                this._buttonEffectShown = !0, this.ab.openBtnEffects1.play(v).process(), this.ab.openBtnEffects2.play(g).process()
            },
            hideOpenBtnEffect: function() {
                if (this._buttonEffectShown === !1) return;
                this._buttonEffectShown = !1, this.ab.openBtnEffects1.play(m).process()
            },
            isShown: function() {
                return this._isShown === !0
            },
            isMenuShown: function() {
                return this._isMenuShown === !0
            },
            showAll: function() {
                if (this._isShown) return;
                return this._isShown = !0, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this._resetButtons(), this
            },
            hideAll: function() {
                if (this._isShown === !1) return;
                return this._isShown = !1, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this._resetButtons(), this
            },
            showMenu: function() {
                if (this._isMenuShown === !0) return;
                return this._isMenuShown = !0, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this
            },
            hideMenu: function() {
                if (!this._isMenuShown) return;
                return this._isMenuShown = !1, this._updateAnimation(), this._updateAllParticleVisible(), this._updateButtonsEnabled(), this
            },
            _updateAllParticleVisible: function(t) {
                t = t === void 0 ? this._isShown === !0 && this._isMenuShown === !0 : t, e.each(this._slots, function(e) {
                    e.setParticleVisible(t)
                })
            },
            _resetButtons: function() {
                s.unlockByGroupName(T)
            },
            _updateButtonsEnabled: function() {
                var t = this;
                this.btnOpen.setEnabled(this._isShown && !this._isMenuShown), this.btnClose.setEnabled(this._isShown && this._isMenuShown), e.each(this._slots, function(e) {
                    e.setButtonEnabled(t._isShown && t._isMenuShown)
                })
            },
            _updateAnimation: function() {
                this._isShown ? this._isMenuShown ? (this._playTag(this.ab.open, this._TAGS.OUT), this._playTag(this.ab.close, this._TAGS.IN), this._playTag(this.ab.btnContainer, this._TAGS.IN)) : (this._playTag(this.ab.open, this._TAGS.IN), this._playTag(this.ab.close, this._TAGS.OUT), this._playTag(this.ab.btnContainer, this._TAGS.OUT)) : (this._playTag(this.ab.open, this._TAGS.OUT), this._playTag(this.ab.close, this._TAGS.OUT), this._playTag(this.ab.btnContainer, this._TAGS.OUT)), this.flush()
            },
            _playTag: function(e, t) {
                if (this._currentTags[e.name] === t) return;
                this._currentTags[e.name] = t, e.play(t)
            },
            setVisible: function(e, t) {
                return this.ab.open.setVisible(e), this.ab.close.setVisible(e), this.ab.btnContainer.setVisible(e), (t || t === void 0) && this.flush(), this
            },
            resetTag: function() {
                e.each(this._slots, function(e) {
                    e.resetTag()
                })
            },
            resetMenuButtons: function() {
                e.each(s.getButtonsByGroupName(T), function(e) {
                    e.reset()
                })
            },
            isUILocked: function() {
                return s.isGroupLocked(T)
            },
            flush: function() {
                var t = [];
                e.each(this.ab, function(e) {
                    t = t.concat(e.stream), e.stream = []
                }), t.length && kickmotor.animation.processAnimation(t)
            },
            dispose: function() {
                this.ab = void 0, this._soulStrikes = void 0, e.each(this._slots, function(e) {
                    e.dispose()
                }), this._slots = void 0
            }
        }, {
            EVENTS: {
                SLOT_SELECTED: "slotSelected",
                SLOT_TOUCH_START: "slotTouchStart",
                SLOT_TOUCH_CANCEL: "slotTouchCancel",
                OPEN_TOUCHED: "openTouched",
                CLOSE_TOUCHED: "closeTouched"
            }
        });
    return FF.ns.battle.view.SoulStrikeSelectorView = C, C
}), define("scenes/battle/view/SoulStrikeGauge", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ab/ABNodeButton", "lib/EventBase", "lib/ClassBase"], function(e, t, n, r, i, s, o, u, a) {
    var f = FF.ns.battle,
        l = a.extend({
            initialize: function(e, t, n) {
                this.gaugeNodePattern = e, this.gaugeCursorNodePattern = t, this.gaugeAddNodePattern = n
            },
            getGaugeNodeName: function(e) {
                return r(this.gaugeNodePattern, e)
            },
            getGaugeCursorNodeName: function(e) {
                return this.gaugeCursorNodePattern ? r(this.gaugeCursorNodePattern, e) : ""
            },
            getGaugeAddNodeName: function(e) {
                return r(this.gaugeAddNodePattern, e)
            },
            hasGaugeCursorNode: function() {
                return !!this.gaugeCursorNodePattern
            }
        }),
        c = new l("critical_gauge_nul_%02d", "image_gauge_cursor_%02d", "image_gauge_bar_add_%02d"),
        h = new l("critical_select_gauge_nul_%02d", "", "image_gauge_bar_add_%02d_01"),
        p = {
            normal: c,
            selector: h
        },
        d = {
            LOOP_ANIM: "bar_light_loop",
            BASE_ANIM: "bar"
        };
    return FF.ns.battle.view.SoulStrikeGauge = a.extend({
        initialize: function(e, t) {
            var n = p[t] || c;
            this._soulStrikePoint = void 0, this._consumePoint = void 0, this.gaugeCursorVisible = !1, this.ab = {}, this.ab.gaugeNode1 = e.createChildNode(n.getGaugeNodeName(1)), this.ab.gaugeNode2 = e.createChildNode(n.getGaugeNodeName(2)), this.ab.gaugeNode3 = e.createChildNode(n.getGaugeNodeName(3)), n.hasGaugeCursorNode && (f.BattleInfo.getInstance().isMo() ? (this.ab.gaugeCursorNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeCursorNodeName(1), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            }), this.ab.gaugeCursorNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeCursorNodeName(2), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            }), this.ab.gaugeCursorNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeCursorNodeName(3), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            })) : (this.ab.gaugeCursorNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeCursorNodeName(1)), this.ab.gaugeCursorNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeCursorNodeName(2)), this.ab.gaugeCursorNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeCursorNodeName(3))), this.ab.gaugeCursorNode1.play(d.LOOP_ANIM, {
                loop: !0
            }), this.ab.gaugeCursorNode2.play(d.LOOP_ANIM, {
                loop: !0
            }), this.ab.gaugeCursorNode3.play(d.LOOP_ANIM, {
                loop: !0
            })), f.BattleInfo.getInstance().isMo() ? (this.ab.gaugeAddNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeAddNodeName(1), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            }), this.ab.gaugeAddNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeAddNodeName(2), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            }), this.ab.gaugeAddNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeAddNodeName(3), {
                layer: FF.ns.battle.mo.BattleLayerNames.FOOTER
            })) : (this.ab.gaugeAddNode1 = this.ab.gaugeNode1.createChildNode(n.getGaugeAddNodeName(1)), this.ab.gaugeAddNode2 = this.ab.gaugeNode2.createChildNode(n.getGaugeAddNodeName(2)), this.ab.gaugeAddNode3 = this.ab.gaugeNode3.createChildNode(n.getGaugeAddNodeName(3))), this.ab.gaugeAddNode1.play(d.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.ab.gaugeAddNode2.play(d.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.ab.gaugeAddNode3.play(d.LOOP_ANIM, {
                loop: !0
            }).setVisible(!1), this.flush()
        },
        setGaugeCursorVisible: function(e) {
            if (this.gaugeCursorVisible === e) return;
            this.gaugeCursorVisible = e, this.setGaugeCursor(this._consumePoint, !0)
        },
        setSoulStrikeGauge: function(e, t) {
            if (e === this._soulStrikePoint) return;
            var n = void 0,
                r = void 0,
                i = d.BASE_ANIM;
            e < 500 ? (n = r = Math.round(e / 500 * 100), this.ab.gaugeNode1.playFrame(i, n, r), this.ab.gaugeNode2.playFrame(i, 0, 0), this.ab.gaugeNode3.playFrame(i, 0, 0), this.ab.gaugeAddNode1.setVisible(!1), this.ab.gaugeAddNode2.setVisible(!1), this.ab.gaugeAddNode3.setVisible(!1)) : e < 1e3 ? (n = r = Math.round((e - 500) / 500 * 100), this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, n, r), this.ab.gaugeNode3.playFrame(i, 0, 0), e >= t && (this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!1), this.ab.gaugeAddNode3.setVisible(!1))) : e < 1500 ? (n = r = Math.round((e - 1e3) / 500 * 100), this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, 100, 100), this.ab.gaugeNode3.playFrame(i, n, r), e >= t && (this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!0), this.ab.gaugeAddNode3.setVisible(!1))) : (this.ab.gaugeNode1.playFrame(i, 100, 100), this.ab.gaugeNode2.playFrame(i, 100, 100), this.ab.gaugeNode3.playFrame(i, 100, 100), this.ab.gaugeAddNode1.setVisible(!0), this.ab.gaugeAddNode2.setVisible(!0), this.ab.gaugeAddNode3.setVisible(!0)), this.setGaugeCursor(t), this.flush(), this._soulStrikePoint = e
        },
        setGaugeCursor: function(e, t) {
            if (!this.ab.gaugeCursorNode1) return;
            if (!t && e === this._consumePoint) return;
            switch (e) {
                case 500:
                    this.ab.gaugeCursorNode1.setVisible(this.gaugeCursorVisible), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(!1);
                    break;
                case 1e3:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(this.gaugeCursorVisible), this.ab.gaugeCursorNode3.setVisible(!1);
                    break;
                case 1500:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(this.gaugeCursorVisible);
                    break;
                default:
                    this.ab.gaugeCursorNode1.setVisible(!1), this.ab.gaugeCursorNode2.setVisible(!1), this.ab.gaugeCursorNode3.setVisible(!1)
            }
            this._consumePoint = e
        },
        updateSoulStrikeGauge: function(e, t, n) {},
        reset: function() {
            this._soulStrikePoint = void 0, this._consumePoint = void 0
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.SoulStrikeGauge
}), define("scenes/battle/view/StatusAilmentsView", ["util", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = {
            INTERVAL: 1500,
            BALLOON_IDS: [r.Conf.STATUS_AILMENTS_TYPE.POISON, r.Conf.STATUS_AILMENTS_TYPE.SILENCE, r.Conf.STATUS_AILMENTS_TYPE.PARALYSIS, r.Conf.STATUS_AILMENTS_TYPE.CONFUSION, r.Conf.STATUS_AILMENTS_TYPE.STOP, r.Conf.STATUS_AILMENTS_TYPE.BLINDED, r.Conf.STATUS_AILMENTS_TYPE.SLEEP, r.Conf.STATUS_AILMENTS_TYPE.BERSERKER, r.Conf.STATUS_AILMENTS_TYPE.STAN, r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_AS_DISADVANTAGE],
            EXIST_BALLOON_ID: {}
        };
    _.each(i.BALLOON_IDS, function(e) {
        i.EXIST_BALLOON_ID[e] = !0
    }), i.AURA_TAG = {}, i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.HASTE] = "eff_light_haste", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SLOW] = "eff_light_slow", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PROTECT] = "eff_light_protect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SHELL] = "eff_light_shell", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MAGIC_CHARM] = "eff_light_shell", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REFLECTION] = "eff_light_reflect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN] = "eff_light_regene", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN_MIDDLE] = "eff_light_regene_3", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REGEN_STRONG] = {
        toBuddy: "eff_light_regene_2",
        toEnemy: "eff_light_regene"
    }, i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_40] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_60] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_80] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_100] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RERAISE_DEATH] = "eff_light_reraise", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SAP] = "eff_light_slip", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.INDOMITABLENESS] = "eff_light_invincible", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.REFLECTION_FULL_TIME] = "eff_light_reflect", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RAGE] = "eff_violent", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.GRAND_CROSS] = "eff_light_grandcross", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_200_3_CUSTOM_MAGIC_DAMAGE_ABILITIES] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_200_5_CUSTOM_MAGIC_DAMAGE_ABILITIES] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_200_4_CUSTOM_MAGIC_DAMAGE_ABILITIES] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_MAX_1_ALL] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_MAX_2_ALL] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_MAX_1_PHYSICAL_DAMAGE_ABILITIES] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_MAX_1_CUSTOM_MAGIC_DAMAGE_ABILITIES] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.CHANGE_CAST_TIME_200_4_ALL] = "eff_chant_short", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.EYE_POWER_CHARM] = "eff_light_special", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.HP_STOCK] = "eff_light_cure4", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.HP_STOCK_2000_25000] = "eff_light_cure4", i.AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.RADIANT_SHIELD] = "eff_reflect_damage", i.OVERLAY_AURA_TAG = {}, i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PYRAMID] = "eff_pyramid", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.PRISON_CAGE] = "eff_prison_cage", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.WATER_BALL] = "eff_water_ball", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.LOCK_ON] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.POSSESSION] = "eff_soulfire", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SWALLOWED] = "eff_swallow", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIGHTY_GUARD_1] = "eff_light_guard", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SUCTION] = "eff_vacuum", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ARM_CATCH] = "eff_restraint", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.TARGET_BUDDY] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ABYSS_WAVE_CANNON_LOCK_ON_1] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ABYSS_WAVE_CANNON_LOCK_ON_2] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ABYSS_WAVE_CANNON_LOCK_ON_3] = "eff_lock_on", i.OVERLAY_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.SWALLOWED_GEOSGAENO] = "eff_swallow", i.ELEMENTAL_AURA_TAG = {}, i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_WEAK] = "eff_thunder_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_MIDDLE] = "eff_thunder_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_LIGHTNING_STRONG] = "eff_thunder_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_WEAK] = "eff_fire_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_MIDDLE] = "eff_fire_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_FIRE_STRONG] = "eff_fire_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WIND_WEAK] = "eff_wind_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WIND_MIDDLE] = "eff_wind_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WIND_STRONG] = "eff_wind_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_EARTH_WEAK] = "eff_earth_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_EARTH_MIDDLE] = "eff_earth_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_EARTH_STRONG] = "eff_earth_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_DARK_WEAK] = "eff_dark_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_DARK_MIDDLE] = "eff_dark_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_DARK_STRONG] = "eff_dark_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_HOLY_WEAK] = "eff_st_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_HOLY_MIDDLE] = "eff_st_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_HOLY_STRONG] = "eff_st_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WATER_WEAK] = "eff_water_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WATER_MIDDLE] = "eff_water_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_WATER_STRONG] = "eff_water_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_ICE_WEAK] = "eff_ice_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_ICE_MIDDLE] = "eff_ice_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_ICE_STRONG] = "eff_ice_03", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_POISON_WEAK] = "eff_poison_01", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_POISON_MIDDLE] = "eff_poison_02", i.ELEMENTAL_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.ATTACH_ELEMENT_POISON_STRONG] = "eff_poison_03", i.BACK_AURA_TAG = {}, i.BACK_AURA_TAG[r.Conf.STATUS_AILMENTS_TYPE.MAGICAL_MINE] = "eff_light_guardian";
    var s = [r.Conf.STATUS_AILMENTS_TYPE.PROVOKE, r.Conf.STATUS_AILMENTS_TYPE.RUNIC, r.Conf.STATUS_AILMENTS_TYPE.RAID, r.Conf.STATUS_AILMENTS_TYPE.NON_DAMAGE, r.Conf.STATUS_AILMENTS_TYPE.CHARM];
    _.each(s, function(e) {
        i.AURA_TAG[e] = "eff_light_special"
    }), i.SPRITE_IDS = [r.Conf.STATUS_AILMENTS_TYPE.BLINDED, r.Conf.STATUS_AILMENTS_TYPE.SLEEP, r.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION, r.Conf.STATUS_AILMENTS_TYPE.WEAKENED, r.Conf.STATUS_AILMENTS_TYPE.MINIMUM, r.Conf.STATUS_AILMENTS_TYPE.TOAD, r.Conf.STATUS_AILMENTS_TYPE.ZOMBIE], i.BALLOON_TAGS = {
        "00": ["01", void 0],
        "01": ["02", "status_01_02"],
        "02": ["01", "status_02_01"]
    }, i.MIRAGE_TAG = {}, i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_1] = "eff_cloning_01", i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_2] = "eff_cloning_02", i.MIRAGE_TAG[r.Conf.STATUS_AILMENTS_TYPE.MIRAGE_3] = "eff_cloning_03", i.TRANCE_TAG = {}, i.TRANCE_TAG[r.Conf.STATUS_AILMENTS_TYPE.TRANCE] = {
        show: "eff_burst_special",
        close: "eff_burst_special_close"
    }, i.NONRESIDENT_BACK_AURA_CONF = [
        [{
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.GREASED_LIGHTNING_1],
            asset: "nonresident_status_eff_greased_lightning",
            tag: "eff_greased_lightning_1"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.GREASED_LIGHTNING_2],
            asset: "nonresident_status_eff_greased_lightning",
            tag: "eff_greased_lightning_2"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.GREASED_LIGHTNING_3],
            asset: "nonresident_status_eff_greased_lightning",
            tag: "eff_greased_lightning_3"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.SUMMONING],
            asset: "nonresident_status_eff_summoning",
            tag: "eff_summoning"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.BLACK_DRAGON_SUMMONING],
            asset: "nonresident_status_eff_summoning",
            tag: "eff_summoning"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.THUNDER_GOD_MODE],
            asset: "nonresident_status_eff_thunder",
            tag: "eff_thunder"
        }],
        [{
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.ABYSS_NEKURO_DOOM_ATK],
            asset: "nonresident_status_eff_necrophobia",
            tag: "eff_death_atk"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.ABYSS_NEKURO_DOOM_MATK],
            asset: "nonresident_status_eff_necrophobia",
            tag: "eff_death_matk"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.ABYSS_NEKURO_DOOM_DEF],
            asset: "nonresident_status_eff_necrophobia",
            tag: "eff_death_def"
        }, {
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.ABYSS_NEKURO_DOOM_MDEF],
            asset: "nonresident_status_eff_necrophobia",
            tag: "eff_death_mdef"
        }]
    ], i.NONRESIDENT_FRONT_AURA_CONF = [
        [{
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.WILD_MODE],
            asset: "nonresident_status_eff_wild_mode",
            tag: "eff_elan"
        }],
        [{
            saIds: [r.Conf.STATUS_AILMENTS_TYPE.DAMAGE_BARRIER_30],
            asset: "damage_barrier",
            tag: "eff_shield"
        }]
    ], FF.ns.battle.view.StatusAilmentsView = n.extend({
        initialize: function(e) {
            this._actorView = e, this._initializeParam()
        },
        _initializeParam: function() {
            this._balloon = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                no: "00"
            }, this._aura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0,
                isAnimating: !1
            }, this._overlayAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0,
                isAnimating: !1
            }, this._elementalAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0,
                isAnimating: !1
            }, this._backAura = {
                idx: 0,
                prevSa: void 0,
                elapsedTime: 0,
                tag: void 0,
                isAnimating: !1
            }, this._timer = {
                count: 0,
                isClosed: !0
            }, this._mirage = {
                tag: void 0
            }, this._trance = {
                prevSa: void 0,
                tag: void 0
            }, this._statusBonusPartsBuddy = {
                visibles: []
            };
            var t = {
                idx: 0,
                prevConfIdx: void 0,
                elapsedTime: 0,
                conf: void 0,
                isAnimating: !1
            };
            this._nonresidentBackAura = _.map(i.NONRESIDENT_BACK_AURA_CONF, function() {
                return e.cloneDeep(t)
            }), this._nonresidentFrontAura = _.map(i.NONRESIDENT_FRONT_AURA_CONF, function() {
                return e.cloneDeep(t)
            })
        },
        update: function(e) {
            this._updateBalloon(e), this._updateTimer(e), this._updateAura(e), this._updateOverlayAura(e), this._updateElementalAura(e), this._updateBackAura(e), this._updateSprite(e), this._updateMirage(e), this._updateTrance(e), this._updateNonresidentBackAura(e), this._updateNonresidentFrontAura(e), this._updateStatusBonusPartsBuddy(e)
        },
        _updateAura: function(e) {
            var t = this,
                n = e.statusAilments;
            this._aura.elapsedTime += FF.scene.elapsedTime;
            if (this._aura.isAnimating) return;
            var r = _.filter(n, function(n) {
                return t._getAuraTagBySa(n, e)
            });
            this._aura.elapsedTime >= i.INTERVAL && this._aura.idx++, this._aura.idx >= r.length && (this._aura.idx = 0);
            var s = r[this._aura.idx];
            if (s !== this._aura.prevSa) {
                var o = this._getAuraTagBySa(s, e);
                this.showStatusAilmentsAura(o), this._aura.elapsedTime = 0, this._aura.prevSa = s
            }
        },
        _getAuraTagBySa: function(e, t) {
            var n = e ? i.AURA_TAG[e] : void 0;
            if (!n) return void 0;
            if (_.isString(n)) return n;
            if (_.isObject(n)) return t.isBuddy && !!n.toBuddy ? n.toBuddy : t.isEnemy && !!n.toEnemy ? n.toEnemy : void 0;
            throw new Error("undefined aura tag with sa: " + e)
        },
        showStatusAilmentsAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._aura.tag === e) return;
            this._aura.tag = e, this._aura.isAnimating = !0, n.ab.statusAilmentsAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsAura.play(e), n.ab.colorChangeNode.play(e, {
                    isPlayChild: !1
                }), n.ab.colorChangeAddNode.play(e, {
                    isPlayChild: !1
                }), n.ab.leftArmColorChangeNode && (n.ab.leftArmColorChangeNode.play(e, {
                    isPlayChild: !1
                }), n.ab.leftArmColorChangeAddNode.play(e, {
                    isPlayChild: !1
                })), n.flush(), t._aura.isAnimating = !1
            })
        },
        _updateOverlayAura: function(e) {
            var t = e.statusAilments;
            this._overlayAura.elapsedTime += FF.scene.elapsedTime;
            if (this._overlayAura.isAnimating) return;
            var n = _.filter(t, function(e) {
                return i.OVERLAY_AURA_TAG[e]
            });
            this._overlayAura.elapsedTime >= i.INTERVAL && this._overlayAura.idx++, this._overlayAura.idx >= n.length && (this._overlayAura.idx = 0);
            var r = n[this._overlayAura.idx];
            if (r !== this._overlayAura.prevSa) {
                var s = r ? i.OVERLAY_AURA_TAG[r] : void 0;
                this.showStatusAilmentsOverlayAura(s), this._overlayAura.elapsedTime = 0, this._overlayAura.prevSa = r
            }
        },
        _updateBackAura: function(e) {
            var t = this._actorView;
            if (!t.ab.statusAilmentsBackAura) return;
            var n = e.statusAilments,
                r = this._backAura,
                s = _.filter(n, function(e) {
                    return i.BACK_AURA_TAG[e]
                });
            r.elapsedTime += FF.scene.elapsedTime;
            if (r.isAnimating) return;
            r.elapsedTime >= i.INTERVAL && r.idx++, r.idx >= s.length && (r.idx = 0);
            var o = s[r.idx];
            if (o !== r.prevSa) {
                var u = o ? i.BACK_AURA_TAG[o] : void 0;
                this.showStatusAilmentsBackAura(u), r.elapsedTime = 0, r.prevSa = o
            }
        },
        showStatusAilmentsOverlayAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._overlayAura.tag === e) return;
            this._overlayAura.tag = e, this._overlayAura.isAnimating = !0, n.ab.statusAilmentsOverlayAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsOverlayAura.play(e), n.flush(), t._overlayAura.isAnimating = !1
            })
        },
        _updateElementalAura: function(e) {
            var t = e.statusAilments,
                n = _.filter(t, function(e) {
                    return i.ELEMENTAL_AURA_TAG[e]
                });
            this._elementalAura.elapsedTime += FF.scene.elapsedTime;
            if (this._elementalAura.isAnimating) return;
            this._elementalAura.elapsedTime >= i.INTERVAL && this._elementalAura.idx++, this._elementalAura.idx >= n.length && (this._elementalAura.idx = 0);
            var r = n[this._elementalAura.idx];
            if (r !== this._elementalAura.prevSa) {
                var s = r ? i.ELEMENTAL_AURA_TAG[r] : void 0;
                this.showStatusAilmentsElementalAura(s), this._elementalAura.elapsedTime = 0, this._elementalAura.prevSa = r
            }
        },
        showStatusAilmentsElementalAura: function(e) {
            var t = this,
                n = this._actorView;
            e || (e = "stop");
            if (this._elementalAura.tag === e) return;
            this._elementalAura.tag = e, this._elementalAura.isAnimating = !0, n.ab.statusAilmentsElementalAura.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.ab.statusAilmentsElementalAura.play(e), n.flush(), t._elementalAura.isAnimating = !1
            })
        },
        showStatusAilmentsBackAura: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsBackAura,
                r = this._backAura;
            e || (e = "stop");
            if (r.tag === e) return;
            r.tag = e, r.isAnimating = !0, n.play("stop").processDeferred("action_stop").then(function() {
                e !== "stop" && n.play(e), t.flush(), r.isAnimating = !1
            })
        },
        _updateBalloon: function(e) {
            var t = e.statusAilments;
            this._balloon.elapsedTime += FF.scene.elapsedTime;
            var n = _.filter(t, function(e) {
                return i.EXIST_BALLOON_ID[e]
            });
            this._balloon.elapsedTime >= i.INTERVAL && this._balloon.idx++, this._balloon.idx >= n.length && (this._balloon.idx = 0);
            var r = n[this._balloon.idx];
            if (r !== this._balloon.prevSa) {
                var s = r ? sprintf("status_icon_%s", r) : void 0;
                this.showStatusAilmentsBalloon(s), this._balloon.elapsedTime = 0, this._balloon.prevSa = r
            }
        },
        showStatusAilmentsBalloon: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsBalloon;
            if (!e) {
                if (this._balloon.no === "00") return;
                this._balloon.no = "00", n.play("status_close").process();
                return
            }
            var r = this._balloon.no,
                s = i.BALLOON_TAGS[r][0],
                o = i.BALLOON_TAGS[r][1],
                u = t.battleViewController.assetsManager.getAssetInfo(e);
            r === "00" ? n.loadBundle(u.bundle).setImage(sprintf("status_icon_img_%s", s), u.assetPath).play("status_open").process() : (n.loadBundle(u.bundle).setImage(sprintf("status_icon_img_%s", s), u.assetPath).process(), n.createVirtualNode("status_icon_anm_nul").play(o).process()), this._balloon.no = s
        },
        _updateTimer: function(e) {
            var t = e.statusAilments,
                n = -1;
            e.isCount && (n = _.max([e.count, 0]));
            if (this._timer.count !== n) {
                var r = n >= 0 ? sprintf("%02d", n) : void 0;
                this.showStatusAilmentsTimer(r), this._timer.count = n
            }
        },
        showStatusAilmentsTimer: function(e) {
            var t = this._actorView,
                n = t.ab.statusAilmentsDoom;
            e ? (n.setText("death_num_txt", e), this._timer.isClosed && (n.setVisible(!0).play("status_open"), this._timer.isClosed = !1)) : (n.play("status_close"), this._timer.isClosed = !0), n.process()
        },
        _updateSprite: function(e) {
            var t = e.statusAilments,
                n = _.filter(t, function(e) {
                    return _.contains(i.SPRITE_IDS, e)
                }),
                r = n[0];
            this.showStatusAilmentsSprite(r)
        },
        showStatusAilmentsSprite: function(e) {
            var t = this._actorView;
            if (!t.baseSpriteId) return;
            if (e) {
                var n = sprintf("%s_%d", t.baseSpriteId, e);
                t.setSprite(n)
            } else t.setSprite(t.baseSpriteId);
            t.flush()
        },
        _updateMirage: function(e) {
            var t = _.find(e.statusAilments, function(e) {
                    return !!i.MIRAGE_TAG[e]
                }),
                n = i.MIRAGE_TAG[t] || void 0;
            this._mirage.tag !== n && this.showStatusAilmentsMirage(n), this._mirage.tag = n
        },
        showStatusAilmentsMirage: function(e) {
            var t = this._actorView.ab.statusAilmentsMirage;
            e ? t.setVisible(!0).play(e) : t.setVisible(!1).play("stop"), t.process()
        },
        _updateTrance: function(e) {
            var t = e.statusAilments,
                n = _.find(e.statusAilments, function(e) {
                    return !!i.TRANCE_TAG[e]
                }),
                r = i.TRANCE_TAG[n] || void 0,
                s = i.TRANCE_TAG[this._trance.prevSa] || void 0;
            !r || !!s && s.show === this._trance.tag ? !r && !!s && s.show === this._trance.tag ? this.showStatusAilmentsTrance(s.close, {
                shouldCreateIfNotExists: !0
            }) : !r && !!s && s.close === this._trance.tag && (this._trance.prevSa = void 0, this._trance.tag = void 0) : (this.showStatusAilmentsTrance(r.show, {
                shouldCreateIfNotExists: !0
            }), this._trance.prevSa = n), !this._actorView.ab.statusAilmentsTranceAura || (r ? this._statusBonusPartsBuddy.visibles.push(!1) : this._statusBonusPartsBuddy.visibles.push(!0))
        },
        showStatusAilmentsTrance: function(e, t) {
            t = t || {};
            var n = this._actorView.getStatusAilmentsTranceAura(t);
            if (!n) return;
            e ? n.setVisible(!0).play(e) : n.setVisible(!1).play("stop"), n.process(), this._trance.tag = e
        },
        _updateNonresidentBackAura: function(e) {
            _.each(i.NONRESIDENT_BACK_AURA_CONF, function(t, n) {
                this.__updateNonresidentAura({
                    info: e,
                    auraInfo: this._nonresidentBackAura[n],
                    auraConfs: t,
                    showStatusAilments: function(e, t) {
                        this._showStatusAilmentsNonresidentBackAuraByConfIdx(n, e, t)
                    }
                })
            }, this)
        },
        showStatusAilmentsNonresidentBackAura: function() {
            _.each(i.NONRESIDENT_BACK_AURA_CONF, function(e, t) {
                this._showStatusAilmentsNonresidentBackAuraByConfIdx(t)
            }, this)
        },
        _showStatusAilmentsNonresidentBackAuraByConfIdx: function(e, t, n) {
            var i = r.Config.getInstance().get("StatusAilments", "Z_ORDER");
            this._showStatusAilmentsNonresidentAura({
                auraInfo: this._nonresidentBackAura[e],
                auraConf: t,
                abFunc: this._actorView.getStatusAilmentsNonresidentBackAura,
                abOptions: _.extend({
                    zOrder: i.NONRESIDENT_AURA_MIN + e
                }, n)
            })
        },
        _updateNonresidentFrontAura: function(e) {
            _.each(i.NONRESIDENT_FRONT_AURA_CONF, function(t, n) {
                this.__updateNonresidentAura({
                    info: e,
                    auraInfo: this._nonresidentFrontAura[n],
                    auraConfs: t,
                    showStatusAilments: function(e, t) {
                        this._showStatusAilmentsNonresidentFrontAuraByConfIdx(n, e, t)
                    }
                })
            }, this)
        },
        showStatusAilmentsNonresidentFrontAura: function() {
            _.each(i.NONRESIDENT_FRONT_AURA_CONF, function(e, t) {
                this._showStatusAilmentsNonresidentFrontAuraByConfIdx(t)
            }, this)
        },
        _showStatusAilmentsNonresidentFrontAuraByConfIdx: function(e, t, n) {
            var i = r.Config.getInstance().get("StatusAilments", "Z_ORDER");
            this._showStatusAilmentsNonresidentAura({
                auraInfo: this._nonresidentFrontAura[e],
                auraConf: t,
                abFunc: this._actorView.getStatusAilmentsNonresidentFrontAura,
                abOptions: _.extend({
                    zOrder: i.NONRESIDENT_AURA_MIN + e
                }, n)
            })
        },
        __updateNonresidentAura: function(e) {
            var t = e.info,
                n = e.auraInfo,
                r = e.auraConfs,
                s = e.showStatusAilments,
                o = t.statusAilments;
            n.elapsedTime += FF.scene.elapsedTime;
            var u = _.filter(_.range(r.length), function(e) {
                return 0 < _.intersection(r[e].saIds, o).length
            });
            if (n.isAnimating) return;
            n.elapsedTime >= i.INTERVAL && n.idx++, n.idx >= u.length && (n.idx = 0);
            var a = u[n.idx];
            if (a !== n.prevConfIdx) {
                var f = _.isUndefined(a) ? void 0 : r[a];
                s.call(this, f, {
                    shouldCreateIfNotExists: !0
                }), n.elapsedTime = 0, n.prevConfIdx = a
            }
        },
        _showStatusAilmentsNonresidentAura: function(e) {
            var t = e.auraInfo,
                n = e.auraConf,
                r = e.abFunc,
                i = e.abOptions || {},
                s = this._actorView,
                o = t.conf,
                u = n;
            if (o && u && o.asset === u.asset && o.tag === u.tag) return;
            t.conf = u, t.isAnimating = !0, $.Deferred().resolve().promise().then(function() {
                if (o) {
                    var e = r.call(s, o.asset, i);
                    return e.play("stop").processDeferred("action_stop")
                }
                return $.Deferred().resolve().promise()
            }).then(function() {
                if (u) {
                    var e = r.call(s, u.asset, i);
                    e && (e.play(u.tag), s.flush())
                }
                t.isAnimating = !1
            })
        },
        _updateStatusBonusPartsBuddy: function(e) {
            if (!!e.isDead) return;
            var t = this._statusBonusPartsBuddy.visibles.length;
            if (t === 0) return;
            var n = _.all(this._statusBonusPartsBuddy.visibles);
            n ? this._actorView.setStatusBonusBuddyVisible(!0) : this._actorView.setStatusBonusBuddyVisible(!1), this._statusBonusPartsBuddy.visibles.splice(0, t)
        },
        dispose: function() {
            this._actorView = void 0
        },
        reset: function() {
            this.showStatusAilmentsAura(), this.showStatusAilmentsBalloon(), this.showStatusAilmentsTimer(), this.showStatusAilmentsMirage(), this.showStatusAilmentsOverlayAura(), this.showStatusAilmentsElementalAura(), this.showStatusAilmentsBackAura(), this.showStatusAilmentsTrance(), this.showStatusAilmentsNonresidentBackAura(), this.showStatusAilmentsNonresidentFrontAura(), this._initializeParam()
        },
        resetForDead: function() {
            this.reset()
        }
    })
}), define("scenes/battle/view/ContinueBonusView", ["underscore", "jquery", "util", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = ["01", "02", "03", "04"],
        f = ["01", "02", "03", "04", "05"],
        l = {
            CARD: "cardNode%s",
            CHARA: "charaNode%s",
            BASE_CHARA: "baseCharaNode%s"
        };
    return FF.ns.battle.view.ContinueBonusView = o.extend({
        initialize: function(t) {
            FF.logger.debug("ContinueBonusView: initialize"), this.battleViewController = t.battleViewController, this.windowNode = t.windowNode, this.menuLayerInfo = t.menuLayerInfo, this._isSelected = !1, this.ab = {};
            var n = this.windowNode.createChildNode("mogu_nul"),
                i = n.createChildNode("mogu_position_nul"),
                s = i.createChildNode("mogu_anm_nul");
            this.ab.moguPosNode = i, this.ab.moguAnmNode = s;
            var o = this.windowNode.createChildNode("chara_group_nul");
            e.each(f, function(e) {
                var t = r(l.BASE_CHARA, e),
                    n = r("chara_nul_%s", e);
                this.ab[t] = o.createChildNode(n)
            }, this), this.ab.charaGroupNode = o, this.flush()
        },
        setup: function() {
            this._setupBuddies(), this._setupCard()
        },
        showPreRaise: function() {
            this.setBaseCharaVisible(!1), this._showBuddiesDead(), this._showCardsInit(), this.ab.moguAnmNode.play("mogu_idle"), this.flush()
        },
        showPostRaise: function() {
            var e = u.DataConstructor.getBattleBgm();
            FF.SoundMgr.playMusic(e), this.showBuddiesHandsUp(), this._showPostAura()
        },
        _setupCard: function() {
            var t = this;
            e.each(a, function(e, n) {
                var s = r("cardNode%s", e);
                if (t.ab[s]) return;
                var o = (new i({
                    name: r("continue_bonus_card_%s", e),
                    layer: t.menuLayerInfo.layerName,
                    touchNodeName: "card_touch",
                    duplicateFrom: "card_nul",
                    duplicateFromOptions: {
                        visualParentLayer: t.menuLayerInfo.layerName,
                        visualParentNode: r("card_pos_nul_%s", e),
                        visualParentTopNode: t.windowNode.name
                    }
                })).setVisible(!0);
                t.ab[s] = o
            }), this.flush()
        },
        _showCardsInit: function() {
            var t = this;
            e.each(a, function(e, n) {
                var i = t.ab[r("cardNode%s", e)];
                i.play("reset"), t._isSelected = !1
            }), this.flush()
        },
        _setCardImage: function(t) {
            var n = this;
            e.each(a, function(e, i) {
                var s = n.ab[r("cardNode%s", e)],
                    o = u.Config.getInstance().get("ContinueBonus", t[i], "cardImageId"),
                    a = n.battleViewController.assetsManager.getAssetInfo(o);
                s.loadBundle(a.bundle).setImage("card_img", a.assetPath)
            }), this.flush()
        },
        registerCardTouch: function(i, s) {
            var o = this;
            e.each(a, function(f, c) {
                var h = o.ab[r(l.CARD, f)];
                h.addCallback("action_touch_ended", function() {
                    if (o._isSelected) return;
                    o._isSelected = !0;
                    var p = e.shuffle(n.cloneDeep(u.Config.getInstance().get("ContinueBonusIds"))),
                        d = p[c],
                        v = t.Deferred();
                    i(d, v), v.promise().then(function() {
                        o._setCardImage(p);
                        var e = r("mogu_pos_%d", c + 1);
                        return o.ab.moguPosNode.play(e, {
                            isPlayChild: !1
                        }).processDeferred("action_stop")
                    }).then(function() {
                        return o.ab.moguAnmNode.play("mogu_selected").processDeferred("action_stop"), h.play("card_open").processDeferred("action_stop")
                    }).then(function() {
                        var n = [];
                        return e.each(e.without(a, f), function(e) {
                            var t = o.ab[r(l.CARD, e)];
                            n.push(t.play("card_open").processDeferred("action_stop"))
                        }), t.when.apply(t, n)
                    }).then(function() {
                        e.each(a, function(e) {
                            o.ab[r(l.CARD, e)].removeAllCallback()
                        }), o.flush(), s(d)
                    })
                })
            }), this.flush()
        },
        _setupBuddies: function() {
            var t = this,
                n = this.battleViewController.assetsManager.getAssetInfo("player_common");
            e.each(u.DataConstructor.loadBuddyDrawInfo(), function(e) {
                var t = e.posId,
                    s = r(l.CHARA, t);
                if (this.ab[s]) return;
                var o = r("continue_bonus_chara_%s", t),
                    u = (new i({
                        name: o,
                        layer: n.layerName,
                        duplicateFrom: "character_nul",
                        duplicateFromOptions: {
                            visualParentLayer: this.menuLayerInfo.layerName,
                            visualParentNode: r("chara_pos_nul_%s", t),
                            visualParentTopNode: this.windowNode.name
                        }
                    })).setParam({
                        color_change_parent: o
                    }),
                    a = r("buddy-%s", e.buddyAnimationInfo.path),
                    f = this.battleViewController.assetsManager.getAssetInfo(a);
                u.loadBundle(f.bundle).setSpriteAnimeByNode("sprite_character_base", f.assetPath).setSpriteAnimeByNode("sprite_character_add", f.assetPath), this.ab[s] = u
            }, this), this.flush()
        },
        _showBuddiesDead: function() {
            this._showBuddies("dead")
        },
        showBuddiesHandsUp: function() {
            this._showBuddies("hands_up")
        },
        _showPostAura: function() {
            this.ab.charaGroupNode.play("continue_resume"), this.flush()
        },
        _showBuddies: function(t) {
            e.each(u.DataConstructor.loadBuddyDrawInfo(), function(e) {
                var n = e.posId,
                    i = r("charaNode%s", n),
                    s = r(l.BASE_CHARA, n);
                this.ab[i].play(t), this.ab[s].setVisible(!0)
            }, this), this.flush()
        },
        setBaseCharaVisible: function(t) {
            var n = this;
            e.each(f, function(e) {
                n.ab[r(l.BASE_CHARA, e)].setVisible(t)
            }), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        deleteNodes: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.ab = {}
        },
        dispose: function() {
            FF.logger.debug("ContinueBonusView: dispose")
        }
    }), FF.ns.battle.view.ContinueBonusView
}), define("scenes/battle/view/TargetArrowView", ["underscore", "jquery", "sprintf", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    return FF.ns.battle.view.TargetArrowView = i.extend({
        initialize: function(e) {
            this.battleViewController = e.battleViewController, this.ab = {};
            var t = this.battleViewController.battleLayer;
            this.ab.scaleNode = t.createNode("target_arrow_scale_nul"), this.ab.arrowNode = this.ab.scaleNode.createChildNode("target_arrow_nul"), this._isOpening = !1, this._selectorUid = void 0, this._targetUid = void 0
        },
        open: function(e, n) {
            var r = this,
                i = e.getUid(),
                s = n.getUid();
            if (i === s) {
                this.close();
                return
            }
            if (i === this._targetUid) return;
            var o = !this.isOpening();
            t.when(e.getTargetPositionDeferred(), n.getTargetPositionDeferred()).done(function(e, t) {
                var n = [t[0], t[1] + 10];
                (!this._selectorUid || this._selectorUid !== s) && r.ab.scaleNode.setPosition(n).setVisible(!0);
                var i = r._calculateDegree(n, e);
                FF.logger.debug("targetArrow info: ", "correctSelectorPos", n, "targetPos", e, "degree", i), r.ab.arrowNode.setRot(i), o && r.ab.arrowNode.play("arrow_open"), r.flush()
            }).fail(function(e) {
                throw new Error("fail to open target arrow. " + JSON.stringify(e))
            }), this._isOpening = !0, this._targetUid = i, this._selectorUid = s
        },
        _calculateDegree: function(e, t) {
            var n = t[0] - e[0],
                r = t[1] - e[1],
                i = Math.round(Math.atan2(r, n) / (Math.PI / 180));
            return i -= 180, i
        },
        close: function() {
            if (!this.isOpening()) return;
            this._playCloseDeferred(), this._isOpening = !1, this._selectorUid = void 0, this._targetUid = void 0
        },
        closeDeferred: function() {
            var e = this;
            return this.isOpening() ? this._playCloseDeferred().then(function() {
                e._isOpening = !1, e._selectorUid = void 0, e._targetUid = void 0
            }) : t.Deferred().resolve().promise()
        },
        _playCloseDeferred: function() {
            var e = this;
            return this.ab.arrowNode.play("arrow_close").processDeferred("action_stop").then(function() {
                e.ab.scaleNode.setVisible(!1), e.flush()
            })
        },
        isOpening: function() {
            return this._isOpening
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {}
    }), FF.ns.battle.view.TargetArrowView
}), define("scenes/battle/view/TutorialBattleView", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    var o = FF.ns.battle;
    FF.ns.battle.view.TutorialBattleView = s.extend({
        initialize: function(e) {
            var t = this;
            this.battleViewController = e.battleViewController, this.ab = {}
        },
        setup: function(e) {
            var t = {
                    battle1: {
                        battleId: "tutorial_battle_1",
                        msgBattleId: "tutorial_msg_battle_1"
                    }
                },
                n = t[e],
                r = this.battleViewController.battleLayer,
                s = this.battleViewController.assetsManager.getAssetInfo(n.battleId);
            this.ab.indicatorNode = (new i({
                name: "tutorial_nul",
                layer: s.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r.layerName
                }
            })).play("reset"), s = this.battleViewController.assetsManager.getAssetInfo(n.msgBattleId), this.ab.tutorNode = (new i({
                name: "tutorial_msg_nul",
                layer: s.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: r.layerName
                }
            })).play("reset"), this.flush()
        },
        playDeferred: function(e, n, r, i) {
            var s = void 0,
                o = void 0;
            return e && (s = {
                action: e,
                messageId: n
            }), r && (o = {
                action: r,
                frameNo: i
            }), t.when(this.playTutorDeferred(s), this.playIndicatorDeferred(o))
        },
        playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (!e) return r.resolve().promise();
            var i = void 0;
            e.messageId && (i = o.TextMaster.getInstance().get(e.messageId));
            switch (e.action) {
                case "IN":
                    i && this.ab.tutorNode.setText("main_txt", i), this.ab.tutorNode.play("in").processDeferred("action_stop").then(function() {
                        n.ab.tutorNode.play("loop"), n.flush(), r.resolve()
                    });
                    break;
                case "SAY":
                    i && this.ab.tutorNode.setText("main_txt", i), this.ab.tutorNode.play("tap").processDeferred("action_stop").then(function() {
                        n.ab.tutorNode.play("loop"), n.flush(), r.resolve()
                    }), this.flush();
                    break;
                case "OUT":
                    this.ab.tutorNode.play("out").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                case "RESET":
                    this.ab.tutorNode.play("reset").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return r.promise()
        },
        playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            if (!e) return n.resolve().promise();
            switch (e.action) {
                case "PLAY":
                    this._playByFrameNoDeferred(e.frameNo).then(function() {
                        n.resolve()
                    });
                    break;
                case "RESET":
                    this.ab.indicatorNode.play("reset").processDeferred("action_stop").then(function() {
                        n.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return n.promise()
        },
        _playByFrameNoDeferred: function(e) {
            var n = this,
                i = t.Deferred(),
                s = r("play_%s", e),
                o = r("loop_%s", e);
            return this.ab.indicatorNode.play(s).processDeferred("action_stop").then(function() {
                n.ab.indicatorNode.play(o), n.flush(), i.resolve()
            }), this.flush(), i.promise()
        },
        setVisible: function(e) {
            this.ab.tutorNode.setVisible(e), this.ab.indicatorNode.setVisible(e), this.flush()
        },
        showSupporterSoulStrikePanel: function() {
            var e = o.DataConstructor.getSupporterSoulStrikeInfo(),
                t = this.battleViewController.supporterViewController;
            t.supporterButtonInDeferred(e)
        },
        hideSupporterSoulStrikePanel: function() {
            var e = this.battleViewController.supporterViewController;
            e.supporterButtonOutDeferred()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            FF.logger.debug("TutorialView: dispose"), e.each(this.ab, function(e) {
                e.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/AnimationBase", ["underscore", "lib/EventBase", "util"], function(e, t, n) {
    var r = FF.ns.battle;
    return FF.ns.battle.view.animation.AnimationBase = t.extend({
        initialize: function(e, n) {
            t.prototype.initialize.apply(this, arguments), this.viewController = n, this.data = e, this.animatingActorInfoArray = [], this._isInLongAction = this.data.abilityInfo && this.data.abilityInfo.isInLongAction
        },
        play: function() {
            this.viewController.isAnimating, this.viewController.isAnimating = !0, r.BattleInfo.getInstance().isMo() && this._isInLongAction && this.viewController.setIsInLongAction(!0);
            var t = this.data.executerInfo;
            t && this.animatingActorInfoArray.push(t);
            var n = this.data.receiverInfo;
            if (e.isArray(n)) {
                var i = e.flatten(n);
                this.animatingActorInfoArray = this.animatingActorInfoArray.concat(i)
            }
            return e.each(this.animatingActorInfoArray, function(e) {
                this.viewController.getActorViewByActorInfo(e).registerIsInAnimation()
            }, this), this
        },
        playEnd: function(e) {
            return this.trigger("end", e), this._playEnd(e)
        },
        _playEnd: function(t) {
            return this.viewController.isAnimating = !1, r.BattleInfo.getInstance().isMo() && this._isInLongAction && this.viewController.setIsInLongAction(!1), e.each(this.animatingActorInfoArray, function(e) {
                this.viewController.getActorViewByActorInfo(e).unregisterIsInAnimation()
            }, this), this
        },
        addCallbackOnce: function(e, t) {
            return this.once(e, t), this
        },
        generateNodeName: function() {
            var e = 1;
            return function(t) {
                return t + "_" + e++ + "_" + n.getTime()
            }
        }()
    }), FF.ns.battle.view.animation.AnimationBase
}), define("scenes/battle/view/animation/AbilityBarrageAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3,
        o = 2;
    FF.ns.battle.view.animation.AbilityBarrageAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1,
                skipDamageMotionCountMap: {}
            }, this.data), this.barrageCount = 0, this.nodeStopDeferreds = [], this.launchNodes = [], this.shotNodes = [], this.landNodes = [], this.launchEndDeferred = void 0, this.hasCharaInOutTag = this.data.abilityInfo.charaOutTag ? !0 : !1
        },
        play: function() {
            r.prototype.play.call(this);
            var t = this,
                n = this.data;
            this.helper.showMessageByAbilityInfo(n.abilityInfo, n.executerInfo), this.launchEndDeferred = $.Deferred(), this.totalBarrageNum = n.receiverInfo.length;
            var i = $.Deferred(),
                s = i.promise();
            s = s.then(function() {
                return t.helper.showSupporterEffectDeferred(n.executerInfo)
            }).then(function() {
                return t.helper.playWalkDeferred(n.executerInfo)
            }), e.each(n.receiverInfo, function(e) {
                s = s.then(function() {
                    return t.playBarrageDeferred(n.executerInfo, e, n.abilityInfo)
                })
            });
            var o = s.then(function() {
                    return t._playLandDeferred(n.executerInfo, n.abilityInfo)
                }),
                u = n.abilityInfo.hasLaunchEnd ? this.launchEndDeferred : o;
            return u.then(function() {
                return t.helper.playCharaInDeferred(n.executerInfo, n.abilityInfo)
            }).then(function() {
                return t.trigger("postHit", n.executerInfo), t.helper.playWalkBackDeferred(n.executerInfo)
            }).then(function() {
                return t.nodeStopDeferreds = t.nodeStopDeferreds.concat(t.helper.nodeStopDeferreds), $.when.apply(null, t.nodeStopDeferreds)
            }).then(function() {
                return t.helper.hideSupporterEffectDeferred(n.executerInfo)
            }).then(function() {
                t.cleanUp(), t.playEnd(n.executerInfo)
            }), i.resolve(), s
        },
        playLaunchNextDeferred: function(e, t, n) {
            var r = this,
                s = $.Deferred(),
                o = !1,
                u = n.hasLaunchEnd;
            switch (n.launchType) {
                case i.Conf.ABILITY_LAUNCH_TYPE.NORMAL:
                    this.barrageCount < this.totalBarrageNum && (u = !1);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE:
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE_AND_ATTACK_MOTION_ONCE:
                    this.barrageCount > 1 && (o = !0, u = !1);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.BUDDY_ONLY:
                    e.isEnemy ? o = !0 : this.barrageCount < this.totalBarrageNum && (u = !1);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE:
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE_AND_ATTACK_MOTION_ONCE:
                    o = !0;
                    break;
                default:
                    throw new Error("invalid launch type: " + n.launchType)
            }
            if (o) {
                s.resolve();
                if (u) throw new Error("shouldUseLaunchEnd=true but launch skipped")
            } else {
                if (e.supporterInfo) {
                    var a = this.helper.createSocialLaunchNode(e);
                    this.launchNodes.push(a), a.play("play").process()
                }
                var f = this.helper.createLaunchNode(e, t, n);
                f.addCallbackOnce("action_next", function() {
                    s.resolve()
                }), u && f.addCallbackOnce("action_end", function() {
                    r.launchEndDeferred.resolve()
                }), this.launchNodes.push(f), this.nodeStopDeferreds.push(f.play("play").processDeferred("action_stop"));
                if (n.launchBack) {
                    var l = this.helper.createLaunchBackNode(e, t, n);
                    this.launchNodes.push(l), this.nodeStopDeferreds.push(l.play("play").processDeferred("action_stop"))
                }
            }
            return s.promise()
        },
        _playBarrageAttackMotionDeferred: function(e, t) {
            return this._shouldSkipBarrageAttackMotion(e, t) ? $.Deferred().resolve().promise() : this.helper.playAttackMotionDeferred(e, t)
        },
        _shouldSkipBarrageAttackMotion: function(t, n) {
            if (this.barrageCount > 1) {
                if (this.hasCharaInOutTag) return !0;
                var r = [i.Conf.ABILITY_LAUNCH_TYPE.ONCE_AND_ATTACK_MOTION_ONCE, i.Conf.ABILITY_LAUNCH_TYPE.NONE_AND_ATTACK_MOTION_ONCE];
                if (e.contains(r, n.launchType)) return !0
            }
            return !1
        },
        _playBarrageCharaOutDeferred: function(e, t) {
            return this.hasCharaInOutTag && this.barrageCount > 1 ? $.Deferred().resolve().promise() : this.helper.playCharaOutDeferred(e, t)
        },
        playBarrageDeferred: function(t, n, r) {
            var s = this,
                u = $.Deferred();
            return s.barrageCount++, i.BattleInfo.getInstance().isMo() && s.barrageCount === 1 && s.helper.showAttackNameBalloon(t, r), $.when(this.playLaunchNextDeferred(t, n, r), this._playBarrageAttackMotionDeferred(t, r)).then(function() {
                if (s.helper.hasPlayedReflectHit) {
                    var t = i.Config.getInstance().get("PlayOnceReflectHitCond"),
                        o = e.contains(t.abilityLaunchTypes, r.launchType);
                    if (o) return $.Deferred().resolve().promise()
                }
                return s.helper.playReflectHitDeferred(n)
            }).then(function() {
                return $.when(s._playBarrageShotNextDeferred(t, n, r), s._playBarrageCharaOutDeferred(t, r))
            }).then(function() {
                return s.helper.playHitNextDeferred(t, n, r, {
                    hitCount: s.barrageCount,
                    playDamageOptions: {
                        speed: o
                    },
                    skipDamageMotion: s._skipDamageMotion()
                })
            }).then(function() {
                return s.helper.playDamageOrSkipDamageDeferred(n, r, {
                    hitCount: s.barrageCount,
                    skipDamageMotion: s._skipDamageMotion(),
                    playDamageOptions: {
                        speed: o
                    }
                })
            }).then(u.resolve), u.promise()
        },
        _skipDamageMotion: function() {
            return !!this.options.skipDamageMotion || !!this.options.skipDamageMotionCountMap[this.barrageCount]
        },
        _playBarrageShotNextDeferred: function(e, t, n) {
            switch (n.shotType) {
                case i.Conf.ABILITY_SHOT_TYPE.NORMAL_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.ATTRACT_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE:
                case i.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE:
                    if (this.barrageCount > 1) return $.Deferred().resolve().promise()
            }
            var r = this,
                s = r.helper.playShotNextDeferred(e, t, n);
            return s.then(function(e, t) {
                r.shotNodes = r.shotNodes.concat(e), r.nodeStopDeferreds = r.nodeStopDeferreds.concat(t)
            }), s
        },
        _playLandDeferred: function(e, t) {
            var n = this.helper.playLandDeferred(e, t);
            return this.landNodes = this.landNodes.concat(n.nodes), this.nodeStopDeferreds.push(n.stopDeferred), n.nextDeferred
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                e.each(t.launchNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.landNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilitySingleAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3;
    FF.ns.battle.view.animation.AbilitySingleAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1
            }, this.data), this.nodeStopDeferreds = [], this.launchNodes = [], this.shotNodes = [], this.landNodes = []
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.showMessageByAbilityInfo(t.abilityInfo, t.executerInfo), this.launchEndDeferred = $.Deferred();
            var n = this.helper.showSupporterEffectDeferred(t.executerInfo).then(function() {
                    return e.helper.playWalkDeferred(t.executerInfo)
                }).then(function() {
                    return i.BattleInfo.getInstance().isMo() && e.helper.showAttackNameBalloon(t.executerInfo, t.abilityInfo), $.when(e.helper.playAttackMotionDeferred(t.executerInfo, t.abilityInfo), e.playLaunchNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo))
                }).then(function() {
                    return e.helper.playReflectHitDeferred(t.receiverInfo)
                }).then(function() {
                    var n = e.helper.playShotNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo);
                    return n.then(function(t, n) {
                        e.shotNodes = e.shotNodes.concat(t), e.nodeStopDeferreds = e.nodeStopDeferreds.concat(n)
                    }), $.when(e.helper.playCharaOutDeferred(t.executerInfo, t.abilityInfo), n)
                }).then(function() {
                    return e.helper.playHitNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo, {
                        skipDamageMotion: e.options.skipDamageMotion
                    })
                }).then(function() {
                    return e._playLandDeferred(t.executerInfo, t.abilityInfo)
                }),
                s = t.abilityInfo.hasLaunchEnd ? this.launchEndDeferred : n;
            return s.then(function() {
                return e.helper.playCharaInDeferred(t.executerInfo, t.abilityInfo)
            }).then(function() {
                return e.helper.playReturnDeferred(t.receiverInfo, t.abilityInfo)
            }).then(function() {
                e.trigger("postHit", t.executerInfo);
                if (t.receiverInfo.length <= 0) {
                    var n = i.TextMaster.getInstance().get("B10060"),
                        r = i.BattleViewController.getInstance();
                    r.showMessage({
                        message: n
                    }), r.resetBgColor()
                }
                var s = [];
                return e.helper.shouldDisplayDamageOnActionDamage(t.abilityInfo) || (e.options.skipDamageMotion ? s.push(e.helper.playSkipDeferred(t.receiverInfo)) : s.push(e.helper.playDamageDeferred(t.receiverInfo, t.abilityInfo))), s.push(e.helper.playWalkBackDeferred(t.executerInfo)), $.when.apply(null, s)
            }).then(function() {
                return e.nodeStopDeferreds = e.nodeStopDeferreds.concat(e.helper.nodeStopDeferreds), $.when.apply(null, e.nodeStopDeferreds)
            }).then(function() {
                return e.helper.hideSupporterEffectDeferred(t.executerInfo)
            }).then(function() {
                e.cleanUp(), e.playEnd(t.executerInfo)
            })
        },
        playLaunchNextDeferred: function(e, t, n) {
            var r = this,
                s = $.Deferred(),
                o = !1,
                u = n.hasLaunchEnd;
            switch (n.launchType) {
                case i.Conf.ABILITY_LAUNCH_TYPE.NORMAL:
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE:
                case i.Conf.ABILITY_LAUNCH_TYPE.ONCE_AND_ATTACK_MOTION_ONCE:
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.BUDDY_ONLY:
                    e.isEnemy && (o = !0);
                    break;
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE:
                case i.Conf.ABILITY_LAUNCH_TYPE.NONE_AND_ATTACK_MOTION_ONCE:
                    o = !0;
                    break;
                default:
                    throw new Error("invalid launch type: " + n.launchType)
            }
            if (o) {
                s.resolve();
                if (u) throw new Error("shouldUseLaunchEnd=true but launch skipped")
            } else {
                if (e.supporterInfo) {
                    var a = this.helper.createSocialLaunchNode(e);
                    this.launchNodes.push(a), a.play("play").process()
                }
                var f = this.helper.createLaunchNode(e, t, n);
                f.addCallbackOnce("action_next", function() {
                    s.resolve()
                }), u && f.addCallbackOnce("action_end", function() {
                    r.launchEndDeferred.resolve()
                }), this.launchNodes.push(f), this.nodeStopDeferreds.push(f.play("play").processDeferred("action_stop"));
                if (n.launchBack) {
                    var l = this.helper.createLaunchBackNode(e, t, n);
                    this.launchNodes.push(l), this.nodeStopDeferreds.push(l.play("play").processDeferred("action_stop"))
                }
            }
            return s.promise()
        },
        _playLandDeferred: function(e, t) {
            var n = this.helper.playLandDeferred(e, t);
            return this.landNodes = this.landNodes.concat(n.nodes), this.nodeStopDeferreds.push(n.stopDeferred), n.nextDeferred
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                e.each(t.launchNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), e.each(t.landNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes(), t.helper.destroyShotNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilitySingleAndDeformAnimation", ["./AnimationBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.view.animation.AbilitySingleAndDeformAnimation = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = this.data,
                r = void 0;
            n.options && (r = n.options.skipDamageMotion ? n.options.skipDamageMotion : void 0), this._attackAnimation = new t.view.animation.AbilitySingleAnimation({
                abilityInfo: n.abilityInfo,
                executerInfo: n.executerInfo,
                receiverInfo: n.receiverInfo,
                skipDamageMotion: r,
                skipAttackMotion: !0
            }, this.viewController), this._deformAnimation = new t.view.animation.DeformAnimation({
                deformInfo: n.deformInfo
            }, this.viewController)
        },
        play: function() {
            e.prototype.play.call(this);
            var t = this,
                n = this.data.options || {},
                r = $.Deferred();
            this._attackAnimation.addCallbackOnce("end", function() {
                r.resolve()
            });
            var i = $.Deferred(),
                s = n.usesMainNode ? void 0 : this.viewController.getActorViewByActorInfo(this.data.executerInfo);
            this._deformAnimation.addAttackCallbackOnce(function() {
                t._attackAnimation.play()
            }, s), this._deformAnimation.addCallbackOnce("end", function() {
                i.resolve()
            }), this._deformAnimation.play(), $.when(r.promise(), i.promise()).then(function() {
                t.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/AbilityBarrageAndDeformAnimation", ["./AnimationBase"], function(e) {
    var t = FF.ns.battle;
    FF.ns.battle.view.animation.AbilityBarrageAndDeformAnimation = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments);
            var n = this.data,
                r = void 0;
            n.options && (r = n.options.skipDamageMotion ? n.options.skipDamageMotion : void 0), this._attackAnimation = new t.view.animation.AbilityBarrageAnimation({
                abilityInfo: n.abilityInfo,
                executerInfo: n.executerInfo,
                receiverInfo: n.receiverInfo,
                skipDamageMotion: r,
                skipAttackMotion: !0
            }, this.viewController), this._deformAnimation = new t.view.animation.DeformAnimation({
                deformInfo: n.deformInfo
            }, this.viewController)
        },
        play: function() {
            e.prototype.play.call(this);
            var t = this,
                n = this.data.options || {},
                r = $.Deferred();
            this._attackAnimation.addCallbackOnce("end", function() {
                r.resolve()
            });
            var i = $.Deferred(),
                s = n.usesMainNode ? void 0 : this.viewController.getActorViewByActorInfo(this.data.executerInfo);
            this._deformAnimation.addAttackCallbackOnce(function() {
                t._attackAnimation.play()
            }, s), this._deformAnimation.addCallbackOnce("end", function() {
                i.resolve()
            }), this._deformAnimation.play(), $.when(r.promise(), i.promise()).then(function() {
                t.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/AnimationFactory", ["underscore"], function(e) {
    var t = FF.ns.battle,
        n = {};
    return n[t.Conf.ANIMATION_TYPE.NORMAL] = function(n, r) {
        return new t.view.animation.AbilitySingleAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.BARRAGE] = function(n, r) {
        return new t.view.animation.AbilityBarrageAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.DROP_ITEM] = function(e, n) {
        return new t.view.animation.DropItemAnimation({
            dropItemInfo: t.DataConstructor.getDropItemInfo(e.dropItemInfo)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.DAMAGE] = function(n, r) {
        return new t.view.animation.DamageAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.DEAD] = function(n, r) {
        return new t.view.animation.DeadAnimation({
            actorInfo: e.map(n.actorInfo, function(e) {
                return t.DataConstructor.getActorInfo(e)
            })
        }, r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM] = function(e, n) {
        return new t.view.animation.DeformAnimation({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(e)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.APPEARANCE] = function(n, r) {
        var i = {
            round: n.round,
            roundNum: n.roundNum,
            materiaBoostBuddies: t.DataConstructor.getMateriaBoostBuddies(n.materiaBoostBuddies),
            deformInfo: e.map(n.deformInfo, function(e) {
                return t.DataConstructor.getDeformInfo(e)
            })
        };
        return new t.view.animation.AppearanceAnimation(i, r)
    }, n[t.Conf.ANIMATION_TYPE.TRANSITION] = function(e, n) {
        return new t.view.animation.TransitionAnimation({
            buddies: t.DataConstructor.getActorInfo(e.buddies),
            buddyTransitType: e.buddyTransitType,
            backgroundChangeType: e.backgroundChangeType
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.JUMP_IN] = function(e, n) {
        return new t.view.animation.JumpInAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.JUMP_IN_AND_BARRAGE] = function(e, n) {
        return new t.view.animation.JumpInAndBarrageAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.JUMP_OUT] = function(e, n) {
        return new t.view.animation.JumpOutAnimation({
            executerInfo: t.DataConstructor.getActorInfo(e.action.executer),
            abilityInfo: t.DataConstructor.getAbilityInfo(e.action)
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.ENEMY_JUMP] = function(n, r) {
        return new t.view.animation.EnemyJumpAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM_ATTACK] = function(n, r) {
        return new t.view.animation.AbilitySingleAndDeformAnimation(e.extend({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(n),
            options: n.options
        }, t.DataConstructor.getActionResultInfo(n.actionResult)), r)
    }, n[t.Conf.ANIMATION_TYPE.DEFORM_BARRAGE] = function(n, r) {
        return new t.view.animation.AbilityBarrageAndDeformAnimation(e.extend({
            deformInfo: t.DataConstructor.getDeformInfoByAnimationInfo(n),
            options: n.options
        }, t.DataConstructor.getActionResultInfo(n.actionResult)), r)
    }, n[t.Conf.ANIMATION_TYPE.INVALIDITY] = function(n, r) {
        return new t.view.animation.InvalidityAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, n[t.Conf.ANIMATION_TYPE.RERAISE_RISE] = function(e, n) {
        return new t.view.animation.ReraiseRiseAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.GUTS_RISE] = function(e, n) {
        return new t.view.animation.GutsRiseAnimation(t.DataConstructor.getActionResultInfo(e.actionResult), n)
    }, n[t.Conf.ANIMATION_TYPE.MESSAGE] = function(e, n) {
        return new t.view.animation.MessageAnimation({
            messageInfo: e.messageInfo
        }, n)
    }, n[t.Conf.ANIMATION_TYPE.WAIT] = function(n, r) {
        var i = n.options || {};
        return new t.view.animation.WaitAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), {
            options: i
        }), r)
    }, n[t.Conf.ANIMATION_TYPE.DAMAGE_BARRAGE] = function(n, r) {
        return new t.view.animation.DamageBarrageAnimation(e.extend(t.DataConstructor.getActionResultInfo(n.actionResult), n.options), r)
    }, FF.ns.battle.view.animation.AnimationFactory = {
        create: function(e, t) {
            var r = n[e.animationType];
            if (!r) throw new Error("invalid animation type: " + e.animationType);
            return r(e, t)
        },
        createForDebug: function(e, n) {
            switch (e.animationType) {
                case t.Conf.ANIMATION_TYPE.NORMAL:
                    return new t.view.animation.AbilitySingleAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.BARRAGE:
                    return new t.view.animation.AbilityBarrageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DROP_ITEM:
                    return new t.view.animation.DropItemAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.ATTACK:
                    return new t.view.animation.AttackAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DAMAGE:
                    return new t.view.animation.DamageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DEAD:
                    return new t.view.animation.DeadAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.DEFORM:
                    return new t.view.animation.DeformAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.JUMP_IN:
                    return new t.view.animation.JumpInAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.JUMP_IN_AND_BARRAGE:
                    return new t.view.animation.JumpInAndBarrageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.JUMP_OUT:
                    return new t.view.animation.JumpOutAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.TRANSITION:
                    return new t.view.animation.TransitionAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.RERAISE_RISE:
                    return new t.view.animation.ReraiseRiseAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.GUTS_RISE:
                    return new t.view.animation.GutsRiseAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.MESSAGE:
                    return new t.view.animation.MessageAnimation(e, n);
                case t.Conf.ANIMATION_TYPE.WAIT:
                    return new t.view.animation.WaitAnimation(e, n);
                default:
                    throw new Error("invalid animation type: " + e.animationType)
            }
        }
    }, FF.ns.battle.view.animation.AnimationFactory
}), define("scenes/battle/view/animation/AnimationHelper", ["underscore", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/ClassBase", "util"], function(e, t, n, r, i) {
    var s = FF.ns.battle;
    FF.ns.battle.view.animation.AnimationHelper = r.extend({
        initialize: function(e) {
            this.viewController = e.viewController, this.layers = {}, this.hitNodes = [], this.shotNodes = [], this.nodeStopDeferreds = [], this.animation = e, this.speed = this.animation.data.speed || s.Conf.ANIMATION.DEFAULT_SPEED, this.saSpeed = this.animation.data.saSpeed || s.Conf.ANIMATION.DEFAULT_SA_SPEED, this.particleSpeed = this.animation.data.particleSpeed || s.Conf.ANIMATION.DEFAULT_PARTICLE_SPEED
        },
        showMessageByAbilityInfo: function(t, n, r) {
            if (s.BattleInfo.getInstance().isMo() && n && n.isBuddy && !t.isSoulStrike) return;
            if (t.skipMessage) return;
            if (!t.aliasName) {
                var i = t.dispName;
                if (t.isCounter) {
                    var o = s.TextMaster.getInstance().get("B10050");
                    i = o + i
                }
                i && this.showMessage(e.extend({
                    message: i
                }, r))
            }
        },
        showMessage: function(e) {
            this.viewController.showMessage(e), this.hasPlayedReflectHit = !1
        },
        playWalkDeferred: function(e) {
            if (s.BattleInfo.getInstance().isMo()) return $.Deferred().resolve().promise();
            if (e.isEnemy) return $.Deferred().resolve().promise();
            var t = e.posId,
                n = this.viewController.buddyViews[t];
            return n.playWalkDeferred("front")
        },
        playWalkBackDeferred: function(e) {
            var t = this,
                n = $.Deferred();
            if (e.isEnemy) return n.resolve().promise();
            var r = e.posId,
                i = this.viewController.buddyViews[r];
            return s.BattleInfo.getInstance().isMo() ? (i.playDeferred("idle"), i.hideSpecialReady(), this.viewController.resetSpecialMessage(), n.resolve().promise()) : (i.playWalkDeferred().then(function() {
                i.hideSpecialReady(), t.viewController.resetSpecialMessage(), n.resolve()
            }), n.promise())
        },
        playBuddiesWalk: function(t) {
            var n = e.filter(t, function(e) {
                    return !e.isDead
                }),
                r = e.filter(t, function(e) {
                    return e.isDead
                });
            e.each(r, function(e) {
                this.viewController.getActorView(e.posInfo).setVisible(!1)
            }, this), e.each(n, function(e) {
                this.viewController.getActorView(e.posInfo).playWalk()
            }, this)
        },
        playBuddiesStopWalk: function(t) {
            var n = e.filter(t, function(e) {
                    return !e.isDead
                }),
                r = e.filter(t, function(e) {
                    return e.isDead
                });
            e.each(r, function(e) {
                this.viewController.getActorView(e.posInfo).setVisible(!0)
            }, this), e.each(n, function(e) {
                this.viewController.getActorView(e.posInfo).playIdle()
            }, this)
        },
        playCharaOutDeferred: function(t, n) {
            if (!n.charaOutTag) return $.Deferred().resolve().promise();
            var r = t.posId,
                i = [];
            return e.each(this.viewController.buddyViews, function(e, t) {
                t === r ? i.push(e.playOutDeferred(n.charaOutTag)) : n.otherOutTag && (e.registerIsInAnimation(), i.push(e.playOutDeferred(n.otherOutTag)))
            }), $.when.apply($, i)
        },
        playCharaInDeferred: function(t, n) {
            if (!n.charaInTag) return $.Deferred().resolve().promise();
            var r = t.posId,
                i = [];
            return e.each(this.viewController.buddyViews, function(e, t) {
                t === r ? i.push(e.playInDeferred(n.charaInTag)) : n.otherInTag && i.push(e.playInDeferred(n.otherInTag, function() {
                    e.unregisterIsInAnimation()
                }))
            }), $.when.apply($, i)
        },
        playStopDeferred: function(e) {
            if (e.isEnemy) return $.Deferred().resolve().promise();
            var t = e.posId,
                n = this.viewController.buddyViews[t];
            return n.playDeferred("stop")
        },
        playAttackMotionDeferred: function(e, t, n) {
            var r = this.viewController.getActorViewByActorInfo(e);
            if (e.isBuddy) return r.playAttackDeferred(t, n);
            var i = this.animation.data.skipAttackMotion;
            return i ? $.Deferred().resolve().promise() : r.playDeferred("attack", n)
        },
        playShotNextDeferred: function(t, n, r) {
            var i = $.Deferred(),
                o = !1,
                u = !1,
                a = !1,
                f = [],
                l = [],
                c = [];
            switch (r.shotType) {
                case s.Conf.ABILITY_SHOT_TYPE.NORMAL:
                case s.Conf.ABILITY_SHOT_TYPE.NORMAL_ONCE:
                    u = !0;
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.ATTRACT:
                case s.Conf.ABILITY_SHOT_TYPE.ATTRACT_ONCE:
                    u = !0, a = !0;
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.BACKWARD:
                case s.Conf.ABILITY_SHOT_TYPE.FORWARD:
                case s.Conf.ABILITY_SHOT_TYPE.NORMAL_SINGLE_SHOT:
                case s.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE:
                case s.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE:
                    break;
                case s.Conf.ABILITY_SHOT_TYPE.NONE:
                    o = !0;
                    break;
                default:
                    throw new Error("invalid shot type: " + r.shotType)
            }
            if (o) return i.resolve(l, c).promise();
            if (u) e.each(n, function(e) {
                var n = $.Deferred(),
                    i;
                e.reflector ? i = this.createShotNode(t, e.reflector, r) : i = this.createShotNode(t, e, r), f.push(n.promise()), i.addCallbackOnce("action_next", function() {
                    n.resolve()
                });
                if (a) {
                    var s = this.viewController.getActorViewByActorInfo(e);
                    s.setAbilityShotAttractor(i)
                }
                l.push(i), c.push(i.play("play").processDeferred("action_stop"))
            }, this);
            else {
                var h = $.Deferred(),
                    p = this.createShotNode(t, n, r);
                f.push(h.promise()), p.addCallbackOnce("action_next", function() {
                    h.resolve()
                }), l.push(p), c.push(p.play("play").processDeferred("action_stop"))
            }
            return $.when.apply(null, f).then(function() {
                i.resolve(l, c)
            }), i.promise()
        },
        playHitNextDeferred: function(t, n, r, i) {
            var o = this;
            i = i || {};
            var u = {},
                a = $.Deferred();
            switch (r.hitType) {
                case s.Conf.ABILITY_HIT_TYPE.NORMAL:
                    break;
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT:
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT_FAST:
                    u = {
                        hitCount: i.hitCount
                    };
                    break;
                default:
                    throw new Error("invalid hit type: " + r.hitType)
            }
            var f = [],
                l = this.viewController.getActorViewByActorInfo(t);
            return e.each(n, function(e) {
                if (e.isNotShownHitMotion) return;
                var n = $.Deferred(),
                    s = i.isJumpAnimation ? this.createHitNodeForJumpAnimation(t, e, r, l, u) : this.createHitNode(t, e, r, u);
                f.push(n.promise()), this.shouldDisplayDamageOnActionDamage(r, {
                    hitCount: i.hitCount
                }) && s.addCallbackOnce("action_damage", function() {
                    i.skipDamageMotion ? o.playSkipDeferred([e]) : o.playDamageDeferred([e], r, i.playDamageOptions)
                }), s.addCallbackOnce("action_next", function() {
                    if (r.hitNextTag && e.isBuddy && e.canHit) {
                        var t = o.viewController.getActorViewByActorInfo(e);
                        t.playOutDeferred(r.hitNextTag).then(function() {
                            n.resolve()
                        })
                    } else n.resolve()
                }), this.hitNodes.push(s), this.nodeStopDeferreds.push(s.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, f).then(function() {
                a.resolve()
            }), a.promise()
        },
        playHitNextDeferredByHitNode: function(t) {
            var n = this,
                r = $.Deferred(),
                i = [],
                s = [];
            return e.each(t, function(e) {
                var t = $.Deferred();
                i.push(t.promise()), e.addCallbackOnce("action_damage", function() {
                    t.resolve()
                }), e.addCallbackOnce("action_next", function() {
                    t.resolve()
                }), s.push(e.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, i).then(function() {
                r.resolve(t, s)
            }), r.promise()
        },
        playLandDeferred: function(e, t) {
            var n = $.Deferred(),
                r = $.Deferred(),
                i = [],
                s = this.createLandNode(e, t);
            return s ? (i.push(s), s.addCallbackOnce("action_next", function() {
                n.resolve()
            }).addCallbackOnce("action_stop", function() {
                r.resolve()
            }).play("play").process()) : (n.resolve(), r.resolve()), {
                nodes: i,
                nextDeferred: n.promise(),
                stopDeferred: r.promise()
            }
        },
        playDamageOrSkipDamageDeferred: function(e, t, n) {
            n = n || {};
            var r = $.Deferred();
            if (this.shouldDisplayDamageOnActionDamage(t, {
                    hitCount: n.hitCount
                })) return r.resolve().promise();
            if (n.skipDamageMotion) return this.playSkipDeferred(e);
            var i = this.playDamageDeferred(e, t, n.playDamageOptions);
            return t.hitType === s.Conf.ABILITY_HIT_TYPE.MULTI_HIT_FAST ? r.resolve() : i.then(r.resolve), r.promise()
        },
        playReturnDamageDeferred: function(e, t) {
            if (e.absorbHp.canHit) return $.Deferred().resolve().promise();
            var n = this.viewController.getActorViewByActorInfo(t);
            return this._playMissDeferred(n)
        },
        playDamageDeferred: function(t, n, r) {
            var i = [];
            return e.each(t, function(e) {
                i.push(this._playDamageMotionDeferred(e, n, r))
            }, this), $.when.apply(null, i)
        },
        playSkipDeferred: function(t) {
            var n = [];
            return e.each(t, function(e) {
                var t = this.viewController.getActorViewByActorInfo(e);
                e.isNoeffect ? n.push(t.playNoeffectDeferred()) : e.advantage ? n.push(this._playAdvantageDeferred(e, e.advantage)) : e.canHit || n.push(t.playMissDeferred()), e.canHit && (e.isAbilityPanel ? n.push(this._playMpDamageMotionHitDeferred(e)) : e.isHpStock && n.push(this._playHpStockMotionDeferred(e)))
            }, this), $.when.apply(null, n)
        },
        playReflectHitDeferred: function(t) {
            var n = [],
                r = [];
            return e.each(t, function(e) {
                e.reflector && r.push(e.reflector)
            }), e.each(r, function(e) {
                var t = this.createReflectHitNode(e);
                e.isBuddy && t.setScale([-1, 1]), n.push(t.play("play").processDeferred("action_stop")), this.hasPlayedReflectHit = !0
            }, this), $.when.apply(null, n)
        },
        _playDamageMotionDeferred: function(e, t, n) {
            return e.canHit ? this._playDamageMotionHitDeferred(e, t, n) : this._playDamageMotionMissDeferred(e, t, n)
        },
        _playDamageMotionMissDeferred: function(e, t, n) {
            var r = this.viewController.getActorViewByActorInfo(e);
            return e.isNoeffect ? r.playNoeffectDeferred() : this._playMissDeferred(r)
        },
        _playMissDeferred: function(e) {
            return e.playMissDeferred()
        },
        _playDamageMotionHitDeferred: function(e, t, n) {
            return e.isAbilityPanel ? this._playMpDamageMotionHitDeferred(e, t, n) : e.isHpStock ? this._playHpStockMotionDeferred(e) : this._playHpDamageMotionHitDeferred(e, t, n)
        },
        _playHpStockMotionDeferred: function(e) {
            var t = this.viewController.getActorViewByActorInfo(e);
            return t.registerIsInAnimation(), $.Deferred().resolve().promise().then(function() {
                return t.playHpStockDamageMotionDeferred(e.canHit, e.hpStockDamage)
            }).then(function() {
                t.unregisterIsInAnimation()
            })
        },
        _playMpDamageMotionHitDeferred: function(e, t, n) {
            var r = this,
                i = this.viewController.getActorViewByActorInfo(e);
            return i.registerIsInAnimation(), $.Deferred().resolve().promise().then(function() {
                return i.playMpDamageMotionDeferred(e.canHit, e.damage)
            }).then(function() {
                i.unregisterIsInAnimation()
            })
        },
        _playHpDamageMotionHitDeferred: function(t, n, r) {
            var i = this,
                s = this.viewController.getActorViewByActorInfo(t);
            s.registerIsInAnimation();
            var o = void 0;
            t.isNotShownDamageMotion ? o = $.Deferred().resolve().promise() : e.isNumber(t.fakeDamage) ? o = this._playHpDamageDeferred(s, t.fakeDamage, r) : o = s.setDamageMotionDeferred(t.canHit, t.prevHp, t.currHp, t.maxHp, t.damage, n.damageTag, n.recoveryTag, r);
            var u = this._playAbsorbMotionDeferred(t);
            return $.Deferred().resolve().promise().then(function() {
                return t.isCritical ? s.playCriticalDeferred() : $.Deferred().resolve().promise()
            }).then(function() {
                return i._playAdvantageDeferred(t, t.advantage)
            }).then(function() {
                return $.when(o, u)
            }).then(function() {
                s.unregisterIsInAnimation()
            })
        },
        _playAdvantageDeferred: function(e, t) {
            var n = this.viewController.getActorViewByActorInfo(e),
                r = void 0;
            switch (e.advantage) {
                case s.Conf.ADVANTAGE.WEAK:
                    r = n.playWeaknessDeferred();
                    break;
                case s.Conf.ADVANTAGE.HALF:
                    r = n.playDefenseDeferred();
                    break;
                case s.Conf.ADVANTAGE.ABSORPTION:
                    r = n.playAbsorbDeferred();
                    break;
                case s.Conf.ADVANTAGE.VOID:
                    r = n.playResistDeferred();
                    break;
                default:
                    r = $.Deferred().resolve().promise()
            }
            return r
        },
        _playHpDamageDeferred: function(e, t, n) {
            return t >= 0 ? e.playHpDamageDeferred(t, n) : e.playHpRecoveryDeferred(-1 * t, n)
        },
        _playAbsorbMotionDeferred: function(e) {
            if (!e.absorber) return $.Deferred().resolve().promise();
            var t = this.viewController.getActorView(e.absorber.posInfo);
            return t.setAbsorbDamageMotionDeferred(e.canHit, e.absorbHp.prevHp, e.absorbHp.currHp, e.absorbHp.maxHp, e.absorbHp.damage, e.damageTag, e.recoveryTag, e.absorbHp.canHit)
        },
        showEnemyName: function(t, n) {
            var r = this.viewController.enemyContainers;
            e.each(r, function(e) {
                e.showEnemyName(t, n)
            })
        },
        showEnemyNameDeferred: function(t) {
            var n = [],
                r = this.viewController.enemyContainers;
            return e.each(r, function(e) {
                n.push(e.showEnemyNameDeferred(t))
            }), $.when.apply($, n)
        },
        setEnemyHpGaugeEnabled: function(t) {
            var n = this.viewController.enemyContainers;
            e.each(n, function(e) {
                e.setHpGaugeEnabled(t)
            })
        },
        createLaunchNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = i.getAbilityNodeDuplicateOptions("launch"),
                o = sprintf("ability-%s_launch", r.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                    name: this.animation.generateNodeName("ability_launch_nul"),
                    layer: this.layers[o].layerName,
                    duplicateFrom: "ability_launch_nul",
                    duplicateFromOptions: s,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                }),
                a = r.launchSpriteNum;
            a > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(u, e.supporterInfo, a) : this._setSpriteToNode(u, e, n, a));
            var f = r.launchParticleJson;
            return f && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(u, e.supporterInfo, f) : this._setParticleTextureToNode(u, e, n, f)), this._addCustomActionCallbacks(u), u
        },
        createLaunchBackNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = sprintf("ability-%s_launch_back", r.abilityAnimationId);
            this.createLayerFromAssetId(s);
            var o = {
                    visualParentLayer: this.viewController.battleLayer.layerName,
                    visualParentNode: sprintf("%s_all_shot_pos_nul_3", i.nodePrefix)
                },
                u = new t({
                    name: this.animation.generateNodeName("ability_back_nul"),
                    layer: this.layers[s].layerName,
                    duplicateFrom: "ability_back_nul",
                    duplicateFromOptions: o,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                });
            return this._addCustomActionCallbacks(u), u
        },
        createSocialLaunchNode: function(e) {
            var n = this.viewController.getActorViewByActorInfo(e),
                r = n.getAbilityNodeDuplicateOptions("launch"),
                i = this.viewController.assetsManager.getAssetInfo("social_attack"),
                s = new t({
                    name: this.animation.generateNodeName("social_launch_nul"),
                    layer: i.layerName,
                    duplicateFrom: "ability_launch_nul",
                    duplicateFromOptions: r,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                });
            return s
        },
        createHitNode: function(e, n, r, i) {
            i = i || {};
            var s = this.viewController.getActorViewByActorInfo(n),
                o = s.getAbilityNodeDuplicateOptions("hit"),
                u = void 0,
                a = void 0;
            n.canHit ? (u = i.hitCount ? sprintf("ability-%s_hit_%d", r.abilityAnimationId, i.hitCount) : sprintf("ability-%s_hit", r.abilityAnimationId), this.createLayerFromAssetId(u), a = this.layers[u].layerName) : (u = "miss_hit", a = this.viewController.assetsManager.getAssetInfo(u).layerName, r.missHit && (u = i.hitCount ? sprintf("ability-%s_miss_hit_%d", r.abilityAnimationId, i.hitCount) : sprintf("ability-%s_miss_hit", r.abilityAnimationId), this.createLayerFromAssetId(u), a = this.layers[u].layerName));
            var f = new t({
                    name: this.animation.generateNodeName("ability_hit_nul"),
                    layer: a,
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: o,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                }),
                l = r.hitSpriteNum;
            l > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(f, e.supporterInfo, l) : this._setSpriteToNode(f, e, n, l));
            var c = r.hitParticleJson;
            return c && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(f, e.supporterInfo, c) : this._setParticleTextureToNode(f, e, n, c)), this._addCustomActionCallbacks(f), r.reverseHit && n.isBuddy && f.setScale([-1, 1]), f
        },
        createHitNodeForJumpAnimation: function(e, n, r, i, s) {
            var o = this.createHitNode(e, n, r, s),
                u = new t({
                    name: sprintf("hit_character_%s", n.posId),
                    layer: i.ab.characterNode.layer,
                    duplicateFrom: "character_nul",
                    duplicateFromOptions: {
                        visualParentLayer: o.layer,
                        visualParentNode: "chara_pos_nul",
                        visualParentTopNode: o.name
                    }
                });
            o.setParam({
                abilityEffTargetLayer: u.layer,
                abilityEffNode: "sprite_character_base",
                abilityEffNodeAdd: "sprite_character_add",
                abilityEffParentNode: u.name
            }), o.process();
            var a = this.viewController.assetsManager.getAssetInfo(i.baseSpriteId);
            return u.loadBundle(a.bundle).setSpriteAnimeByNode("sprite_character_base", a.assetPath).setSpriteAnimeByNode("sprite_character_add", a.assetPath).setVisible(!1, {
                topNode: u.name,
                node: "shadow_nul"
            }).process(), this.hitNodes.push(o, u), o
        },
        createShotNode: function(e, n, r) {
            var i = this.viewController.getActorViewByActorInfo(e),
                s = {};
            this._isShotTypeForBackward(r.shotType) || this._isShotTypeForForward(r.shotType) ? s = {
                visualParentLayer: this.viewController.battleLayer.layerName,
                visualParentNode: this._isShotTypeForBackward(r.shotType) ? sprintf("%s_all_shot_pos_nul", i.nodePrefix) : sprintf("%s_all_shot_pos_nul_2", i.nodePrefix)
            } : s = i.getAbilityNodeDuplicateOptions("shot");
            var o = sprintf("ability-%s_shot", r.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                    name: this.animation.generateNodeName("ability_shot_nul"),
                    layer: this.layers[o].layerName,
                    duplicateFrom: "ability_shot_nul",
                    duplicateFromOptions: s,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                }),
                a = r.shotSpriteNum;
            a > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(u, e.supporterInfo, a) : this._setSpriteToNode(u, e, n, a));
            var f = r.shotParticleJson;
            return f && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(u, e.supporterInfo, f) : this._setParticleTextureToNode(u, e, n, f)), this._addCustomActionCallbacks(u), r.reverseShot && e.isEnemy && u.setScale([-1, 1]), u
        },
        createReturnShotNode: function(e, n) {
            var r = this.viewController.getActorViewByActorInfo(e),
                i = {};
            n.returnType === s.Conf.ABILITY_RETURN_TYPE.BACKWARD || n.returnType === s.Conf.ABILITY_RETURN_TYPE.FORWARD ? i = {
                visualParentLayer: this.viewController.battleLayer.layerName,
                visualParentNode: n.returnType === s.Conf.ABILITY_RETURN_TYPE.BACKWARD ? sprintf("%s_all_shot_pos_nul_2", r.nodePrefix) : sprintf("%s_all_shot_pos_nul", r.nodePrefix)
            } : i = r.getAbilityNodeDuplicateOptions("shot");
            var o = sprintf("ability-%s_return_shot", n.abilityAnimationId);
            this.createLayerFromAssetId(o);
            var u = new t({
                name: this.animation.generateNodeName("ability_return_shot_nul"),
                layer: this.layers[o].layerName,
                duplicateFrom: "ability_shot_nul",
                duplicateFromOptions: i,
                speed: this.speed,
                saSpeed: this.saSpeed,
                particleSpeed: this.particleSpeed
            });
            return this._addCustomActionCallbacks(u), u
        },
        createReturnHitNode: function(e, n) {
            var r = e.absorber,
                i = this.viewController.getActorViewByActorInfo(r),
                s = i.getAbilityNodeDuplicateOptions("hit"),
                o = void 0;
            e.absorbHp.canHit ? o = sprintf("ability-%s_return_hit", n.abilityAnimationId) : (o = "miss_hit", n.returnMissHit && (o = sprintf("ability-%s_return_miss_hit", n.abilityAnimationId))), this.createLayerFromAssetId(o);
            var u = new t({
                name: this.animation.generateNodeName("ability_return_hit_nul"),
                layer: this.layers[o].layerName,
                duplicateFrom: "ability_hit_nul",
                duplicateFromOptions: s,
                speed: this.speed,
                saSpeed: this.saSpeed,
                particleSpeed: this.particleSpeed
            });
            return this._addCustomActionCallbacks(u), u
        },
        createReflectHitNode: function(e) {
            return this._createHitNode({
                actorInfo: e,
                assetId: "reflect_hit",
                nodeName: "reflect_hit_nul"
            })
        },
        createReraiseRiseHitNode: function(e) {
            return this._createHitNode({
                actorInfo: e,
                assetId: "reraise_rise_hit",
                nodeName: "reraise_rise_hit_nul"
            })
        },
        createGutsRiseHitNode: function(e) {
            return this._createHitNode({
                actorInfo: e,
                assetId: "guts_rise_hit",
                nodeName: "guts_rise_hit_nul"
            })
        },
        createLandNode: function(e, n) {
            var r = {},
                i = this.viewController.getActorViewByActorInfo(e),
                s = i.getAbilityNodeDuplicateOptions("launch"),
                o = sprintf("ability-%s_land", n.abilityAnimationId),
                u = this.viewController.assetsManager.getAssetInfo(o, {
                    error: !1
                });
            if (!u) return;
            this.createLayerFromAssetId(o);
            var a = new t({
                    name: this.animation.generateNodeName("ability_land_nul"),
                    layer: this.layers[o].layerName,
                    duplicateFrom: "ability_land_nul",
                    duplicateFromOptions: s,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                }),
                f = n.landSpriteNum;
            f > 0 && (e.supporterInfo ? this._setSpriteToNodeForSupporter(a, e.supporterInfo, f) : this._setSpriteToNode(a, e, r, f));
            var l = n.landParticleJson;
            return l && (e.supporterInfo ? this._setParticleTextureToNodeForSupporter(a, e.supporterInfo, l) : this._setParticleTextureToNode(a, e, r, l)), this._addCustomActionCallbacks(a), a
        },
        _createHitNode: function(e) {
            var n = this.viewController.assetsManager.getAssetInfo(e.assetId),
                r = this.viewController.getActorViewByActorInfo(e.actorInfo),
                i = r.getAbilityNodeDuplicateOptions("hit"),
                s = new t({
                    name: this.animation.generateNodeName(e.nodeName),
                    layer: n.layerName,
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: i,
                    speed: this.speed,
                    saSpeed: this.saSpeed,
                    particleSpeed: this.particleSpeed
                });
            return this.hitNodes.push(s), s
        },
        _addCustomActionCallbacks: function(e) {
            var t = this,
                n = this.animation.data.abilityInfo.aliasName;
            e.setParam({
                layer_battle_field: this.viewController.battleLayer.layerName
            }), e.addCallback("action_shake_part", function() {
                t.viewController.startShakeBackground()
            }), e.addCallback("action_shake_part_stop", function() {
                t.viewController.stopShakeBackground()
            }), e.addCallback("action_flash", function() {
                t.viewController.playFlash()
            }), e.addCallback("action_shake_all", function() {
                t.viewController.startShakeField()
            }), e.addCallback("action_shake_all_stop", function() {
                t.viewController.stopShakeField()
            }), e.addCallbackOnce("action_special_name_in", function() {
                t.viewController.showSpecialMessage(n)
            }), e.addCallbackOnce("action_special_name_out", function() {
                t.viewController.hideSpecialMessage()
            })
        },
        showSupporterEffectDeferred: function(e) {
            return e.supporterInfo ? this.viewController.supporterViewController.showSupporterEffectDeferred(e) : $.Deferred().resolve().promise()
        },
        hideSupporterEffectDeferred: function(e) {
            return e.supporterInfo ? this.viewController.supporterViewController.hideSupporterEffectDeferred(e) : $.Deferred().resolve().promise()
        },
        createLayerFromAssetId: function(e) {
            if (!this.layers[e]) {
                var t = this.viewController.assetsManager.getAssetInfo(e);
                this.layers[e] = (new n({
                    layerName: t.layerName + "_" + i.getTime()
                })).createLayer(t.assetPath, t.bundle, {}, {
                    ignoreSameNameLayer: !0
                }).process()
            }
        },
        _isShotTypeForBackward: function(t) {
            return e.contains([s.Conf.ABILITY_SHOT_TYPE.BACKWARD, s.Conf.ABILITY_SHOT_TYPE.BACKWARD_ONCE], t)
        },
        _isShotTypeForForward: function(t) {
            return e.contains([s.Conf.ABILITY_SHOT_TYPE.FORWARD, s.Conf.ABILITY_SHOT_TYPE.FORWARD_ONCE], t)
        },
        _setSpriteToNode: function(e, t, n, r) {
            var i = this._decideActorInfoToSetSprite(t, n);
            if (i) {
                var s = this.viewController.assetsManager.getAssetInfo("buddy-" + i.buddyAnimationInfo.path);
                e = e.loadBundle(s.bundle);
                for (var o = 1; o <= r; o++) e.setSpriteAnimeByNode(sprintf("chara_sprite_%02d", o), s.assetPath)
            }
        },
        _setParticleTextureToNode: function(t, n, r, i) {
            var s = this._decideActorInfoToSetSprite(n, r);
            if (s) {
                var o = this.viewController.assetsManager.getAssetInfo("buddy-" + s.buddyAnimationInfo.path);
                t = t.loadBundle(o.bundle), e.each(i, function(n, r) {
                    e.each(n, function(e) {
                        t.setSpriteAnimeByNode(r, o.assetPath, {
                            emitterName: e
                        })
                    })
                })
            }
        },
        _decideActorInfoToSetSprite: function(e, t) {
            var n = e.isBuddy ? e : t.isBuddy ? t : void 0;
            return n
        },
        _setSpriteToNodeForSupporter: function(e, t, n) {
            var r = t && t.buddyAnimationInfo && t.buddyAnimationInfo.path;
            if (r) {
                var i = this.viewController.assetsManager.getAssetInfo("buddy-" + r);
                e = e.loadBundle(i.bundle);
                for (var s = 1; s <= n; s++) e.setSpriteAnimeByNode(sprintf("chara_sprite_%02d", s), i.assetPath)
            }
        },
        _setParticleTextureToNodeForSupporter: function(t, n, r) {
            var i = n && n.buddyAnimationInfo && n.buddyAnimationInfo.path;
            if (i) {
                var s = this.viewController.assetsManager.getAssetInfo("buddy-" + i);
                t = t.loadBundle(s.bundle), e.each(r, function(n, r) {
                    e.each(n, function(e) {
                        t.setSpriteAnimeByNode(r, s.assetPath, {
                            emitterName: e
                        })
                    })
                })
            }
        },
        playReturnDeferred: function(e, t) {
            var n = this,
                r = $.Deferred();
            return t.returnType === s.Conf.ABILITY_RETURN_TYPE.NONE ? r.resolve().promise() : this.playReturnShotNextDeferred(e, t).then(function() {
                return n.playReturnHitNextDeferred(e, t)
            })
        },
        playReturnShotNextDeferred: function(t, n) {
            var r = $.Deferred(),
                i = !1,
                o = !1,
                u = !1;
            switch (n.returnType) {
                case s.Conf.ABILITY_RETURN_TYPE.NORMAL:
                    o = !0;
                    break;
                case s.Conf.ABILITY_RETURN_TYPE.ATTRACT:
                    o = !0, u = !0;
                    break;
                case s.Conf.ABILITY_RETURN_TYPE.BACKWARD:
                case s.Conf.ABILITY_RETURN_TYPE.FORWARD:
                    break;
                case s.Conf.ABILITY_RETURN_TYPE.NONE:
                    i = !0;
                    break;
                default:
                    throw new Error("invalid return type: " + n.returnType)
            }
            if (i) return r.resolve().promise();
            if (o) {
                var a = [],
                    f = this._filterToReturnable(t);
                e.each(f, function(e) {
                    var t = $.Deferred(),
                        r = this.createReturnShotNode(e, n);
                    a.push(t.promise()), r.addCallbackOnce("action_next", function() {
                        t.resolve()
                    });
                    if (u) {
                        var i = this.viewController.getActorViewByActorInfo(e.absorber);
                        i.setAbilityShotAttractor(r)
                    }
                    this.shotNodes.push(r), this.nodeStopDeferreds.push(r.play("play").processDeferred("action_stop"))
                }, this), $.when.apply(null, a).then(function() {
                    r.resolve()
                })
            } else {
                var l = this.createReturnShotNode(t[0], n);
                l.addCallbackOnce("action_next", function() {
                    r.resolve()
                }), this.shotNodes.push(l), this.nodeStopDeferreds.push(l.play("play").processDeferred("action_stop"))
            }
            return r.promise()
        },
        playReturnHitNextDeferred: function(t, n) {
            var r = this,
                i = $.Deferred(),
                s = [],
                o = this._filterToReturnable(t);
            return e.each(o, function(e) {
                var t = $.Deferred(),
                    i = this.createReturnHitNode(e, n);
                i.addCallbackOnce("action_next", function() {
                    r.playReturnDamageDeferred(e, e.absorber).then(function() {
                        t.resolve()
                    })
                }), s.push(t.promise()), this.hitNodes.push(i), this.nodeStopDeferreds.push(i.play("play").processDeferred("action_stop"))
            }, this), $.when.apply(null, s)
        },
        shouldDisplayDamageOnActionDamage: function(e, t) {
            t = t || {};
            if (!e.hasHitTiming) return !1;
            var n = !0;
            switch (e.hitType) {
                case s.Conf.ABILITY_HIT_TYPE.NORMAL:
                    break;
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT:
                case s.Conf.ABILITY_HIT_TYPE.MULTI_HIT_FAST:
                    t.hitCount && t.hitCount < e.hitArg && (n = !1);
                    break;
                default:
                    throw new Error("invalid hit type: " + e.hitType)
            }
            return n
        },
        _filterToReturnable: function(t) {
            return e.filter(t, function(t) {
                return e.isUndefined(t.absorber) ? !1 : t.canHit ? !0 : !1
            })
        },
        showAttackNameBalloon: function(e, t) {
            FF.logger.debug("showAttackNameBalloon", t);
            if (e.isEnemy) return;
            var n = e.posId,
                r = this.viewController.buddyViews[n];
            r.showAttackNameBalloon(t)
        },
        destroyLayers: function() {
            e.each(this.layers, function(e) {
                e.destroyLayer({
                    clearParsedJsonCache: !1,
                    forced: !0
                }).process()
            })
        },
        destroyHitNodes: function() {
            e.each(this.hitNodes, function(e) {
                e.deleteNode().process()
            })
        },
        destroyShotNodes: function() {
            e.each(this.shotNodes, function(e) {
                e.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/AppearanceAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.AppearanceAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var r = this,
                i = this.data.round,
                s = this.data.roundNum,
                o = this.data.materiaBoostBuddies,
                u = this.data.deformInfo,
                a = new t({
                    name: "battle_start_nul",
                    layer: this.viewController.battleLayer.layerName
                }),
                f = a.setText("battle_start_num_txt_1", i).setText("battle_start_num_txt_2", "/ " + s).setVisible(!0).play("battle_start").processDeferred("action_stop");
            return f.then(function() {
                var t = [];
                return u.length === 0 ? r.helper.setEnemyHpGaugeEnabled(!0) : e.each(u, function(e) {
                    t.push(r._playDeformDeferred(e))
                }), e.each(o, function(n, i) {
                    i === "exp" ? e.each(n, function(e) {
                        t.push(r._playExpBonusDeferred(e))
                    }) : i === "gil" && e.each(n, function(e) {
                        t.push(r._playGilBonusDeferred(e))
                    })
                }), $.when.apply($, t).then(function() {
                    r.helper.showEnemyName(2e3), r.playEndHook(), r.playEnd()
                })
            })
        },
        _playDeformDeferred: function(e) {
            var t = this.viewController.enemyContainers[e.posId],
                n = {
                    isRandom: e.isRandom,
                    invisibleHpGaugePosArray: e.invisibleHpGaugePosArray
                };
            return t.playDeformDeferred(e.deformTag, e.posArray, e.shouldDeformAllNodes, n)
        },
        _playExpBonusDeferred: function(e) {
            return this.viewController.buddyViews[e.posId].ab.txtEffNode.play("exp_up").processDeferred("action_stop")
        },
        _playGilBonusDeferred: function(e) {
            return this.viewController.buddyViews[e.posId].ab.txtEffNode.play("g_up").processDeferred("action_stop")
        },
        playEndHook: function() {}
    })
}), define("scenes/battle/view/animation/AttackAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.AttckAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.playAttackMotionDeferred(t.executerInfo, t.atkMotion).then(function() {
                e.playEnd(t.executerInfo)
            })
        }
    })
}), define("scenes/battle/view/animation/InvalidityAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.InvalidityAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this)
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.showMessageByAbilityInfo(t.abilityInfo, t.executerInfo, {
                duration: 1e3
            });
            var n = this.viewController.getActorViewByActorInfo(t.executerInfo);
            return this.helper.playWalkDeferred(t.executerInfo).then(function() {
                if (t.executerInfo.isEnemy) return n.playDeferred("attack")
            }).then(function() {
                var t = i.TextMaster.getInstance().get(e._detectTextId());
                return e.viewController.showMessage({
                    message: t
                }), i.util.DelayCallback.registerDeferred(1500)
            }).then(function() {
                return e.helper.playWalkBackDeferred(t.executerInfo)
            }).then(function() {
                e.helper.destroyLayers(), e.helper.destroyHitNodes(), e.playEnd(t.executerInfo)
            })
        },
        _detectTextId: function() {
            var e = this.data.invalidityType,
                t = void 0;
            switch (e) {
                case i.Conf.INVALIDITY_TYPE.DO_ABILITY:
                case i.Conf.INVALIDITY_TYPE.MAGIC:
                    t = "B10060";
                    break;
                case i.Conf.INVALIDITY_TYPE.FIGHT_ATTACK:
                    t = "B15260";
                    break;
                default:
                    throw new Error("unknown invalidityType:" + e)
            }
            return t
        }
    })
}), define("scenes/battle/view/animation/DamageAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.DamageAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1,
                normalDamageMotion: !1,
                isParallelPlayAnimation: !1
            }, this.data)
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data,
                n = void 0;
            e.options.skipDamageMotion ? n = e.helper.playSkipDeferred(t.receiverInfo) : e.options.normalDamageMotion ? n = e.helper.playDamageDeferred(t.receiverInfo, t.abilityInfo) : n = this._playSaDamageMotionDeferred(), n.done(function() {
                e.playEnd()
            }).fail(function(e) {
                throw new Error("Error has occured on DamageAnimation : ", t)
            }), this.options.isParallelPlayAnimation && this.trigger("end")
        },
        playEnd: function() {
            this.options.isParallelPlayAnimation || this.trigger("end"), this._playEnd()
        },
        _playSaDamageMotionDeferred: function() {
            var t = this,
                n = this.data,
                r = [];
            return e.each(n.receiverInfo, function(e) {
                var n = t.viewController.getActorView(e.posInfo);
                e.damage >= 0 ? r.push($.when(n.playHpDamageDeferred(e.damage), n.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp))) : r.push($.when(n.playHpRecoveryDeferred(-1 * e.damage), n.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp)))
            }), $.when.apply($, r)
        }
    })
}), define("scenes/battle/view/animation/DamageBarrageAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.DamageBarrageAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1,
                normalDamageMotion: !1,
                damageMotionMsec: void 0
            }, this.data)
        },
        play: function() {
            r.prototype.play.call(this);
            var t = this,
                n = this.data,
                s = $.Deferred().resolve().promise();
            e.each(n.receiverInfo, function(r) {
                s = s.then(function() {
                    var s;
                    if (t.options.skipDamageMotion) s = t.helper.playSkipDeferred(r);
                    else {
                        if (!t.options.normalDamageMotion) throw new Error("Not supported DamageMotion on DamageBarrageAnimation");
                        s = t.helper.playDamageDeferred(r, n.abilityInfo)
                    }
                    return e.isNumber(t.options.damageMotionMsec) ? i.util.DelayCallback.registerDeferred(t.options.damageMotionMsec) : s
                })
            }), s.done(function() {
                t.playEnd()
            }).fail(function(e) {
                throw new Error("Error has occured on DamageBarrageAnimation")
            })
        },
        playEnd: function() {
            this.trigger("end"), this._playEnd()
        }
    })
}), define("scenes/battle/view/animation/DeadAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.DeadAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments)
        },
        play: function() {
            var t = this;
            n.prototype.play.call(this);
            var r = this.data.actorInfo,
                i = [];
            e.each(r, function(e) {
                e.nodeNamePrefix === "enemy" && i.push(t._playDeadDeferred(e))
            }), $.when.apply($, i).then(function() {
                t.playEnd()
            })
        },
        _playDeadDeferred: function(e) {
            var t = this.viewController.getActorView(e.posInfo),
                n = this._getDeadTag(e),
                i = e.deadAnimateType === r.Conf.DEAD_ANIMATE_TYPE.APPARENT_DEAD,
                s = t.ab.characterNode.play(n).processDeferred("action_stop").then(function() {
                    t.setDeadInfo({
                        isApparentDead: i
                    })
                });
            return t.setHpGaugeEnabled(!1), $.when(s, t.playDeferred(n))
        },
        _getDeadTag: function(e) {
            return e.deadAnimateType ? r.Config.getInstance().get("DeadTag", e.deadAnimateType) : e.isSpEnemy && e.isFinalEnemy ? r.Config.getInstance().get("DeadTag", r.Conf.DEAD_ANIMATE_TYPE.BOSS) : r.Config.getInstance().get("DeadTag", r.Conf.DEAD_ANIMATE_TYPE.DEAD)
        }
    })
}), define("scenes/battle/view/animation/DeformAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.DeformAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this), this.msgCallBack = void 0
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data.deformInfo,
                r = this._detectEnemyContainer(),
                i = t.skipEnemyName,
                s = t.forceShowNamePosArray,
                o = {
                    isRandom: t.isRandom,
                    filteringDeformPosArray: t.filteringDeformPosArray,
                    skipMainNodeDeform: t.skipMainNodeDeform,
                    invisibleHpGaugePosArray: t.invisibleHpGaugePosArray
                },
                u = t.messageInfo,
                a = $.Deferred(),
                f = function() {
                    a.resolve()
                };
            u ? (this.msgCallBack = u.callback, u.callback = f, this.helper.showMessage(u)) : f(), r.playDeformDeferred(t.deformTag, t.posArray, t.shouldDeformAllNodes, o).then(function() {
                i || e.helper.showEnemyName(2e3, s), a.then(function() {
                    e.msgCallBack && e.msgCallBack(), e.playEnd()
                })
            })
        },
        addAttackCallbackOnce: function(e, t) {
            var n = this,
                r = "attack";
            this.addCallbackOnce(r, e);
            var i;
            if (t) i = t.ab.characterNode;
            else {
                var s = this._detectEnemyContainer();
                i = s.mainNode
            }
            i.addCallbackOnce("action_ability", function() {
                n.trigger(r)
            })
        },
        _detectEnemyContainer: function() {
            var e = this.data.deformInfo.posId;
            return this.viewController.enemyContainers[e]
        }
    })
}), define("scenes/battle/view/animation/DropItemAnimation", ["underscore", "lib/ab/ABNode", "lib/ab/ABLayer", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = i.Conf,
        o = {};
    o[s.DROP_ITEM_TYPE.POTION] = "playPotionItemDeferred", o[s.DROP_ITEM_TYPE.HI_POTION] = "playHiPotionItemDeferred", o[s.DROP_ITEM_TYPE.X_POTION] = "playPotionItemDeferred", o[s.DROP_ITEM_TYPE.ETHER] = "playEtherItemDeferred", o[s.DROP_ITEM_TYPE.TURBO_ETHER] = "playEtherItemDeferred", o[s.DROP_ITEM_TYPE.GIL] = "_setGilNum", o[s.DROP_ITEM_TYPE.TREASURE] = "_setTreasureNum", o[s.DROP_ITEM_TYPE.ORB] = "_setOrbNum";
    var u = {
        POTION: 1,
        ETHER: 2,
        HI_POTION: 3
    };
    FF.ns.battle.view.animation.DropItemAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.layers = {}, this.dropItemViews = {}, this._gil = 0, this._treasure = 0, this._orb = 0
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data.dropItemInfo;
            return $.Deferred().resolve().promise().then(function() {
                return e.playDropItemInDeferred()
            }).then(function() {
                return e.playDropItemOutDeferred()
            })
        },
        playDropItemInDeferred: function() {
            var t = this.data.dropItemInfo,
                n = this,
                r = [],
                s = {};
            return e.each(t, function(e) {
                var t = e.executerInfo.posId;
                s[t] = s[t] || [], s[t].push(e.item)
            }), e.each(s, function(e, t) {
                n.dropItemViews[t] = new i.view.DropItemView({
                    posId: t,
                    battleViewController: n.viewController
                });
                var s = n.dropItemViews[t].dropItemDeferred(e);
                r.push(s)
            }), $.when.apply(null, r)
        },
        playDropItemOutDeferred: function() {
            var t = this.data.dropItemInfo,
                n = this,
                r = this.playGetItemDeferred(t),
                i = this.playEraseItemDeferred().then(function() {
                    n.playNum()
                });
            return this.playGilNum(), $.when(r, i).then(function() {
                n.playEnd(t), e.each(n.dropItemViews, function(e) {
                    e.dispose()
                }), n.dropItemViews = null
            })
        },
        playNum: function() {
            this.playOrbNum(), this.playTreasureNum()
        },
        playEraseItemDeferred: function() {
            var t = [];
            return e.each(this.dropItemViews, function(e) {
                t.push(e.workDeferred())
            }), $.when.apply(null, t)
        },
        playGetItemDeferred: function(t) {
            var n = [];
            return e.each(t, function(e) {
                var t = this._getFuncName(e.item.type),
                    r = this[t](e);
                r && n.push(r)
            }, this), $.when.apply($, n)
        },
        _setGilNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._gil && (this._gil = t)
        },
        _setTreasureNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._treasure && (this._treasure = t)
        },
        _setOrbNum: function(e) {
            var t = e.receiverInfo[0].currNum;
            t > this._orb && (this._orb = t)
        },
        playGilNum: function() {
            this._gil > 0 && this.viewController.setGilNum(this._gil)
        },
        playTreasureNum: function() {
            this._treasure > 0 && this.viewController.setTreasureNum(this._treasure)
        },
        playOrbNum: function() {
            this._orb > 0 && this.viewController.setOrbNum(this._orb)
        },
        playPotionItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.POTION)
        },
        playHiPotionItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.HI_POTION)
        },
        playEtherItemDeferred: function(e) {
            return this._playCureItemDeferred(e, u.ETHER)
        },
        _playCureItemDeferred: function(r, i) {
            var s = this,
                o = this.viewController.battleLayer,
                a = o.layerName,
                f = r.executerInfo.posId,
                l = this.dropItemViews[f],
                c = void 0;
            switch (i) {
                case u.POTION:
                    c = "20000";
                    break;
                case u.HI_POTION:
                    c = "20001";
                    break;
                case u.ETHER:
                    c = "20010";
                    break;
                default:
                    c = "20000"
            }
            var h = [],
                p = [],
                d = [],
                v = sprintf("ability-%s_shot", c),
                m = sprintf("ability-%s_hit", c),
                g = this.viewController.assetsManager.getAssetInfo(v),
                y = this.viewController.assetsManager.getAssetInfo(m);
            return this.layers[v] = (new n({
                layerName: g.layerName
            })).createLayer(g.assetPath, g.bundle, {}, {
                ignoreSameNameLayer: !0
            }).process(), this.layers[m] = (new n({
                layerName: y.layerName
            })).createLayer(y.assetPath, y.bundle, {}, {
                ignoreSameNameLayer: !0
            }).process(), e.each(r.receiverInfo, function(e) {
                var n = $.Deferred(),
                    r = e.posId,
                    o = "player",
                    u = s.viewController.getActorView(e.posInfo);
                u.registerIsInAnimation(), s.animatingActorInfoArray.push(e);
                var f = new t({
                    name: sprintf("%s_ability_shot_nul_%s", o, r),
                    layer: sprintf("layer_ability-%s_shot", c),
                    duplicateFrom: "ability_shot_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a,
                        visualParentNode: "drop_item_eff_pos_nul_02",
                        visualParentTopNode: l.dropItemNode.name
                    }
                });
                f.setAttractor("shot_particle", sprintf("%s_attractor_%s", o, r), {
                    attractorLayer: a
                });
                var v = new t({
                    name: sprintf("%s_ability_hit_nul_%s", o, r),
                    layer: sprintf("layer_ability-%s_hit", c),
                    duplicateFrom: "ability_hit_nul",
                    duplicateFromOptions: {
                        visualParentLayer: a,
                        visualParentNode: sprintf("%s_hit_pos_nul_%s", o, r)
                    }
                });
                v.addCallbackOnce("action_stop", function() {
                    v.deleteNode().process(), f.deleteNode().process(), n.resolve()
                }), f.addCallbackOnce("action_next", function() {
                    v.play("play").process(), s._playActorEffectDeferred(e, i)
                }), v.process(), f.process(), h.push(v), p.push(f), d.push(n.promise())
            }), e.each(p, function(e) {
                e.play("play").process()
            }), $.when.apply(null, d)
        },
        _playActorEffectDeferred: function(e, t) {
            var n, r = this.viewController.getActorView(e.posInfo);
            switch (t) {
                case u.POTION:
                case u.HI_POTION:
                    n = r.setDamageMotionDeferred(!0, e.prevHp, e.currHp, e.maxHp, e.damage);
                    break;
                case u.ETHER:
                    n = r.playMpRecoveryDeferred(-1 * e.damageNum);
                    break;
                default:
                    n = $.Deferred().resolve().promise()
            }
            return n
        },
        _getFuncName: function(e) {
            var t = o[e];
            if (!this[t]) throw new Error("invalid drop item type.t=" + e);
            return t
        },
        destroyLayers: function() {
            e.each(this.layers, function(e) {
                e.destroyLayer({
                    clearParsedJsonCache: !1,
                    forced: !0
                }).process()
            })
        }
    })
}), define("scenes/battle/view/animation/JumpInAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = 3e3;
    FF.ns.battle.view.animation.JumpInAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this;
            this.playJumpInDeferred().then(function() {
                return $.when.apply(null, e.helper.nodeStopDeferreds)
            }).then(function() {
                e.cleanUp(), e.playEnd()
            })
        },
        playJumpInDeferred: function() {
            var t = this,
                n = this.data,
                r = this.data.executerInfo,
                i = this.data.receiverInfo,
                s = this.data.abilityInfo,
                o = [],
                u = this.viewController.getActorViewByActorInfo(r);
            return e.each(i, function(e) {
                var n = this.helper.createHitNodeForJumpAnimation(r, e, s, u);
                n.addCallbackOnce("action_next", function() {
                    t.helper.playDamageDeferred([e], s)
                }), o.push(n.play("play").processDeferred("action_stop"))
            }, this), $.when.apply($, o).then(function() {
                return e.each(t.helper.hitNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.playCharaInDeferred(r, s), u.setVisible(!0), $.when.apply(null, [t.helper.playReturnDeferred(i, s), t.helper.playWalkBackDeferred(r)])
            })
        },
        cleanUp: function() {
            var e = this;
            r.util.DelayCallback.register(i, function() {
                e.helper.destroyHitNodes(), e.helper.destroyShotNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/JumpOutAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle;
    FF.ns.battle.view.animation.JumpOutAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this)
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this,
                t = this.data;
            this.helper.playWalkDeferred(t.executerInfo).then(function() {
                return r.BattleInfo.getInstance().isMo() && (e.helper.showAttackNameBalloon(t.executerInfo, t.abilityInfo), r.BattleViewController.getInstance().cancelBuddysTargetByUid(t.executerInfo.uid)), e.playJumpDeferred()
            }).then(function() {
                e.playEnd()
            })
        },
        playJumpDeferred: function() {
            var e = this,
                t = this.data.abilityInfo,
                n = this.data.executerInfo,
                r = this.data.receiverInfo;
            this.helper.showMessageByAbilityInfo(t, n);
            var i = [],
                s = this.helper.createLaunchNode(n, r, t);
            i.push(s.play("play").processDeferred("action_stop").then(function() {
                return e.helper.playCharaOutDeferred(n, t)
            }));
            var o = this.helper.createShotNode(n, r, t);
            return i.push(o.play("play").processDeferred("action_stop")), $.when.apply($, i).then(function() {
                var t = e.viewController.getActorViewByActorInfo(n);
                t.setVisible(!1)
            }).then(function() {
                s.deleteNode().process(), o.deleteNode().process()
            })
        }
    })
}), define("scenes/battle/view/animation/JumpInAndBarrageAnimation", ["underscore", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n) {
    var r = FF.ns.battle,
        i = 3e3,
        s = 2;
    FF.ns.battle.view.animation.JumpInAndBarrageAnimation = n.extend({
        initialize: function() {
            n.prototype.initialize.apply(this, arguments), this.helper = new r.view.animation.AnimationHelper(this), this.barrageCount = 0
        },
        play: function() {
            n.prototype.play.call(this);
            var e = this;
            this.playJumpInDeferred().then(function() {
                return $.when.apply(null, e.helper.nodeStopDeferreds)
            }).then(function() {
                e.cleanUp(), e.playEnd()
            })
        },
        playJumpInDeferred: function() {
            var t = this,
                n = this.data,
                r = this.data.executerInfo,
                i = this.data.receiverInfo,
                s = this.data.abilityInfo,
                o = this.viewController.getActorViewByActorInfo(r),
                u = $.Deferred(),
                a = u.promise();
            return e.each(i, function(e) {
                a = a.then(function() {
                    return t._playHitDeferred(r, e, s, o)
                })
            }), u.resolve(), a.then(function() {
                return t.helper.playCharaInDeferred(r, s), o.setVisible(!0), t.helper.playWalkBackDeferred(r)
            })
        },
        _playHitDeferred: function(e, t, n, r) {
            var i = this,
                o = $.Deferred();
            return this.barrageCount++, i.helper.playHitNextDeferred(e, t, n, {
                hitCount: i.barrageCount,
                playDamageOptions: {
                    speed: s
                },
                isJumpAnimation: !0
            }).then(function() {
                return i.helper.playDamageOrSkipDamageDeferred(t, n, {
                    hitCount: i.barrageCount,
                    playDamageOptions: {
                        speed: s
                    }
                })
            }).then(o.resolve), o.promise()
        },
        cleanUp: function() {
            var e = this;
            r.util.DelayCallback.register(i, function() {
                e.helper.destroyHitNodes(), e.helper.destroyShotNodes()
            })
        }
    })
}), define("scenes/battle/view/animation/TransitionAnimation", ["underscore", "util", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.TransitionAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.data = t.option({
                buddies: void 0,
                backgroundChangeType: !1,
                buddyTransitType: void 0
            }, this.data)
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data.backgroundChangeType,
                n = t === i.Conf.BACKGROUND_CHANGE_TYPE.NONE ? this._playTransitionDeferred() : this._playBgChangeDeferred(t);
            n.then(function() {
                e.playEnd()
            })
        },
        _playBgChangeDeferred: function(e) {
            var t = this,
                n = e === i.Conf.BACKGROUND_CHANGE_TYPE.WALK,
                r = this.data.buddies;
            n && this.helper.playBuddiesWalk(r);
            var s = $.Deferred();
            return this.viewController.backgroundView.playChangeTransitionDeferred().then(function() {
                n && t.helper.playBuddiesStopWalk(r), s.resolve()
            }), s.promise()
        },
        _playTransitionDeferred: function() {
            var e = this.data.buddyTransitType;
            switch (e) {
                case i.Conf.TRANSITION_TYPE.NONE:
                    return $.Deferred().resolve().promise();
                case i.Conf.TRANSITION_TYPE.SCROLL:
                    return this._playTransitionWalkDeferred();
                default:
                    throw new Error("invalid transit type.t=" + e)
            }
        },
        _playTransitionWalkDeferred: function() {
            var e = this,
                t = this.data.buddies;
            this.helper.playBuddiesWalk(t);
            var n = $.Deferred();
            return this.viewController.backgroundView.playScrollTransitionDeferred().then(function() {
                e.helper.playBuddiesStopWalk(t), e.viewController.backgroundView.suspendTransition(), n.resolve()
            }), n.promise()
        }
    })
}), define("scenes/battle/view/animation/EnemyJumpAnimation", ["underscore", "lib/ab/ABNode", "util", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle,
        s = 3e3;
    FF.ns.battle.view.animation.EnemyJumpAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.options = n.option({
                skipDamageMotion: !1
            }, this.data), this.nodeStopDeferreds = [], this.launchNode = void 0, this.shotNodes = []
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this,
                t = this.data;
            return this.helper.showMessageByAbilityInfo(t.abilityInfo, t.executerInfo), this.helper.playAttackMotionDeferred(t.executerInfo, t.abilityInfo).then(function() {
                return e.playJumpOutDeferred()
            }).then(function() {
                return e.helper.playHitNextDeferred(t.executerInfo, t.receiverInfo, t.abilityInfo)
            }).then(function(t) {
                return e.playJumpInDeferred()
            }).then(function() {
                return e.trigger("postHit", t.executerInfo), e.options.skipDamageMotion ? $.Deferred().resolve().promise() : e.helper.playDamageDeferred(t.receiverInfo, t.abilityInfo)
            }).then(function() {
                return e.nodeStopDeferreds = e.nodeStopDeferreds.concat(e.helper.nodeStopDeferreds), $.when.apply(null, e.nodeStopDeferreds)
            }).then(function() {
                e.cleanUp(), e.playEnd(t.executerInfo)
            })
        },
        playJumpOutDeferred: function() {
            var e = this.data.abilityInfo,
                t = this.data.executerInfo,
                n = this.data.receiverInfo,
                r = [],
                i = this.viewController.getActorViewByActorInfo(t),
                s = this.helper.createLaunchNode(t, n, e);
            r.push(s.play("play").processDeferred("action_stop").then(function() {
                return i.playOutDeferred(e.charaOutTag)
            }));
            var o = this.helper.createShotNode(t, n, e);
            return r.push(o.play("play").processDeferred("action_stop")), $.when.apply($, r).then(function() {
                s.deleteNode().process(), o.deleteNode().process()
            })
        },
        playJumpInDeferred: function() {
            var e = this.data.abilityInfo,
                t = this.data.executerInfo,
                n = this.viewController.getActorViewByActorInfo(t);
            return n.playInDeferred(e.charaInTag)
        },
        cleanUp: function() {
            var t = this;
            i.util.DelayCallback.register(s, function() {
                t.launchNode && t.launchNode.deleteNode().process(), e.each(t.shotNodes, function(e) {
                    e.deleteNode().process()
                }), t.helper.destroyLayers(), t.helper.destroyHitNodes()
            })
        }
    })
}), define("ww/scenes/common/util/VCApi", ["jquery", "underscore", "lib/api"], function(e, t, n) {
    return t.extend({}, {
        getVCBundlesDeferred: function(e) {
            return e && e.handleRetry ? (e.callingFunction = "getVCBundlesDeferred", n.callDeferredWithRetry(this._getVCBundlesDeferred.bind(this), e)) : this._getVCBundlesDeferred()
        },
        _getVCBundlesDeferred: function(n) {
            var r = this,
                i = e.Deferred();
            return kickmotor.platform.getVCBundles(function(e) {
                if (i) {
                    if (e.success) {
                        if (FF.env.isAndroid()) {
                            var n = [];
                            t.each(e.vcBundles, function(e) {
                                e.title = e.detail, n.push(e)
                            }), e.vcBundles = n
                        }
                        i.resolve(e.vcBundles)
                    } else FF.logger.debug("Failed to get VC due to : " + e.reason), i.reject();
                    i = null
                }
            }), i.promise()
        },
        buyVCBundleDeferred: function(t) {
            var n = this,
                r = e.Deferred();
            return kickmotor.platform.buyVCBundle(t, function(e) {
                e.success ? r.resolve(e.wallet) : (FF.logger.debug("Failed to buy VC due to : " + e.reason), r.reject(e.reason))
            }), r.promise()
        }
    })
}), define("ww/scenes/battle/view/VCListView", ["underscore", "util", "sprintf", "lib/ab/ABNode", "lib/ab/ABLayer", "lib/EventBase", "ww/scenes/common/util/VCApi", "jquery"], function(e, t, n, r, i, s, o, u) {
    var a = FF.ns.battle,
        f = ["1", "2", "3", "4", "5"],
        l = {
            BUNDLE: "bundleNode%s"
        };
    return FF.ns.battle.view.VCListView = s.extend({
        initialize: function(e) {
            FF.logger.debug("VCListView: initialize"), this.windowMainNode = e.windowMainNode, this.menuLayerInfo = e.menuLayerInfo, this.battleLayerName = e.battleLayerName, this._isSelected = !1, this.ab = {}, this.btnEnableInfo = {}, this._tappingBtnName = void 0, this._initBaseNode(), this._initThanksAnim(), this._initBundleNodes(), this.flush()
        },
        _initBaseNode: function() {
            this.ab.bundleGroupNode = this.windowMainNode.createChildNode("buy_select_nul")
        },
        _initThanksAnim: function() {
            var e = this.windowMainNode,
                t = this.menuLayerInfo,
                n = this.battleLayerName;
            this.ab.thankNode = new r({
                name: "buy_thank_nul",
                layer: t.layerName,
                visualParentTo: "zero_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: n
                }
            }), this.ab.thankNode.setVisible(!0)
        },
        _initBundleNodes: function() {
            var t = this;
            e.each(f, function(e, r) {
                var i = n("bundleNode%s", e);
                if (t.ab[i]) return;
                t.ab[i] = t._createBtnNode(n("buy_select_bt_%s_nul", e), function(e) {
                    if (!t.ab || !t.ab[i] || !t._isBtnEnable(t.ab[i]) || t.isSelected) return;
                    t.isSelected = !0, t._onClickBundleNodeDeferred(r).done(function() {
                        return t.ab.thankNode.play("buy_thank").processDeferred("action_stop")
                    }).always(function() {
                        t.isSelected = !1, e()
                    })
                })
            }), this.flush()
        },
        _onClickBundleNodeDeferred: function(e) {
            return o.buyVCBundleDeferred(this.vcBundles[e].sku)
        },
        setupDeferred: function() {
            var e = this,
                t = u.Deferred();
            return o.getVCBundlesDeferred().done(function(n) {
                e.vcBundles = n, e._setupBundles(), t.resolve()
            }).fail(function() {
                t.reject()
            }), t.promise()
        },
        _setupBundles: function() {
            var t = this;
            if (!this.vcBundles) return;
            e.each(f, function(e, r) {
                var i = n("bundleNode%s", e),
                    s = t.ab[i];
                if (r < t.vcBundles.length) {
                    var o = t.vcBundles[r],
                        u = o.title || o.sku;
                    u = u.replace("Gem ", "");
                    var a = o.value + " Gems";
                    s.setText(n("buy_select_menu_word_%s", e), u).process(), s.setText(n("buy_select_gem_num_%s", e), a).process(), s.setText(n("text_buy_select_bt_%s", e), o.displayPrice).process(), s.setVisible(!0)
                }
            }), this.flush()
        },
        setButtonVisibility: function(t) {
            var r = this;
            e.each(f, function(e) {
                r.ab[n("bundleNode%s", e)].setVisible(t)
            }), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        deleteNodes: function() {
            e.each(this.ab, function(e) {
                e.deleteNode()
            }), this.flush(), this.ab = {}
        },
        dispose: function() {
            FF.logger.debug("VCListView: dispose")
        },
        _createNode: function(e) {
            var t = this.ab.bundleGroupNode.createChildNode(e);
            return t
        },
        _createBtnNode: function(e, t) {
            var n = this._createNode(e);
            return this._createBtnNodeFromNode(n, t)
        },
        _createBtnNodeFromNode: function(e, t) {
            var n = this;
            return this._setBtnEnable(e, !0), e.addCallback("action_touch_began", function() {
                if (!n._isBtnEnable(e)) return;
                if (!n._lockBtnTap(e)) return;
                n.touchBeganDeferred = e.play("tap").processDeferred("action_stop")
            }), e.addCallback("action_touch_ended", function() {
                if (!n._isLockedBtnTap(e) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    FF.SoundMgr.playChooseEffect(), n.touchBeganDeferred = void 0, t(function() {
                        e.play("reset").process(), n._unlockBtnTap()
                    })
                })
            }), e.addCallback("action_touch_exited", function() {
                if (!n._isLockedBtnTap(e) || !n.touchBeganDeferred) return;
                n.touchBeganDeferred.then(function() {
                    e.play("reset").process(), n.touchBeganDeferred = void 0, n._unlockBtnTap()
                })
            }), e
        },
        _setBtnEnable: function(e, t) {
            this.btnEnableInfo[e.name] = t
        },
        _isBtnEnable: function(e) {
            return this.btnEnableInfo[e.name] ? !0 : !1
        },
        _playBtnEnable: function(e) {
            this._isBtnEnable(e) ? e.play("reset", {
                autoRemove: !1
            }) : e.play("bt_disable", {
                autoRemove: !1
            }), this.flush()
        },
        _lockBtnTap: function(e) {
            return this._tappingBtnName ? !1 : (this._tappingBtnName = e.name, !0)
        },
        _isLockedBtnTap: function(e) {
            return !!this._tappingBtnName && this._tappingBtnName === e.name
        },
        _unlockBtnTap: function() {
            this._tappingBtnName = void 0
        }
    }), FF.ns.battle.view.VCListView
}), define("scenes/battle/view/animation/ReraiseRiseAnimation", ["underscore", "./AnimationBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.view.animation.ReraiseRiseAnimation = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.helper = new n.view.animation.AnimationHelper(this)
        },
        play: function() {
            t.prototype.play.call(this);
            var n = this,
                r = this.data;
            this.helper.showMessageByAbilityInfo(r.abilityInfo, r.executerInfo);
            var i = e.map(r.receiverInfo, function(e) {
                return n.helper.createReraiseRiseHitNode(e)
            });
            return n.helper.playHitNextDeferredByHitNode(i).then(function() {
                var t = [];
                return e.each(r.receiverInfo, function(e) {
                    var r = n.viewController.getActorView(e.posInfo);
                    t.push($.when(r.playHpRecoveryDeferred(-1 * e.damage), r.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp)))
                }), $.when.apply(null, t)
            }).then(function() {
                n.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/GutsRiseAnimation", ["underscore", "./AnimationBase"], function(e, t) {
    var n = FF.ns.battle;
    FF.ns.battle.view.animation.GutsRiseAnimation = t.extend({
        initialize: function() {
            t.prototype.initialize.apply(this, arguments), this.helper = new n.view.animation.AnimationHelper(this)
        },
        play: function() {
            t.prototype.play.call(this);
            var n = this,
                r = this.data;
            this.helper.showMessageByAbilityInfo(r.abilityInfo, r.executerInfo);
            var i = e.map(r.receiverInfo, function(e) {
                return n.helper.createGutsRiseHitNode(e)
            });
            return n.helper.playHitNextDeferredByHitNode(i).then(function() {
                var t = [];
                return e.each(r.receiverInfo, function(e) {
                    var r = n.viewController.getActorView(e.posInfo);
                    t.push($.when(r.playHpRecoveryDeferred(-1 * e.damage), r.setLifeGaugeMotionDeferred(e.prevHp, e.currHp, e.maxHp)))
                }), $.when.apply(null, t)
            }).then(function() {
                n.playEnd()
            })
        }
    })
}), define("scenes/battle/view/animation/MessageAnimation", ["underscore", "util", "lib/ab/ABNode", "./AnimationBase"], function(e, t, n, r) {
    var i = FF.ns.battle;
    FF.ns.battle.view.animation.MessageAnimation = r.extend({
        initialize: function() {
            r.prototype.initialize.apply(this, arguments), this.helper = new i.view.animation.AnimationHelper(this), this.callback = void 0
        },
        play: function() {
            r.prototype.play.call(this);
            var e = this.data.messageInfo;
            e.callback && (this.callback = e.callback), e = t.cloneDeep(e), e.callback = this.playEnd.bind(this), this.helper.showMessage(e)
        },
        playEnd: function() {
            r.prototype.playEnd.call(this), this.callback && this.callback()
        }
    })
}), define("scenes/battle/view/animation/WaitAnimation", ["./AnimationBase"], function(e) {
    var t = FF.ns.battle,
        n = 1e3;
    FF.ns.battle.view.animation.WaitAnimation = e.extend({
        initialize: function() {
            e.prototype.initialize.apply(this, arguments), this.helper = new t.view.animation.AnimationHelper(this)
        },
        play: function() {
            e.prototype.play.call(this);
            var r = this,
                i = this.data,
                s = this.data.options.waitTime || n;
            this.helper.showMessageByAbilityInfo(i.abilityInfo, i.executerInfo), t.BattleInfo.getInstance().isMo() && this.helper.showAttackNameBalloon(this.data.executerInfo, this.data.abilityInfo), t.util.DelayCallback.register(s, function() {
                r.playEnd()
            })
        },
        playEnd: function() {
            e.prototype.playEnd.call(this)
        }
    })
}), define("scenes/battle/BattleScene", ["util", "lib/Ticker", "lib/Scene", "lib/Battle", "lib/BattleConfig", "lib/BattleStorage", "lib/JsLoader", "lib/Watchdog", "lib/Cipher", "backbone", "jquery", "pako", "lib/Chara", "./AbilityFactory", "./AbilityInfoMgr", "./AbilityMgr", "./ActiveTarget", "./ActorBase", "./ActorBuddy", "./ActorSupporter", "./ActorEnemy", "./ActorMgr", "./ActorParamHolder", "./ActorTimeMgr", "./Api", "./BattleEventMgr", "./BattleEventMgr", "./BattleFsm", "./BattleInfo", "./BattleInitData", "./BattleLog", "./BattleProcessMgr", "./BattleResultFsm", "./BattleScene", "./BattleViewController", "./SupporterViewController", "./BuddyPartyMgr", "./Commander", "./Conf", "./Config", "./ContinueBonus", "./ContinueFsm", "./ContinueTxn", "./Counters", "./DataConstructor", "./ActorStats", "./actorStats/StatsBase", "./actorStats/DamageReceiveCount", "./actorStats/DamageReceiveCountConfig", "./DeathFsm", "./Debug", "./EnemyContainer", "./EnemyParty", "./EnemyPartyMgr", "./EventFsm", "./ExpireFsm", "./ExternalFunc", "./ExternalUserAuth", "./MoSnsShareHelper", "./LotteryBox", "./MateriaFactory", "./MateriaHolder", "./MateriaUnifier", "./Message", "./PreBattleFsm", "./RemoteLogger", "./Score", "./StatusAilments", "./StatusAilmentsConfig", "./TextMaster", "./ParameterEncoder", "./action/ActionBase", "./action/helper/ActionHelper", "./action/helper/MoActionHelper", "./action/helper/AnimationHelper", "./action/BuiltinHealDeathAction", "./action/BuiltinIncreaseMpAction", "./action/BuiltinInflictSaAction", "./action/BuiltinHealHpByDamageSumAction", "./action/BuiltinHealHpAction", "./action/BuiltinEnemyMultipleAbilityAction", "./action/BuiltinFractionalHealHpAction", "./action/BuiltinHealSaAction", "./action/CustomParamAction", "./action/CustomParamDeformAction", "./action/CustomParamAndSelfDestructAction", "./action/CustomParamAndInflictHpStockAction", "./action/DoNothingAction", "./action/DoNothingStrictlyAction", "./action/DamagedHpAttackAction", "./action/DealSsPointAction", "./action/DefenseAction", "./action/DeformAction", "./action/DeformMultiAction", "./action/DoNothingAction", "./action/EnemyJumpAction", "./action/FractionalAttackByHpAction", "./action/FractionalAttackByMaxHpAction", "./action/FractionalAttackByHpWithoutSaAction", "./action/FractionalAttackByHpWithoutSaAndInflictSaAction", "./action/FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAction", "./action/FractionalAttackByHpWithoutSaAndInflictSaMultiAndHealSaMultiAndDeformAction", "./action/FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAction", "./action/FractionalAttackByHpAndInflictSaMultiAndHealSaMultiAndDeformAction", "./action/FractionalHealByHpAction", "./action/FractionalHealByHpAndInflictSaAction", "./action/PhysicalAttackElementAndCustomParamAction", "./action/HealDeathAction", "./action/ReraiseRiseAction", "./action/GutsRiseAction", "./action/HealHpAction", "./action/HealHpAndCustomParamAction", "./action/HealHpAndInflictSaAndSelfCustomParamAction", "./action/HealHpAndInflictSaMultiAndHealSaMultiAction", "./action/HealHpAndInflictSaMultiAndHealSaMultiAndDeformAction", "./action/HealHpAndHealSaMultiAction", "./action/HealHpAndHealSaAction", "./action/HealSaAction", "./action/HealSaLotAction", "./action/HealSaMultiAction", "./action/HealAndInflictSaAction", "./action/HealHpAndInflictHpStockAction", "./action/InflictSaAction", "./action/InflictSaAndFallbackMagicAttackAction", "./action/InflictSaAndIncreaseMpAction", "./action/InflictSaHitAction", "./action/InflictSaHitAndDeformAction", "./action/JumpAction", "./action/PhysicalAttackMultiAndSelfSaMultiAction", "./action/LotAction", "./action/MagicAttackAction", "./action/MagicAttackAndAbsorbHpAction", "./action/MagicAttackAndDefIgnoredAction", "./action/MagicAttackAndDefIgnoredAndDeformAction", "./action/MagicAttackAndDeformAction", "./action/MagicAttackAndDefBoostIgnoredAction", "./action/MagicAttackMultiAction", "./action/MagicAttackMultiAndDeformAction", "./action/MagicAttackMultiWithMultiSaAction", "./action/MagicAttackAndHealHpAction", "./action/MagicAttackAndHealSelfHpAction", "./action/MagicAttackAndHealSelfHpAndDeformAction", "./action/MagicAttackAndPhysicalAttackElementAction", "./action/MagicAttackMultiAndPartyCustomParamAction", "./action/MagicAttackMultiAndInflictSaMultiAndHealSaAction", "./action/MagicAttackMultiAndInflictSaAndCustomParamAction", "./action/MagicAttackMultiAndHealHpAndCustomParamAction", "./action/PhysicalAttackWithMultiSaAction", "./action/ParamBoosterAction", "./action/PhysicalAttackAction", "./action/PhysicalAttackAndAbsorbHpAction", "./action/PhysicalAttackAndAbsorbHpAndReduceMpAction", "./action/PhysicalAttackAndCustomParamAction", "./action/PhysicalAttackAndCustomParamDeformAction", "./action/PhysicalAttackAndDefIgnoredAction", "./action/PhysicalAttackMultiAndHpBarterAction", "./action/PhysicalAttackCriticalOrMissAction", "./action/PhysicalAttackElementAction", "./action/PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAction", "./action/PhysicalAttackElementAndInflictSaMultiAndHealSaMultiAndDeformAction", "./action/PhysicalAttackHitAction", "./action/PhysicalAttackMultiAction", "./action/PhysicalAttackMultiWithMultiParamsAction", "./action/PhysicalAttackMultiWithMultiSaAction", "./action/PhysicalAttackMultiWithHealSaAction", "./action/PhysicalAttackWithoutAimingBySaAction", "./action/PhysicalAttackAndSelfCustomParamAction", "./action/PhysicalAttackAndPartyCustomParamAction", "./action/MagicAttackAndSelfCustomParamAction", "./action/CustomParamBidirectionallyAction", "./action/PhysicalInflictSaBidirectionallyAction", "./action/PhysicalAttackMultiAndInflictSaAndCustomParamAction", "./action/PhysicalAttackMultiAndHealSaMultiAction", "./action/PhysicalAttackElementMultiAndSelfSaAndSelfCustomParamAction", "./action/ReduceMpAction", "./action/IncreaseMpAction", "./action/IncreaseFixedMpAction", "./action/SaPoisonAction", "./action/SaRegenAction", "./action/SaHpStockAction", "./action/SaRadiantShieldAction", "./action/SelfDestructAction", "./action/SelfDestructAndDeformAction", "./action/FixedDamageAction", "./action/FixedDamageMultiAction", "./action/FixedDamageMultiAndCustomParamAndInflictSaMultiAction", "./action/FixedDamageAndHealSaMultiAndInflictSaAndDeformAction", "./action/FixedDamageAndDeformAction", "./action/FixedDamageAndHealSaMultiAndInflictSaAndDeformAction", "./action/LvInflictSaAction", "./action/MagicAttackAndCustomParamAction", "./action/FixedHpAction", "./action/FixedHpAndDeformAction", "./action/MagicAttackAndHealDeathAction", "./action/PhysicalAttackWithHealSaAction", "./action/PhysicalAttackMultiAndDeformAction", "./action/PhysicalAttackAndDeformAction", "./action/ShowAbilityEffectAction", "./action/PhysicalDamagedHpAttackAction", "./action/PhysicalAttackAndSelfSaAction", "./action/PhysicalAttackMultiAndColleagueSaAndCustomParamAction", "./action/PhysicalAttackMultiAndSelfSaAction", "./action/PhysicalAttackMultiAndCustomParamAndHealSaMultiAction", "./action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamAction", "./action/PhysicalAttackMultiAndCustomParamAndSelfCustomParamWithEffectAction", "./action/PhysicalAttackMultiAndCustomParamAndSelfSaAction", "./action/PhysicalAttackMultiAndSelfAttachElementAction", "./action/PhysicalAttackMultiAndSelfCustomParamAction", "./action/PhysicalAttackElementMultiAndIncreaseMpAction", "./action/InflictSaAndCustomProbabilityDeformAction", "./action/ShowAbilityEffectDeformAction", "./action/PhysicalAttackMultiAndHealHpAction", "./action/CustomParamMultiAndInflictSaMultiAction", "./action/WrappedAbilityActionBase", "./action/RageAction", "./action/TranceAction", "./action/PhysicalAttackElementAndInflictSaAndSelfSaAction", "./action/AttachElementAction", "./action/CustomParamMultiAction", "./action/PhysicalAttackElementMultiAndSelfCustomParamAction", "./action/PhysicalAttackElementMultiAndPartyCustomParamAction", "./action/PhysicalAttackWithMultiHealSaAction", "./action/ChangeCastTimeAction", "./action/HealHpAndHealDeathAction", "./action/HealHpOrHealDeathAction", "./action/MagicAttackMultiAndSelfSaAction", "./action/MagicAttackAndInflictSaMultiAction", "./action/MagicAttackAndInflictSaMultiAndHealSaMultiAction", "./action/MagicAttackAndInflictSaMultiAndHealSaMultiAndDeformAction", "./action/MagicAttackAndAbsorbHpAndDeformAction", "./action/HealSaMultiAndDeformAction", "./action/PhysicalAttackAndAbsorbHpAndDeformAction", "./action/FractionalAttackByHpOnAttackerHpAction", "./action/HealHpAndIncreaseMpAction", "./action/PhysicalAttackMultiDependedOnSaAction", "./action/PhysicalAttackMultiAndCustomParamAndPartyCustomParamAction", "./action/ExecAbilityBySelfSaAction", "./action/ExecAbilityByStatusAction", "./action/ExecAbilityByUsedAbilityCountAction", "./action/ExecAbilityByCondThresholdAction", "./action/ExecAbilityWithNoEffectSelfCustomParamAndSelfSaAction", "./action/PhysicalAttackMultiAndHealHpByHitDamageAction", "./action/MagicAttackMultiAndHealHpByHitDamageAction", "./action/PhysicalAttackMultiAndAttachElementAsDisadvantageAction", "./action/MagicAttackMultiWithMultiElementAction", "./action/PhysicalAttackMultiWithMultiElementAction", "./action/MagicAttackMultiAndSelfAttachElementAction", "./action/CustomParamMultiAndHpBarterAction", "./action/MagicAttackMultiAndSelfSaAndSelfCustomParamAction", "./action/MagicAttackMultiAndHpBarterAction", "./action/PhysicalAttackAndDefIgnoredAndDeformAction", "./action/CustomParamAndInflictSaDirectionSelectiveAction", "./action/AttachElementAsDisadvantageAndCustomParamAndInflictSaDirectionSelectiveAction", "./action/CustomParamAndInflictSaAndSelfAttachElementAction", "./action/MagicAttackMultiAndAttachElementAsDisadvantageAction", "./action/MagicAttackMultiWithMultiElementAndFractionalHealHpAction", "./action/MagicAttackMultiAndColleagueSaAction", "./action/MagicAttackMultiAndSelfCustomParamAction", "./action/PhysicalAttackElementMultiAndColleagueSaAction", "./action/PhysicalAttackMultiAndAttachElementAsDisadvantageWithMultiElement", "./action/PhysicalAttackMultiWithMultiElementAndFractionalHealHpAndHealSaMultiAction", "./action/HealHpAndSelfCustomParamAction", "./action/FractionalHealByHpAndHealSaMultiAndCustomParamAction", "./action/MagicAttackMultiAndHealHpAndInflictSaAction", "./action/FixedHealHpAction", "./action/ExecAbilityByTargetWeaknessAction", "./action/MagicAttackElementMultiAndSelfIncreaseMpAction", "./action/HealSaMultiDirectionSelectiveAction", "./action/MagicAttackMultiWithHealSaAction", "./ai/AiUtil", "./ai/AiArgument", "./ai/Constraint", "./action/PhysicalAttackElementMultiAndSelfCustomParamWithEffectAction", "./ai/StateSnippet", "./ai/stateSnippet/HpRateTransition", "./ai/stateSnippet/HpRateTransitionV2", "./ai/stateSnippet/Wave", "./ai/State", "./ai/StateMap", "./ai/StateMapBuilder", "./ai/TransitCondition", "./ai/Transition", "./ai/ConditionFlag", "./ai/ResultObjectTmp", "./ai/resultObjectTmp/BoostResultObjectTmp", "./ai/resultObjectTmp/DamageResultObjectTmp", "./ai/resultObjectTmp/BuddyDamageResultObjectTmp", "./ai/state/DoNothingState", "./ai/state/DoNothingStrictlyState", "./ai/state/InitState", "./ai/state/InterruptAbility", "./ai/state/InterruptMultipleAbility", "./ai/state/SimpleState", "./ai/state/SimpleWithoutState", "./ai/transition/NextStateIdTransition", "./ai/transitCondition/AbilityCountTransitCondition", "./ai/transitCondition/EachDamageTransitCondition", "./ai/transitCondition/DamageTransitCondition", "./ai/transitCondition/DamageTransitConditionV2", "./ai/transitCondition/TimeTransitCondition", "./ai/transitCondition/TurnTransitCondition", "./fsm/State", "./fsm/StateMap", "./fsm/TransitCondition", "./fsm/Transition", "./materia/MateriaHelper", "./materia/FirstAttackMateria", "./materia/PanelNumMateria", "./materia/PanelNumMateriaByCategory", "./materia/PanelNumMateriaByMultiCategory", "./materia/PanelSwapMateria", "./materia/PanelSwapAbilityInfoMateria", "./materia/PanelRandomSwapMateria", "./materia/PanelSwapAndInflictSaMateria", "./materia/ParamMateria", "./materia/ParamAndInflictSaMateria", "./materia/InflictSaMateria", "./materia/InflictSaWhenHpFallsMateria", "./materia/DamageBoostWhenWeaknessMateria", "./materia/DamageBoostElementMateria", "./materia/DamageBoostByWeaponMateria", "./materia/BlackMagicDamageBoostByWeaponMateria", "./materia/DamageBoostByEquipmentAndExerciseTypeMateria", "./materia/DamageBoostAbilityMateria", "./materia/DamageBoostByWeaponWithAllowableTypesMateria", "./materia/HealBoostMateria", "./materia/CounterMateria", "./materia/ParamBoostInBuddyDeadMateria", "./materia/ParamBoostInHpDecreaseMateria", "./materia/ParamBoostByArmorMateria", "./materia/ParamBoostByWeaponMateria", "./materia/SoulStrikePointFactorBoostMateria", "./materia/SeqActionByCategoryMateria", "./materia/DamageReduceMateria", "./materia/MateriaBase", "./recept/AbilityPanel", "./recept/ReceptBase", "./recept/Skip", "./recept/SoulStrike", "./recept/SoulStrikePanel", "./recept/SupporterSoulStrike", "./recept/PositiveIncontrollable", "./util/DamageCalculator", "./util/DamageCalculateHook", "./util/DamageCalculateParamAdjuster", "./util/DelayCallback", "./util/DropItem", "./util/Targeting", "./util/EnemyTargeting", "./util/PanelTargeting", "./util/ParamCalculator", "./view/AbilityPanelView", "./view/BackgroundView", "./view/BuddyView", "./view/CommandView", "./view/MateriaDropView", "./view/DropItemView", "./view/EnemyContainer", "./view/EnemyView", "./view/MenuWindowView", "./view/LoadingView", "./view/MessageView", "./view/SoulStrikeView", "./view/SoulStrikeSelectorView", "./view/SoulStrikeGauge", "./view/StatusAilmentsView", "./view/ContinueBonusView", "./view/TargetArrowView", "./view/TutorialBattleView", "./view/animation/AbilityBarrageAnimation", "./view/animation/AbilitySingleAnimation", "./view/animation/AbilitySingleAndDeformAnimation", "./view/animation/AbilityBarrageAndDeformAnimation", "./view/animation/AnimationBase", "./view/animation/AnimationFactory", "./view/animation/AnimationHelper", "./view/animation/AppearanceAnimation", "./view/animation/AttackAnimation", "./view/animation/InvalidityAnimation", "./view/animation/DamageAnimation", "./view/animation/DamageBarrageAnimation", "./view/animation/DeadAnimation", "./view/animation/DeformAnimation", "./view/animation/DropItemAnimation", "./view/animation/JumpInAnimation", "./view/animation/JumpOutAnimation", "./view/animation/JumpInAndBarrageAnimation", "./view/animation/TransitionAnimation", "./view/animation/EnemyJumpAnimation", "ww/scenes/battle/view/VCListView", "./view/animation/ReraiseRiseAnimation", "./view/animation/GutsRiseAnimation", "./view/animation/MessageAnimation", "./view/animation/WaitAnimation"], function(e, t, n, r, i, s, o, u, a, f, l, c) {
    var h = "battle/ai/conf/%d",
        p = 2,
        d = FF.ns.battle;
    return n.extend({
        initialize: function(e) {
            e = e || {}, FF.logger.debug("call BattleScene initialize!"), this.isFinished = !1, this._fpsCount = 0, this._fpsBaseTime = 0, this._frame = 0
        },
        setupDeferred: function() {
            var e = this,
                t = this.getErrorHandler(),
                n = void 0;
            return l.Deferred().resolve().promise().then(t.bindTryCatchDeferred(function() {
                return n = "4017", FF.logger.debug("checkSession"), e._checkSessionDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4020", FF.logger.debug("loadStorage"), s.loadDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4033", FF.logger.debug("requestBattleData"), e._requestBattleDataDeferred()
            })).then(t.bindTryCatchDeferred(function(e) {
                n = "4046", FF.logger.debug("validate data");
                var t = new d.BattleInitData(e);
                d.BattleInfo.getInstance().load(t.validate())
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4059", i.loadBattleConfigDeferred().then(function(e) {
                    d.BattleInfo.getInstance().setBattleConfig(e)
                })
            })).then(t.bindTryCatchDeferred(function() {
                n = "4062", FF.logger.debug("loadAbility");
                var e = d.BattleInfo.getInstance().getBattleInitData(),
                    t = e.battle,
                    r = [];
                r = r.concat(t.enemyAbilities), _.each(t.buddy, function(e) {
                    r = r.concat(_.values(e.abilities)), _.each(e.soulStrikes, function(e) {
                        r.push(e)
                    })
                }, this), _.each(t.supporter, function(e) {
                    r = r.concat(_.values(e.abilities)), r.push(e.soulStrikes[0])
                }, this), d.AbilityInfoMgr.getInstance().load(r)
            })).then(t.bindTryCatchDeferred(function() {
                return n = "4075", FF.logger.debug("requestDynamicJs"), e._requestDynamicJsDeferred()
            })).then(t.bindTryCatchDeferred(function() {
                n = "4088";
                var e = d.BattleInfo.getInstance().getBattleInitData();
                return d.Message.load(e.battle.messages), d.BattleViewController.getInstance().loadDeferred(e)
            })).fail(function(e) {
                if (!FF.env.isNative()) throw e;
                window.onErrorFunc(e, n), n === "4033" && d.Api.sendBattleErrorDeferred(e, n)
            })
        },
        _checkSessionDeferred: function() {
            var e = l.Deferred();
            if (!FF.env.isNative()) return e.resolve().promise();
            if (FF.env.isTutorial()) return e.resolve().promise();
            var t = d.BattleInfo.getInstance().getAppInitDataSessionKey();
            return r.checkSessionAndUpdateDeferred(t)
        },
        navigate: function(e, t) {
            d.BattleViewController.getInstance().deactivateABScreen(), f.history.navigate(e, t)
        },
        redirect: function(t, n) {
            n = e.option({
                noFadeOut: !1
            }, n);
            var r = d.BattleViewController.getInstance(),
                i = function() {
                    r.deactivateABScreen(), FF.redirect(t)
                };
            if (n.noFadeOut) {
                i();
                return
            }
            r.playFadeOutDeferred().then(i)
        },
        redirectTop: function() {
            FF.scene.redirect("/dff/", {
                noFadeOut: !0
            })
        },
        start: function() {
            var e = this;
            d.BattleInfo.getInstance().set("isPlaying", !0), this.defineOnAppForeground();
            var n = this.getErrorHandler();
            n.onError = function(e) {
                FF.env.isNative() && d.BattleViewController.getInstance().showSystemWindow(d.Conf.SYSTEM_WINDOW.ERROR), FF.scene.suspend(), FF.logger.debug(e.message, e.stack)
            }, d.ExternalUserAuth.checkExternalUserAuthCallDeferred().always(function() {
                e.battleEventMgr = new d.BattleEventMgr, e.listenTo(t, "tick", n.bindTryCatch(e._update, e)), e.ticker = t
            }), d.MoSnsShareHelper.checkAndClearForSnsShareDeferred()
        },
        defineOnAppForeground: function() {
            if (!FF.env.isNative()) return;
            kickmotor.nativefn.onApplicationForeground = function() {
                d.BattleViewController.getInstance().startPause(), FF.env.checkMobageLoginDeferred().then(function(e) {
                    e ? d.ExternalUserAuth.checkExternalUserAuthCallDeferred() : d.BattleViewController.getInstance().showSystemWindow(d.Conf.SYSTEM_WINDOW.LOGIN)
                }), d.MoSnsShareHelper.checkAndClearForSnsShareDeferred(), kickmotor.nativefn.getRemoteNotificationLog(function(e) {
                    if (!e) return;
                    d.RemoteLogger.pushRemoteNotificationInfomation(e)
                })
            }
        },
        clearOnAppForeground: function() {
            if (!FF.env.isNative()) return;
            kickmotor.nativefn.onApplicationForeground = function() {}
        },
        suspend: function() {
            if (!d.BattleInfo.getInstance().get("isPlaying")) return;
            d.BattleInfo.getInstance().set("isPlaying", !1), d.BattleViewController.getInstance().suspendAnime(), FF.SoundMgr.pause()
        },
        resume: function() {
            if (d.BattleInfo.getInstance().get("isPlaying")) return;
            d.BattleInfo.getInstance().set("isPlaying", !0);
            var e = d.BattleViewController.getInstance();
            e.resumeAnime(), FF.env.isTutorial() && e.tutorialBattleView.setVisible(!0), FF.SoundMgr.resume()
        },
        escape: function() {
            var e = this;
            d.BattleViewController.getInstance().resumeAnime(), d.BattleResultFsm.sendEscapeResultDeferred().done(function(t) {
                e.saveBattleConfigDeferred().then(function() {
                    s.removeDataDeferred().then(function() {
                        var n = d.BattleInfo.getInstance();
                        n.set("resultInfo", {
                            data: t
                        }), e._transferEscapePage()
                    })
                })
            })
        },
        toggleDoubleSpeed: function() {
            this.isDoubleSpeed ? (d.BattleViewController.getInstance().setUpdateTimeSpeed(1), this.isDoubleSpeed = !1) : (d.BattleViewController.getInstance().setUpdateTimeSpeed(p), this.isDoubleSpeed = !0)
        },
        saveBattleConfigDeferred: function() {
            return i.saveBattleConfigDeferred(d.BattleInfo.getInstance().getBattleConfig())
        },
        _requestBattleDataDeferred: function() {
            var e = this;
            if (!FF.env.isNative()) return l.Deferred().resolve(this._battleInitData).promise();
            if (a.isClientAesKeyClientVersion() && !1) {
                var t = l.Deferred();
                return this._requestBattleDataWithEncryptionDeferred().then(function(e) {
                    t.resolve(e)
                }).fail(function(n) {
                    var r = n && n.message || "";
                    e._requestBattleDataWithDigestDeferred().then(function(e) {
                        t.resolve(e)
                    }).fail(function(e) {
                        var n = e && e.message || "",
                            i = "1000001";
                        r && (i += " " + r), n && (i += " " + n), t.reject({
                            message: i
                        })
                    })
                }), t.promise()
            }
            return this._requestBattleDataWithDigestDeferred()
        },
        _requestBattleDataWithEncryptionDeferred: function() {
            var e = l.Deferred(),
                t = this.getErrorHandler(),
                n = null,
                r = null,
                i = null,
                s = function(e) {
                    try {
                        n = n || "", r = r || "", i = i || "";
                        var t = n.length + " " + r.length + " " + i.length + " ";
                        t += n + r + i;
                        var s = btoa(c.deflate(t, {
                            to: "string"
                        }));
                        d.Api.warnDeferred(JSON.stringify({
                            error: e,
                            message: s
                        }))
                    } catch (o) {
                        d.Api.warnDeferred(JSON.stringify({
                            error: e,
                            message: "failed to send battle init data log."
                        }))
                    }
                };
            return a.getAesKeyDeferred().then(function(e) {
                return n = e, d.Api.getBattleInitDeferred(e)
            }, function(t) {
                e.reject({
                    message: "1000002"
                })
            }).then(t.bindTryCatchDeferred(function(t, n, i) {
                if (t.success) return r = t.value, a.decryptTextDeferred(t.value);
                e.reject({
                    message: "1000003"
                })
            }), function() {
                e.reject({
                    message: "1000004"
                })
            }).then(function(t) {
                i = t;
                var n;
                try {
                    n = JSON.parse(i)
                } catch (r) {
                    s("failed to parse decrypted data"), e.reject({
                        message: "1000005"
                    });
                    return
                }
                try {
                    n.resClientSnapshot = d.ParameterEncoder.snapshotResponse(n)
                } catch (r) {
                    s("failed to build client snapshot"), e.reject({
                        message: "1000006"
                    });
                    return
                }
                e.resolve(n)
            }).fail(function() {
                s("unknown error"), e.reject({
                    message: "1000007"
                })
            }), e.promise()
        },
        _requestBattleDataWithDigestDeferred: function() {
            var e = l.Deferred(),
                t = this.getErrorHandler(),
                n = null;
            return d.Api.getBattleInitDeferred().then(t.bindTryCatchDeferred(function(e, t, r) {
                return n = e, a.verifyDigestDeferred(r.responseText, r.getResponseHeader("Ff-chk"))
            }), function() {
                e.reject({
                    message: "1000008"
                })
            }).then(function(t, r) {
                n.initChkResult = t, n.initChkResultText = r, n.resClientSnapshot = d.ParameterEncoder.snapshotResponse(n), e.resolve(n)
            }, function() {
                e.reject({
                    message: "1000009"
                })
            }).fail(function() {
                e.reject({
                    message: "1000010"
                })
            }), e.promise()
        },
        _requestDynamicJsDeferred: function() {
            var e = l.Deferred(),
                t = [],
                n = d.BattleInfo.getInstance().getEnemyContainerParams();
            _.each(n, function(e) {
                if (!e.aiId) return;
                t.push(e.aiId)
            });
            var r = d.BattleInfo.getInstance().getEnemyParams();
            _.each(r, function(e) {
                if (!e.aiId) return;
                t.push(e.aiId)
            }), t = _.uniq(t);
            var i = _.map(t, function(e) {
                return sprintf(h, e)
            });
            return o.load(i, function() {
                e.resolve()
            }), e.promise()
        },
        _transferNextScene: function() {
            var e = d.BattleInfo.getInstance();
            if (e.get("isExpired")) {
                this._exit();
                if (!FF.env.isNative()) return;
                this.redirectTop();
                return
            }
            if (e.get("isAllEnded")) {
                this._exit();
                if (!FF.env.isNative()) return;
                var t = d.BattleViewController.getInstance();
                e.isVictory() ? this._transferWinPage() : e.isLose() ? this._transferLosePage() : e.isForceEscape() && this._transferEscapePage()
            }
        },
        _transferWinPage: function() {
            var e = d.BattleViewController.getInstance(),
                t = d.BattleInfo.getInstance();
            t.isResultAlreadyEnded() ? e.showSystemWindow(d.Conf.SYSTEM_WINDOW.BATTLE_RESULT, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : t.isResultExpired() ? e.showSystemWindow(d.Conf.SYSTEM_WINDOW.EXPIRE, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : t.isResultError() ? e.showSystemWindow(d.Conf.SYSTEM_WINDOW.ERROR, function() {
                FF.scene.redirect(t.detectUrlFromResultInfo())
            }) : (this.clearOnAppForeground(), FF.battleResult = t.get("resultInfo").data, FF.battleResult.battleLayers = e.assetsManager.layerNames, this.navigate("battle_result", !0))
        },
        _transferLosePage: function() {
            var e = d.BattleInfo.getInstance();
            FF.scene.redirect(e.detectUrlFromResultInfo())
        },
        _transferEscapePage: function() {
            var e = d.BattleInfo.getInstance();
            FF.SoundMgr.stopMusic(), FF.SoundMgr.resume(), FF.scene.redirect(e.detectUrlFromResultInfo())
        },
        _exit: function() {
            this.isFinished = !0, t.reset(), this.stopListening()
        },
        _update: function(e) {
            this.elapsedTime = e;
            if (d.BattleInfo.getInstance().get("isPlaying")) {
                this._frame++, this.timeCompression > 0 && (this.elapsedTime *= this.timeCompression);
                var t = d.BattleInfo.getInstance().getBattleConfig().speed || 100;
                this.elapsedBattleTime = Math.floor(e * +t / 100), this.battleEventMgr.update(), d.BattleViewController.getInstance().update(), d.util.DelayCallback.update(this.elapsedTime, this.elapsedBattleTime), u.update(this.elapsedTime), d.BattleLog.update()
            }
            this._transferNextScene(), this._updateFps()
        },
        _updateFps: function() {
            if (!FF.env.isDevelop()) return;
            this._fpsCount++;
            var t = e.getTime(),
                n = t - this._fpsBaseTime;
            n > 1e3 && (this.fps = Math.floor(this._fpsCount / n * 1e3), this._fpsCount = 0, this._fpsBaseTime = t)
        },
        b: function() {
            return FF.env.b
        },
        c: function() {
            return FF.env.c
        },
        d: function() {
            return FF.env.f
        },
        dispose: function() {
            n.prototype.dispose.apply(this)
        }
    })
}), define("scenes/common/config/FriendInvite", ["lib/TextMaster"], function(e) {
    return {
        postingTextOf: {
            copy: "FINAL FANTASY Record Keeper",
            facebook: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            fb_messenger: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            twitter: function() {
                return e.getInstance().get("friend_invite_text_short")
            },
            mail: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            line: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            googleplus: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            whatsapp: function() {
                return e.getInstance().get("friend_invite_text_long")
            },
            other: function() {
                return e.getInstance().get("friend_invite_text_short")
            }
        }
    }
}), define("scenes/common/config/GoogleAnalytics", [], function() {
    var e = {
        BattleAnimationStart: "BattleAnimationStart",
        BattleAnimationResult: "BattleAnimationResult",
        EquipEnhancementAnimation: "EquipEnhancementAnimation",
        EquipEvolutionAnimation: "EquipEvolutionAnimation",
        AbilityGenerateAnimation: "AbilityGenerateAnimation",
        AbilityUpgradeAnimation: "AbilityUpgradeAnimation"
    };
    return {
        DIRECT_CALL_SCREEN_NAME_OF: e,
        screenNameToUrlRegex: {
            WorldTop: /^#?world$/,
            GameTop: /^#?title$/,
            DungeonsSelect: /^#?world\/dungeons\/[^\/]+$/,
            BattlesSelect: /^#?world\/battles\/[^\/]+$/,
            EventsTop: /^#?events$/,
            EventsDungeonsSelect: /^#?event\/[^\/]+\/[^\/]+\/dungeons$/,
            EventsBattleSelect: /^#?event\/[^\/]+\/[^\/]+\/battles\/[^\/]+$/,
            EventsPrizes: /^#?event\/[^\/]+\/[^\/]+\/prizes$/,
            PartyTop: /^#?party$/,
            EquipChangeEdit: /^#?party\/equipment_change\/[^\/]+$/,
            GachaLineUp: /^#?gacha$/,
            GachaTop: /^#?gacha\/top\/[^\/]+$/,
            GachaAnimation: /^#?gacha\/anim\/(free|item|coin)\/$/,
            GachaResult: /^#?gacha\/result\/$/,
            BattleLose: /^#?battle\/fail\/[^\/]+\/lose\/$/,
            DungeonsClear: /^#?world\/battles\/[^\/]+\/clear$/,
            EquipTop: /^#?party\/equipment_top$/,
            EquipLimitExpand: /^#?party\/possession_limit_expand\/equipment$/,
            EquipChangeTop: /^#?party\/equipment$/,
            GiftBox: /^#?gift_box$/,
            EquipEnhancement: /^#?party\/enhancement$/,
            EquipEnhancementSelect: /^#?party\/enhancement_selected\/[^\/]+$/,
            AbilityChangeEdit: /^#?party\/ability_change\/[^\/]+$/,
            AbilityTop: /^#?party\/ability_top$/,
            AbilityLimitExpand: /^#?party\/possession_limit_expand\/ability$/,
            EquipChangeEditWeapon: /^#?party\/equipment_change_detail\/[^\/]+\/weapon$/,
            EquipChangeEditArmor: /^#?party\/equipment_change_detail\/[^\/]+\/armor$/,
            AbilityChange: /^#?party\/ability$/,
            AbilityGenerate: /^#?party\/ability_generate$/,
            PartyEditTop: /^#?party\/party_edit$/,
            BattleOpeTop: /^#?battle\/operations$/,
            AbilityChangeEditSlot1: /^#?party\/ability_change_detail\/[^\/]+\/1$/,
            EquipChangeEditAccessory: /^#?party\/equipment_change_detail\/[^\/]+\/accessory$/,
            AbilityChangeEditSlot2: /^#?party\/ability_change_detail\/[^\/]+\/2$/,
            EquipEvolution: /^#?party\/evolution$/,
            AbilityUpgrade: /^#?party\/ability_upgrade$/,
            BattleLeave: /^#?battle\/fail\/[^\/]+\/leave\/$/,
            EquipEvolutionSelect: /^#?party\/evolution_selected\/[^\/]+$/,
            EventsIntro: /^#?event\/[^\/]+\/intro$/,
            Quest: /^#?quest$/
        }
    }
}), define("scenes/common/config/PartialTemplate", [], function() {
    return {
        paths: ["templates/achievement_room/views/AchivementInfoCondition", "templates/party/views/AbilityGenerationList", "templates/party/views/AbilityUpgradeList", "templates/common/EquipmentAttributeForSort"]
    }
}), define("scenes/common/Config", ["./config/FriendInvite", "./config/GoogleAnalytics", "./config/PartialTemplate"], function(e, t, n) {
    return {
        friendInvite: e,
        googleAnalytics: t,
        partialTemplate: n
    }
}), define("scenes/common/helper/FirstDungeonClearFlag", ["jquery", "lib/Storage"], function(e, t) {
    var n = "first_dungeon_clear_flag";
    return {
        saveDeferred: function(e) {
            var r = {
                isFirstClear: e
            };
            return t.setItemDeferred(n, JSON.stringify(r))
        },
        loadDeferred: function() {
            var r = e.Deferred();
            return t.getItemDeferred(n).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        },
        resetDeferred: function() {
            return t.removeItemDeferred(n)
        }
    }
}), define("scenes/common/helper/MissionBaseHelper", ["underscore", "jquery", "backbone", "lib/Storage"], function(e, t, n, r) {
    var i = {
        MISSION_STORAGE_DATA_KEY: "MISSION_STORAGE"
    };
    return {
        _storageData: null,
        _initializeStorageData: function() {
            this._storageData.achievedMissions = this._storageData.achievedMissions || []
        },
        _loadStorageDataDeferred: function() {
            var e = t.Deferred();
            return this._storageData ? e.resolve().promise() : (r.initDeferred().then(function(e) {
                return r.getItemDeferred(i.MISSION_STORAGE_DATA_KEY)
            }).then(function(t) {
                this._storageData = t.result ? JSON.parse(t.value) : {}, this._initializeStorageData(), e.resolve()
            }.bind(this)), e.promise())
        },
        _saveStorageDataDeferred: function() {
            var e = t.Deferred();
            return r.initDeferred().then(function(e) {
                return r.setItemDeferred(i.MISSION_STORAGE_DATA_KEY, JSON.stringify(this._storageData))
            }.bind(this)).then(function(t) {
                e.resolve()
            }), e.promise()
        },
        saveAchievedMissionsDeferred: function(e, n) {
            var r = t.Deferred();
            return n = n || {}, !e || e.length === 0 ? r.resolve().promise() : (n.isBattle || FF.datastore.missionCollection.add(e, {
                merge: !0
            }), this._loadStorageDataDeferred().then(function() {
                return this._storageData.achievedMissions = this._storageData.achievedMissions.concat(e), this._saveStorageDataDeferred()
            }.bind(this)).then(function() {
                r.resolve()
            }), r.promise())
        }
    }
}), define("scenes/common/models/LastWinDungeon", ["lib/Model"], function(e) {
    return e.extend({
        isSameWorld: function(e) {
            return this.get("world_id") === +e
        },
        hasRenderedDungeonListInThePast: function() {
            return !!this.get("hasRenderedDungeonListInThePast")
        },
        isJustReturningFromBattle: function(e) {
            return this.isSameWorld(e) ? !this.hasRenderedDungeonListInThePast() : !1
        }
    })
}), define("scenes/common/helper/LastWinDungeon", ["jquery", "underscore", "lib/Storage", "scenes/common/models/LastWinDungeon"], function(e, t, n, r) {
    var i = "LAST_WIN_DUNGEON";
    return {
        resetDeferred: function(e) {
            return n.setItemDeferred(i, JSON.stringify(e))
        },
        addDataDeferred: function(r) {
            var s = e.Deferred();
            return this.getDeferred().then(function(s) {
                if (!s) return e.Deferred().resolve().promise();
                var o = t.extend({}, s, r);
                return n.setItemDeferred(i, JSON.stringify(o))
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        getDeferred: function() {
            var t = this,
                r = e.Deferred();
            return n.getItemDeferred(i).then(function(e) {
                try {
                    var n = e.value ? JSON.parse(e.value) : null;
                    r.resolve(n)
                } catch (i) {
                    FF.logger.error("Failed JSON.parse:[" + e.value + "] " + i.message), t.removeDeferred().then(function() {
                        r.resolve()
                    })
                }
            }), r.promise()
        },
        removeDeferred: function() {
            return n.removeItemDeferred(i)
        },
        getModelDeferred: function() {
            var n = e.Deferred();
            return this.getDeferred().then(function(e) {
                var i = e && e.dungeonId ? FF.datastore.dungeonCollection.get(e.dungeonId) : null,
                    s = i ? new r(t.extend({}, i.attributes, e)) : null;
                n.resolve(s)
            }), n.promise()
        },
        addDataOfHasRenderedDungeonListInThePastDeferred: function() {
            return this.addDataDeferred({
                hasRenderedDungeonListInThePast: !0
            })
        }
    }
}), define("scenes/progress_map/LatestProgressData", ["lib/Storage"], function(e) {
    var t = {
        DUNGEON: "latest_dungeon_data",
        CAN_RETURN: "can_return_progress_map"
    };
    return {
        saveCanReturnDeferred: function(n) {
            var r = this,
                i = $.Deferred(),
                s = {
                    canReturn: n
                };
            return e.setItemDeferred(t.CAN_RETURN, JSON.stringify(s)).then(function(e) {
                i.resolve()
            }), i.promise()
        },
        saveDungeonDataByModelsDeferred: function(e, t) {
            if (e.isNormalWorld()) {
                var n = t.get("id"),
                    r = t.isForce(),
                    i = t.get("progress_map_level");
                return r ? this.saveDungeonDataDeferred(void 0, n, i, !0) : this.saveDungeonDataDeferred(n, void 0, i, !1)
            }
            return $.Deferred().resolve().promise()
        },
        saveDungeonDataDeferred: function(n, r, i, s) {
            var o = $.Deferred(),
                u = {
                    level: i,
                    dungeonId: void 0,
                    normalDungeonId: n,
                    forceDungeonId: r,
                    isForce: s
                };
            return e.setItemDeferred(t.DUNGEON, JSON.stringify(u)).then(function(e) {
                o.resolve()
            }), o.promise()
        },
        getCanReturnDeferred: function() {
            var n = this,
                r = $.Deferred();
            return e.getItemDeferred(t.CAN_RETURN).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        },
        getDungeonDataDeferred: function() {
            var n = this,
                r = $.Deferred();
            return e.getItemDeferred(t.DUNGEON).then(function(e) {
                var t = e.value ? JSON.parse(e.value) : {};
                r.resolve(t)
            }), r.promise()
        }
    }
}), define("scenes/battle_result/models/Score", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(e) {
            this.medalStatuses = [], _.each(e, _.bind(function(e) {
                var t = +e.medalNum,
                    n = [];
                for (var r = 0; r < t; r++) n.push(!1);
                this.medalStatuses.push(n)
            }, this)), this.maxMedalNum = this.medalStatuses.length * 3, this.medalSum = _.reduce(this.medalStatuses, function(e, t) {
                return e + t.length
            }, 0), this.currentIntervalRank = 0, this.thresGood = this.maxMedalNum / 2, this.thresExcellent = this.maxMedalNum * 5 / 6, this.startRatio = this.currentIntervalRatio = 0, this.currentIntervalMedalNum = 0, this.endRatio = this.medalSum / this.maxMedalNum
        },
        progress: function(e) {
            this.currentIntervalRatio += e, this.currentIntervalRatio >= this.endRatio && (this.currentIntervalRatio = this.endRatio);
            var t = this._calcMedalNum();
            this.trigger("update:gauge", this._getFrameByRatio(this.currentIntervalRatio)), t > this.currentIntervalMedalNum && this._showMedal(t - this.currentIntervalMedalNum), this.currentIntervalMedalNum = t, this._updateCurrentIntervalRank(), this.currentIntervalRatio >= this.endRatio && this.trigger("finish:animation")
        },
        _getFrameByRatio: function(e) {
            return e * 100 || 0
        },
        _calcMedalNum: function() {
            return Math.floor(this.maxMedalNum * this.currentIntervalRatio)
        },
        _showMedal: function(e) {
            _.each(this.medalStatuses, _.bind(function(t, n) {
                if (e === 0) return;
                var r = 0,
                    i = 0;
                _.each(t, function(e) {
                    e ? i++ : r++
                });
                if (!r) return;
                for (var s = i; s < t.length; s++) e > 0 && (this.medalStatuses[n][s] = !0, this.trigger("show:medal", n, s), e--)
            }, this))
        },
        _getRankByMedalNum: function(e) {
            return e >= this.thresExcellent ? 2 : e >= this.thresGood ? 1 : 0
        },
        _updateCurrentIntervalRank: function() {
            var e = this._getRankByMedalNum(this.currentIntervalMedalNum);
            if (e > this.currentIntervalRank) {
                for (var t = this.currentIntervalRank + 1; t <= e; t++) this.trigger("update:rank", t);
                this.currentIntervalRank = e
            }
        },
        _calcRankCoords: function(e) {
            var t = -250,
                n = 250,
                r, i = -10,
                s = (n - t) / this.maxMedalNum;
            if (e === 0) r = t;
            else if (e === 1) r = t + s * this.thresGood - 3;
            else {
                if (e !== 2) throw new Error("invalid rank " + e);
                r = t + s * this.thresExcellent - 7
            }
            return [r, i]
        },
        getRankNodeName: function() {
            var e = this._getRankByMedalNum(this.medalSum);
            return "rank_" + (e + 1) + "_nul"
        }
    });
    return t
}), define("scenes/battle_result/views/AnimationPool", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABNode", "lib/ClassBase"], function(e, t, n, r, i, s) {
    return s.extend({
        initialize: function(e) {
            e = e ? e : {}, this.interval = e.interval || 16, this.nodes = e.nodes || []
        },
        flush: function() {
            var t = [];
            e.each(this.nodes, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        start: function() {
            var e = this;
            this.timer = setInterval(function() {
                e.flush()
            }, this.interval)
        },
        stop: function() {
            clearInterval(this.timer)
        },
        dispose: function() {
            this.nodes = null, this.stop()
        }
    })
}), define("scenes/battle_result/views/ResultScore", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "util", "../models/Score", "./AnimationPool"], function(e, t, n, r, i, s, o, u) {
    var a = {
            SCORE_SOUND_MAP: {
                1: "SE_RESULT_NORMAL",
                2: "SE_RESULT_GOOD",
                3: "SE_RESULT_EXCELLENT"
            },
            SE: {
                SE_RESULT_EXCELLENT: "se_battle_common_101053",
                SE_RESULT_GOOD: "se_battle_common_101052",
                SE_RESULT_NORMAL: "se_battle_common_101051",
                SE_LEADER_EFFECT: "se_battle_common_101053"
            },
            INTERVAL_UPDATING_GAUGE: 30,
            INCREMENTAL_RATIO_PER_LOOP: .03,
            INCREMENTAL_RATIO_ON_COMPLETE_AT_ONCE: 1,
            WAIT_MS_BEFORE_RANK_EFFECT: 300
        },
        f = i.extend({
            msecPerFrame: 62.5,
            initialize: function(t) {
                this._timerIdAll = {}, this.duration = e.isNumber(t) ? t : 800
            },
            dispose: function() {
                for (var e in this._timerIdAll) this._clearTimerId(e)
            },
            _clearTimerId: function(e) {
                FF.logger.debug("_clearTimerId", e), this._timerIdAll[e] !== void 0 && (clearInterval(e), delete this._timerIdAll[e])
            },
            executeDeferred: function(n, r) {
                var i = this,
                    o = t.Deferred(),
                    u = s.getTime(),
                    a = setInterval(function() {
                        var t = s.getTime() - u,
                            f = t / i.duration;
                        f = e.min([f, 1]), n && n.call(r, f), f === 1 && (i._clearTimerId(a), o.resolve())
                    }, i.msecPerFrame);
                return this._timerIdAll[a] = !0, o.promise()
            }
        }),
        l = i.extend({
            initialize: function(e) {
                this.rate = Number(e)
            },
            setFromTo: function(e, t) {
                this.from = Number(e), this.to = Number(t)
            }
        }),
        c = i.extend({
            baseValue: 0,
            recordMateriaBonus: null,
            leaderBonus: null,
            initialize: function(e) {
                var t = Number(e.gil),
                    n = e.gilOptionalInfo ? e.gilOptionalInfo.boost : null,
                    r = e.moOptionalInfo || {},
                    i = r.leaderBonus || null;
                this.baseValue = t, this.recordMateriaBonus = n ? new l(n.boostRate) : null, this.leaderBonus = i ? new l(i.gilRate) : null;
                if (this.leaderBonus)
                    if (this.recordMateriaBonus) {
                        this.baseValue = Number(n.originalValue);
                        var s = t / (this.leaderBonus.rate * .01);
                        this.recordMateriaBonus.setFromTo(this.baseValue, s), this.leaderBonus.setFromTo(s, t)
                    } else this.baseValue = t / (this.leaderBonus.rate * .01), this.leaderBonus.setFromTo(this.baseValue, t);
                else this.recordMateriaBonus && (this.baseValue = n.originalValue, this.recordMateriaBonus.setFromTo(this.baseValue, t))
            }
        }),
        h = i.extend({
            baseValue: 0,
            expBonus: null,
            leaderBonus: null,
            initialize: function(e) {
                var t = Number(e.scoreBaseExp),
                    n = Number(e.scoreExpWithBonus),
                    r = e.moOptionalInfo || {},
                    i = r.leaderBonus || null;
                this.baseValue = t, this.expBonus = new l(100 * n / t), this.expBonus.setFromTo(t, n), this.leaderBonus = i ? new l(i.expRate) : null, this.leaderBonus && this.leaderBonus.setFromTo(n, i.expWithBonus)
            }
        });
    return i.extend({
        initialize: function(e) {
            FF.logger.debug("ResultScore: initialize", e), this.tutorialView = e.tutorialView, this.score = e.result.score, this.hasMoInfo = !!e.result.moOptionalInfo, this.gilBonusInfo = new c(e.result), this.expBonusInfo = new h(e.result), this.layer = e.layer, this.bonusAnimUpdateTimer = new f(800), this.startBonusUpdateTimer = new f(1200), this.animationPool = new u, this.animationPool.start(), this.stageNode = new r({
                name: "stage_nul",
                layer: this.layer.layerName
            }), this.totalScoreNode = new r({
                name: "total_score_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.totalScoreNode), this.expNumNode = new r({
                name: "exp_num_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.expNumNode), this.gilNode = new r({
                name: "gil_nul",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.gilNode), this.gilBonusNode = this.gilNode.createChildNode("gil_bonus"), this.leaderBonusNode1 = new r({
                name: "leader_gil_bonus",
                layer: this.layer.layerName
            }), this.leaderBonusNode2 = new r({
                name: "leader_exp_bonus",
                layer: this.layer.layerName
            }), this.animationPool.nodes.push(this.leaderBonusNode1), this.animationPool.nodes.push(this.leaderBonusNode2), this.duplicatedNodes = [];
            var t = this.makeSpecificScores(),
                n = this.makeGeneralScores();
            this.scoreInfo = n.concat(t), this.scoreModel = new o(this.scoreInfo), this.rankNode = new r({
                name: this.scoreModel.getRankNodeName(),
                layer: this.layer.layerName,
                parentNodeName: "bonus_rank_" + this.score.rank + "_nul"
            }), this.rankNode.setVisible(!1), this.animationPool.nodes.push(this.rankNode);
            var i = FF.ns.battle.TextMaster.getInstance(),
                s = i.get("R10280");
            this.stageNode.setText("score_txt", s).process();
            var a = i.get("R10290");
            this.stageNode.setText("special_score_txt", a).process()
        },
        makeSpecificScores: function() {
            var t = 3,
                n = [];
            for (var i = 0, s = this.score.specific.length; i < s; i++) {
                if (!this.score.specific[i]) return n;
                if (i >= t) return FF.logger.error("specific score num is over maxLength:" + t), n;
                var o = (new r({
                        name: "dup_txt_special_score_pos_nul_" + (i + 1),
                        layer: this.layer.layerName,
                        duplicateFrom: "txt_score_base_nul",
                        duplicateFromOptions: {
                            parentNode: "txt_special_score_pos_nul_" + (i + 1)
                        }
                    })).process(),
                    u = [];
                for (var a = 1; a <= 3; a++) {
                    var f = (new r({
                        name: "dup_s_medal_" + (i + 1) + "_" + a,
                        layer: this.layer.layerName,
                        duplicateFrom: "medal_nul",
                        duplicateFromOptions: {
                            parentNode: "medal_pos_nul_" + a,
                            parentTopNode: o.name
                        }
                    })).process();
                    this.duplicatedNodes.push(f), u.push(f)
                }
                n.push(e.extend({
                    textPosNode: o,
                    medalNodes: u
                }, this.score.specific[i])), this.duplicatedNodes.push(o), this.animationPool.nodes.push(o)
            }
            return n
        },
        makeGeneralScores: function() {
            var t = 3,
                n = [];
            for (var i = 0, s = this.score.general.length; i < s; i++) {
                if (!this.score.general[i]) return n;
                if (i >= t) return FF.logger.error("general score num is over maxLength:" + t), n;
                var o = (new r({
                        name: "dup_txt_score_pos_nul_" + (i + 1),
                        layer: this.layer.layerName,
                        parentNodeName: "txt_score_pos_nul_" + (i + 1),
                        duplicateFrom: "txt_score_base_nul",
                        duplicateFromOptions: {
                            parentNode: "txt_score_pos_nul_" + (i + 1)
                        }
                    })).process(),
                    u = [];
                for (var a = 1; a <= 3; a++) {
                    var f = (new r({
                        name: "dup_g_medal_" + (i + 1) + "_" + a,
                        layer: this.layer.layerName,
                        duplicateFrom: "medal_nul",
                        duplicateFromOptions: {
                            parentNode: "medal_pos_nul_" + a,
                            parentTopNode: o.name
                        }
                    })).process();
                    this.duplicatedNodes.push(f), u.push(f)
                }
                n.push(e.extend({
                    textPosNode: o,
                    medalNodes: u
                }, this.score.general[i])), this.duplicatedNodes.push(o), this.animationPool.nodes.push(o)
            }
            return n
        },
        start: function() {
            var t = this;
            this.updateExpTextNode(this.expBonusInfo.baseValue), this.expNumNode.play("score_total_start"), this.playGil(), this.prepareScoreItems(), this.animateGaugeDeferred().then(this.tutorialView.getTutorialFunc("firstMog")).then(e.bind(this.waitBeforeRankEffectDeferred, this)).then(e.bind(this.showRankDeferred, this)).then(e.bind(this.animateBonusDeferred, this)).then(this.tutorialView.getTutorialFunc("battleScoreMog")).then(e.bind(this.showNextDeferred, this))
        },
        startLeaderBonusEffect: function() {
            this.isDone = !1, this.playLeaderBonusDeferred().then(e.bind(this.showNextDeferred, this))
        },
        hasLeaderBonusEffect: function() {
            return this.hasMoInfo && (this.gilBonusInfo.leaderBonus || this.expBonusInfo.leaderBonus)
        },
        isLeaderBonusEffectDone: function() {
            return this.leaderEffectDone || !1
        },
        playGil: function() {
            this.gilNode.setText("gil_value_txt", this.gilBonusInfo.baseValue).play("score_total_start")
        },
        prepareScoreItems: function() {
            e.each(this.scoreInfo, function(t) {
                FF.logger.debug("scoreinfo", t), t.textPosNode.play("score_txt_start").setText("score_key_txt", t.title).process(), e.each(t.medalNodes, function(e) {
                    e.play("medal_empty").process()
                })
            }), this.rankPointNodes = [];
            for (var t = 0; t < 3; t++) this.rankPointNodes.push(new r({
                name: "rank_point_nul_" + (t + 1),
                layer: this.layer.layerName
            })), this.rankPointNodes[t].setPosition(this.scoreModel._calcRankCoords(t)).process();
            this.rankPointNodes[0].setVisible(!1).process()
        },
        animateGaugeDeferred: function() {
            return this.gaugeDeferred = t.Deferred(), this.scoreGauge = new r({
                name: "mask_image_total_guage",
                layer: this.layer.layerName
            }), this.listenToOnce(this.scoreModel, "finish:animation", e.bind(function() {
                this.stopListening(this.scoreModel), this.gaugeDeferred.resolve()
            }, this)), this.listenTo(this.scoreModel, "update:gauge", e.bind(function(e) {
                this.scoreGauge.playFrame("score_guage", e, e).process()
            }, this)), this.listenTo(this.scoreModel, "show:medal", e.bind(function(t, n) {
                FF.logger.debug("show:medal received", [t, n]), this.scoreInfo[t].medalNodes[n].setVisible(!0).play("medal_in").processDeferred("action_stop").then(e.bind(function() {
                    this.scoreInfo[t].medalNodes[n].play("medal_loop").process()
                }, this))
            }, this)), this.listenTo(this.scoreModel, "update:rank", e.bind(function(e) {
                FF.logger.debug("update:rank received", e), this.rankPointNodes[e].play("score_guage_clear").process()
            }, this)), this.gaugeDeferred.progress(e.bind(function(t) {
                this.scoreModel.progress(t);
                var n = setInterval(e.bind(function() {
                    clearInterval(n), this.shouldCompleteAtOnce ? this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_ON_COMPLETE_AT_ONCE) : this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_PER_LOOP)
                }, this), a.INTERVAL_UPDATING_GAUGE)
            }, this)), this.gaugeDeferred.notify(a.INCREMENTAL_RATIO_PER_LOOP), this.gaugeDeferred.promise()
        },
        waitBeforeRankEffectDeferred: function() {
            var e = t.Deferred();
            if (this.shouldCompleteAtOnce) e.resolve();
            else var n = setInterval(function() {
                clearInterval(n), e.resolve()
            }, a.WAIT_MS_BEFORE_RANK_EFFECT);
            return e.promise()
        },
        showRankDeferred: function() {
            var e = t.Deferred(),
                n = a.SE[a.SCORE_SOUND_MAP[this.score.rank]];
            return FF.SoundMgr.playEffect(n), this.rankNode.setVisible(!0).play("rank").processDeferred("action_stop").then(function() {
                e.resolve()
            }), e.promise()
        },
        animateBonusDeferred: function() {
            var n = t.Deferred();
            return this.waitForPlayBonusExpDeferred().then(e.bind(function() {
                return this.playBonusExpDeferred(this.updateTotalExp)
            }, this)).then(e.bind(function() {
                return this.playBonusGilDeferred()
            }, this)).then(e.bind(function() {
                n.resolve()
            }, this)), n.promise()
        },
        showNextDeferred: function() {
            return this.isDone = !0, this.trigger("show:nextBtn"), t.Deferred().resolve().promise()
        },
        waitForPlayBonusExpDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.hasBonusExp() ? (this.rankNode.play("rank_bonus"), this.startBonusUpdateTimer.executeDeferred(null, this)) : n.resolve().promise()
        },
        playBonusExpDeferred: function(e) {
            return this.bonusAnimUpdateTimer.executeDeferred(e, this)
        },
        updateTotalExp: function(e) {
            var t = this.expBonusInfo.expBonus,
                n = t.to - t.from,
                r = Math.round(t.from + n * e);
            this.updateExpTextNode(r)
        },
        updateTotalExpForLeaderBonus: function(e) {
            var t = this.expBonusInfo.leaderBonus,
                n = t.to - t.from,
                r = Math.round(t.from + n * e);
            this.updateExpTextNode(r)
        },
        updateExpTextNode: function(e) {
            this.expNumNode.setText("exp_num_value_txt", e)
        },
        playBonusGilDeferred: function() {
            var e = this,
                n = t.Deferred(),
                r = this.gilBonusInfo.recordMateriaBonus;
            return r ? (this.setPercentageSpriteNodes(r.rate, this.gilNode, "gil_bonus_num_sprite_%02d"), this.gilNode.play("record_bonus").processDeferred("action_stop").then(function() {
                e.bonusAnimUpdateTimer.executeDeferred(function(t) {
                    var n = Math.floor(r.from + (r.to - r.from) * t);
                    e.updateGilTextNode(n)
                }, e).then(function() {
                    n.resolve()
                })
            }), n.promise()) : n.resolve().promise()
        },
        updateTotalGilForLeaderBonus: function(e) {
            var t = this,
                n = this.gilBonusInfo.leaderBonus,
                r = n.to - n.from,
                i = Math.floor(n.from + (n.to - n.from) * e);
            t.updateGilTextNode(i)
        },
        updateGilTextNode: function(e) {
            this.gilNode.setText("gil_value_txt", e)
        },
        setPercentageSpriteNodes: function(t, n, r) {
            var i = sprintf("%03d", +t).split("");
            e.each(i, function(e, t) {
                var i = sprintf(r, t + 1);
                n.setSpriteActionByNode(i, sprintf("txt_%s", e))
            }, this)
        },
        hasBonusExp: function() {
            return this.score.rank > 1
        },
        completeAtOnce: function() {
            !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.bonusAnimUpdateTimer.duration = 10, this.startBonusUpdateTimer.duration = 10, this.shouldCompleteAtOnce = !0)
        },
        playLeaderBonusDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (!this.hasLeaderBonusEffect()) return n.resolve().promise();
            this.leaderEffectDone = !0, this.rankNode.setVisible(!1).process(), this.gilBonusNode.setVisible(!1).process(), this.setPercentageSpriteNodes(this.gilBonusInfo.leaderBonus.rate, this.leaderBonusNode1, "leader_gil_bonus_num_sprite_%02d"), this.setPercentageSpriteNodes(this.expBonusInfo.leaderBonus.rate, this.leaderBonusNode2, "leader_exp_bonus_num_sprite_%02d");
            var r = "leader_bonus";
            return this.gilBonusInfo.baseValue > 0 && this.leaderBonusNode1.setVisible(!0).play(r).process(), this.leaderBonusNode2.setVisible(!0).play(r).processDeferred("action_stop").then(function() {
                return e.countUpLeaderBonusDeferred()
            }).then(function() {
                n.resolve()
            }), FF.SoundMgr.playEffect(a.SE.SE_LEADER_EFFECT), n.promise()
        },
        countUpLeaderBonusDeferred: function() {
            var e = this,
                t = this.gilBonusInfo.leaderBonus;
            return this.bonusAnimUpdateTimer.executeDeferred(function(t) {
                e.updateTotalGilForLeaderBonus(t), e.updateTotalExpForLeaderBonus(t)
            })
        },
        initNodesForUnitTest: function() {
            var e = new r({
                name: "visible_stage_nul",
                layer: this.layer.layerName
            });
            e.play("score_reset").process()
        },
        resetNodesForUnitTest: function() {
            this.rankNode && this.rankNode.setVisible(!1).process(), this.leaderBonusNode1.setVisible(!1).process(), this.leaderBonusNode2.setVisible(!1).process(), this.gilBonusNode.setVisible(!0).process()
        },
        dispose: function() {
            this.animationPool.dispose(), this.animationPool = null, this.bonusAnimUpdateTimer.dispose(), this.bonusAnimUpdateTimer = null, this.startBonusUpdateTimer.dispose(), this.startBonusUpdateTimer = null, this.totalScoreNode.setVisible(!1).process(), e.each(this.scoreInfo, function(t) {
                e.each(t.medalNodes, function(e) {
                    e.suspendParticle().process()
                })
            });
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            t(this.duplicatedNodes), this.tutorialView = void 0
        }
    })
}), define("scenes/battle_result/views/ExpCell", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "util", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = FF.ns.battle,
        a = {
            1: "_150",
            2: "_200",
            3: "_200"
        };
    return i.extend({
        initialize: function(t) {
            this.idx = t.idx, this.layer = t.layer, this.assetsManager = t.assetsManager, this.model = t.model, this.animationPool = t.animationPool;
            var n = this.assetsManager.getAssetInfo("player_common");
            this._setStatusAilmentsFlg();
            var i;
            if (this.isPetrified) {
                var s = FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION + "";
                i = "buddy-" + this.model.get("path") + "_" + s
            } else i = "buddy-" + this.model.get("path");
            var u = this.assetsManager.getAssetInfo(i);
            this.expNode = (new r({
                name: "dup_exp_" + this.idx,
                layer: this.layer.layerName,
                parentNodeName: "exp_chara_pos_nul_" + this.idx,
                duplicateFrom: "exp_chara_nul",
                duplicateFromOptions: {
                    parentNode: "exp_chara_pos_nul_" + this.idx
                }
            })).process();
            var a = sprintf("soulstrike_exp%s", this._getSoulStrikeExpNodeInfix());
            this.soulStrikeExpNode = (new r({
                name: "dup_soulstrike_exp_" + this.idx,
                layer: this.layer.layerName,
                parentNodeName: "soulstrike_exp_pos_" + this.idx,
                duplicateFrom: a,
                duplicateFromOptions: {
                    parentNode: "soulstrike_exp_pos_" + this.idx
                }
            })).setVisible(!1).process();
            var f = "dup_exp_chara_" + this.idx;
            this.charaNode = (new r({
                name: f,
                layer: n.layerName,
                duplicateFrom: "character_nul",
                duplicateFromOptions: {
                    visualParentLayer: this.layer.layerName,
                    visualParentNode: "chara_pos_nul",
                    visualParentTopNode: "exp_chara_pos_nul_" + this.idx
                }
            })).setParam({
                color_change_parent: f
            }).loadBundle(u.bundle).setSpriteAnimeByNode("sprite_character_base", u.assetPath).setSpriteAnimeByNode("sprite_character_add", u.assetPath).play("idle").process();
            if (this.canShowSeriesEffect()) {
                var l = this._getStatusBonusAssetName(),
                    c = this.assetsManager.getAssetInfo(l);
                this.seriesNode = (new r({
                    name: sprintf("status_bonus_eff_chara_%s", this.idx),
                    layer: c.layerName,
                    duplicateFrom: "status_bonus_eff_chara_nul",
                    duplicateFromOptions: {
                        visualParentLayer: n.layerName,
                        visualParentNode: "status_bonus_eff_back_pos_nul",
                        visualParentTopNode: f
                    }
                })).setVisible(!0).play("play").process()
            }
            this.isDead && this.charaNode.play("dead").process(), this.setExpNode(), this.CurrentLevelNode = this.expNode.createVirtualNode("exp_lv_txt"), this.CurrentLevelNode.setText("exp_lv_txt", "Lv" + this.model.get("startLevel"), {
                topNode: this.expNode.name
            }).process(), this.HPNode = this.expNode.createVirtualNode("exp_hp_txt_nul"), this.HPNode.setText("exp_hp_txt", sprintf("%s / %s", this.model.get("hp"), this.model.get("maxHp"))).process(), this.charaNameNode = this.expNode.createVirtualNode("chara_name_nul"), this.charaNameNode.setText("chara_name_txt", this.model.get("name"), {
                topNode: this.expNode.name
            }).process(), this.CurrentLevelUpTextNode = this.expNode.createVirtualNode("exp_lv_up_txt"), this.expLvNextTextNode = this.expNode.createVirtualNode("exp_lv_next_txt"), this.animationPool.nodes.push(this.expLvNextTextNode), this.soulStrikeExpNode.play("init", {
                autoRemove: !1
            }).process(), this.expCoverNode = new r({
                name: "exp_cover_win",
                layer: this.layer.layerName
            }), this.expCoverNode.setVisible(!1).play("init", {
                autoRemove: !1
            }).process(), this.preLoadSoulStrikeExpImages(), this._isMasterAnimCalled = [], this.setExpToNextLevelText(), this.listenTo(this.model, "levelUp", e.bind(this.levelUp, this)), this.listenTo(this.model, "change:progressRatio", e.bind(this.progress, this)), this.listenTo(this.model, "change:progressSSRatio", e.bind(this.progressSS, this));
            var h = o.getInstance().get("BWW15171");
            this.CurrentLevelNode.setText("exp_lv_txt", h + " " + this.model.get("startLevel"), {
                topNode: this.expNode.name
            }).process()
        },
        _setStatusAilmentsFlg: function() {
            var t = this.model.get("statusAilments");
            e.contains(t, FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.PETRIFACTION + "") && (this.isPetrified = !0), e.contains(t, FF.ns.battle.Conf.STATUS_AILMENTS_TYPE.DEATH + "") && (this.isDead = !0)
        },
        setupDeferred: function() {
            var e = t.Deferred();
            return this.expGaugeNode.addCallbackOnce("action_stop", function() {
                e.resolve()
            }, {
                topNode: this.expNode.name
            }), this.expGaugeNode.playFrame("exp_guage", 0, this.model.getInitialFrame(), {
                speed: 100 * this.model.getInitialFrame()
            }).process(), this.previousFrame = 0, this.model.get("isLevelMax") && this.model.get("currentLevel") === this.model.get("endLevel") && this.suspendParticle(), this.model.get("incrementalExp") || this.suspendParticle(), e.promise()
        },
        setSoulStrikeExpGaugeDeferred: function() {
            var n = this,
                r = t.Deferred(),
                i = this.model.get("soulStrikeExps"),
                s = 0;
            return e.each(i, function(e) {
                var t = "_0" + (s + 1),
                    i = n.soulStrikeExpNodes[s];
                i.addCallbackOnce("action_stop", function() {
                    r.resolve()
                }, {
                    topNode: n.soulStrikeExpNode.name
                }), e.isAlreadyMastered || i.playFrame("exp_guage", 0, e.frameSets[0][0], {
                    speed: 100 * e.frameSets[0][0]
                }).process(), e.isAlreadyMastered && i.suspendParticle({
                    topNode: n.soulStrikeExpNode.name
                }).process(), s++
            }), this.previousSSFrame = 0, r.promise()
        },
        setSoulStrikeExpDeferredList: function() {
            var e = this.model.get("soulStrikeExps"),
                t = [];
            if (e.length === 0) return t;
            var n = this.canShowSeriesEffect();
            return t = t.concat(this.expCoverNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), n ? (t = t.concat(this.soulStrikeExpNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), t = t.concat(this._setSoulStrikeExpNodeByIsSeriesMatchedDeferredList(n))) : (t = t.concat(this.soulStrikeExpNode.setVisible(!0).play("soulstrike_exp_start").processDeferred("action_stop")), t = t.concat(this._setSoulStrikeExpNodeByIsSeriesMatchedDeferredList(n))), t
        },
        _setSoulStrikeExpNodeByIsSeriesMatchedDeferredList: function(t) {
            var n = this,
                r = this.model.get("soulStrikeExps"),
                i = this._getSoulStrikeExpNodeInfix(),
                s = [];
            this.soulStrikeExpNodeOne = this.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_01", i)), this.soulStrikeExpNodeOne.setVisible(!1).process(), this.soulStrikeExpNodeTwo = this.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_02", i)), this.soulStrikeExpNodeTwo.setVisible(!1).process(), this.soulStrikeExpNodes = [this.soulStrikeExpNodeOne, this.soulStrikeExpNodeTwo];
            var o = 0;
            return e.each(r, function(e) {
                n.soulStrikeExpNodes[o].setVisible(!0).process();
                var t = "_0" + (o + 1);
                if (e.isAlreadyMastered) {
                    var r = n.soulStrikeExpNodes[o].createChildNode(sprintf("soulstrike_exp%s_gauge%s", i, t));
                    s.push(r.play("soulstrike_master_comp", {
                        autoRemove: !1
                    }).processDeferred("action_stop"))
                }
                o++
            }), s
        },
        preLoadSoulStrikeExpImages: function() {
            var t = this,
                n = this._getSoulStrikeExpNodeInfix(),
                r = this.model.get("soulStrikeExps");
            if (r.length === 0) return;
            var i = 0;
            e.each(r, function(e) {
                var r = "_0" + (i + 1);
                t.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_txt%s", n, r), e.dispExp).process();
                if (+e.evolutionNum > 0) {
                    var s = a[+e.evolutionNum];
                    t.soulStrikeExpNode.createVirtualNode(sprintf("soulstrike_exp%s_bonus%s_img%s", n, s, r)).setVisible(!0).process()
                }
                t.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_name_txt%s", n, r), e.soulStrikeDispName).setVisible(!0).process(), t.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_num_txt%s", n, r), e.currentExp).setVisible(!0).process();
                var o = "equipment_" + e.soulStrikeId,
                    u = t.assetsManager.getAssetInfo(o);
                t.soulStrikeExpNode.loadBundle(u.bundle).setImage(sprintf("soulstrike_exp%s_equipment_img%s", n, r), u.assetPath).process();
                var f = "soul_strike_" + e.soulStrikeId,
                    l = t.assetsManager.getAssetInfo(f);
                t.soulStrikeExpNode.loadBundle(l.bundle).setImage(sprintf("soulstrike%s_img%s", n, r), l.assetPath).process(), e.previousExp === e.newExp && !e.isAlreadyMastered && t.suspendSoulStrikeExpParticle(), i++
            })
        },
        _getSoulStrikeExpNodeInfix: function() {
            var e = FF.ns.battle.Conf;
            if (!this.model.get("statusBonusFlgOf").buddy) return "";
            if (this.model.get("statusBonusTypeOf") === e.STATUS_BONUS_TYPE.SERIES) return "_series";
            if (this.model.get("statusBonusTypeOf") === e.STATUS_BONUS_TYPE.ROLE) return "_role";
            throw new Error("does not match any bonus types")
        },
        progress: function() {
            var e = this.model.get("currentFrame");
            this.expGaugeNode.playFrame("exp_guage", e, e), this.setExpToNextLevelText(), this.previousFrame = e
        },
        progressSS: function() {
            var t = this,
                n = this.model.get("soulStrikeExps"),
                r = 0,
                i = this._getSoulStrikeExpNodeInfix();
            e.each(n, function(e) {
                if (e.isAlreadyMastered) {
                    r++;
                    return
                }
                var n = "_0" + (r + 1),
                    s = t.soulStrikeExpNodes[r],
                    o = e.currentFrame;
                t.soulStrikeExpNode.setText(sprintf("soulstrike_exp%s_num_txt%s", i, n), e.currentExp).setVisible(!0).process();
                if (e.currentExp === 0) {
                    if (!t._isMasterAnimCalled[r]) {
                        var u = t.soulStrikeExpNode.createChildNode(sprintf("soulstrike_exp%s_gauge%s", i, n));
                        u.play("soulstrike_master").process()
                    }
                    t._isMasterAnimCalled[r] = !0
                } else s.playFrame("exp_guage", o, o).process();
                r++
            })
        },
        setExpNode: function() {
            this.expGaugeNode = this._setExpNode(), this.animationPool.nodes.push(this.expGaugeNode)
        },
        _setExpNode: function() {
            var e;
            return this.canShowMateriaExpBonusEffect() ? (this.expNode.createChildNode("guage_exp_lv_nul").setVisible(!1).process(), e = this._createMateriaBonusEffect()) : this.canShowSeriesEffect() ? (this.expNode.createChildNode("guage_exp_lv_nul").setVisible(!1).process(), e = this.expNode.createChildNode("series_exp_lv_nul").setVisible(!0).process()) : e = this.expNode.createChildNode("guage_exp_lv_nul").process(), e
        },
        canShowSeriesEffect: function() {
            return this._canShowEffect() ? this.isSeriesMatched() ? !0 : !1 : !1
        },
        canShowMateriaExpBonusEffect: function() {
            if (!this._canShowEffect()) return !1;
            var e = this.model.get("exp").expBonusInfo;
            return e.typeName !== "RECORD_MATERIA" ? !1 : !0
        },
        _canShowEffect: function() {
            return this.isDead ? !1 : this.isPetrified ? !1 : !0
        },
        _createMateriaBonusEffect: function() {
            var t = this.model.get("exp").expBonusInfo,
                n = t.boostRate,
                r = sprintf("%03d", +n),
                i = r.split("").reverse(),
                s = this.expNode.createChildNode("rmbonus_txt");
            return e.each(i, function(e, t) {
                var n = sprintf("rmbonus_num_%d_sprite", t);
                s.setSpriteActionByNode(n, sprintf("txt_%s", e))
            }), s.process(), this.expNode.createChildNode("rmbonus_exp_lv_nul").setVisible(!0).process()
        },
        isSeriesMatched: function() {
            return this.model.get("statusBonusFlgOf").buddy
        },
        _getStatusBonusAssetName: function() {
            var e = FF.ns.battle.Conf,
                t = {};
            return t[e.STATUS_BONUS_TYPE.SERIES] = "series_eff_chara", t[e.STATUS_BONUS_TYPE.ROLE] = "role_eff_chara", t[this.model.get("statusBonusTypeOf")]
        },
        levelUp: function(e) {
            this.expNode.play("exp_lv_up").process(), this.expNode.createChildNode("exp_hp_txt").setVisible(!1).process();
            var t = this.model.get("levelToHpMax")[e - 1],
                n = this.model.get("levelToHpMax")[e];
            this.expNode.createChildNode("exp_hp_lvup_txt").setText("exp_hp_lvup_txt", sprintf("%s / %s%s", n, t, n)).setVisible(!0).process(), this.setCurrentLevelUpText(e), this.charaNode.play("hands_up").process()
        },
        setExpToNextLevelText: function() {
            var e = this.model.get("expToNextLevel");
            this.expLvNextTextNode.setText("exp_lv_next_txt", e, {
                topNode: this.expNode.name
            })
        },
        setCurrentLevelUpText: function(e) {
            this.CurrentLevelUpTextNode.setText("exp_lv_up_txt", e, {
                topNode: this.expNode.name
            }).process()
        },
        suspendParticle: function() {
            this.expNode.suspendParticle().process()
        },
        suspendSoulStrikeExpParticle: function() {
            this.soulStrikeExpNode.suspendParticle().process()
        },
        isSoulStrikeCountUp: function() {
            var t = this.model.get("soulStrikeExps");
            return e.some(t, function(e) {
                return e.isAlreadyMastered ? !1 : e.previousExp === e.newExp ? !1 : !0
            })
        },
        dispose: function() {
            n.Events.stopListening(this.model, "change:progressRatio"), this.canShowSeriesEffect() && (this.seriesNode.suspendParticle().setVisible(!1).process(), this.seriesNode.deleteNode().process()), this.expNode.suspendParticle().process(), this.expNode.deleteNode().process(), this.charaNode.deleteNode().process(), this.expGaugeNode.deleteNode().process(), this.CurrentLevelNode.deleteNode().process(), this.charaNameNode.deleteNode().process(), this.CurrentLevelUpTextNode.deleteNode().process(), this.expLvNextTextNode.deleteNode().process(), this.soulStrikeExpNode.deleteNode().process(), this.layer = null, this.assetsManager = null, this.model = null, this.animationPool = null
        }
    })
}), define("scenes/battle_result/models/BuddyExp", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(t) {
            e.Model.prototype.initialize.apply(t);
            var n = t.exp.levelToHpMax,
                r = t.exp.levelToExp,
                i = _.sortBy(_.keys(r), function(e) {
                    return +e
                });
            this.set("levels", i), this.set("levelToHpMax", n), this.set("levelToExp", r);
            var s, o = _.map(i, function(e, t) {
                return i[t + 1] && (s = r[i[t + 1]]), {
                    level: +e,
                    threshold: +r[e],
                    thresForNextLevel: +s
                }
            });
            this.levelMap = o, this.set("isLevelMax", t.exp.isLevelMax);
            var u = +t.exp.previousLevel,
                a = +t.exp.previousExp,
                f = +t.exp.currentLevel,
                l = +t.exp.currentExp,
                c = o[0].thresForNextLevel - a;
            _.isNaN(c) && (c = 0), this.set("expToNextLevel", c), this.set("startLevel", u), this.set("startExp", a), this.set("endLevel", f), this.set("endExp", l), this.set("incrementalExp", l - a);
            var h = this._buildFrameSets();
            FF.logger.debug("frameSets:", h), this.set("frameSets", h), this.set("currentFrameSet", 0), this.set("totalFrameCount", this.getTotalFrameCount()), this.set("currentExp", +this.get("startExp")), this.set("currentLevel", +this.get("startLevel")), this.set("progressRatio", 0), this.set("progressSSRatio", 0), this._setSoulStrikeExp()
        },
        _setSoulStrikeExp: function() {
            var e = this,
                t = this.get("soulStrikeExps");
            t = _.sortBy(t, function(e) {
                return +e.equipmentId
            }), _.each(t, function(t) {
                t.previousExp = +t.previousExp, t.newExp = +t.newExp, t.requiredExp = +t.requiredExp, t.frameSets = e._buildSSFrameSets(t.previousExp, t.newExp, t.requiredExp), t.totalFrame = e._getTotalSSFrameCount(t.frameSets), t.currentExp = +t.requiredExp - t.previousExp
            }), this.set("soulStrikeExps", t)
        },
        _buildFrameSets: function() {
            var e = [],
                t = this.get("levels"),
                n = this.get("levelToExp"),
                r = this.get("startExp"),
                i = this.get("endExp"),
                s = this.get("isLevelMax"),
                o, u, a, f;
            if (s && this.levelMap.length === 1) return e = [
                [100, 100]
            ], e;
            for (var l = 0, c = t.length - 1; l < c; l++) {
                a = n[t[l]], f = n[t[l + 1]];
                var h = f - a;
                r > a ? o = Math.round((r - a) / h * 100) : o = 0, i < f ? u = Math.round((i - a) / h * 100) : u = 100, e.push([o, u])
            }
            return e
        },
        _buildSSFrameSets: function(e, t, n) {
            var r = [],
                i = this.get("isLevelMax"),
                s = Math.round(e / n * 100),
                o = Math.round(t / n * 100);
            return r.push([s, o]), r
        },
        getTotalFrameCount: function() {
            var e = this.get("frameSets"),
                t = _.reduce(_.map(e, function(e) {
                    return e[1] - e[0]
                }), function(e, t) {
                    return e + t
                });
            return t
        },
        _getTotalSSFrameCount: function(e) {
            var t = _.reduce(_.map(e, function(e) {
                return e[1] - e[0]
            }), function(e, t) {
                return e + t
            });
            return t
        },
        getInitialFrame: function() {
            return this.get("frameSets")[0][0]
        },
        updateByProgressRatio: function(e) {
            var t = this.get("endExp") - this.get("startExp");
            this.set("prevExp", this.get("currentExp")), this.set("currentExp", this.get("startExp") + Math.round(t * e));
            var n = this.get("currentLevel"),
                r = this._calcCurrentLevel();
            n !== r && (this.set("currentLevel", r), this.trigger("levelUp", r)), this._calcExpToNextLevel(), this.set("currentFrame", this._calcCurrentFrame(e)), this.set("progressRatio", e)
        },
        updateByProgressSSRatio: function(e) {
            var t = this,
                n = this.get("soulStrikeExps");
            _.each(n, function(n) {
                n.currentFrame = t._calcSSCurrentFrame(e, n.frameSets, n.totalFrame);
                var r = +n.newExp - +n.previousExp;
                n.currentExp = +n.requiredExp - (+n.previousExp + Math.round(r * e))
            }), this.set("progressSSRatio", e)
        },
        _calcCurrentLevel: function() {
            var e = this.get("currentExp");
            for (var t = 0, n = this.levelMap.length; t < n; t++)
                if (e >= this.levelMap[t].threshold && e < this.levelMap[t].thresForNextLevel) return this.levelMap[t].level;
            if (e === _.last(this.levelMap).threshold) return _.last(this.levelMap).level;
            throw FF.logger.debug("level for exp doesnt exist. levelMap:", this.levelMap), new Error(sprintf("cant calc level."))
        },
        _calcExpToNextLevel: function() {
            var e = 0,
                t = this.get("levelToExp"),
                n = this.get("currentLevel") + 1;
            if (this.get("isLevelMax") && this.get("currentLevel") === this.get("endLevel")) {
                FF.logger.debug("max dayo"), this.set("expToNextLevel", 0);
                return
            }
            e = t[n] - this.get("currentExp"), this.set("expToNextLevel", e)
        },
        _calcCurrentFrame: function(e) {
            var t = this.get("frameSets"),
                n = this.get("totalFrameCount"),
                r = Math.round(n * e),
                i, s, o, u;
            for (var a = 0, f = t.length; a < f; a++) {
                s = t[a][0], o = t[a][1], u = o - s;
                if (!(r > u)) {
                    i = t[a][0] + r;
                    break
                }
                r -= u
            }
            return i
        },
        _calcSSCurrentFrame: function(e, t, n) {
            var r = Math.round(n * e),
                i, s, o, u;
            for (var a = 0, f = t.length; a < f; a++) {
                s = t[a][0], o = t[a][1], u = o - s;
                if (!(r > u)) {
                    i = t[a][0] + r;
                    break
                }
                r -= u
            }
            return i
        }
    });
    return t
}), define("scenes/battle_result/collections/BuddyExp", ["backbone", "../models/BuddyExp"], function(e, t) {
    var n = e.Collection.extend({
        model: t,
        updateByProgressRatio: function(e) {
            _.each(this.models, function(t) {
                t.updateByProgressRatio(e)
            }), this.trigger("update:progressRatio", e)
        },
        updateByProgressSSRatio: function(e) {
            _.each(this.models, function(t) {
                t.updateByProgressSSRatio(e)
            }), this.trigger("update:progressSSRatio", e)
        }
    });
    return n
}), define("scenes/battle_result/views/SoulStrikeLevelupModal", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/ab/ABNodeButton", "lib/EventBase", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = {
        TAG_OPEN: "play",
        TAG_OPEN_SPECIAL: "play_special",
        TAG_CLOSE: "close",
        LABEL_MESSAGE: "message_txt",
        LABEL_PARAM_BOOST_MESSAGE: "message_special_txt",
        LABEL_BUTTON_OK: "btn_txt",
        IMAGE_NODE: "ability_img",
        SPRITE_NODE: "chara_sprite"
    };
    return s.extend({
        initialize: function(e) {
            FF.logger.debug("SoulStrikeLevelupView: initialize");
            var t = this;
            this._lastTg = void 0, this.ab = {}, this.ab.topNode = e, this.ab.bgImgNode = new r({
                name: "bg_black_img",
                layer: this.ab.topNode.layer
            }), this.ab.centerNode = new r({
                name: "pos_center_nul",
                layer: this.ab.topNode.layer
            }), this.ab.posCenterAnmNode = e.createChildNode("pos_center_anm"), this.ab.messageSpecialNode = e.createChildNode("message_special"), this.ab.buttonNode = e.createChildNode("btn"), this.ab.buttonPosNode = e.createChildNode("btn_pos"), this.ab.bgAllWinNode = new r({
                name: "bg_all_win",
                layer: this.ab.topNode.layer
            }), this.ab.bgAllWinNode.play("init", {
                autoRemove: !1
            }).process(), this.ab.bgAllFrameWinNode = new r({
                name: "bg_all_frame_win",
                layer: this.ab.topNode.layer
            }), this.ab.bgAllFrameWinNode.play("init", {
                autoRemove: !1
            }).process(), this.button = (new i(e.createChildNode("btn"), e.name, "btnGroupName")).setButtonStateTags("btn_touch", void 0, void 0).setTouchHandler(function(e) {
                t.button.setEnabled(!1), t._closeDeferred().then(function() {
                    t._handleNextModal()
                })
            }).setEnabled(!0), this.button.setLabelWithDetail(o.getInstance().get("ok"), !0, u.LABEL_BUTTON_OK)
        },
        addModalData: function(e, t, n, r) {
            this._modalDataQueue === void 0 && (this._modalDataQueue = []), this._modalDataQueue.push({
                message: e,
                paramBoostMessage: t,
                spriteAssetInfo: n,
                abilityInfo: r
            })
        },
        showModalsDeferred: function() {
            return this._deferred = t.Deferred(), this._handleNextModal(), this._deferred.promise()
        },
        _handleNextModal: function() {
            if (!this._modalDataQueue || this._modalDataQueue.length === 0) this._deferred && (this._deferred.resolve(), this._deferred = void 0);
            else {
                var e = this._modalDataQueue.shift();
                this._showModal(e.message, e.paramBoostMessage, e.spriteAssetInfo, e.abilityInfo)
            }
        },
        _showModal: function(e, t, n, r) {
            var i = this;
            this.ab.topNode.setText(u.LABEL_MESSAGE, e);
            var s;
            t ? (s = u.TAG_OPEN_SPECIAL, this._initNodes("special_pos_01"), this.ab.messageSpecialNode.setVisible(!0), this.ab.topNode.setText(u.LABEL_PARAM_BOOST_MESSAGE, t)) : (s = u.TAG_OPEN, this._initNodes("init"), this.ab.messageSpecialNode.setVisible(!1)), this.ab.topNode.loadBundle(n.bundle).setSpriteAnimeByNode(u.SPRITE_NODE, n.assetPath), this.ab.topNode.loadBundle(r.bundle).setImage(u.IMAGE_NODE, r.assetPath), this._playTag(s, !0, function() {
                i.button.setEnabled(!0)
            }), this.button.setEnabled(!1)
        },
        _initNodes: function(e) {
            this.ab.centerNode.play(e, {
                autoRemove: !1
            }), this.ab.bgAllWinNode.play(e, {
                autoRemove: !1
            }), this.ab.bgAllFrameWinNode.play(e, {
                autoRemove: !1
            }), this.ab.buttonPosNode.play(e, {
                autoRemove: !1
            })
        },
        _closeDeferred: function() {
            var e = t.Deferred();
            return this._playTag(u.TAG_CLOSE, !0, function() {
                e.resolve()
            }), e.promise()
        },
        _playTag: function(e, t, n) {
            var r = this;
            if (this._lastTg === e) return;
            this._lastTg = e, this.ab.posCenterAnmNode.play(e).processDeferred("action_stop").then(function() {
                (e === u.TAG_OPEN || e === u.TAG_OPEN_SPECIAL) && r.ab.buttonNode.setVisible(!0).play("btn_open").process()
            }), this.ab.bgImgNode.play(e).processDeferred("action_stop").then(function() {
                FF.logger.debug("action stopped"), n && n()
            }), t && this._flush()
        },
        _flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.button && (this.button.dispose(), this.button = void 0)
        }
    })
}), define("scenes/battle_result/views/ResultExp", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "./ExpCell", "../collections/BuddyExp", "./AnimationPool", "./SoulStrikeLevelupModal", "lib/TextMaster"], function(e, t, n, r, i, s, o, u, a, f) {
    var l = {
        ANIMATION_POOL_FLUSH_INTERVAL: 30,
        MILLISECONDS_PER_TICK: 30,
        PROGRESS_PER_TICK: .03,
        SE: {
            COUNTUP: "se_battle_common_101054"
        }
    };
    return i.extend({
        initialize: function(t) {
            this.tutorialView = t.tutorialView, this.exp = t.exp, this.totalExp = t.totalExp, this.layer = t.layer, this.assetsManager = t.assetsManager, this.stageNode = new r({
                name: "stage_nul",
                layer: this.layer.layerName
            }), this.expTextNode = new r({
                name: "exp_get_txt_nul",
                layer: this.layer.layerName
            }), this.animationPool = new u({
                interval: l.ANIMATION_POOL_FLUSH_INTERVAL
            }), this.animationPool.nodes.push(this.expTextNode), this.animationPool.start(), this.buddyExpCollection = new o(this.exp), this.progressPerTicks = l.PROGRESS_PER_TICK, this.progressSSPerTicks = l.PROGRESS_PER_TICK, this.expCells = [];
            for (var i = 0, a = this.exp.length; i < a; i++) this.expCells[i] = new s({
                idx: i + 1,
                layer: this.layer,
                assetsManager: this.assetsManager,
                model: this.buddyExpCollection.findWhere({
                    buddyId: this.exp[i].buddyId
                }),
                animationPool: this.animationPool
            });
            this.expTextNode.setText("exp_get_txt", this.totalExp), n.Events.listenTo(this.buddyExpCollection, "update:progressRatio", e.bind(this.updateExpGetText, this)), this.soulStrikeLevelUpLayer = t.soulStrikeLevelUpLayer, this.soulStrikeLevelUpInfos = t.soulStrikeLevelUpInfos || []
        },
        start: function() {
            var n = this,
                r = [];
            e.each(this.expCells, function(e) {
                r.push(e.setupDeferred())
            }), t.when.apply(null, r).done(function() {
                setTimeout(function() {
                    n.startUpdatingGauges()
                }, 100)
            })
        },
        startUpdatingGauges: function() {
            var t = this,
                n = 0,
                r = 0,
                i = l.MILLISECONDS_PER_TICK;
            FF.SoundMgr.playEffect(l.SE.COUNTUP, {
                loop: !0
            }), this.progressTimer = setInterval(function() {
                t.buddyExpCollection.updateByProgressRatio(n), n += t.progressPerTicks, n >= 1 && (FF.SoundMgr.stopEffect(), t.buddyExpCollection.updateByProgressRatio(1), clearInterval(t.progressTimer), t.tutorialView.getTutorialFunc("battleExpMog")().then(function() {
                    e.each(t.expCells, function(e) {
                        e.suspendParticle()
                    }), t.isDone = !0, t.trigger("show:nextBtn")
                }))
            }, i)
        },
        drawSoulStrikeExp: function() {
            var n = this,
                r = 0,
                i = l.MILLISECONDS_PER_TICK,
                s = [];
            e.each(n.expCells, function(e) {
                s = s.concat(e.setSoulStrikeExpDeferredList())
            }), t.when.apply(t, s).then(function() {
                var r = [];
                return e.each(n.expCells, function(e) {
                    r.push(e.setSoulStrikeExpGaugeDeferred())
                }), t.when(r)
            }).then(function() {
                var t = e.some(n.expCells, function(e) {
                    return e.isSoulStrikeCountUp()
                });
                t ? FF.SoundMgr.playEffect(l.SE.COUNTUP, {
                    loop: !0
                }) : r = 1, n.isSSPhase = !0, n.progressSSTimer = setInterval(function() {
                    n.buddyExpCollection.updateByProgressSSRatio(r), r += n.progressSSPerTicks, r >= 1 && (FF.SoundMgr.stopEffect(), e.each(n.expCells, function(e) {
                        e.suspendSoulStrikeExpParticle()
                    }), n.buddyExpCollection.updateByProgressSSRatio(1), clearInterval(n.progressSSTimer), n.isSSDone = !0, n._showSoulStrikeLevelUpDeferred().then(function() {
                        n.trigger("show:nextBtn")
                    }))
                }, i)
            })
        },
        updateExpGetText: function(e) {
            var t = Math.round(this.totalExp * (1 - e));
            this.expTextNode.setText("exp_get_txt", t)
        },
        completeAtOnce: function() {
            FF.SoundMgr.stopEffect(), !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.progressPerTicks = 1, this.shouldCompleteAtOnce = !0), this.isSSPhase && !this.isSSDone && !this.shouldCompleteSSAtOnce && (this.progressSSPerTicks = 1, this.shouldCompleteSSAtOnce = !0)
        },
        _showSoulStrikeLevelUpDeferred: function() {
            function s(e) {
                var t = "buddy-" + e.path;
                return n.assetsManager.getAssetInfo(t)
            }

            function o(e) {
                var t = "soul_strike_" + e.soulStrikeId;
                return n.assetsManager.getAssetInfo(t)
            }

            function u(t) {
                if (e.keys(t.paramBooster).length === 0) return "";
                var n = f.getInstance().get("R10230") + "\n",
                    r = ["hp", "spd", "atk", "def", "matk", "mdef", "mnd", "acc", "eva"],
                    i = r.length;
                for (var s = 0; s <= i; s++) {
                    var o = r[s] + "Boost";
                    t.paramBooster[o] > 0 && (n += sprintf(f.getInstance().get("R10240"), f.getInstance().get("param_category_name_" + r[s]), t.paramBooster[o]))
                }
                return n
            }
            FF.logger.debug("ResultView: showSoulStrikeLvupDeferred");
            var n = this;
            if (this.soulStrikeLevelUpInfos.length === 0) return t.Deferred().resolve().promise();
            var r = this.soulStrikeLevelUpLayer.createNode("stage_nul"),
                i = new a(r);
            return e.each(this.soulStrikeLevelUpInfos, function(e) {
                var t = e.buddy.name,
                    n = e.soulStrike.soulStrikeName,
                    r = s(e.buddy),
                    a = o(e.soulStrike),
                    l = u(e.soulStrike),
                    c = f.getInstance().get("R10200");
                i.addModalData(sprintf(c, t, n), l, r, a)
            }), i.showModalsDeferred().then(function() {
                i.dispose()
            })
        },
        dispose: function() {
            n.Events.stopListening(this.buddyExpCollection, "update:progressRatio"), this.expTextNode.deleteNode().process(), e.each(this.expCells, function(e) {
                e.dispose()
            }), this.animationPool.dispose(), clearInterval(this.progressTimer), clearInterval(this.progressSSTimer), this.tutorialView = void 0, FF.SoundMgr.stopEffect()
        }
    })
}), define("scenes/battle_result/misc/CampaignItemDiscriminator", ["underscore", "jquery", "backbone", "lib/ClassBase"], function(e, t, n, r) {
    var i, s = r.extend({
        initialize: function() {
            this.resetCampaignsData()
        },
        resetCampaignsData: function() {
            this._campaignItemIdList = []
        },
        applyCampaignsData: function(t) {
            var n = [],
                r = [];
            e.each(t, function(t) {
                t.wasOpenWhenBattleBegun && e.each(t.dropItemIncreaser, function(e) {
                    n.push(e.itemId)
                }), t.wasOpenWhenBattleEnded && e.each(t.dungeonPrizeIncreaser, function(e) {
                    r.push(e.itemId)
                })
            }), this._campaignItemIdListDropItem = n, this._campaignItemIdListDungeonPrize = r, FF.logger.debug("campaignItemIdList", this._campaignItemIdList)
        },
        isCampaignBonusItemForDropItem: function(e) {
            var t = "" + e.id;
            return this._campaignItemIdListDropItem.indexOf(t) >= 0
        },
        isCampaignBonusItemForDungeonPrize: function(e) {
            var t = "" + e.id;
            return this._campaignItemIdListDungeonPrize.indexOf(t) >= 0
        }
    }, {
        getInstance: function() {
            return i || (i = new s), i
        }
    });
    return s
}), define("scenes/battle_result/views/ResultItem", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase", "lib/TextMaster", "../misc/CampaignItemDiscriminator"], function(e, t, n, r, i, s, o, u) {
    var a = {
        MAX_ROW: 9,
        RECORD_MATERIA_COND_TYPE: {
            SCORE: 4
        },
        RECORD_MATERIA_MODAL_ASSET_SIZE: 128,
        BONUS_NODE_NAMES: ["campaign_bonus", "leader_bonus", "member_bonus", "battle_bonus", "equip_bonus"]
    };
    return s.extend({
        initialize: function(t) {
            this.tutorialView = t.tutorialView, this.layer = t.layer, this.assetsManager = t.assetsManager, this.buddy = t.buddy, this.dropItemIdToNum = t.dropItemIdToNum, this.dropItemIdToEquipBonus = t.dropItemIdToEquipBonus, this.dropRecordMateriaItemIdToNum = t.dropRecordMateriaItemIdToNum, this.scoreRecordMateriaItemIdToNum = t.scoreRecordMateriaItemIdToNum, this.buddyLevelRecordMateriaItemIdToNum = t.buddyLevelRecordMateriaItemIdToNum, this.hostPrizeItemIdToNum = t.hostPrizeItemIdToNum, this.guestPrizeItemIdToNum = t.guestPrizeItemIdToNum, this.singlePrizeItemIdToNum = t.singlePrizeItemIdToNum, this.itemCollection = t.itemCollection, this.centerFrontNode = t.centerFrontNode, this.centerFrontNewNode = t.centerFrontNewNode, this.playSpeedCoefficient = 1, this.serverConst = t.serverConst, this._moLeaderItemListRange = {
                from: -1,
                to: -1
            }, this._moGuestItemListRange = {
                from: -1,
                to: -1
            }, this._moSigleItemListRange = {
                from: -1,
                to: -1
            }, this.dropItemList = [], e.size(this.hostPrizeItemIdToNum) > 0 && (this._moLeaderItemListRange.from = this.dropItemList.length, this.dropItemList = this.dropItemList.concat(this.itemCollection.makeItemList(this.hostPrizeItemIdToNum)), this._moLeaderItemListRange.to = this.dropItemList.length), e.size(this.guestPrizeItemIdToNum) > 0 && (this._moGuestItemListRange.from = this.dropItemList.length, this.dropItemList = this.dropItemList.concat(this.itemCollection.makeItemList(this.guestPrizeItemIdToNum)), this._moGuestItemListRange.to = this.dropItemList.length), e.size(this.singlePrizeItemIdToNum) > 0 && (this._moSigleItemListRange.from = this.dropItemList.length, this.dropItemList = this.dropItemList.concat(this.itemCollection.makeItemList(this.singlePrizeItemIdToNum)), this._moSigleItemListRange.to = this.dropItemList.length), this.dropItemList = this.dropItemList.concat(this.itemCollection.makeItemList(this.dropRecordMateriaItemIdToNum), this.itemCollection.makeItemList(this.scoreRecordMateriaItemIdToNum), this.itemCollection.makeItemList(this.buddyLevelRecordMateriaItemIdToNum), this.itemCollection.makeItemList(this.dropItemIdToNum)), this.dropItemNum = e.min([a.MAX_ROW, this.dropItemList.length]), FF.logger.debug("ResultItem : ", this.dropItemList);
            if (this._hasRecordMateriaInList()) {
                var r = "materia_get",
                    i = this.assetsManager.getAssetInfo(r);
                this.materiaGetLayer = new n({
                    layerName: i.layerName,
                    assetPath: i.assetPath
                }), this.materiaGetLayer.activate()
            }
            this.itemNodes = []
        },
        start: function() {
            var e = this,
                t = this._makeItems();
            this._showListItemsDeferred(t).then(this.tutorialView.getTutorialFunc("battleItemMog")).then(function() {
                FF.logger.debug("ResultItem animation complete"), e.isDone = !0, e.trigger("show:nextBtn")
            })
        },
        _hasRecordMateriaInList: function() {
            for (var e = 0; e < this.dropItemNum; e++) {
                var t = this.dropItemList[e];
                if (t.isRecordMateria()) return 1
            }
            return 0
        },
        _makeItems: function() {
            var e = [];
            for (var t = 0; t < this.dropItemNum; t++) {
                var n = (new i({
                        name: "item_pos_nul_" + (t + 1),
                        layer: this.layer.layerName,
                        parentNodeName: "item_pos_nul_" + (t + 1),
                        duplicateFrom: "item_base_nul",
                        duplicateFromOptions: {
                            parentNode: "item_pos_nul_" + (t + 1)
                        }
                    })).process(),
                    r = this.dropItemList[t].getAssetIdOfTreasure(),
                    s = this.assetsManager.getAssetInfo(r);
                n.loadBundle(s.bundle).setSpriteAnimeByNode("sprite_treasure_symbol", s.assetPath).setSpriteActionByNode("sprite_treasure_symbol", "stop").process();
                var o = this._moLeaderItemListRange.from <= t && t < this._moLeaderItemListRange.to,
                    u = this._moGuestItemListRange.from <= t && t < this._moGuestItemListRange.to,
                    a = this._moSigleItemListRange.from <= t && t < this._moSigleItemListRange.to,
                    f = o || u || a,
                    l = this.dropItemList[t].get("itemId"),
                    c = !f && !!this.dropItemIdToEquipBonus[l];
                e.push({
                    node: n,
                    model: this.dropItemList[t],
                    isMoLeaderBonus: o,
                    isMoGuestBonus: u,
                    isMoSingleBonus: a,
                    isEquipBonus: c
                }), this.itemNodes.push(n)
            }
            return e
        },
        _showListItemsDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (e.length === 0) return r.resolve().promise();
            var i = function(t) {
                    t.then(function() {
                        if (e.length === 0) {
                            r.resolve();
                            return
                        }
                        var t = e.shift(),
                            s = n._showEachItemDeferred(t);
                        i(s)
                    })
                },
                s = e.shift(),
                o = this._showEachItemDeferred(s);
            return i(o), r.promise()
        },
        _showEachItemDeferred: function(e) {
            return e.model.needToDisplayModal(this.serverConst) ? this._showItemInListWithModalDeferred(e) : this._showItemInListDeferred(e)
        },
        _showItemInListDeferred: function(n) {
            var r = this,
                i = t.Deferred(),
                s = n.model.get("name"),
                o = n.model.getNameWithNum(),
                a = n.model.getAssetId(),
                f = this.assetsManager.getAssetInfo(a),
                l = n.model.getRewardListPlayTagName(),
                c = n.isMoLeaderBonus,
                h = n.isMoGuestBonus,
                p = n.isMoSingleBonus,
                d = n.isEquipBonus,
                v = [{
                    nodeName: "leader_bonus",
                    isVisible: c
                }, {
                    nodeName: "member_bonus",
                    isVisible: h
                }, {
                    nodeName: "battle_bonus",
                    isVisible: p
                }, {
                    nodeName: "campaign_bonus",
                    isVisible: u.getInstance().isCampaignBonusItemForDropItem(n.model)
                }, {
                    nodeName: "equip_bonus",
                    isVisible: d
                }];
            FF.logger.debug(" ", s, "playTag", l), n.node.setSpriteActionByNode("sprite_treasure_symbol", "open").setText("icon_item_txt", o);
            var m;
            if (this.shouldCompleteAtOnce) {
                var g = e.find(v.reverse(), function(e) {
                    return e.isVisible
                });
                return m = g ? g.nodeName : "", this._setBonusVisible(n, m), n.node.loadBundle(f.bundle).setImage("image_icon_item", f.assetPath).play(l, {
                    speed: r.playSpeedCoefficient
                }).process(), i.resolve().promise()
            }
            var y = e.find(v, function(e) {
                return e.isVisible
            });
            m = y ? y.nodeName : "";
            var b = e.filter(v, function(e) {
                    return e.isVisible && e.nodeName !== m
                }),
                w = e.map(b, function(e) {
                    return e.nodeName
                });
            return this._setBonusVisible(n, m), n.node.loadBundle(f.bundle).setImage("image_icon_item", f.assetPath).play(l, {
                speed: r.playSpeedCoefficient
            }).processDeferred("action_stop").then(function() {
                return r._showAdditionalAnimationForItemInListDeferred(n, w, f, l)
            }).then(function() {
                return i.resolve()
            }), i.promise()
        },
        _setBonusVisible: function(t, n) {
            e.each(a.BONUS_NODE_NAMES, function(e) {
                var r = n && e === n ? !0 : !1;
                t.node.setVisibleByNode(e, r)
            })
        },
        _showAdditionalAnimationForItemInListDeferred: function(e, n, r, i) {
            var s = this,
                o = t.Deferred();
            if (n.length === 0) return o.resolve().promise();
            var u = function(t) {
                    t.then(function() {
                        if (n.length === 0) {
                            o.resolve();
                            return
                        }
                        var t = n.shift(),
                            a = s._showAdditionalAnimationDeferred(e, t, r, i);
                        u(a)
                    })
                },
                a = n.shift(),
                f = this._showAdditionalAnimationDeferred(e, a, r, i);
            return u(f), o.promise()
        },
        _showAdditionalAnimationDeferred: function(e, t, n, r) {
            return this._setBonusVisible(e, t), e.node.loadBundle(n.bundle).play(r, {
                speed: this.playSpeedCoefficient
            }, t).processDeferred("action_stop", {
                node: t
            })
        },
        _showItemInListWithModalDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                s = e.model,
                o = s.getAssetId(),
                u = this.assetsManager.getAssetInfo(o),
                a = s.getRewardModalCloseButtonNodeName(),
                f = s.isRecordMateria() ? n.materiaGetLayer : n.layer.layerName,
                l = new i({
                    name: a,
                    layer: f
                });
            return s.isRecordMateria() ? n._showRecordMateriaModalDeffered(l, e).then(function() {
                r.resolve()
            }) : n._showNormalModalDeffered(l, e, u).then(function() {
                r.resolve()
            }), r.promise()
        },
        _showNormalModalDeffered: function(e, n, r) {
            var i = this,
                s = t.Deferred(),
                u = n.model,
                a = this.assetsManager.getAssetInfo(u.getAssetIdOfTreasure());
            return this.centerFrontNode.loadBundle(a.bundle).setSpriteAnimeByNode("sprite_treasure_symbol_front", a.assetPath).setSpriteActionByNode("sprite_treasure_symbol_front", "stop").setVisible(!0).setText(u.getModalTextTagName(), sprintf(o.getInstance().get("R10040"), u.get("name"))).loadBundle(r.bundle).setImage(u.getModalImageTagName(), r.assetPath).play(u.getRewardModalPlayTagName()).processDeferred("action_stop").then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return i.centerFrontNode.play(u.getModalCloseTagName()).processDeferred("action_stop")
            }).then(function() {
                return i.centerFrontNode.setVisible(!1).process(), i._showItemInListDeferred(n)
            }).then(function() {
                s.resolve()
            }), s.promise()
        },
        _showRecordMateriaModalDeffered: function(e, n) {
            var r = this,
                i = t.Deferred();
            return this._prepareRecordMateriaModal(n), this.materiaGetNode.play("in").processDeferred("action_stop").then(function() {
                r.materiaGetNode.play("loop").process()
            }).then(function() {
                return e.processDeferred("action_touch_ended")
            }).then(function() {
                return r.materiaGetNode.play("tap_end").processDeferred("action_stop")
            }).then(function() {
                return r.materiaGetNode.setVisible(!1).process(), r._showItemInListDeferred(n)
            }).then(function() {
                i.resolve()
            }), i.promise()
        },
        _getRecordMateriaCutinBodyText: function(e) {
            var t = this._isCondTypeScore(e) ? o.getInstance().get("R10140") + "\n" : "";
            return t + sprintf(o.getInstance().get("R10040"), e.model.get("name"))
        },
        _prepareRecordMateriaModal: function(t) {
            var n = this,
                r = t.model.getAssetId(a.RECORD_MATERIA_MODAL_ASSET_SIZE),
                i = this.assetsManager.getAssetInfo(r),
                s = this._getRecorcMateriaModalPlayTag(t);
            this.materiaGetLayer.createNode("cutin_bg_nul").play(s, {
                autoRemove: !1
            }).process();
            var o = this._getRecordMateriaCutinBodyText(t),
                u = e.findWhere(this.buddy, {
                    buddyId: t.model.get("buddyId")
                }),
                f = sprintf("buddy-%s", u.path),
                l = this.assetsManager.getAssetInfo(f);
            this.materiaGetNode = this.materiaGetLayer.createNode("cutin_nul"), this.materiaGetNode.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", o).loadBundle(i.bundle).setImage("materia_img", i.assetPath).setImage("materia_img_add", i.assetPath).loadBundle(l.bundle).setSpriteAnimeByNode("chara_sprite", l.assetPath).setVisible(!0);
            var c = t.model.get("condDescription");
            c = c.replace(/<br>/g, "\n"), this._isCondTypeScore(t) && n.materiaGetNode.setText("notice_txt", c)
        },
        _getRecorcMateriaModalPlayTag: function(e) {
            return this._isCondTypeScore(e) ? "scale_window_2" : "scale_window_1"
        },
        _isCondTypeScore: function(e) {
            var t = parseInt(e.model.get("condType"));
            return t === a.RECORD_MATERIA_COND_TYPE.SCORE ? !0 : !1
        },
        completeAtOnce: function() {
            !this.isDone && !this.shouldCompleteAtOnce && (FF.SoundMgr.playChooseEffect(), this.playSpeedCoefficient = 100, this.shouldCompleteAtOnce = !0)
        },
        dispose: function() {
            this.dropItemIdToNum = null, this.itemCollection = null;
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            e(this.itemNodes).each(function(e) {
                e.suspendParticle().setVisible(!1).process()
            }), this.centerFrontNode.createChildNode("reward_front_nul").suspendParticle().process(), this.centerFrontNode.setVisible(!1).process(), t(this.itemNodes), this.tutorialView = void 0
        }
    })
}), define("scenes/battle_result/views/result_dungeon/AnimationParams", ["underscore", "jquery", "backbone", "lib/ClassBase"], function(e, t, n, r) {
    return r.extend({
        playSpeedCoefficient: 1,
        shouldCompleteAtOnce: !1,
        initialize: function() {
            this.reset()
        },
        reset: function() {
            this.playSpeedCoefficient = 1, this.shouldCompleteAtOnce = !1
        }
    })
}), define("scenes/battle_result/views/result_dungeon/Util", ["underscore", "jquery", "backbone", "../../misc/CampaignItemDiscriminator"], function(e, t, n, r) {
    return {
        deleteDuplicatedNodes: function(t) {
            e.each(t, function(e) {
                e && (e.removeAllCallback(), e.deleteNode().process())
            })
        },
        showItemInListDeferred: function(e, n, i) {
            var s = t.Deferred(),
                o = i.model.get("name"),
                u = i.model.getNameWithNum(),
                a = i.model.getAssetId(),
                f = e.getAssetInfo(a),
                l = i.model.getDungeonRewardListPlayTagName();
            return FF.logger.debug(" ", o, "playTag", l), FF.logger.debug(i), i.node.setVisible(!0).setVisibleByNode("campaign_bonus", r.getInstance().isCampaignBonusItemForDungeonPrize(i.model)).setText("icon_item_txt", u).loadBundle(f.bundle).setImage("image_icon_item", f.assetPath).play(l, {
                speed: n.playSpeedCoefficient
            }), n.shouldCompleteAtOnce ? s.resolve() : i.node.addCallbackOnce("action_stop", function() {
                s.resolve()
            }), i.node.process(), s.promise()
        }
    }
}), define("scenes/battle_result/views/result_dungeon/ScrollListView", ["underscore", "jquery", "backbone", "lib/ClassBase", "lib/ab/ABNode", "./Util"], function(e, t, n, r, i, s) {
    var o = r.extend({
        initialize: function(e, t, n, r) {
            this._type = e, this._nodeName = sprintf("reward_%s_nul", e), this._innerNodeNamePrefix = sprintf("reward_%s_item_pos_nul_", e), this._numItem = 0, this._numItemSlot = t, this._originalPosX = n, this._originalPosY = r, this._active = !0
        },
        getInfoString: function() {
            return sprintf("[RewardLayout] %s x:%s y:%s h:%s (%s/%s)", this._type, this._originalPosX, this.getPosY(), this.getHeight(), this._numItem, this._numItemSlot)
        },
        getType: function() {
            return this._type
        },
        getNumItemSlot: function() {
            return this._numItemSlot
        },
        getPosY: function() {
            return this._prevGroup ? this._prevGroup.getPosY() + this._prevGroup.getHeight() : this._originalPosY
        },
        getHeight: function() {
            return this._numItem <= 0 || !this._active ? 0 : o.TITLE_HEIGHT + o.ITEM_PADDING + o.ITEM_HEIGHT * this._numItem
        },
        getBottom: function() {
            return this.getPosY() + this.getHeight()
        },
        getInnerNodeNameByPosNum: function(e) {
            return this._innerNodeNamePrefix + e
        },
        getInnerNodeYPostions: function() {
            var e = [];
            if (!this._active) return e;
            var t = this.getPosY() + o.TITLE_HEIGHT;
            for (var n = 0; n < this._numItem; n++) e.push(t + n * o.ITEM_HEIGHT);
            return e
        },
        setActive: function(e) {
            this._active = e
        },
        setPrevGroup: function(e) {
            this._prevGroup = e
        },
        setNumItem: function(e) {
            this._numItem = Math.min(this._numItemSlot, e)
        },
        updateView: function() {
            var e = new i({
                    name: this._nodeName,
                    layer: o._layerName
                }),
                t = this.getPosY();
            e.setPosition([this._originalPosX, t]), e.setVisible(this._active && this._numItem > 0);
            for (var n = 1; n <= this._numItemSlot; n++) e.setVisibleByNode(this.getInnerNodeNameByPosNum(n), this._numItemSlot >= n);
            e.process()
        }
    }, {
        TITLE_HEIGHT: 32,
        ITEM_HEIGHT: 32,
        ITEM_PADDING: 0,
        setLayerName: function(e) {
            this._layerName = e
        }
    });
    o.CLEAR = new o("clear", 3, 0, 13), o.MASTER = new o("master", 3, 0, 108), o.FIRST = new o("first", 3, 0, 236), o.CLEAR.setPrevGroup(null), o.MASTER.setPrevGroup(o.CLEAR), o.FIRST.setPrevGroup(o.MASTER);
    var u = r.extend({
            initialize: function(e) {
                this._layerName = e, this._currentY = u.BASE_Y, this._scrollbarNode = new i({
                    name: u.SCROLLBAR_NODE,
                    layer: this._layerName
                }), this._scrollbarNode.setVisible(!0).process(), this._scrollContainer = new i({
                    name: u.CONTAINER_NODE,
                    layer: this._layerName
                })
            },
            dispose: function() {
                this._scrollContainer = void 0, this._scrollbarNode = void 0, kickmotor.animation.processAnimation([{
                    exec: "clearTouchRect",
                    layer: this._layerName,
                    node: u.CONTAINER_NODE
                }])
            },
            scrollToDeferred: function(e) {
                FF.logger.debug("scrollToDeferred", e);
                var n = t.Deferred(),
                    r = u.SCROLL_START_THRESHOLD - e;
                if (e === void 0 || r >= 0) return n.resolve().promise();
                r = u.BASE_Y + r, FF.logger.debug("moveBy", r);
                var i = [{
                    action: "moveBy",
                    duration: .25,
                    pos: [0, r - this._currentY]
                }];
                return this._currentY = r, this._scrollContainer.sequence(i, function(e) {
                    FF.logger.debug("onScrollDone", e), n.resolve()
                }).process(), n.promise()
            },
            setDraggable: function(e) {
                var t = u.BASE_Y - this._currentY;
                kickmotor.animation.processAnimation([{
                    exec: "addTouchRect",
                    layer: this._layerName,
                    node: u.CONTAINER_NODE,
                    rect: [-u.TOUCHAREA_WIDTH * .5, -u.TOUCHAREA_HEIGHT * .5, u.TOUCHAREA_WIDTH, u.TOUCHAREA_HEIGHT],
                    isHitTestEnable: !0
                }]), kickmotor.animation.processAnimation([{
                    exec: "setDragEnable",
                    layer: this._layerName,
                    node: u.CONTAINER_NODE,
                    isEnable: e,
                    dragArea: [u.BASE_X, u.BASE_Y - t, 0, t],
                    dragMargin: [0, u.DRAG_MARGIN, 0, u.DRAG_MARGIN],
                    slowdownRate: 16
                }])
            },
            isScrolled: function() {
                return this._currentY !== u.BASE_Y
            }
        }, {
            BASE_X: 140,
            BASE_Y: 100,
            SCROLL_START_THRESHOLD: 240,
            DRAG_MARGIN: 50,
            TOUCHAREA_WIDTH: 320,
            TOUCHAREA_HEIGHT: 480,
            CONTAINER_NODE: "dungeon_clear_column",
            SCROLLBAR_NODE: "dungeon_clear_scroll"
        }),
        a = r.extend({
            initialize: function(e) {
                this._duplicateNodes = [], this._assetsManager = e.assetsManager, this._animationParams = e.animationParams, this._layerName = e.layerName, this._modalManager = e.modalManager, this._serverConst = e.serverConst;
                var t = e.result,
                    n = e.itemCollection;
                this._isFirstClearMaster = t.isFirstClearMaster, this._clearPrizeList = n.makeItemList(t.clearPrizeItemIdToNum), this._firstMasterPrizeList = n.makeItemList(t.firstMasterPrizeItemIdToNum), this._firstClearPrizeList = n.makeItemList(t.firstClearPrizeItemIdToNum), this._totalListItemIndex = 0, this._listItemPositions = [], this._scroller = new u(this._layerName), this._adjustListItemsPosition(), FF.logger.debug("clearPrizeList", this._clearPrizeList), FF.logger.debug("firstClearPrizeList", this._firstClearPrizeList), FF.logger.debug("firstMasterPrizeList", this._firstMasterPrizeList)
            },
            dispose: function() {
                s.deleteDuplicatedNodes(this._duplicateNodes), this._scroller && (this._scroller.dispose(), this._scroller = void 0), this._duplicateNodes = void 0, this._assetsManager = void 0, this._animationParams = void 0, this._modalManager = void 0, this._firstClearPrizeList = void 0, this._clearPrizeList = void 0, this._firstMasterPrizeList = void 0
            },
            showBonusesDeferred: function() {
                var e = this,
                    n = t.Deferred();
                return this._showClearBonusDeferred().then(function() {
                    return e._showMasterBonusDeferred()
                }).then(function() {
                    return e._showFirstBonusDeferred()
                }).then(function() {
                    n.resolve()
                }), n.promise()
            },
            startDrag: function() {
                this._scroller.setDraggable(!0)
            },
            _adjustListItemsPosition: function() {
                o.setLayerName(this._layerName), o.CLEAR.setNumItem(this._clearPrizeList.length), o.CLEAR.setActive(!0), o.MASTER.setNumItem(this._firstMasterPrizeList.length), o.MASTER.setActive(this._isFirstClearMaster), o.FIRST.setNumItem(this._firstClearPrizeList.length), o.FIRST.setActive(!0), o.CLEAR.updateView(), o.MASTER.updateView(), o.FIRST.updateView(), FF.logger.debug(o.CLEAR.getInfoString()), FF.logger.debug(o.MASTER.getInfoString()), FF.logger.debug(o.FIRST.getInfoString()), this._listItemPositions = this._listItemPositions.concat(o.CLEAR.getInnerNodeYPostions()), this._listItemPositions = this._listItemPositions.concat(o.MASTER.getInnerNodeYPostions()), this._listItemPositions = this._listItemPositions.concat(o.FIRST.getInnerNodeYPostions()), FF.logger.debug("listItemPositions", this._listItemPositions)
            },
            _showClearBonusDeferred: function() {
                FF.logger.debug("");
                var e = t.Deferred(),
                    n = this._makeBonusItems(o.CLEAR, this._clearPrizeList);
                return this._showListDeferred(n, this._showEachItemDeferred).then(function() {
                    e.resolve()
                }), e.promise()
            },
            _showMasterBonusDeferred: function() {
                FF.logger.debug("");
                var e = t.Deferred(),
                    n = this._makeBonusItems(o.MASTER, this._firstMasterPrizeList);
                return this._showListDeferred(n, this._showEachItemDeferred).then(function() {
                    e.resolve()
                }), e.promise()
            },
            _showFirstBonusDeferred: function() {
                FF.logger.debug("");
                var e = t.Deferred(),
                    n = this._makeBonusItems(o.FIRST, this._firstClearPrizeList);
                return this._showListDeferred(n, this._showEachItemDeferred).then(function() {
                    e.resolve()
                }), e.promise()
            },
            _makeBonusItems: function(t, n) {
                var r = [],
                    s = e.min([t.getNumItemSlot(), n.length]);
                for (var o = 0; o < s; o++) {
                    var u = t.getInnerNodeNameByPosNum(o + 1),
                        a = (new i({
                            name: u,
                            layer: this._layerName,
                            parentNodeName: u,
                            duplicateFrom: "item_base_nul",
                            duplicateFromOptions: {
                                parentNode: u
                            }
                        })).process();
                    r.push({
                        node: a,
                        model: n[o]
                    }), this._duplicateNodes.push(a)
                }
                return r
            },
            _showListDeferred: function(e, n) {
                var r = this,
                    i = t.Deferred();
                if (e.length === 0) return i.resolve().promise();
                var s = function(t) {
                        t.then(function() {
                            if (e.length === 0) {
                                i.resolve();
                                return
                            }
                            var t = e.shift(),
                                o = n.call(r, t);
                            s(o)
                        })
                    },
                    o = e.shift(),
                    u = n.call(this, o);
                return s(u), i.promise()
            },
            _showEachItemDeferred: function(e) {
                var n = this,
                    r = e.model.needToDisplayModalInDungeonReward(this._serverConst),
                    i = this._listItemPositions[this._totalListItemIndex++];
                if (r) return t.when(this._scroller.scrollToDeferred(i), this._modalManager.showItemInListWithModalDeferred(e));
                var o = t.Deferred();
                return this._scroller.scrollToDeferred(i).then(function() {
                    return s.showItemInListDeferred(n._assetsManager, n._animationParams, e)
                }).then(function() {
                    o.resolve()
                }), o.promise()
            }
        });
    return a
}), define("scenes/common/Constant", [], function() {
    return {
        GLOBAL: {
            CLASS: {
                ANIM_DISABLE: "g-disable-animation",
                ANIM_END: "webkitAnimationEnd animationend"
            }
        },
        EQUIPMENT: {
            TYPE_NAME_OF: {
                WEAPON: "weapon",
                ARMOR: "armor",
                ACCESSORY: "accessory",
                HAMMERING: "hammering"
            },
            PARAM_OPTION_CALC_BOOST_STATUS: {
                calcBoostStatus: !0
            },
            ATTRIBUTE: {
                ELEMENT_ATK_TYPE_NAME_OF: {
                    SMALL: "small"
                },
                ELEMENT_DEF_TYPE_NAME_OF: {
                    WEAKNESS: "weakness",
                    SMALL: "small",
                    MIDDLE: "middle",
                    LARGE: "large"
                },
                ELEMENT_ATK_TYPE_ID_OF: {
                    SMALL: 120
                },
                ELEMENT_DEF_TYPE_ID_OF: {
                    WEAKNESS: 1,
                    SMALL: 2,
                    MIDDLE: 4,
                    LARGE: 7
                }
            },
            ATK_TYPE: {
                INDIRECT: 2
            },
            SPECIAL_ATTRIBUTE_TEXT_ID_OF: {
                23080245: "equip_element_def_all_strength_rate_small"
            }
        },
        STATUS_AILMENT: {
            TYPE_NAME_OF: {
                LOW: "low",
                MIDDLE: "middle",
                HIGH: "high"
            },
            ATK_RATE_ID_OF: {
                LOW_BOTTOM: 3,
                LOW_TOP: 5
            },
            DEF_RATE_ID_OF: {
                LOW: 2,
                MIDDLE: 10,
                HIGH: 100
            }
        },
        DATA_APP_OF: {
            BTN_BACK: "data-app-btn-back"
        },
        CSS_VALUE: {
            SCROLL_FACE_HEIGHT: 31
        },
        STORAGE_KEYS: {
            SORT_MODULE: {
                SORT: "sort",
                ORDER: "order",
                PRIOR_SERIES: "priorSeries",
                CHARA_ROLE: "charaRole",
                ABILITY_TYPE: "abilityType",
                SOUL_STRIKE_TYPE: "soulStrikeType",
                SPHERE_LEVEL_TYPE: "sphereLevelType",
                ELEMENT_TYPE: "elementType",
                AILMENT_TYPE: "ailmentType",
                RESONANCE: "resonance",
                LAST_TAB: "sort_module:last_tab",
                STORAGE_KEY: "sort_collection_types_data"
            },
            EVENT: {
                NIGHTMARE_DUNGEON: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_nightmare_dungeon_intro_page"
                }
            }
        },
        COOKIE_KEYS: {
            DESIGN_TYPE_OF: {
                PARTY: "design_type_of_party"
            },
            LEAD_TO_SECOND_DUNGEON: "lead_to_second_dungeon",
            EVENT: {
                FRAGMENT_DUNGEON: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_fragment_dungeon_intro_page"
                },
                FES6: {
                    HAS_SHOWN_FIRST_TIME_FES6_INTRO_PAGE: "has_shown_first_time_fes6_intro_page",
                    HAS_SHOWN_FIRST_TIME_FES6_INTRO_MOVIE: "has_shown_first_time_fes6_intro_movie"
                },
                GW_2016: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_GW_2016_intro_page",
                    HAS_SHOWN_FIRST_TIME_INTRO_MOVIE: "has_shown_first_time_GW_2016_intro_movie"
                },
                GW_2016_COLISEUM: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_GW_2016_coliseum_intro_page",
                    HAS_SHOWN_FIRST_TIME_INTRO_MOVIE: "has_shown_first_time_GW_2016_coliseum_intro_movie"
                },
                GW_2016_MINI_GAME: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_GW_2016_mini_game_intro_page"
                },
                FES7: {
                    HAS_SHOWN_FIRST_TIME_FES7_INTRO_PAGE: "has_shown_first_time_fes7_intro_page",
                    HAS_SHOWN_FIRST_TIME_FES7_INTRO_MOVIE: "has_shown_first_time_fes7_intro_movie",
                    HAS_SHOWN_FIRST_TIME_FES7_FIFTH_BOSS_INTRO_PAGE: "has_shown_first_time_fes7_fifth_boss_intro_page"
                },
                REVENGE_DUNGEON: {
                    HAS_SHOWN_FIRST_TIME_INTRO_PAGE: "has_shown_first_time_revenge_dungeon_intro_page"
                }
            }
        },
        OVERSCROLL_NUMS: {
            TILE: 40,
            BUDDY_TILE: 50,
            PROFILE_TILE: 5,
            RECORD_MATERIA_TILE: 10,
            BUTTON: 20,
            EQUIP_TILE: 27,
            PARTY_EDIT_TILE: 42,
            BUDDY_WIDE_LIST: 20,
            INFINIT: 99999
        },
        REVIEW_ID_OF: {
            BANNER: 999999
        },
        PAYMENT_ERROR_CODE_OF: {
            PURCHASING_COIN_FAILED: 10002,
            PURCHASING_COIN_CANCELED: 10003
        },
        FOLLOW_SCENE_ID_OF: {
            AFTER_DUNGEON: 1,
            INVITE_ID_SEARCH: 2,
            FOLLOWER_LIST: 3
        },
        PARTY_TOP_SUB_CATEGORY: {
            EQUIPMENT: 1,
            SOULSTRIKE: 2,
            ABILITY: 3,
            RECORD_MATERIA: 4
        },
        BUDDY_LIST_DESIGN_TYPE_OF: {
            ICON: 1,
            WIDE: 2
        },
        FF_PORTAL_URL: {
            IOS: {
                LAUNCH_URL: "com.square-enix.ffportal://open",
                STORE_URL: "itms-apps://itunes.apple.com/app/id933144512?mt=8"
            },
            ANDROID: {
                LAUNCH_URL: "com.square-enix.ffportal.googleplay://open",
                STORE_URL: "market://details?id=com.square_enix.ffportal.googleplay"
            }
        },
        GENERAL_ORDER_TYPE_OF: {
            DESC: "desc",
            ASC: "asc"
        },
        SORT_MODULE: {
            ORDER_DESC_TYPE_OF: {
                NONE: "none",
                VALUE_TYPE: "valueType",
                DATE_TYPE: "dateType"
            },
            SUB_SORT_TYPE_OF: {
                NONE: "none",
                ASC_OR_DESC: "ascOrDesc",
                SERIES_ID: "seriesId",
                CHARA_ROLE: "charaRole",
                ABILITY: "ability",
                SOUL_STRIKE: "soulStrike",
                SPHERE_LEVEL: "sphereLevel",
                ELEMENT: "element",
                AILMENT: "ailment"
            }
        },
        EVENT_ID_OF: {
            FES_6_FIRST_EVENT: 523,
            GW_2016: {
                ZAKUZAKU: 529,
                COLISEUM: {
                    FIRST_COLISEUM_EVENT: 530,
                    SECOND_COLISEUM_EVENT: 531,
                    THIRD_COLISEUM_EVENT: 532,
                    FOURTH_COLISEUM_EVENT: 533,
                    FIFTH_COLISEUM_EVENT: 534
                }
            },
            FES_7: {
                FIRST: 538,
                SECOND: 539,
                THIRD: 540,
                FOURTH: 541,
                FIFTH: 542
            }
        },
        WORLD_ID_OF: {
            COUNTDOWN_2016: 100517,
            MOBIUS: 101908,
            FES_6_FIRST_WORLD: 100523,
            GW_2016_ZAKUZAKU_WORLD: 100529,
            GW_2016_FIRST_COLISEUM_WORLD: 100530,
            GW_2016_BRABRA_WORLD: 100911,
            FFGM: 111913,
            FFGM_MO: 211020,
            FES_7_FIRST_WORLD: 100538
        },
        EVENT_TAG_OF: {
            FRAGMENT_DUNGEON: "fragment_dungeon",
            GW_2016: "gw_2016",
            GW_2016_COLISEUM: "gw_2016_coliseum",
            FES_7: "fes7",
            REVENGE_DUNGEON: "revenge_dungeon",
            NIGHTMARE_DUNGEON: "nightmare_dungeon"
        },
        GACHA_SERIES_ID_OF: {
            TUTORIAL: 1e3,
            GW_2016_MINI_GAME: 188
        },
        FOX_LTV_PARAM: {
            IOS: 7007,
            ANDROID: 7008
        },
        FOX_LTV_JUDGE_DUNGEON_ID: 207002,
        SERVER_MOVIE_PATH: "video/%s.m4v",
        WDAY_INDEX_OF: {
            SUNDAY: 0,
            MONDAY: 1,
            TUESDAY: 2,
            WEDNESDAY: 3,
            THURSDAY: 4,
            FRIDAY: 5,
            SATURDAY: 6
        },
        ROULETTE_GRADE_TO_RARITY: {
            GW2016: {
                NORMAL: 1,
                SILVER: 2,
                GOLD: 3
            }
        },
        FRAGMENT_DUNGEON: {
            REQUIREMENT: {
                MAX_STAMINA: 60
            }
        },
        REVENGE_DUNGEON: {
            REQUIREMENT: {
                MAX_STAMINA: 60
            }
        },
        NIGHTMARE_DUNGEON: {
            REQUIREMENT: {
                MAX_STAMINA: 60
            }
        },
        TEXT_MASTER_ID_MAPS_FOR_REMAP: {
            BUDDY: {
                GROW_EGG: "R10210"
            },
            MEMORY_CRYSTAL: {
                GROW_EGG: "R10220"
            },
            DRESS_RECORD: {
                GROW_EGG: "R10260"
            }
        },
        SOUL_STRIKE: {
            CLASS_NAME_OF: {
                OVERFLOW: "p-over-flow",
                BURST: "p-burst",
                SUPER: "p-super",
                UNIQUE: "p-unique",
                COMMON: "p-common",
                DEFAULT: "p-default"
            }
        },
        STAMP_EDIT: {
            STAMP_BOX_MAX_LEN: 3,
            STAMP_IN_BOX_LEN: 8,
            STAMP_MOVE_ANIM_DURATION: 1e3,
            ELEM_STATE: {
                IS_EDIT: "is-edit",
                IS_CURRENT: "is-current",
                IS_USING: "is-using",
                IS_CHANGE: "is-change",
                IS_SHOW: "is-show",
                IS_HIDE: "is-hide",
                IS_MOVE: "is-move",
                IS_PUSH_BACK: "is-push-back",
                IS_DISABLE: "is-disable",
                IS_NONE: "di-n"
            },
            EVENT: {
                CANCEL: "cancel",
                COMPLETE: "complete",
                CLOSE: "close",
                EDITING_STORAGE_BOX: "editing_storage_box",
                EDITING_USING_BOX: "editing_using_box",
                COMPLETE_STORAGE_BOX: "complete_storage_box",
                COMPLETE_USING_BOX: "complete_using_box"
            },
            ANIM_EVENT: {
                PUSH_IN_COMPLETE: "push_in_complete",
                PUSH_BACK_COMPLETE: "push_back_complete"
            },
            API_EVENT: {
                SEND_STAMP_LIST: "send_stamp_list"
            },
            COMPONENTS_EVENT: {
                CHANGE_STATE: "changedState",
                CAROUSEL_MOVING: "carousel_moving",
                CAROUSEL_MOVED: "carousel_moved"
            },
            SCENE_STATE: {
                NONE: "none",
                SELECT_STORAGE_STAMP: "select_storage_stamp",
                SELECT_USING_STAMP: "select_using_stamp"
            },
            PARTY_SEARCH: {
                PARTY_SEARCH_DATA: "party_search_data",
                LAST_PARTY_ID: "last_party_id"
            },
            IS_DURING_ANIMATION: "isDuringAnimation"
        },
        TWEET_STAMINA_CAMPAIGNS: [],
        CLIENT_VERSION_OF: {
            SHOW_UID_LABEL: 353
        }
    }
}), define("scenes/battle_result/views/result_dungeon/ModalManager", ["underscore", "jquery", "backbone", "scenes/common/Constant", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/EventBase", "sprintf", "lib/ab/ScrollableTextNode", "lib/TextMaster", "./Util"], function(e, t, n, r, i, s, o, u, a, f, l) {
    var c = {
            STAMINA_PIECE: "stamina_piece",
            MEMORY_CRYSTAL_TO_GROW_EGG: "crystal_growegg",
            MEMORY_CRYSTAL_GET: "crystal_get",
            BUDDY_TO_GROW_EGG: "chara_growegg"
        },
        h = {
            UNLOCK_FLD_WIDTH: 260,
            UNLOCK_FLD_HEIGHT: 135,
            UNLOCK_FLD_MARGIN: 8,
            DURATION_PER_PX: .015,
            STAMINA_PIECE_NUM_FOR_GAIN_STAMINA: 5
        },
        p = o.extend({
            initialize: function(e) {
                this._assetsManager = e.assetsManager, this._tutorialView = e.tutorialView, this._layerName = e.layerName, this._centerFrontNode = e.centerFrontNode, this._animationParams = e.animationParams, this._isShowingModal = !1, this._didTouchBeganCloseButton = !1, this._duplicateNodes = [], this._duplicateModalNewNode()
            },
            dispose: function() {
                this._assetsManager = void 0, this._tutorialView = void 0, this._centerFrontNode = void 0, this._animationParams = void 0, l.deleteDuplicatedNodes(this._duplicateNodes), this._memoryCrystalToGrowEggGetLayer = void 0, this._memoryCrystalGetLayer = void 0, this._buddyToGrowEggGetLayer = void 0
            },
            isShowingModal: function() {
                return this._isShowingModal
            },
            _isTutorial: function() {
                return this._tutorialView.isTutorial()
            },
            _duplicateModalNewNode: function() {
                var e = this,
                    t = (new s({
                        name: "pos_center_front_chara_new_nul",
                        layer: this._layerName,
                        parentNodeName: "new_chara_get_pos_nul",
                        duplicateFrom: "new_nul",
                        duplicateFromOptions: {
                            parentNode: "new_chara_get_pos_nul"
                        }
                    })).process();
                t.play("new_loop", {
                    speed: e._animationParams.playSpeedCoefficient
                }).setVisible(!0).process(), this._duplicateNodes.push(t);
                var n = (new s({
                    name: "pos_center_front_dungeon_new_nul",
                    layer: this._layerName,
                    parentNodeName: "new_unlock_pos_nul",
                    duplicateFrom: "new_nul",
                    duplicateFromOptions: {
                        parentNode: "new_unlock_pos_nul"
                    }
                })).process();
                n.play("new_loop", {
                    speed: e._animationParams.playSpeedCoefficient
                }).setVisible(!0).process(), this._duplicateNodes.push(n)
            },
            showStaminaPieceDeferred: function(n) {
                FF.logger.debug("showStaminaPieceDeferred", n);
                var r = this,
                    i = t.Deferred(),
                    o = this._assetsManager.getAssetInfo(c.STAMINA_PIECE);
                if (e.isEmpty(n) || !n.additionalStamina) return FF.logger.debug("no stamina"), i.resolve().promise();
                var a = u(f.getInstance().get("R10090"), h.STAMINA_PIECE_NUM_FOR_GAIN_STAMINA),
                    l = u(f.getInstance().get("R10100"), n.additionalStamina, n.prevMaxStamina, n.currentMaxStamina),
                    p = new s({
                        name: "get_piece_close_btn_nul",
                        layer: r._layerName
                    });
                return this._tutorialView.isTutorial() && p.setVisible(!1).process(), this._isShowingModal = !0, this._centerFrontNode.setVisible(!0).setText("get_piece_title_txt", a).setText("get_piece_body_txt", l).loadBundle(o.bundle).setImage("image_get_piece", o.assetPath).play("get_piece", {
                    speed: r._animationParams.playSpeedCoefficient
                }).processDeferred("action_stop").then(this._tutorialView.getTutorialFunc("battleStaminaMog")).then(function() {
                    return r._tutorialView.isTutorial() && p.setVisible(!0).process(), t.Deferred().resolve().promise()
                }).then(function() {
                    return p.processDeferred("action_touch_ended")
                }).then(function() {
                    return r._centerFrontNode.play("close_window").processDeferred("action_stop")
                }).then(function() {
                    r._isShowingModal = !1, r._centerFrontNode.setVisible(!1).process(), i.resolve()
                }), i.promise()
            },
            showUnlockedDungeonDeferred: function(n) {
                FF.logger.debug("showUnlockedDungeonDeferred", n);
                var r = this,
                    i = t.Deferred(),
                    o;
                n = n || [];
                if (!n.length) return i.resolve().promise();
                var u = new a({
                        name: "unlock_txt",
                        layer: this._layerName
                    }),
                    l = new s({
                        name: "reward_front_nul",
                        layer: this._layerName
                    });
                l.suspendParticle().process();
                var c = t.Deferred(),
                    p = n.join("\n"),
                    d = function() {
                        var e = t.Deferred();
                        return u.setVisible(!0).setText(p, {
                            callback: function(t) {
                                FF.logger.debug("whole text size", t), o = t.height, u.addTouchRect([0, 0, h.UNLOCK_FLD_WIDTH, o]).addCallbackOnce("action_touch_began", v).process(), e.resolve()
                            }
                        }).process(), e.promise()
                    },
                    v = function() {
                        c.reject();
                        var e = o > h.UNLOCK_FLD_HEIGHT - h.UNLOCK_FLD_MARGIN ? !0 : !1;
                        u.setDragEnable([0, -(o / 2) + h.UNLOCK_FLD_MARGIN * 3, 0, o / 2 - h.UNLOCK_FLD_MARGIN * 3], e, {
                            dragMargin: [0, 0, 0, 0]
                        }).process()
                    },
                    m = function() {
                        if (o > h.UNLOCK_FLD_HEIGHT - h.UNLOCK_FLD_MARGIN) {
                            var e = h.UNLOCK_FLD_HEIGHT - h.UNLOCK_FLD_MARGIN - o;
                            u.scrollDeferred({
                                x: 0,
                                y: e,
                                duration: Math.abs(e * h.DURATION_PER_PX)
                            }).then(function() {
                                FF.logger.debug("scroll done"), c.resolve()
                            })
                        } else c.resolve()
                    };
                return c.progress(e.bind(m, this)), this._isShowingModal = !0, this._centerFrontNode.setVisible(!0).play("get_dungeon", {
                    speed: r._animationParams.playSpeedCoefficient
                }).addCallbackOnce("action_stop", function() {
                    (new s({
                        name: "unlock_title_txt",
                        layer: r._layerName
                    })).setText("unlock_title_txt", f.getInstance().get("R10110")).process();
                    var e = new s({
                        name: "close_btn_nul",
                        layer: r._layerName
                    });
                    r._registerDialogOnBackKey(e, i), e.addCallback("action_touch_began", function() {
                        r._didTouchBeganCloseButton = !0
                    }).addCallback("action_touch_ended", function() {
                        r._didTouchBeganCloseButton ? (r._unregisterDialogOnBackKey(), e.removeAllCallback().process(), r._centerFrontNode.removeAllCallback().play("close_window").addCallbackOnce("action_stop", function() {
                            r._isShowingModal = !1, r._centerFrontNode.setVisible(!1).process(), i.resolve()
                        }).process()) : r._didTouchBeganCloseButton = !1
                    }).addCallback("action_touch_exited", function() {
                        r._didTouchBeganCloseButton = !1
                    }).process(), d().then(function() {
                        return c.notify()
                    })
                }).process(), i.promise()
            },
            _registerDialogOnBackKey: function(e, t) {
                if (FF.env.isWWRegion()) {
                    var n = this;
                    kickmotor.nativefn.onBackKeyHandler.once("System::onBackKey", function() {
                        n._unregisterDialogOnBackKey(), e.removeAllCallback().process(), n.centerFrontNode.removeAllCallback().play("close_window").addCallbackOnce("action_stop", function() {
                            n.isShowingModal = !1, n.centerFrontNode.setVisible(!1).process(), t.resolve()
                        }).process()
                    }, n)
                }
            },
            _unregisterDialogOnBackKey: function() {
                FF.env.isWWRegion() && kickmotor.nativefn.onBackKeyHandler.off("System::onBackKey", null, this)
            },
            showItemInListWithModalDeferred: function(e) {
                var n = this,
                    r = t.Deferred(),
                    i = e.model,
                    o = i.getAssetId(),
                    u = this._assetsManager.getAssetInfo(o),
                    a = new s({
                        name: i.getDungeonModalCloseButtonNodeName(),
                        layer: this._getModalLayerName(i)
                    });
                FF.logger.debug("Modal ", name), FF.logger.debug("layerName    :", this._getModalLayerName(i)), FF.logger.debug("closeBtnNode :", a.name), this._isTutorial() && a.setVisible(!1).process(), this._isShowingModal = !0;
                var f = function() {
                    n._isShowingModal = !1, r.resolve()
                };
                return i.isMemoryCrystalToGrowEgg() ? n._showMemoryCrystalToGrowEggModalDeffered(a, e, u).then(function() {
                    f()
                }) : i.isMemoryCrystal() ? n._showMemoryCrystalModalDeffered(a, e, u).then(function() {
                    f()
                }) : i.isBuddyToGrowEgg() || i.isDressRecordToGrowEgg() ? n._showBuddyToGrowEggModalDeffered(a, e, u).then(function() {
                    f()
                }) : n._showNormalModalDeffered(a, e, u).then(function() {
                    f()
                }), r.promise()
            },
            _getModalLayerName: function(e) {
                var t, n;
                return e.isMemoryCrystalToGrowEgg() ? (FF.logger.debug("Layer:MemoryCrystalToGrowEgg"), this._memoryCrystalToGrowEggGetLayer || (n = this._assetsManager.getAssetInfo(c.MEMORY_CRYSTAL_TO_GROW_EGG), this._memoryCrystalToGrowEggGetLayer = new i({
                    layerName: n.layerName,
                    assetPath: n.assetPath
                }), this._memoryCrystalToGrowEggGetLayer.activate()), t = this._memoryCrystalToGrowEggGetLayer) : e.isMemoryCrystal() ? (FF.logger.debug("Layer:MemoryCrystal"), this._memoryCrystalGetLayer || (n = this._assetsManager.getAssetInfo(c.MEMORY_CRYSTAL_GET), this._memoryCrystalGetLayer = new i({
                    layerName: n.layerName,
                    assetPath: n.assetPath
                }), this._memoryCrystalGetLayer.activate()), t = this._memoryCrystalGetLayer) : e.isBuddyToGrowEgg() || e.isDressRecordToGrowEgg() ? (FF.logger.debug("Layer:BuddyToGrowEgg|DressRecordToGrowEgg"), this._buddyToGrowEggGetLayer || (n = this._assetsManager.getAssetInfo(c.BUDDY_TO_GROW_EGG), this._buddyToGrowEggGetLayer = new i({
                    layerName: n.layerName,
                    assetPath: n.assetPath
                }), this._buddyToGrowEggGetLayer.activate()), t = this._buddyToGrowEggGetLayer) : FF.logger.debug("Layer:default"), t ? t.layerName : this._layerName
            },
            _showMemoryCrystalModalDeffered: function(e, n, r) {
                FF.logger.debug("_showMemoryCrystalModalDeffered");
                var i = this,
                    s = t.Deferred(),
                    o = u("memory-crystal-buddy-%s", n.model.get("itemId")),
                    a = this._assetsManager.getAssetInfo(o),
                    c = u("memory-crystal-battle-result-modal-%s", n.model.get("itemId")),
                    h = this._assetsManager.getAssetInfo(c),
                    p = u(f.getInstance().get("R10040"), n.model.get("name")) + "\n" + u(f.getInstance().get("R10150"), n.model.get("buddyName")),
                    d = i._memoryCrystalGetLayer.createNode("cutin_nul");
                return d.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("cutin_body_txt", p).loadBundle(a.bundle).setSpriteAnimeByNode("chara_sprite", a.assetPath).loadBundle(h.bundle).setImage("crystal_img", h.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                    d.play("loop").process()
                }).then(function() {
                    return e.processDeferred("action_touch_ended")
                }).then(function() {
                    return d.play("tap_end").processDeferred("action_stop")
                }).then(function() {
                    return d.setVisible(!1).process(), l.showItemInListDeferred(i._assetsManager, i._animationParams, n)
                }).then(function() {
                    s.resolve()
                }), this._applyMemoryCrystalEffect(n), s.promise()
            },
            _applyMemoryCrystalEffect: function(e) {
                var t = this._assetsManager.getAssetInfo(c.MEMORY_CRYSTAL_GET),
                    n = +e.model.get("rank");
                (new s({
                    name: u("eff_cutin_particle_%02d", n),
                    layer: t.layerName
                })).setVisible(!0).process(), (new s({
                    name: u("crystal_star_particle_%02d", n),
                    layer: t.layerName
                })).setVisible(!0).process()
            },
            _showBuddyToGrowEggModalDeffered: function(e, n, i) {
                FF.logger.debug("_showBuddyToGrowEggModalDeffered");
                var s = this,
                    o = t.Deferred(),
                    a = u("animation-buddy-%s", n.model.get("itemId")),
                    c = this._assetsManager.getAssetInfo(a),
                    h = n.model.getRemapItemModel(),
                    p = u("item-%s", h.get("itemId")),
                    d = this._assetsManager.getAssetInfo(p),
                    v = n.model.getRemapItemModel(),
                    m = u(f.getInstance().get("R10300"), v.get("name")),
                    g = n.model.get("typeName"),
                    y = v.get("typeName"),
                    b = r.TEXT_MASTER_ID_MAPS_FOR_REMAP[g][y],
                    w = s._buddyToGrowEggGetLayer.createNode("cutin_nul");
                return w.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("txt_title_1", m).setText("cutin_body_txt", f.getInstance().get(b)).loadBundle(c.bundle).setSpriteAnimeByNode("chara_sprite", c.assetPath).loadBundle(d.bundle).setImage("grow_egg_img", d.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                    return w.play("loop").process(), e.processDeferred("action_touch_ended")
                }).then(function() {
                    return w.play("tap_end").processDeferred("action_stop")
                }).then(function() {
                    w.setVisible(!1).process();
                    var e = h.clone();
                    return e.num = n.model.num, l.showItemInListDeferred(s._assetsManager, s._animationParams, {
                        node: n.node,
                        model: e
                    })
                }).then(function() {
                    o.resolve()
                }), o.promise()
            },
            _showMemoryCrystalToGrowEggModalDeffered: function(e, n, i) {
                FF.logger.debug("_showMemoryCrystalToGrowEggModalDeffered");
                var s = this,
                    o = t.Deferred(),
                    a = u("memory-crystal-battle-result-modal-%s", n.model.get("itemId")),
                    c = this._assetsManager.getAssetInfo(a),
                    h = n.model.getRemapItemModel(),
                    p = u("item-%s", h.get("itemId")),
                    d = this._assetsManager.getAssetInfo(p),
                    v = n.model.getRemapItemModel(),
                    m = u(f.getInstance().get("R10300"), v.get("name")),
                    g = n.model.get("typeName"),
                    y = v.get("typeName"),
                    b = r.TEXT_MASTER_ID_MAPS_FOR_REMAP[g][y],
                    w = s._memoryCrystalToGrowEggGetLayer.createNode("cutin_nul");
                return w.setVisualParent("layer_battle_result", "cutin_pos_nul").setText("txt_title_1", m).setText("cutin_body_txt", f.getInstance().get(b)).loadBundle(c.bundle).setImage("crystal_img_01", c.assetPath).loadBundle(d.bundle).setImage("grow_egg_img", d.assetPath).setVisible(!0).play("in").processDeferred("action_stop").then(function() {
                    return w.play("loop").process(), e.processDeferred("action_touch_ended")
                }).then(function() {
                    return w.play("tap_end").processDeferred("action_stop")
                }).then(function() {
                    w.setVisible(!1).process();
                    var e = h.clone();
                    return e.num = n.model.num, l.showItemInListDeferred(s._assetsManager, s._animationParams, {
                        node: n.node,
                        model: e
                    })
                }).then(function() {
                    o.resolve()
                }), o.promise()
            },
            _showNormalModalDeffered: function(e, n, r) {
                FF.logger.debug("_showNormalModalDeffered");
                var i = this,
                    s = t.Deferred(),
                    o = n.model,
                    u = this._assetsManager.getAssetInfo(o.getAssetIdOfTreasure());
                return FF.logger.debug("tag::", o.getDungeonRewardModalPlayTagName()), this._centerFrontNode.loadBundle(u.bundle).setSpriteAnimeByNode("sprite_treasure_symbol_front", u.assetPath).setSpriteActionByNode("sprite_treasure_symbol_front", "stop").setVisible(!0).setText(o.getModalTextTagName(), o.getDungeonRewardText()).setText(o.getModalHeaderTextTagName(), o.getModalHeaderText()).loadBundle(r.bundle).setImage(o.getModalImageTagName(), r.assetPath).play(o.getDungeonRewardModalPlayTagName(), {
                    speed: i._animationParams.playSpeedCoefficient
                }).processDeferred("action_stop").then(function() {
                    return o.isMythril() ? i._tutorialView.getTutorialFunc("battleMythrilMog")() : t.Deferred().resolve().promise()
                }).then(function() {
                    return i._isTutorial() && e.setVisible(!0).process(), t.Deferred().resolve().promise()
                }).then(function() {
                    return e.processDeferred("action_touch_ended")
                }).then(function() {
                    return i._centerFrontNode.play(o.getModalCloseTagName()).processDeferred("action_stop")
                }).then(function() {
                    return i._centerFrontNode.setVisible(!1).process(), l.showItemInListDeferred(i._assetsManager, i._animationParams, n)
                }).then(function() {
                    s.resolve()
                }), s.promise()
            }
        });
    return p
}), define("scenes/battle_result/views/ResultDungeon", ["underscore", "jquery", "backbone", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/EventBase", "lib/GooglePlayGameService", "sprintf", "lib/TextMaster", "./result_dungeon/AnimationParams", "./result_dungeon/ScrollListView", "./result_dungeon/ModalManager"], function(e, t, n, r, i, s, o, u, a, f, l, c) {
    var h = {
        RANK_NUM_EXCELLENT: 3
    };
    return s.extend({
        initialize: function(e) {
            this._assetsManager = e.assetsManager, this._tutorialView = e.tutorialView, this._dungeonRank = e.result.dungeonRank, this._googlePlayAchievements = e.result.googlePlayAchievements, this._staminaInfo = e.result.staminaInfo, this._layerName = e.layer.layerName, this.serverConst = e.serverConst, this.unlockDungeons = e.result.unlockDungeons, this.unlockWorlds = e.result.unlockWorlds, this._animationParams = new f, this._masterBackEffNode = new i({
                name: "master_back_eff_nul",
                layer: this._layerName
            }), this._modalManager = new c({
                assetsManager: this._assetsManager,
                tutorialView: this._tutorialView,
                layerName: this._layerName,
                centerFrontNode: e.centerFrontNode,
                animationParams: this._animationParams
            }), this._scrollListView = new l({
                assetsManager: this._assetsManager,
                animationParams: this._animationParams,
                layerName: this._layerName,
                modalManager: this._modalManager,
                result: e.result,
                itemCollection: e.itemCollection,
                serverConst: e.serverConst
            })
        },
        dispose: function() {
            this._modalManager && (this._modalManager.dispose(), this._modalManager = void 0), this._scrollListView && (this._scrollListView.dispose(), this._scrollListView = void 0), this._tutorialView = void 0, this._animationParams = void 0
        },
        start: function() {
            var t = this;
            FF.logger.debug("");
            var n = this._makeUnlockPlaces();
            this._showSymbolDeferred().then(function() {
                return FF.logger.debug(""), t._playMasterDeferred()
            }).then(function() {
                return FF.logger.debug(""), o.sendAchievement(t._googlePlayAchievements), e.each(t._googlePlayAchievements, function(e) {
                    kickmotor.iosgamecenter.unlockAchievement(e.achievementId)
                }), t._modalManager.showUnlockedDungeonDeferred(n)
            }).then(function() {
                return FF.logger.debug(""), t._scrollListView.showBonusesDeferred()
            }).then(function() {
                return FF.logger.debug(""), t._modalManager.showStaminaPieceDeferred(t._staminaInfo)
            }).then(this._tutorialView.getTutorialFunc("battleDungeonMog")).then(function() {
                FF.logger.debug(""), t._scrollListView.startDrag(), t.isDone = !0, t.trigger("show:nextBtn")
            })
        },
        completeAtOnce: function() {
            !this.isDone && !this._animationParams.shouldCompleteAtOnce && !this._modalManager.isShowingModal() && (FF.SoundMgr.playChooseEffect(), this._animationParams.shouldCompleteAtOnce = !0, this._animationParams.playSpeedCoefficient = 100)
        },
        getDungeonTypeName: function(e) {
            return e.isForce ? a.getInstance().get("R10080") + " " : ""
        },
        getDungeonUnlockText: function(e) {
            return a.getInstance().get("R10070")
        },
        _makeUnlockPlaces: function() {
            var t = this,
                n = this.unlockDungeons || [],
                r = this.unlockWorlds || [];
            if (n.length + r.length === 0) return [];
            var i = e.map(n, function(e) {
                return u(t.getDungeonUnlockText(e), e.worldName, t.getDungeonTypeName(e), e.name)
            });
            return i
        },
        _showSymbolDeferred: function() {
            var e = this,
                n = t.Deferred(),
                r = new i({
                    name: "symbol_nul",
                    layer: this._layerName
                });
            return this._dungeonRank === 0 ? n.resolve().promise() : (r.setVisible(!0).addCallbackOnce("action_stop", function() {
                n.resolve()
            }).play("symbol_start_" + this._dungeonRank, {
                speed: e._animationParams.playSpeedCoefficient
            }).process(), n.promise())
        },
        _playMasterDeferred: function() {
            return t.when(this._playMasterBackEffDeferred(), this._playDungeonClearTitleDeferred())
        },
        _playMasterBackEffDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this._dungeonRank === h.RANK_NUM_EXCELLENT ? this._masterBackEffNode.play("master", {
                speed: e._animationParams.playSpeedCoefficient
            }).processDeferred("action_stop").then(function() {
                n.resolve()
            }) : n.resolve(), n.promise()
        },
        _playDungeonClearTitleDeferred: function() {
            var e = t.Deferred();
            return (new i({
                name: "dungeon_clear_title_nul",
                layer: this._layerName
            })).play("master").processDeferred("action_stop").then(function() {
                e.resolve()
            }), e.promise()
        }
    })
}), define("scenes/battle_result/models/Tutorial", ["backbone"], function(e) {
    var t = e.Model.extend({
        initialize: function(e) {
            this.talks = e
        },
        isTutorial: function() {
            return FF.env.isTutorial()
        },
        getMessage: function(e) {
            var t = _.findWhere(this.talks, {
                no: e
            });
            return t.content ? t.content : ""
        }
    });
    return t
}), define("scenes/battle_result/views/TutorialActionHelper", [], function() {
    var e = {
        firstMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "101"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2091"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "102"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleScoreMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "103"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2092"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2093"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2094"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "104"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleExpMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2095"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleItemMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2097"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleDungeonMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "203"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2101"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "205"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2102"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "206"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2103"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e.nodeMap.tutor.setPosition([0, -180]).process(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "207"
                }), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2104"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playIndicatorDeferred({
                    action: "PLAY",
                    frameNo: "208"
                }), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleMythrilMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2098"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2099"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        },
        battleStaminaMog: function() {
            var e = this;
            return function() {
                return e.setVisible(!0), $.Deferred().resolve().promise()
            }().then(function() {
                e._playTutorDeferred({
                    action: "IN",
                    autoResolve: !0
                })
            }).then(function() {
                return e._playTutorDeferred({
                    action: "SAY",
                    messageId: "2100"
                })
            }).then(function() {
                return FF.SoundMgr.playChooseEffect(), e._playTutorDeferred({
                    action: "OUT"
                })
            }).then(function() {
                return e.setVisible(!1), $.Deferred().resolve().promise()
            })
        }
    };
    return e
}), define("scenes/battle_result/views/ResultTutorial", ["underscore", "jquery", "backbone", "lib/ab/ABNode", "lib/EventBase", "../models/Tutorial", "./TutorialActionHelper", "util"], function(e, t, n, r, i, s, o, u) {
    return i.extend({
        initialize: function(e) {
            this.assetsManager = e, this.nodeMap = {}
        },
        prepareForTutorial: function() {
            var e = FF.battleResult.result.tutorial_talks;
            this.model = new s(e);
            if (!this.isTutorial()) return;
            var t = "tut_res_1",
                n = this.assetsManager.getAssetInfo(t);
            this.nodeMap.indicator = (new r({
                name: "tutorial_nul",
                layer: n.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: "layer_battle_field"
                }
            })).play("reset");
            var i = "tut_res_msg_1",
                o = this.assetsManager.getAssetInfo(i);
            this.nodeMap.tutor = (new r({
                name: "tutorial_msg_nul",
                layer: o.layerName,
                visualParentTo: "tutorial_pos_nul",
                visualParentToOptions: {
                    visualParentLayer: "layer_battle_field"
                }
            })).play("reset"), this.flush()
        },
        releaseFromWaiting: function() {
            this.promiseWaitingForTouch && (this.promiseWaitingForTouch.resolve(), this.promiseWaitingForTouch = void 0)
        },
        _playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (e.action === "OUT") this.playTutorDeferred({
                action: e.action
            }).then(function() {
                r.resolve()
            });
            else {
                var i = e.autoResolve ? function() {
                    r.resolve()
                } : function() {
                    n.promiseWaitingForTouch = r
                };
                this.playTutorDeferred({
                    action: e.action,
                    messageId: e.messageId
                }).then(i)
            }
            return r.promise()
        },
        _playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            return this.playIndicatorDeferred(e).then(function() {
                n.resolve()
            }), n.promise()
        },
        playTutorDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            if (!e) return r.resolve().promise();
            var i = void 0;
            e.messageId && (i = this.model.getMessage(e.messageId));
            switch (e.action) {
                case "IN":
                    i && this.nodeMap.tutor.setText("main_txt", i), this.nodeMap.tutor.play("in").processDeferred("action_stop").then(function() {
                        n.nodeMap.tutor.play("loop"), n.flush(), r.resolve()
                    });
                    break;
                case "SAY":
                    i && this.nodeMap.tutor.setText("main_txt", i), this.nodeMap.tutor.play("tap").processDeferred("action_stop").then(function() {
                        n.nodeMap.tutor.play("loop"), n.flush(), r.resolve()
                    }), this.flush();
                    break;
                case "OUT":
                    this.nodeMap.tutor.play("out").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                case "RESET":
                    this.nodeMap.tutor.play("reset").processDeferred("action_stop").then(function() {
                        r.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return r.promise()
        },
        playIndicatorDeferred: function(e) {
            var n = t.Deferred();
            if (!e) return n.resolve().promise();
            switch (e.action) {
                case "PLAY":
                    this._playByFrameNoDeferred(e.frameNo).then(function() {
                        n.resolve()
                    });
                    break;
                case "RESET":
                    this.nodeMap.indicator.play("reset").processDeferred("action_stop").then(function() {
                        n.resolve()
                    });
                    break;
                default:
                    throw new Error("invalid acion. " + e.action)
            }
            return n.promise()
        },
        _playByFrameNoDeferred: function(e) {
            var n = this,
                r = t.Deferred(),
                i = sprintf("play_%s", e),
                s = sprintf("loop_%s", e);
            return this.nodeMap.indicator.play(i).processDeferred("action_stop").then(function() {
                n.nodeMap.indicator.play(s), n.flush(), r.resolve()
            }), this.flush(), r.promise()
        },
        setVisible: function(e) {
            this.nodeMap.tutor.setVisible(e), this.nodeMap.indicator.setVisible(e), this.flush()
        },
        flush: function() {
            var t = [];
            e.each(this.nodeMap, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        isTutorial: function() {
            return this.model.isTutorial()
        },
        getTutorialFunc: function(n) {
            var r = this,
                i;
            return this.isTutorial() ? i = o[n] : i = function() {
                return t.Deferred().resolve().promise()
            }, e.bind(i, this)
        },
        dispose: function() {
            var t = function(t) {
                e.each(t, function(e) {
                    e && (e.removeAllCallback(), e.deleteNode().process())
                })
            };
            t(this.nodeMap)
        }
    })
}), define("scenes/battle_result/views/PrizeBuddyModal", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase", "lib/TextMaster"], function(e, t, n, r, i, s, o) {
    var u = ["acc", "atk", "def", "eva", "hp", "matk", "mdef", "mnd", "spd"];
    return s.extend({
        initialize: function(e) {
            this.prizeBuddyInfoList = e.prizeBuddyInfoList, this.layer = e.layer, this.assetsManager = e.assetsManager, this.ab = {}, this.ab.topNode = this.layer.createNode("visible_nul"), this.ab.cutInNode = this.ab.topNode.createChildNode("cutin_nul"), this.ab.cutInFrameNode = this.ab.topNode.createChildNode("cutin_frame_nul"), this.ab.charaNameNode = this.ab.topNode.createChildNode("chara_name_nul"), this.ab.btnNode = this.ab.topNode.createChildNode("btn_cutin_01"), this._createStatusNode()
        },
        _createStatusNode: function() {
            var t = this;
            this._statusNodes = {}, e.each(u, function(e) {
                t._statusNodes[e] = new i({
                    name: sprintf("%s_pos_nul", e),
                    layer: t.ab.topNode.layer,
                    duplicateFrom: "status_point_nul",
                    duplicateFromOptions: {
                        parentNode: sprintf("%s_pos_nul", e)
                    }
                })
            })
        },
        showModalsDeferred: function() {
            var e = this;
            return this._handleNextModal(), this._deferred = t.Deferred(), this._deferred.promise()
        },
        _handleNextModal: function() {
            if (!this.prizeBuddyInfoList || this.prizeBuddyInfoList.length === 0) this._deferred && (this.dispose(), this._deferred.resolve(), this._deferred = void 0);
            else {
                var e = this.prizeBuddyInfoList.shift();
                this._showModal(e)
            }
        },
        _showModal: function(t) {
            var n = this;
            this._setUpCharacter(t), this._setUpSoulStrike(t), this.ab.topNode.setVisible(!0).process(), this.ab.cutInNode.play("in").addCallbackOnce("action_point", function() {
                e.each(n._statusNodes, function(e, n) {
                    e.play(sprintf("status_point_%s", t.starNum[n]), {
                        autoRemove: !1
                    }).process()
                })
            }).addCallbackOnce("action_stop", function() {
                n.ab.cutInNode.play("loop").process(), n._setUpBtn()
            }).addCallbackOnce("action_chara_change", function() {
                n.ab.topNode.setSpriteActionByNode("chara_sprite", t.prizeImage).process()
            }), this.flush()
        },
        _setUpCharacter: function(e) {
            this.ab.cutInFrameNode.setText("job_txt", e.roleTypeName), this.ab.charaNameNode.setText("chara_name_txt", e.name);
            var t = "animation-buddy-" + e.id,
                n = this.assetsManager.getAssetInfo(t);
            this.ab.topNode.loadBundle(n.bundle).setSpriteAnimeByNode("chara_sprite", n.assetPath)
        },
        _setUpSoulStrike: function(e) {
            this.ab.cutInFrameNode.setText("special_name_txt", e.soulStrike.name), this.ab.cutInFrameNode.setText("special_description_txt", e.soulStrike.description);
            var t = "soul_strike_" + e.id,
                n = this.assetsManager.getAssetInfo(t);
            this.ab.topNode.loadBundle(n.bundle).setImage("special_orb_img", n.assetPath);
            var r = +e.soulStrike.consumeSsGauge;
            switch (r) {
                case 1:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    });
                    break;
                case 2:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_02"
                    });
                    break;
                case 3:
                    this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_01"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_02"
                    }), this.ab.cutInFrameNode.setVisible(!0, {
                        node: "gauge_img_03"
                    });
                    break;
                default:
            }
        },
        _setUpBtn: function() {
            var e = this;
            this.ab.btnNode.addCallbackOnce("action_touch_began", function() {
                e.ab.cutInNode.play("tap_start").process()
            }, {
                node: "btn_cutin_visible_touch_01"
            }).addCallbackOnce("action_touch_ended", function() {
                e.ab.cutInNode.play("tap_end").processDeferred("action_stop").then(function() {
                    e.ab.cutInNode.play("out").addCallbackOnce("action_stop", function() {
                        e._handleNextModal()
                    }).process()
                })
            }, {
                node: "btn_cutin_visible_touch_01"
            }).process()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.topNode.setVisible(!1).process(), this.ab.btnNode.deleteNode().process(), e.each(this._statusNodes, function(e) {
                e.deleteNode().process()
            }), this.layer = null
        }
    })
}), define("scenes/battle_result/views/SpecialItemModal", ["underscore", "jquery", "lib/ab/ABLayer", "backbone", "lib/ab/ABNode", "lib/EventBase"], function(e, t, n, r, i, s) {
    return s.extend({
        initialize: function(e) {
            this.itemInfoList = e.specialItemInfoList, this.layer = e.layer, this.assetsManager = e.assetsManager, this.ab = {}, this.ab.topNode = this.layer.createNode("visible_nul"), this.ab.cutInNode = this.ab.topNode.createChildNode("cutin_nul"), this.ab.rewardFrontNode = this.ab.topNode.createChildNode("reward_front_nul"), this.ab.itemNameNode = this.ab.topNode.createChildNode("item_name_nul"), this.ab.btnNode = this.ab.topNode.createChildNode("btn_cutin_01")
        },
        showModalsDeferred: function() {
            var e = this,
                n = t.Deferred();
            if (this.itemInfoList.length === 0) return n.resolve().promise();
            var r = function(t) {
                    t.then(function() {
                        if (e.itemInfoList.length === 0) {
                            e.dispose(), n.resolve();
                            return
                        }
                        var t = e.itemInfoList.shift(),
                            i = e._showModalDeferred(t);
                        r(i)
                    })
                },
                i = this.itemInfoList.shift(),
                s = this._showModalDeferred(i);
            return r(s), n.promise()
        },
        _showModalDeferred: function(e) {
            var n = this,
                r = t.Deferred();
            return this._setUpItem(e), this.ab.topNode.setVisible(!0), this.ab.cutInNode.play("in").addCallbackOnce("action_stop", function() {
                n.ab.cutInNode.play("loop"), n._setUpBtnDeferred().then(function() {
                    r.resolve()
                })
            }), this.flush(), r.promise()
        },
        _setUpItem: function(e) {
            var t = sprintf("item-%s", e.get("itemId")),
                n = this.assetsManager.getAssetInfo(t);
            this.ab.rewardFrontNode.loadBundle(n.bundle).setImage("image_reward_front ", n.assetPath).setVisible(!0), this.ab.rewardFrontNode.setText("cutin_frame_txt ", e.get("description")), this.ab.itemNameNode.setText("item_name_txt", e.get("name"))
        },
        _setUpBtnDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this.ab.btnNode.addCallbackOnce("action_touch_began", function() {
                e.ab.cutInNode.play("tap_start").process()
            }, {
                node: "btn_cutin_visible_touch_01"
            }).addCallbackOnce("action_touch_ended", function() {
                e.ab.cutInNode.play("tap_end").processDeferred("action_stop").then(function() {
                    e.ab.cutInNode.play("out").addCallbackOnce("action_stop", function() {
                        n.resolve()
                    }).process()
                })
            }, {
                node: "btn_cutin_visible_touch_01"
            }).process(), n.promise()
        },
        flush: function() {
            var t = [];
            e.each(this.ab, function(e) {
                t = t.concat(e.stream), e.stream = []
            }), t.length && kickmotor.animation.processAnimation(t)
        },
        dispose: function() {
            this.ab.topNode.setVisible(!1).process(), this.ab.btnNode.deleteNode().process(), this.layer = null
        }
    })
}), define("scenes/battle_result/models/Item", ["backbone", "sprintf", "lib/TextMaster"], function(e, t, n) {
    var r = {
            THRESHOLD_RARITY: 4,
            TYPE_OF_TYPE_NAME: {
                EQUIPMENT: "box",
                ABILITY: "box",
                ABILITY_MATERIAL: "orb",
                GROW_EGG: "box",
                EQUIPMENT_SP_MATERIAL: "box",
                EQUIPMENT_HYPER_EVOLVE_MATERIAL: "box",
                COMMON: "box",
                BUDDY: "box",
                RECORD_MATERIA: "box",
                MEMORY_CRYSTAL: "box",
                DRESS_RECORD: "box",
                SPHERE_MATERIAL: "box"
            },
            ITEM_ID_FOR_MYTHRIL: 91e6,
            ITEM_ID_FOR_GIL: 92e6
        },
        i = e.Model.extend({
            idAttribute: "itemId",
            initialize: function(t) {
                e.Model.prototype.initialize.apply(t)
            },
            isEquip: function() {
                return this.get("typeName") === "EQUIPMENT"
            },
            isBuddy: function() {
                return this.get("typeName") === "BUDDY"
            },
            isCommon: function() {
                return this.get("typeName") === "COMMON"
            },
            isMythril: function() {
                return this.get("itemId") === r.ITEM_ID_FOR_MYTHRIL
            },
            isRecordMateria: function() {
                return this.get("typeName") === "RECORD_MATERIA"
            },
            isMemoryCrystal: function() {
                return this.get("typeName") === "MEMORY_CRYSTAL"
            },
            isAbility: function() {
                return this.get("typeName") === "ABILITY"
            },
            isAbilityMaterial: function() {
                return this.get("typeName") === "ABILITY_MATERIAL"
            },
            isNew: function() {
                return this.get("isNew") ? !0 : !1
            },
            isRemapped: function() {
                return this.get("remapItemId") ? !0 : !1
            },
            isBuddyToGrowEgg: function() {
                return this.isBuddy() && this.isRemapped()
            },
            isMemoryCrystalToGrowEgg: function() {
                return this.isMemoryCrystal() && this.isRemapped()
            },
            isDressRecordToGrowEgg: function() {
                return this.isDressRecord() && this.isRemapped()
            },
            isGrowEgg: function() {
                return this.get("typeName") === "GROW_EGG"
            },
            isDressRecord: function() {
                return this.get("typeName") === "DRESS_RECORD"
            },
            isEquipmentSpMaterial: function() {
                return this.get("typeName") === "EQUIPMENT_SP_MATERIAL"
            },
            isEquipmentHyperEvolveMaterial: function() {
                return this.get("typeName") === "EQUIPMENT_HYPER_EVOLVE_MATERIAL"
            },
            needToDisplayModal: function(e) {
                return this.isRecordMateria() ? !0 : this._shouldShowModal(e) ? !0 : !1
            },
            needToDisplayModalInDungeonReward: function(e) {
                return this.isBuddyToGrowEgg() ? !0 : this._isNoRarityItem() ? !0 : this.isMemoryCrystal() ? !0 : this.isDressRecord() ? !0 : this.isBuddyToGrowEgg() ? !0 : this._shouldShowModal(e) ? !0 : !1
            },
            _shouldShowModal: function(e) {
                var t = _.any([this.isEquip(), this.isAbilityMaterial() && +this.get("type") !== +e.ABILITY_MATERIAL.TYPE_OF.MEMORY, this.isAbility(), this.isGrowEgg(), this.isEquipmentSpMaterial(), this.isEquipmentHyperEvolveMaterial()]);
                return t && this._getRarity() >= r.THRESHOLD_RARITY
            },
            getRewardListPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                FF.logger.debug(e, this.get("typeName"), this.attributes);
                if (!e) throw new Error("invalid type");
                return t("reward_open_%s_%s", e, this._getRarity())
            },
            getRewardModalPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")],
                    n = this._getRarity();
                if (!e) throw new Error("invalid type");
                if (n < 3) throw new Error("invalid rarity:" + n);
                return t("reward_open_%s_%s", e, n)
            },
            getRewardModalCloseButtonNodeName: function() {
                return this.isRecordMateria() ? "cutin_bt_nul_01" : "reward_front_close_btn_nul"
            },
            getDungeonRewardModalPlayTagName: function() {
                if (this.isDressRecord()) return "get_chara";
                if (this._isNoRarityItem()) return "get_system";
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                if (!e) throw new Error("invalid type");
                var n;
                return this._getRarity() > r.THRESHOLD_RARITY ? n = this._getRarity() : n = r.THRESHOLD_RARITY, t("reward_open_%s_%s", e, n)
            },
            getDungeonRewardListPlayTagName: function() {
                var e = r.TYPE_OF_TYPE_NAME[this.get("typeName")];
                FF.logger.debug(e, this.get("typeName"), this.attributes);
                if (!e) throw new Error("invalid type:" + this.get("typeName"));
                return t("reward_open_%s_%s", e, 1)
            },
            getDungeonModalCloseButtonNodeName: function() {
                return this.isMemoryCrystal() || this.isBuddyToGrowEgg() || this.isMemoryCrystalToGrowEgg() || this.isDressRecordToGrowEgg() ? "cutin_bt_nul_01" : this.isDressRecord() || this._isNoRarityItem() ? "close_btn_nul" : "reward_front_close_btn_nul"
            },
            getDungeonRewardText: function() {
                return this.isDressRecord() ? t(n.getInstance().get("R10250"), this.get("name")) : t(n.getInstance().get("R10040"), this.get("name"))
            },
            getModalTextTagName: function() {
                return this.isDressRecord() ? "chara_get_txt" : this._isNoRarityItem() ? "system_body_txt" : "reward_front_txt"
            },
            getModalHeaderTextTagName: function() {
                return this._isNoRarityItem() ? "system_title_txt" : "reward_front_title_txt"
            },
            getModalHeaderText: function() {
                if (this.isDressRecord()) return "";
                var e = this._getHeaderTextId();
                return n.getInstance().get(e)
            },
            getModalImageTagName: function() {
                return this.isDressRecord() ? "image_get_chara" : this._isNoRarityItem() ? "system_image" : "image_reward_front"
            },
            getModalCloseTagName: function() {
                return this.isDressRecord() || this._isNoRarityItem() ? "close_window" : "reward_close"
            },
            getAssetId: function(e) {
                return e ? t("item-%s-%s", e, this.get("itemId")) : t("item-%s", this.get("itemId"))
            },
            getAssetIdOfTreasure: function() {
                return t("treasure%s_%s", r.TYPE_OF_TYPE_NAME[this.get("typeName")], this.get("rarity"))
            },
            getNameWithNum: function() {
                var e = this.get("name");
                if (this.isDressRecord()) return e;
                if (this.get("itemId") === r.ITEM_ID_FOR_GIL) {
                    var i = FF.env.isWWRegion() ? " " : "";
                    return t("%s%s%s", this.num, i, n.getInstance().get("R10050"))
                }
                return t("%s x %s", e, this.num)
            },
            _getRarity: function() {
                return this.isCommon() ? 1 : this.get("rarity")
            },
            getRemapItemModel: function() {
                if (!this.isRemapped()) throw new Error("not defined remap_item_id");
                return this.collection.get(+this.get("remapItemId"))
            },
            _isNoRarityItem: function() {
                return this.isMythril() ? !0 : !1
            },
            _getHeaderTextId: function() {
                return this.isMythril() ? "R10010" : "R10020"
            }
        });
    return i
}), define("scenes/battle_result/collections/Item", ["backbone", "../models/Item", "util"], function(e, t, n) {
    var r = e.Collection.extend({
        model: t,
        makeItemList: function(e) {
            var t = this,
                r = [];
            return _.each(e, function(e, i) {
                var s = n.cloneDeep(t.get(i));
                s.num = e, r.push(s)
            }), r.sort(function(e, t) {
                return e.get("itemId") < t.get("itemId") ? -1 : 1
            }), r
        }
    });
    return r
}), define("scenes/battle_result/ResultViewController", ["underscore", "jquery", "backbone", "sprintf", "lib/ab/ABLayer", "lib/ab/ABNode", "lib/ab/BattleAssetsManager", "lib/EventBase", "lib/api", "components/Loading", "components/Overlay", "./views/ResultScore", "./views/ResultExp", "./views/ResultItem", "./views/ResultDungeon", "./views/ResultTutorial", "./views/PrizeBuddyModal", "./views/SpecialItemModal", "./misc/CampaignItemDiscriminator", "./collections/Item", "util"], function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w) {
    var E = {
        NEXT_ACTIONS: ["drawExpResult", "drawSoulStrikeExp", "drawItemResult", "drawDungeonResult", "goOutToExternalUrl"],
        WAIT_UNTIL_NEXT_BTN_DISPLAYED: 300
    };
    return FF.ns.battle.ResultViewController = u.extend({
        initialize: function(n, r) {
            FF.logger.debug("ResultView: initialize", n), this.result = n, this.serverConst = r, this.isFirstClear = n.isFirstClear, this.firstClearPrizeNum = w.sum(e.values(n.firstClearPrizeItemIdToNum)), this.nextActions = e.clone(E.NEXT_ACTIONS), this.overlay = new l({
                el: t(".overlay")
            }), this.loading = new f({
                el: t(".loading")
            }), this.overlay.registerChildren(this.loading), kickmotor.nativefn.call("setIsEnableTouchEvent", {
                isEnable: !0
            }), this.assetsManager = new o, this.resultLayer = null, this.itemCollection = new b(e.map(e.values(n.prizeMaster), function(e) {
                return e.itemId = +e.itemId, e
            })), this.soulStrikeLevelUpInfos = this._createSoulStrikeLevelUpInfos(), y.getInstance().applyCampaignsData(n.prizeIcreaseCampaigns)
        },
        willShowSoulStrikeLevelup: function() {
            return this.soulStrikeLevelUpInfos.length > 0
        },
        loadViewDeferred: function() {
            FF.logger.debug("ResultView: loadView");
            var e = this,
                n = t.Deferred();
            return this.loadAssetsDeferred().then(function() {
                e.loadLayer(), e.loadExtraLayer(), e.loading.hide(), e._drawModalBeforeBattleResultsDeferred().then(function() {
                    e.createTutorialView(), e.drawView(), e.makeNextActionsQueue(), e.drawScoreResult(), n.resolve()
                })
            }).fail(function() {
                n.reject()
            }), n.promise()
        },
        loadAssetsDeferred: function() {
            FF.logger.debug("ResultView: loadAssetsDeferred");
            var e = t.Deferred();
            return this.assetsManager.populateAssetsDeferred(FF.battleResult.assets).then(function() {
                e.resolve()
            }).fail(function() {
                e.reject()
            }), e.promise()
        },
        loadLayer: function() {
            FF.logger.debug("ResultView: loadLayer");
            var e = "battle_result",
                t = this.assetsManager.getAssetInfo(e);
            this.battleResultLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.battleResultLayer.activate()
        },
        loadExtraLayer: function() {
            this.willShowSoulStrikeLevelup() && this.loadLayerForSoulStrikeLevelup(), this._hasPrizeBuddy() && this.loadLayerForPrizeBuddy(), this._hasSpecialPrizeItem() && this.loadLayerForSpecialItem()
        },
        loadLayerForSoulStrikeLevelup: function() {
            FF.logger.debug("ResultView: loadLayerForSoulStrikeLevelup");
            var e = this,
                t = "soul_strike_lvup",
                n = this.assetsManager.getAssetInfo(t);
            this.soulStrikeLevelUpLayer = new i({
                layerName: n.layerName,
                assetPath: n.assetPath
            }), this.soulStrikeLevelUpLayer.activate()
        },
        loadLayerForPrizeBuddy: function() {
            var e = "chara_get",
                t = this.assetsManager.getAssetInfo(e);
            this.charaGetLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.charaGetLayer.activate()
        },
        loadLayerForSpecialItem: function() {
            var e = "item_get",
                t = this.assetsManager.getAssetInfo(e);
            this.specialItemGetLayer = new i({
                layerName: t.layerName,
                assetPath: t.assetPath
            }), this.specialItemGetLayer.activate()
        },
        createTutorialView: function() {
            this.tutorialView = new v(this.assetsManager), this.tutorialView.prepareForTutorial()
        },
        drawView: function() {
            this.stageNode = new s({
                name: "stage_nul",
                layer: this.battleResultLayer.layerName
            }), this.nextBtnNode = new s({
                name: "next_btn_nul",
                layer: this.battleResultLayer.layerName
            }), this.nextBtnNode.setVisible(!1).process(), this.centerFrontNode = (new s({
                name: "pos_center_front_nul",
                layer: this.battleResultLayer.layerName
            })).setVisible(!1).process(), this.centerFrontNewNode = (new s({
                name: "pos_center_front_new_nul",
                layer: this.battleResultLayer.layerName,
                parentNodeName: "new_reward_front_pos_nul",
                duplicateFrom: "new_nul",
                duplicateFromOptions: {
                    parentNode: "new_reward_front_pos_nul"
                }
            })).setVisible(!1).process(), this.centerFrontNewNode.play("new_loop").setVisible(!1).process(), this.stageNode.addCallback("action_touch_began", e.bind(function() {
                this.tutorialView.promiseWaitingForTouch ? this.tutorialView.releaseFromWaiting() : this.currentPageView.completeAtOnce()
            }, this)).process(), FF.env.isUsingWWBackKeyHandler() && FF.env.isTutorial() && this.setupTutorialOnBackKey()
        },
        changeCurrentPage: function(e) {
            this.currentPageView && this.stopListening(this.currentPageView), this.currentPageView = e, this.listenTo(this.currentPageView, "show:nextBtn", this.showNextBtn)
        },
        showNextBtn: function() {
            this.nextBtnNode.setVisible(!0).process(), this._nextBtnDrawn = !0;
            var t = setTimeout(e.bind(function() {
                this.nextBtnNode.addCallbackOnce("action_touch_began", e.bind(function() {
                    this.nextBtnNode.play("tap_start").process()
                }, this)).addCallbackOnce("action_touch_ended", e.bind(function() {
                    FF.SoundMgr.playChooseEffect(), this.nextBtnNode.play("tap_end").processDeferred("action_stop").then(e.bind(function() {
                        this.nextBtnNode.setVisible(!1).process(), this.beforeDrawNextPage(this.currentPageView)
                    }, this))
                }, this)).process(), clearTimeout(t), this._bindBackKeyToNextBtn()
            }, this), E.WAIT_UNTIL_NEXT_BTN_DISPLAYED)
        },
        beforeDrawNextPage: function(e) {
            this.drawNextPage()
        },
        drawNextPage: function() {
            this._nextBtnDrawn = !1;
            var e = this.nextActionsQueue.shift();
            e()
        },
        _bindBackKeyToNextBtn: function() {
            FF.env.isUsingWWBackKeyHandler() && this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", e.bind(function() {
                if (!this._nextBtnDrawn) return;
                this._nextBtnDrawn = !1, this.nextBtnNode.play("tap_end").processDeferred("action_stop").then(e.bind(function() {
                    this.nextBtnNode.setVisible(!1).process(), this.drawNextPage()
                }, this))
            }, this))
        },
        makeNextActionsQueue: function() {
            this.nextActionsQueue = this.nextActions, this.result.isDungeonClear || (this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawDungeonResult"
            })), this._hasBattleDropPrize() || (this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawItemResult"
            }));
            if (!this._hasSoulStrikeExp() || !this._hasUnmasteredSoulStrike()) this.nextActionsQueue = e.reject(this.nextActionsQueue, function(e) {
                return e === "drawSoulStrikeExp"
            });
            this.nextActionsQueue = e(this.nextActionsQueue).map(function(t) {
                return e.bind(this[t], this)
            }, this)
        },
        _hasBattleDropPrize: function() {
            return e.keys(this.result.dropItemIdToNum).length || e.keys(this.result.dropRecordMateriaItemIdToNum).length || e.keys(this.result.scoreRecordMateriaItemIdToNum).length || e.keys(this.result.hostPrizeItemIdToNum).length || e.keys(this.result.guestPrizeItemIdToNum).length || e.keys(this.result.singlePrizeItemIdToNum).length || e.keys(this.result.buddyLevelRecordMateriaItemIdToNum).length ? !0 : !1
        },
        _hasSoulStrikeExp: function() {
            return e.some(this.result.buddy, function(e) {
                return e.soulStrikeExps.length > 0
            })
        },
        setupTutorialOnBackKey: function() {
            this.listenTo(kickmotor.nativefn.onBackKeyHandler, "System::onBackKey", e.bind(function() {
                this.tutorialView.promiseWaitingForTouch ? this.tutorialView.releaseFromWaiting() : this.currentPageView.completeAtOnce()
            }, this))
        },
        _hasUnmasteredSoulStrike: function() {
            return e.some(this.result.buddy, function(t) {
                return e.some(t.soulStrikeExps, function(e) {
                    return !e.isAlreadyMastered
                })
            })
        },
        _hasPrizeBuddy: function() {
            return this.result.prizeBuddyInfoList.length === 0 ? !1 : e.some(this.result.prizeBuddyInfoList, function(e) {
                return e.remapItemId === null
            })
        },
        _hasSpecialPrizeItem: function() {
            return this.itemCollection.length === 0 ? !1 : this._getSpecialPrizeItemList().length > 0
        },
        _getSpecialPrizeItemList: function() {
            var e = this.serverConst.ABILITY_MATERIAL.TYPE_OF.MEMORY;
            return this.itemCollection.filter(function(t) {
                return t.isAbilityMaterial() ? e === +t.get("type") : !1
            })
        },
        goOutToExternalUrl: function() {
            this.stageNode.removeAllCallback(), this.nextBtnNode.removeAllCallback(), this.tutorialView.dispose(), this.assetsManager.destroyAllLayer(), this.stopListening(), FF.redirect(this.result.url)
        },
        drawPrizeBuddyModalDeferredIfNeedDeferred: function() {
            return this._hasPrizeBuddy() ? (this.prizeBuddyModal = new m({
                layer: this.charaGetLayer,
                assetsManager: this.assetsManager,
                prizeBuddyInfoList: e.filter(this.result.prizeBuddyInfoList, function(e) {
                    return !e.remapItemId
                })
            }), this.prizeBuddyModal.showModalsDeferred()) : t.Deferred().resolve().promise()
        },
        drawSpecialItemModalDeferredIfNeedDeferred: function() {
            return this._hasSpecialPrizeItem() ? (this.specialItemModal = new g({
                layer: this.specialItemGetLayer,
                assetsManager: this.assetsManager,
                specialItemInfoList: this._getSpecialPrizeItemList()
            }), this.specialItemModal.showModalsDeferred()) : t.Deferred().resolve().promise()
        },
        drawScoreResult: function() {
            FF.logger.debug("ResultView: drawScoreResult");
            var e = this,
                t = this.result.score.specific && this.result.score.specific.length,
                n = !!this.result.moOptionalInfo,
                r = n ? "mo_score_start" : t ? "special_score_start" : "score_start";
            FF.battleResult.isMock ? ((new s({
                name: "visible_stage_nul",
                layer: this.battleResultLayer.layerName
            })).setVisible(!0).process(), FF.ns.battle.Conf = {
                STATUS_AILMENTS_TYPE: {
                    PETRIFACTION: 212
                }
            }) : this.stageNode.setVisualParent("layer_battle_field", "sys_pos_nul").process(), this.stageNode.setVisible(!0).play(r).process(), this.resultScoreView = new c({
                layer: this.battleResultLayer,
                result: this.result,
                tutorialView: this.tutorialView
            }), this.changeCurrentPage(this.resultScoreView), this.resultScoreView.start()
        },
        drawExpResult: function() {
            FF.logger.debug("ResultView: drawExpResult"), this.resultScoreView && this.resultScoreView.dispose(), this.stageNode.play("exp_start").process(), this.resultExpView = new h({
                layer: this.battleResultLayer,
                exp: this.result.buddy,
                totalExp: this.result.totalDevidedExp,
                assetsManager: this.assetsManager,
                tutorialView: this.tutorialView,
                soulStrikeLevelUpLayer: this.soulStrikeLevelUpLayer,
                soulStrikeLevelUpInfos: this.soulStrikeLevelUpInfos
            }), this.changeCurrentPage(this.resultExpView), this.resultExpView.start()
        },
        drawSoulStrikeExp: function() {
            FF.logger.debug("ResultView: drawSoulStrikeExpResult"), this.resultExpView.drawSoulStrikeExp()
        },
        _createSoulStrikeLevelUpInfos: function() {
            var t = [];
            return e.each(this.result.buddy, function(n) {
                var r = e.sortBy(n.soulStrikeExps, function(e) {
                    return +e.equipmentId
                });
                e.each(r, function(e) {
                    if (e.isLevelUp) {
                        var r = {};
                        r.buddy = n, r.soulStrike = e, t.push(r)
                    }
                })
            }), t
        },
        _drawModalBeforeBattleResultsDeferred: function() {
            var e = t.Deferred(),
                n = this;
            return this.drawPrizeBuddyModalDeferredIfNeedDeferred().then(this.drawSpecialItemModalDeferredIfNeedDeferred.bind(this)).then(function() {
                e.resolve()
            }), e.promise()
        },
        drawItemResult: function() {
            FF.logger.debug("ResultView: drawItemResult"), this.resultExpView && (this.resultExpView.dispose(), this.resultExpView = null), this.stageNode.play("reward_start").process(), this.resultItemView = new p({
                layer: this.battleResultLayer,
                buddy: this.result.buddy,
                dropItemIdToNum: this.result.dropItemIdToNum,
                dropItemIdToEquipBonus: this.result.dropItemIdToEquipBonus,
                dropRecordMateriaItemIdToNum: this.result.dropRecordMateriaItemIdToNum,
                scoreRecordMateriaItemIdToNum: this.result.scoreRecordMateriaItemIdToNum,
                buddyLevelRecordMateriaItemIdToNum: this.result.buddyLevelRecordMateriaItemIdToNum,
                hostPrizeItemIdToNum: this.result.hostPrizeItemIdToNum,
                guestPrizeItemIdToNum: this.result.guestPrizeItemIdToNum,
                singlePrizeItemIdToNum: this.result.singlePrizeItemIdToNum,
                itemCollection: this.itemCollection,
                assetsManager: this.assetsManager,
                centerFrontNode: this.centerFrontNode,
                centerFrontNewNode: this.centerFrontNewNode,
                tutorialView: this.tutorialView,
                serverConst: this.serverConst
            }), this.changeCurrentPage(this.resultItemView), this.resultItemView.start()
        },
        resultDungeonViewClass: d,
        drawDungeonResult: function() {
            var e = this.isFirstClear && this.firstClearPrizeNum ? "clear_start_first" : "clear_start";
            FF.logger.debug("ResultView: drawDungeonResult"), this.resultExpView && (this.resultExpView.dispose(), this.resultExpView = null), this.resultItemView && this.resultItemView.dispose(), this.stageNode.play(e).process(), this.resultDungeonView = new this.resultDungeonViewClass({
                layer: this.battleResultLayer,
                result: this.result,
                serverConst: this.serverConst,
                itemCollection: this.itemCollection,
                assetsManager: this.assetsManager,
                centerFrontNode: this.centerFrontNode,
                tutorialView: this.tutorialView
            }), this.changeCurrentPage(this.resultDungeonView), this.resultDungeonView.start()
        }
    }), FF.ns.battle.ResultViewController
}), define("scenes/battle_result/BattleResultScene", ["underscore", "jquery", "backbone", "scenes/common/Config", "scenes/common/helper/FirstDungeonClearFlag", "scenes/common/helper/MissionBaseHelper", "scenes/common/helper/LastWinDungeon", "scenes/progress_map/LatestProgressData", "./ResultViewController", "lib/Scene", "lib/Ticker", "lib/Storage", "util", "lib/api", "lib/ab/kickmotor/LayerFactory"], function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d) {
    var v = FF.ns.battle;
    return f.extend({
        initialize: function() {
            FF.logger.debug("FF.battleResult", FF.battleResult), FF.battleResult || FF.redirect("/dff/"), FF.battleResult.isMock || v.ExternalFunc.openLoading();
            var e = FF.battleResult.result;
            this.result = e || {}, this.battleLayers = FF.battleResult.battleLayers || [], this.result = h.camelizeDeep(e), this.result.url = FF.battleResult.url, this.serverConst = JSON.parse(t("[data-app-constants-data]").html()), l.start()
        },
        setupDeferred: function() {
            var e = this,
                n = t.Deferred();
            return this._saveAchievedMissionsDeferred().then(u.getCanReturnDeferred.bind(u)).then(function(t) {
                t.canReturn || n.resolve(), e._setDungeonClearDataDeferred().then(e._saveIsFirstClearDeferred.bind(e)).then(function() {
                    n.resolve()
                })
            }), n.promise()
        },
        _setDungeonClearDataDeferred: function() {
            var e = this,
                n = t.Deferred();
            return o.resetDeferred({
                dungeonId: this.result.dungeonId
            }).then(function() {
                if (e.result.isFirstClear || e.result.isFirstMaster) {
                    var t = "LATEST_UNLOCK_DUNGEONS",
                        r = {
                            isFirstClear: e.result.isFirstClear,
                            isFirstMaster: e.result.isFirstClearMaster,
                            clearDungeonId: e.result.dungeonId,
                            clearDungeonRank: e.result.dungeonRank,
                            unlockDungeons: e.result.unlockDungeons
                        };
                    c.setItemDeferred(t, JSON.stringify(r)).then(function(e) {
                        n.resolve()
                    })
                } else n.resolve()
            }), n.promise()
        },
        _saveAchievedMissionsDeferred: function() {
            var e = t.Deferred(),
                n = FF.battleResult.result.achieved_mission_modal_info_list;
            return n ? s.saveAchievedMissionsDeferred(n, {
                isBattle: !0
            }) : e.resolve().promise()
        },
        _saveIsFirstClearDeferred: function() {
            return i.saveDeferred(this.result.isFirstClear)
        },
        start: function() {
            var e = this;
            kickmotor.googleanalytics.sendScreenName(r.googleAnalytics.DIRECT_CALL_SCREEN_NAME_OF.BattleAnimationResult);
            var n = this.getErrorHandler();
            this._setupErrorHandler();
            var i = void 0;
            t.Deferred().resolve().promise().then(n.bindTryCatchDeferred(function() {
                i = "4122";
                var t = v.BattleViewController.getInstance();
                return t.dispose(), e.viewController = new v.ResultViewController(e.result, e.serverConst), FF.logger.debug("loadView"), e.viewController.loadViewDeferred()
            })).then(n.bindTryCatchDeferred(function() {
                i = "4135", FF.battleResult.isMock || v.ExternalFunc.closeLoading(), FF.logger.debug("processCount", FF.Debug.processCount)
            })).fail(function(t) {
                if (!FF.env.isNative()) throw t;
                e._revealErrorMessage(), window.onErrorFunc(t, i)
            }), this.defineOnAppForeground(), v.ExternalUserAuth.checkExternalUserAuthCallDeferred(), v.MoSnsShareHelper.checkAndClearForSnsShareDeferred()
        },
        defineOnAppForeground: function() {
            if (!FF.env.isNative()) return;
            kickmotor.nativefn.onApplicationForeground = function() {
                FF.env.checkMobageLoginDeferred().then(function(e) {
                    e && v.ExternalUserAuth.checkExternalUserAuthCallDeferred()
                }), v.MoSnsShareHelper.checkAndClearForSnsShareDeferred()
            }
        },
        _revealErrorMessage: function() {
            var n = this,
                r = [];
            n.battleLayers.push("layer_battle_result"), n.battleLayers.push("layer_soul_strike_lvup"), e(n.battleLayers).each(function(e) {
                d.getInstance().destroy(e)
            }), t(".overlay").removeClass("hide")
        },
        _setupErrorHandler: function() {
            var e = this._errorHandler;
            t(window).off("error"), t(window).on("error", e.bind(this))
        },
        _errorHandler: function(e) {
            var n = e.originalEvent;
            t(window).off("error"), this._revealErrorMessage(), window.onErrorFunc(n, "4148");
            var r = {
                filename: n.filename,
                lineno: n.lineno || 0,
                colno: n.colno || 0,
                message: n.message || "",
                error: n.error || ""
            };
            p.errorDeferred(JSON.stringify(r))
        },
        dispose: function() {
            f.prototype.dispose.apply(this)
        }
    })
}), define("routers/Battle", ["underscore", "backbone", "lib/ab/kickmotor/LayerFactory", "scenes/battle/BattleScene", "scenes/battle_result/BattleResultScene"], function(e, t, n, r, i) {
    return t.Router.extend({
        initialize: function() {
            this.currentScene = void 0, this._setupOnBackKey()
        },
        routes: {
            "": "createBattleScene",
            "battle_result(/)(:url)": "createBattleResultScene"
        },
        createBattleScene: function() {
            this.disposeCurrentScene(), FF.scene = this.currentScene = new r, FF.scene.setupDeferred().then(function() {
                FF.scene.start()
            })
        },
        createBattleResultScene: function() {
            var e = this;
            this.disposeCurrentScene(), this.currentScene = new i, this.currentScene.setupDeferred().then(function() {
                e.currentScene.start()
            })
        },
        disposeCurrentScene: function() {
            this.currentScene && (this.currentScene.dispose(), this.currentScene = null), n.getInstance().dump()
        },
        getCurrentScene: function() {
            return this.currentScene
        },
        _setupOnBackKey: function() {
            FF.env.isUsingWWBackKeyHandler() && (kickmotor.nativefn.onBackKeyHandler = e.extend({
                hasModal: !1
            }, t.Events), kickmotor.nativefn.onBackKey = function() {
                kickmotor.nativefn.onBackKeyHandler.trigger("System::onBackKey")
            })
        }
    })
}), require(["jquery", "underscore", "backbone", "kickmotor", "lib/SoundMgr", "logger", "env", "scenes/battle/Conf"], function(e, t, n, r, i) {
    require(["routers/Battle"], function(t) {
        e(function() {
            var n = e("input#debug-battle-init-ep").val();
            n && (FF.Debug || (FF.Debug = {}), FF.Debug.battleInitEp = n), e.nativefn = r.nativefn, r.animation.setAnimationInterval(1 / FF.env.framesPerSecond), r.view.showGameView(), FF.SoundMgr = new i, FF.router = new t, FF.onload()
        })
    })
}), define("battle", function() {});